<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-09-13T22:33:10+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">Haskell 学习</title><link href="/lang/Haskell%E5%AD%A6%E4%B9%A0.html" rel="alternate" type="text/html" title="Haskell 学习" /><published>2024-09-08T00:00:00+08:00</published><updated>2024-09-08T00:00:00+08:00</updated><id>/lang/Haskell%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="/lang/Haskell%E5%AD%A6%E4%B9%A0.html"><![CDATA[<p><em>origin written at 2020-11-01</em></p>

<h2 id="纯函数">纯函数</h2>

<p>Haskell 是 <strong>纯函数</strong> 语言，语义实现的全过程都在于形式演算，而非传统的值计算。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="形式化简">形式化简</h3>

<h4 id="阿尔法化简-alpha-conversion">阿尔法化简 （$\alpha$-conversion）</h4>

<p>通过变量名重命名来做等价变换:<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

\[\lambda x \rightarrow \lambda y \rightarrow x + y \equiv \lambda a \rightarrow \lambda y \rightarrow a + y\]

<h4 id="贝塔化简-beta-reduction">贝塔化简 （$\beta$-reduction）</h4>

<p>用实际的函数体替换掉参数。</p>

<h4 id="伊塔化简-eta-reduction">伊塔化简 （$\eta$-reduction）</h4>

<p>冗余简化:</p>

\[\lambda x \rightarrow f(x) \equiv f\]

<h3 id="柯里化currying">柯里化（currying）</h3>

<p>函数都是单参数的，多参函数，是通过柯里化方式转换成单参数：</p>

<p><code class="language-plaintext highlighter-rouge">\x1 x2 ... xn -&gt; f(x1 x2 ... xn)</code> 的实际形式是 <code class="language-plaintext highlighter-rouge">\x1 -&gt; \x2 -&gt;...xn -&gt; f(x1 x2 ... xn)</code>。</p>

<p>或者说，函数参数是右结合的。</p>

<p>举个例子:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">add</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">add'</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">&gt;</span> <span class="n">add'</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span>
</code></pre></div></div>

<h3 id="不动点fixed-point">不动点（fixed point）</h3>

<p>本身的概念是满足 $f(x) = x$ 的 $x$ ，这里用作递归的形式演算 <code class="language-plaintext highlighter-rouge">fix f = f (fix f)</code> 。</p>

<p>比如牛顿法开方：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 迭代次数 -&gt; 根值 -&gt; 结果</span>
<span class="c1">-- Normal Bad Version</span>
<span class="n">sqrtNB</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">sqrtNB</span> <span class="n">n</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtNB</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">sqrtNB</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1">-- 性能很差</span>
<span class="o">&gt;</span> <span class="n">sqrtNB</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="mf">2.23606797749979</span>
<span class="p">(</span><span class="mf">1.81</span> <span class="n">secs</span><span class="p">,</span> <span class="mi">914</span><span class="p">,</span><span class="mi">438</span><span class="p">,</span><span class="mi">408</span> <span class="n">bytes</span><span class="p">)</span>
</code></pre></div></div>

<p>使用不动点为：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqrtFix</span> <span class="n">n</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fix</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">n</span> <span class="n">t</span> <span class="o">-&gt;</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="kr">then</span> <span class="n">t</span>
        <span class="kr">else</span> <span class="n">f</span>  <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">n</span> <span class="n">x</span>

<span class="o">&gt;</span> <span class="n">sqrtFix</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="mf">2.23606797749979</span>
<span class="p">(</span><span class="mf">0.01</span> <span class="n">secs</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span><span class="mi">688</span> <span class="n">bytes</span><span class="p">)</span>
</code></pre></div></div>

<p>` fix` 实际实现里：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fix</span> <span class="n">f</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">x</span>  <span class="c1">-- `in` 限制了 `let` 绑定的作用域</span>
</code></pre></div></div>

<h2 id="函子">函子</h2>

<h3 id="所谓函子functor">所谓函子（Functor）</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span>        <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    
    <span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span>        <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span>        <span class="o">=</span>  <span class="n">fmap</span> <span class="o">.</span> <span class="n">const</span>
</code></pre></div></div>

<p>函子提供了一种在上下文 <code class="language-plaintext highlighter-rouge">f</code> <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">3</a></sup><sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">4</a></sup>里进行函数操作的方式。</p>

<p>从名字上它叫函子不叫函数，就是暗示它支持把一般函数作为一个组件，带入上下文里（进行函数操作）。</p>

<p><code class="language-plaintext highlighter-rouge">class Functor</code>  只有一个必须实现的接口函数 <code class="language-plaintext highlighter-rouge">fmap</code> ，它的签名也很好地反映了函子的本质：接受一个函数 <code class="language-plaintext highlighter-rouge">a-&gt;b</code> ，把它应用在上下文 <code class="language-plaintext highlighter-rouge">f</code> 里，使得 <code class="language-plaintext highlighter-rouge">f a</code> 变为 <code class="language-plaintext highlighter-rouge">f b</code> 。</p>

<p>（标准库）还为函子的 <code class="language-plaintext highlighter-rouge">fmap</code> 导出了等价的中缀操作符 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;$&gt;</span>

<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmap</span>
</code></pre></div></div>

<p>此外，<code class="language-plaintext highlighter-rouge">class Functor</code> 提供了一个有默认实现<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>的 <code class="language-plaintext highlighter-rouge">(&lt;$)</code> <sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup>。</p>

<p>其中，<code class="language-plaintext highlighter-rouge">.</code> 有 <code class="language-plaintext highlighter-rouge">(.) f g = \x -&gt; f (g x)</code> ，<code class="language-plaintext highlighter-rouge">const</code> 有</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">const</span>                   <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">const</span> <span class="n">x</span> <span class="kr">_</span>               <span class="o">=</span>  <span class="n">x</span>
</code></pre></div></div>

<p>可以手工（形式演算）推出 <code class="language-plaintext highlighter-rouge">(&lt;$)</code> 的类型签名：</p>

<p><code class="language-plaintext highlighter-rouge">fmap . const = a -&gt; f1 (g a)</code> ，展开 <code class="language-plaintext highlighter-rouge">.</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">g = a-&gt;b-&gt;a</code> =&gt; <code class="language-plaintext highlighter-rouge">(g a) = (b-&gt;a)</code>，展开 <code class="language-plaintext highlighter-rouge">const</code></li>
  <li><code class="language-plaintext highlighter-rouge">f1 = (a -&gt; b) -&gt; f2 a -&gt; f2 b</code> ， 展开 <code class="language-plaintext highlighter-rouge">fmap</code></li>
  <li><code class="language-plaintext highlighter-rouge">f1 (g a) = f1 (b-&gt;a) = f1 b -&gt; f1 a</code> ，规约替换 <code class="language-plaintext highlighter-rouge">(g a)</code>  和 <code class="language-plaintext highlighter-rouge">f1</code></li>
  <li><code class="language-plaintext highlighter-rouge">a -&gt; f1 (g a) = a -&gt; f1 b -&gt; f1 a</code> ，规约替换 <code class="language-plaintext highlighter-rouge">f1 (g a)</code></li>
  <li><code class="language-plaintext highlighter-rouge">fmap . const = a -&gt; f b -&gt; f a</code> ，重命名 <code class="language-plaintext highlighter-rouge">f1 = f</code></li>
</ul>

<h3 id="应用函子applicative">应用函子（Applicative）</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="cp">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>

    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>

    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">id</span>

    <span class="n">liftA2</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
    <span class="n">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>

    <span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    <span class="n">a1</span> <span class="o">*&gt;</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;$</span> <span class="n">a1</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">a2</span>

    <span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">const</span>
    
<span class="c1">-- ...</span>

<span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;$</span>
<span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;*&gt;</span>
</code></pre></div></div>

<p>应用函子的设计是在上下文里为同一个函数连接多个参数。</p>

<p><code class="language-plaintext highlighter-rouge">class Applicative</code> 最小实现需要实现 1.  <code class="language-plaintext highlighter-rouge">pure</code> ，2.  <code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code> 与 <code class="language-plaintext highlighter-rouge">liftA2</code> 中任意一个 <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>。</p>

<h4 id="pure"><code class="language-plaintext highlighter-rouge">pure</code></h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>把一个参数装进上下文 <code class="language-plaintext highlighter-rouge">f</code> 中 。<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup><sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup></p>

<h4 id="-和-lifta2"><code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 和 <code class="language-plaintext highlighter-rouge">liftA2</code></h4>

<p><code class="language-plaintext highlighter-rouge">Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code></p>

<p>因为 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 与 <code class="language-plaintext highlighter-rouge">liftA2</code> 分别有以对方为基础的默认实现，所以接口只需实现其中任意一个，让我们看下它们的函数签名和默认实现。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">id</span>

<span class="n">liftA2</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="n">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>相比于前面的 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> ， <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 是说把 <code class="language-plaintext highlighter-rouge">a -&gt; b</code> 也放进上下文 <code class="language-plaintext highlighter-rouge">f</code> 里，这样做的好处是可以利用函数柯里化，在上下文里连接多个参数。</p>

<p>比如有一个多参函数 <code class="language-plaintext highlighter-rouge">a -&gt; b -&gt; c -&gt; d</code> ，那么可以结合 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 操作符，用 <code class="language-plaintext highlighter-rouge">(a -&gt; b -&gt; c -&gt; d) &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; f c</code> 的形式在上下文里传参。<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup></p>

<p>而 <code class="language-plaintext highlighter-rouge">liftA2</code> 则像是多一个参数的 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 。</p>

<p>因为这就是[]对Applicative的实现</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span>    <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="o">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>  <span class="c1">-- 定义在这里</span>
    <span class="n">liftA2</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="p">]</span>
    <span class="n">xs</span> <span class="o">*&gt;</span> <span class="n">ys</span>  <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="kr">_</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="p">]</span>
</code></pre></div></div>

<p>下面例子针对构造器Maybe</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>  
    <span class="n">pure</span> <span class="o">=</span> <span class="kt">Just</span>  
    <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>  
    <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">something</span>

<span class="o">&gt;</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>

<span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span>
<span class="o">&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>可以看出<code class="language-plaintext highlighter-rouge">pure</code>是指明构造器，<code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code>核心算法解构逻辑。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">=</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span> <span class="c1">-- pure of Maybe is Just </span>
</code></pre></div></div>

<p>从定义上看，</p>

<p><code class="language-plaintext highlighter-rouge">pure f &lt;*&gt; x</code> 等价于 <code class="language-plaintext highlighter-rouge">fmap f x</code></p>

<p><strong>lift函数</strong></p>

<p>Module Control.Applicative</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftA2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>

<span class="n">liftA2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">(</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">3</span>
</code></pre></div></div>

<p>计算第一个参数但忽略结果，返回第二个：(*&gt;)</p>

<p>相反地返回第一个参数 的是 (&lt;*)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="n">const</span> <span class="n">id</span><span class="p">)</span>  <span class="c1">-- const 1 2 =》 1</span>

<span class="kt">Just</span> <span class="mi">1</span> <span class="o">*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>

<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">const</span>
<span class="kt">Just</span> <span class="mi">1</span> <span class="o">&lt;*</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">1</span>
</code></pre></div></div>

<h4 id="alternative-functor">Alternative Functor</h4>

<p>Module Control.Applicative</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixl</span> <span class="mi">3</span> <span class="o">&lt;|&gt;</span>
<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Alternative</span> <span class="n">f</span> <span class="kr">where</span>
	<span class="n">empty</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>&lt;</td>
      <td>&gt; ：其他的选择</td>
    </tr>
  </tbody>
</table>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">1</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="单子应用monad">单子应用（Monad）</h3>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>相比之下，作为函数式语言的另一个分支，Lisp家族，以 CommonLisp 为例，实际上广泛地使用可变的数据结构和有副作用的函数。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>当然前提是不能有命名冲突。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">f</code> 是单参的类型构造器（一种特殊的函数），不过正如前面讲的，Haskell 多参函数的本质都是柯里化的单参函数 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>按照官方文档的说法，  <code class="language-plaintext highlighter-rouge">f a</code> 也可以叫做 action <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">infixl</code> 关键字规定中缀操作符是（向）左结合的，并指定它的优先级，给的数字越大优先级越高，类似地还有指定右结合的 <code class="language-plaintext highlighter-rouge">infixl</code> 和不指定结合性的 <code class="language-plaintext highlighter-rouge">infix</code> （此时， <a href="https://stackoverflow.com/questions/27770118/how-does-the-infix-work">只能通过括号显式指定结合性</a>）；并且不显式指定结合性和优先级，<a href="https://www.haskell.org/onlinereport/decls.html#fixity">那么默认是左结合，优先级为最高（最高为 $9$ ）</a> 。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>文档里也支持自己实现更高效的版本 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>从命名规律上讲，不妨称之为：“左偏刀”，还有 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> ，可以称之为 “全刀”，后面还有一些特殊符号的运算符：<code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> ，<code class="language-plaintext highlighter-rouge">&lt;*</code> 和<code class="language-plaintext highlighter-rouge">*&gt;</code>可以依次称之为 “全星”，“左偏星” 和“右偏星” <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>或者两个都实现，只要二者不发生矛盾 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">=&gt;</code> 前面是类型约束 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>在非纯函的语言看来，这个函数签名简直莫名其妙，这个 <code class="language-plaintext highlighter-rouge">f</code> 它从哪儿来的，怎么绑定的？这都不知道，唯一好像可以类比得是闭包里捕获的自由变量，但完全没有类比意义，基本上在 Haskell 里需要完全抛弃基于值的非纯函的编程模型，只考虑形式演算的问题，在这种前提下，我们就知道 <code class="language-plaintext highlighter-rouge">f</code> 会在形式演算的过程中根据签名匹配出来。 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 虽然优先级相同，但都是左结合 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[origin written at 2020-11-01]]></summary></entry><entry><title type="html">质数筛子</title><link href="/algs/Prime1.html" rel="alternate" type="text/html" title="质数筛子" /><published>2024-08-27T00:00:00+08:00</published><updated>2024-08-27T00:00:00+08:00</updated><id>/algs/Prime1</id><content type="html" xml:base="/algs/Prime1.html"><![CDATA[<p><em>质数筛子的原理是质因数分解</em>。</p>

<h2 id="前言">前言</h2>

<p>所有（可用的）质数筛子，如果不使用分段技术，那么不管它的<strong>时间复杂度</strong>和<strong>空间复杂度</strong>在理论上是超线性、线性还是亚线性，在实践上它们的时间和空间复杂度都可以视为线性。</p>

<p>这是因为，一方面是因为它们的区别只在于 $ n\log\log n$,  $n$ 和 $\large\frac{n}{\log\log n}$ 。一方面 $\log\log n$ 对于一个 64 位机的指针宽度的最大数字也就是 $\log\log64 = 8$ ，很可能还不如一个常数大；另一个方面，在实现上，超线性和线性算法有数据结构简单的优势，而亚线性算法则有实际实现不了的劣势。</p>

<p>分段技术会将空间占用降为 $O(\sqrt n)$ 。</p>

<p>通常来讲，算法的瓶颈在于空间占用，使用了分段技术的算法有无可匹敌的优势。</p>

<p><em>以下介绍的筛子按照发明的时间顺序进行排列， 标题括号里的是对其总体评价。</em></p>

<h2 id="e-筛子">E-筛子（√√√）</h2>

<p>Eratosthenes 筛子，简称作E-筛子，属于是非常古老、简单的一种筛子算法：</p>

<ol>
  <li>在对整个范围一遍扫描的过程中，开始先逐个数检查质性；</li>
  <li>当发现一个质数 $p$ 时，就把它的乘积： $2p, 3p, \dots , \lfloor n/p\rfloor p$ ，都标记为合数；</li>
  <li>这样在继续扫描的过程中发现被标记为合数的就直接跳过，直到发现下一个质数，然后重复步骤2直到 $n$</li>
</ol>

<p>实际上我们标记合数的方法是追踪所有小于它的质数，因为根据之前所讲的<a href="/algs/Prime0.html#算式基本定理">正整数唯一分解定理</a>，也就是所有的合数都可以做质因数分解，一定存在一个严格比它小的质数可以除它。这样地话，如果我们是从第一个质数开始，那么实际上：</p>

<ol>
  <li>标记合数的过程不需要从 $2p$ 开始，而是直接从 $p\cdot p$ 开始，因为所有 $\lt p$ 的合数已经被更小的质数标记过了；</li>
  <li>最外轮的扫描只到 $\lfloor \sqrt{n} \rfloor$ 即可，因为作为合数的因子对，只需要通过那些较小的就可以完成合数的标记了</li>
</ol>

<h3 id="样例代码">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">bit_vec</span><span class="p">::</span><span class="n">BitVec</span><span class="p">;</span>

<span class="nd">macro_rules!</span> <span class="n">sieve_spec_case</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">empty</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="nv">$n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析">复杂度分析</h3>

<p>每查找到一个质数 $p$ ，就需要 $n/p$ 的操作次数，因此总的操作数为 $\displaystyle \sum_{ p\leqslant \sqrt{n}}  n/p $ 。而根据已知的结论，来自<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>  chapter 22 的：$\displaystyle \sum_{p \leqslant x} \frac{1}{p} = \log\log x + O(1)$ ，可以得到算法的最坏时间复杂度为 $O(n\log\log n)$ 。</p>

<h3 id="算法评价">算法评价</h3>

<p>是最快的算法！空间占用也仅次于它的分段算法！</p>

<h2 id="分段e-筛">分段E-筛（√√√）</h2>

<p>分段处理可以把空间占用从 $O(n)$ 降到 $O(\sqrt{n})$ ，指数级地缓解算法的空间占用。</p>

<p>方法是可以预计算出所有到 $\sqrt{n}$ 为止的质数，根据前面已知，所有 $\leqslant n$ 范围内的合数都可以由预计算出的质数构造出，只需要知到这些质数的乘积落在每个分段上的第一个数，就可以标记完所有这个分段的合数。</p>

<p>而如何知道质数 $p$ （的乘积）落在某个分段区间的第一个数呢？只需要知道分段的左边缘 $l$ ，那么易知落点为 $l+p-(l\mod{p})$ 。</p>

<h3 id="样例代码-1">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Space: O(\sqrt{n})</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_seg_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">acc</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">e_seg_sieve_0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pris</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">l</span><span class="p">)));</span>

        <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">acc</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>

<span class="cd">/// 0. p^2 &gt;= l+delta</span>
<span class="cd">/// 1. pris from 0..x, no empty.</span>
<span class="cd">/// 2. return (l, l+delta]</span>
<span class="k">fn</span> <span class="n">e_seg_sieve_0</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
    <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">pris</span><span class="nf">.is_empty</span><span class="p">());</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">seg</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

            <span class="k">for</span> <span class="o">&amp;</span><span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">p</span><span class="o">..=</span><span class="n">delta</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">seg</span><span class="nf">.set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="k">in</span> <span class="n">seg</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析-1">复杂度分析</h3>

<p>这样主要辅助空间是两个 $\sqrt{n}$ bit 的数组，因此空间复杂度为 $O(\sqrt{n})$ 。而当分段大小为 $\sqrt{n}$ 时，总的时间复杂度仍然是 $O(n\log\log n)$ 。</p>

<h3 id="算法评价-1">算法评价</h3>

<p>综合最优！算法属于最快的一档，而且空间占用具有无与伦比的优势！</p>

<h2 id="分段-e-筛拓展">分段 E-筛拓展</h2>

<h3 id="增量e-筛">增量E-筛（√√）</h3>

<p>事实上根据前面的分段思路可以抽象出一个范用的函数：给它一个前 $k$ 个质数组成的集合 $P= \lbrace p_1,p_2,\dots, p_k \rbrace$ ，让它补足计算到 $N$ 为止的所有质数，把它们加入到 $P$ 中。</p>

<p><em>因为这就像是重新接手前面一个查找质数的工作，所以加了一个reentrant的后缀。</em></p>

<p>显然，首先要判断这前 $k$ 个质数是否足以筛完 $[0, N]$ 范围内的剩余质数，如果不能，就要一轮一轮地扩充质数数量，直到 $p_k^2 \geqslant N$ 。</p>

<p>这个过程中，不管是每轮筛 $[p_k+1, p_k^2]$ 范围的质数，还是最后筛 $[p_k+1, N]$ 范围的质数，都可以直接使用前面分段 E-筛的子函数 <code class="language-plaintext highlighter-rouge">e_seg_sieve_0</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// 1. pris from 0..x, no empty.</span>
<span class="cd">/// 2. return (l, l+delta]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_inc_sieve_reentrant</span><span class="p">(</span><span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">pris</span><span class="nf">.is_empty</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">pris</span><span class="nf">.extend</span><span class="p">(</span>
            <span class="nf">e_seg_sieve_0</span><span class="p">(</span><span class="n">pris</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
        <span class="p">);</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">rem</span> <span class="o">=</span> <span class="nf">e_seg_sieve_0</span><span class="p">(</span><span class="n">pris</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="n">pris</span><span class="nf">.extend</span><span class="p">(</span><span class="n">rem</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>利用 <code class="language-plaintext highlighter-rouge">e_inc_sieve_reentrant</code> 这个函数，可以递归地使用，成为一个筛子：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_inc_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="nf">e_inc_sieve_reentrant</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pris</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法评价-2">算法评价</h4>

<p>最快的那一档。</p>

<h3 id="增量-e-筛增量筛">增量 E-筛增量筛（√√）</h3>

<p>也可以逐轮地使用，得到一个增量筛，名字有些拗口：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_inc_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span> <span class="c1">// ~p0^2</span>
                <span class="k">let</span> <span class="n">round</span> <span class="o">=</span> <span class="nf">e_seg_sieve_0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pris</span><span class="p">,</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span><span class="p">)</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">round</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">round</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">pris</span><span class="nf">.extend</span><span class="p">(</span><span class="n">round</span><span class="p">);</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法评价-3">算法评价</h4>

<p>性能在增量筛里还算可以。</p>

<h2 id="mairson-筛子">Mairson 筛子（√）</h2>

<p>仔细考虑下，前面E-筛子的计算过程还有重复的操作，就是有一些合数比如 $C = p_m^i\cdot p_n^j\cdot p_q^k,\ (p_m\neq p_n\neq p_q)$ 它会被不同的质数 $p_m, p_n, p_q$ 重复标记，这也是它超线性时间复杂的原因。</p>

<p>Mairson 筛子<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的实质是取消这些重复标记的过程，把问题转化为线性，为此每用一个质数 $p$ 标记完一些合数后，就要把这些合数排除在后续的标记范围里。</p>

<p>道理都懂，问题是怎么排除，Mairson 很实在地给出了具体的数据结构，也是大家根据这个具体情况自然而然能想到的，即，一个基于数组的双向链表：</p>

<ol>
  <li>一般情况下，既然是集合的操作，那么就可以考虑哈希集合，但从冗余度上讲空间占用会是所需的几倍；而质数的情况是值空间有限，实际上都是连续的自然数，完全可以放进一个数组里，用数组的下标作为索引的键；</li>
  <li>再考虑到从集合删除元素的操作需要是常数级 $O(1)$ ，那么就需要是一个链表，而且是双向链表；</li>
  <li>数组每个位置存储下一个节点的索引坐标，这样在标记某个数被删除时，只需要修改它的左右节点，就可以跳过这个节点；</li>
  <li>这个链表的头可以就是数组头，而它的尾部只需要靠存储值为零进行标记，同时这种设计使得这个链表在首尾连成了一个环，头部也形成了一个自环，体现了一种优雅。</li>
</ol>

<p>于是我们构造这个结构如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// n &gt; 0</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<p>用 <code class="language-plaintext highlighter-rouge">forward</code> 数组记录前向链接、<code class="language-plaintext highlighter-rouge">backward</code> 数组记录后向链接，开始时它们应该初始化为：</p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/forward.svg" style="zoom:100%;" /></div>
</p>
<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/backward.svg" style="zoom:100%;" /></div>
</p>

<p>这样当从集合里删除某个数 $i$ 时，只需要：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div></div>

<p>这样整个算法过程的其他部分和之前的 E-筛子一样。</p>

<h3 id="样例代码-2">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// lpf (least prime factor)</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2usize</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="cm">/* collected andthen remove all number which lpf is p from S. */</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                    <span class="c1">// remove p*f from S</span>
                    <span class="n">c</span><span class="nf">.push</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span><span class="p">);</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">c</span> <span class="p">{</span>
                    <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="n">i</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意得是，不能标记一个合数 $f$ 就立刻把它删除，因为还需要依靠它去标记 $p\cdot f$ 以及其它后续的合数。所以必须要先收集一个质数 $p$ 标记的所有合数，然后再把它们删除。</p>

<h3 id="算法改进">算法改进</h3>

<p>如果可以从由 $p$ 组成的最大的那个合数开始逆序标记，那么就可以立刻删除 $p\cdot f$ 而不需要先收集起来。<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>这可以带来一些性能的提升和空间的节省。</p>

<p>那么问题就变成如何找到最大待标记数对应的 $f$ ，或者如何追踪它。</p>

<p>我们一步步地考虑这个问题，开始时 $p_1 = 2$ ，那么 $f_{\text{max}} = \large\lfloor \frac{n}{2} \rfloor$ ，在用 $p_1$ 标记完一轮后，再从 $f_{\text{max}}$  开始逐个向下检查，直到找到一个还在链表上的数，然后从它开始沿着链表倒序查找，找到一个满足  $p_2 \cdot f \leqslant n$ 的值作为第二轮 $p_2$ 对应的 $f_{\text{max}}$ 。</p>

<p>这样的话在从链表上删除某个数的时候，还需要在对应下标的某个数组上额外标记它，以便于能在 $O(1)$ 的时间里检查某个数是否在链表上。<code class="language-plaintext highlighter-rouge">backward</code> 还需要用来向前查找，可以用 <code class="language-plaintext highlighter-rouge">forward[i] = n+1</code> ，表示 $i$ 被删除。</p>

<p>这样的话标记结束的条件也可以用 $f_{\text{max}} \geqslant p$ 来代替。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">while</span> <span class="n">f_max</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f_max</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
        <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>
        <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>

        <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag it</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">forward</span><span class="p">[</span><span class="n">f_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">while</span> <span class="n">f_max</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//...</span>
</code></pre></div></div>

<p>有一个推论，但是还无法证明，链表上相邻的两个数不会被同一个 $p$ 标记<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">4</a></sup>，那么下一轮的 <code class="language-plaintext highlighter-rouge">f_max = backward[f_max]</code> 。</p>

<p>这样改进后的完整算法如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// lpf (least prime factor)</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2usize</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">f_max</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f_max</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
                    <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>
                    <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>

                    <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag it</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
                <span class="k">if</span> <span class="n">forward</span><span class="p">[</span><span class="n">f_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
                <span class="k">while</span> <span class="n">f_max</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="n">i</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析-2">复杂度分析</h3>

<p>显然，时间复杂度和空间复杂度均为 $O(N)$ 。</p>

<h3 id="算法评价-4">算法评价</h3>

<p>一般，跑得不快，内存占用在线性算法里也属于常数比较大的。</p>

<h2 id="轮筛骗局">轮筛骗局（×）</h2>

<p>轮筛<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup> 是假的，但轮子是真的。</p>

<h2 id="分段固定轮筛">分段固定轮筛<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup>（√√√）</h2>

<p>SFWS</p>

<h2 id="mairson-对偶筛">Mairson 对偶筛<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>（√√）</h2>

<h2 id="bengelloun-增量筛">Bengelloun 增量筛<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">9</a></sup><sup id="fnref:8:1" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>（√√√）</h2>

<h2 id="gpf-筛子">GPF 筛子<sup id="fnref:8:2" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>（√√）</h2>

<h2 id="gpf-增量筛">GPF 增量筛<sup id="fnref:8:3" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>（√√）</h2>

<p>为此引入了最小质因数因子 $\text{lpf}$ ，表示一个数它的唯一质因数分解里最小的那个质数，因此有一个递归定义：</p>

\[\text{lpf}(x)\]

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>G. H. Hardy and E. M. Wright. An Introduction to the Theory of Numbers. 1962. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Harry G. Mairson. Some new upper bounds on the generation of prime numbers. 1977. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>J.Misra. An Exercise in Program Explanation.  1979. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>形式地说，任意两个相邻的最小质因数为 $p_i$ 的自然数之间，至少存在一个最小质因数为 $p_j \gt p_i$ 的自然数。 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Paul Pritchard. A Sublinear Additive Sieve for Finding Prime Numbers. 1981. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Paul Pritchard. Explaining the Wheel Sieve. 1982. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Paul Pritchard. Fast Compact Prime Number Sieves (among Others). 1983. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Paul Pritchard. LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE. 1987. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:8:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:8:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a> <a href="#fnref:8:3" class="reversefootnote" role="doc-backlink">&#8617;<sup>4</sup></a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>S.A. Bengelloun. An Incremental Primal Sieve. 1986. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[质数筛子的原理是质因数分解。]]></summary></entry><entry><title type="html">算法复杂度分析的标记符号</title><link href="/algs/ComplexityNotations.html" rel="alternate" type="text/html" title="算法复杂度分析的标记符号" /><published>2024-07-28T00:00:00+08:00</published><updated>2024-07-28T00:00:00+08:00</updated><id>/algs/ComplexityNotations</id><content type="html" xml:base="/algs/ComplexityNotations.html"><![CDATA[<p>介绍下在分析算法复杂度时用到的标记符号，及其数学来源。</p>

<p>这些标记符号开始源于德国数学家 <a href="https://en.wikipedia.org/wiki/Paul_Gustav_Heinrich_Bachmann">Paul Bachmann</a> 和 <a href="https://en.wikipedia.org/wiki/Edmund_Landau">Edmund Landau</a> 的发明，后经 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a> 的整理，形成了现在熟悉的这些渐进符号（<strong>asymptotic notation</strong>）。</p>

<h2 id="o-记号">$O$ 记号</h2>

<p>开始叫做 big-O<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，后经过 Knuth 整理，也可以表示为 big Omicron 。</p>

<h3 id="形式化描述">形式化描述</h3>

<p>$f(x) = O(g(x)),\quad x\to \infty $</p>

<p>等价于：</p>

<p>$\exists (M\gt0, x_0)$ ，使得所有 $x \geqslant x_0$ ，都有 $|f(x)| \leqslant M g(x)$ ， 其中函数 $g(x)$ 对于足够大的 $x$ 来说总是正数。</p>

<h2 id="o-记号-1">$o$ 记号</h2>

<p>叫做 little-o ，也可以叫做 little omicron 。相比于 big-O ，little-o 的限制更加严格。</p>

<h3 id="形式化描述-1">形式化描述</h3>

<p>$f(x) = o(g(x)),\quad x\to \infty $</p>

<p>等价于：</p>

<p>$\forall \epsilon \gt 0,\ \exists x_0$ ，使得所有 $x \geqslant x_0$ ，都有 $|f(x)| \leqslant \epsilon g(x)$ ， 其中函数 $g(x)$ 对于足够大的 $x$ 来说总是正数。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>这个定义形式上就类似微分里面的上极限的定义。</p>

<h3 id="另一种形式">另一种形式</h3>

<p>按照定义高阶无穷小的方式，它还可以写作：</p>

<p>$\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = 0$</p>

<p>也就是说，$g(x)$ 是更高阶的一个函数，是 $f(x)$ 的严格上限。这种 little-o 的记号在泰勒展开式里作为余项也用到过。</p>

<h3 id="与-o-的关系">与 $O$ 的关系</h3>

<p>记号描述得其实是一种集合成员与集合的概念，这样我们就清楚了 big-O 实际上就是同阶函数和更高阶函数 $o$ 两个不相交集合的并集 <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<h2 id="omega--omega-记号">$\Omega$ &amp; $\omega$ 记号</h2>

<p>分别叫做 big Omega 和 little omega ，根据 Knuth 的归纳调整，big Omega 成为了：</p>

<p>$f(x) = \Omega(g(x)) \Leftrightarrow g(x) = O(f(x))$</p>

<p>而 little omega 则对应了：</p>

<p>$f(x) = \omega(g(x)) \Leftrightarrow g(x) = o(f(x))$</p>

<p>但是按照函数阶的集合的观点更直观，big Omega 代表小于或等于这个阶的函数集合，而 little omega 则代表了；严格小于这个阶的函数集合。</p>

<h2 id="theta-记号">$\Theta$ 记号</h2>

<p>叫做 big Theta。根据 Knuth 的定义：</p>

<p>$f(x) = \Theta(g(x)) \Leftrightarrow f(x) = O(g(x)) = \Omega(g(x))$</p>

<p>是说给出的 $g(x)$ 同时满足了 big-O 和 big Omega 这两个集合的定义。</p>

<h2 id="总结">总结</h2>

<p>可以按照如下表对复杂度记号进行理解：</p>

<table>
  <thead>
    <tr>
      <th>记号</th>
      <th>逻辑关系</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$O$</td>
      <td>$\leqslant$</td>
    </tr>
    <tr>
      <td>$o$</td>
      <td>$\lt$</td>
    </tr>
    <tr>
      <td>$\Theta$</td>
      <td>$\simeq$</td>
    </tr>
    <tr>
      <td>$\Omega$</td>
      <td>$\geqslant$</td>
    </tr>
    <tr>
      <td>$\omega$</td>
      <td>$\gt$</td>
    </tr>
  </tbody>
</table>

<p><a href="https://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities">备查时间复杂度表</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>根据 <a href="https://en.wikipedia.org/wiki/Big_O_notation#History_(Bachmann%E2%80%93Landau,_Hardy,_and_Vinogradov_notations)">wiki</a> 的说法， big-O 来源于德语 “Ordnung”，用来表示近似阶的意思。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>显然这里的 $\epsilon$ 和 big-O 形式化定义里面的 $M$ 是一样的，只是作为一种对使用传统的尊重，大写英文字母用作某个常数而 $\epsilon$ 用作任意（小）的数字。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>很容易搞混得是 $f(x)\sim g(x)$ 描述得是等价关系 $\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = 1$ 而不是同阶关系 $\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = C \gt 0 $，缺少一个描述同阶关系的记号有点儿别扭。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[介绍下在分析算法复杂度时用到的标记符号，及其数学来源。]]></summary></entry><entry><title type="html">质数基础</title><link href="/algs/Prime0.html" rel="alternate" type="text/html" title="质数基础" /><published>2023-12-29T00:00:00+08:00</published><updated>2023-12-29T00:00:00+08:00</updated><id>/algs/Prime0</id><content type="html" xml:base="/algs/Prime0.html"><![CDATA[<h2 id="定义">定义</h2>

<p>质数（prime），指大于 $1$ 的自然数里，不能拆解为比它严格更小两个的自然数乘积的数。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>互质（co-prime），两个整数 $a$，$b$ 没有除了 $1$ 以外的作为正整数的共同除数（divisor），则说 $a$ 质于 $b$ ，或者 $a,b$ 互质<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup>。<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">3</a></sup></p>

<h2 id="性质">性质</h2>

<h3 id="欧几里得引理">欧几里得引理<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">4</a></sup></h3>

<p><del><strong>原始版本</strong>：如果质数 $p$ 能够除 $a\cdot b$ <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">5</a></sup>，并且 $p$ 不能除 $a$ ，则 $p$ 能够除 $b$ 。</del></p>

<p><strong>现代版本</strong>：如果一个整数 $n$ 能够除 $a\cdot b$ ，并且 $n$ 与 $a$ 互质，则 $n$ 能够除 $b$ 。</p>

<h4 id="证明">证明</h4>

<p>现代版是对把原始欧几里得引理推广到一般整数上，我们直接对此进行证明。</p>

<p>不妨假设 $n$ 是非负数：</p>

<h5 id="证初始条件">证初始条件</h5>

<p>对于初始情况，比如 $ab = 0$ ，此时 $a=0$ 或 $b=0$ 。</p>

<p>假设 $a=0$ ，因为 $n\perp a$ ，那么显然有 $n = 1$ ，而 $1$ 可以除任何数，当然能够除 $b$ ，结论成立；</p>

<p>假设 $b=0$，$b$ 能够被任何数整除，当然能被 $n$ 整除，条件成立。</p>

<h5 id="证递推关系">证递推关系</h5>

<p>假设结论对于所有积在 $[0, ab)$ 的情况结论都成立：</p>

<p>因为 $n | a\cdot b$ ，不妨令</p>

\[n\cdot q=ab \qquad\qquad \texttt{(1)}\]

<p>如果 $n=a$ ，因为 $n\perp a$ ，那么显然有 $|n| = 1$ ，那么 $n$ 一定可以除 $b$ ；</p>

<p>如果 $n\lt a$ ，两边减去 $n\cdot b$ ，得到 $nq - nb = ab - nb$ ，也就是 $n(q-b) = (a-n)b$ 。又因为 $n\perp a$ ，所以有 $n\perp a-n$ <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">6</a></sup> ，而 $0 \leqslant (a-n)b \lt ab$ ，按照假设，有 $n | b$ ；</p>

<p>否则 $n \gt a$，两边减去 $a\cdot q$ ，得到 $nq-aq = ab-aq$ ，也即</p>

\[(n-a)q=a(b-q) \qquad\qquad \texttt{(2)}\]

<p>类似地， 因为 $n-a\perp a$ ，而 $0 \leqslant a(b-q) \lt ab$ ，所以有 $n-a | b-q $ 。不妨令 $b-q = r(n-a)$ ，代回式 $\texttt{(2)}$ 得到 $(n-a)q=(n-a)ar$ ，于是有 $q=ar$ ，代回式 $\texttt{(1)}$ 有 $nar=ab$，$b=nr$ ，也就是 $n|b$ 。</p>

<p>于是我们证明了递推关系的成立。</p>

<p>欧几里得引理证毕。</p>

<h3 id="算式基本定理">算式基本定理<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup></h3>

<p>每一个大于 $1$ 的正整数都可以，而且唯一地分解为一组质数的乘积。</p>

<h4 id="证明-1">证明</h4>

<h5 id="存在性证明">存在性证明</h5>

<p>这很容易理解，假如一个大于 $1$ 的正整数的因式分解不是质数就是合数，因式分解后，如果存在合数，那么合数本身也一定可以继续分解，直到只剩下质数为止。</p>

<h5 id="唯一性证明">唯一性证明</h5>

<p>反证法，假设 $s$ 是最小的、至少有两个质数分解组合的正整数：$s = \prod p_m = \prod q_n$ 。</p>

<p>既然 $p_1 \perp q_k$ ，根据上文欧式引理，有 $p_1 |\prod_{1}^{n-1} q$；同理，$p_1 \perp p_{k=n-1}$ ，可得 $p_1 | \prod_{1}^{n-2} q$ ；直到 $p_1 | q_1$ 。又因为 $p_1 \perp q_1$ ，所以只能是 $p_1 = q_1$ ，这样就得到了比 $s$ 更小的能分解为至少两个质数组合的正整数 $\prod_{2}^{m} p = \prod_{2}^{n} q$ ，与前提假设相悖，于是反证成立。</p>

<h5 id="唯一性证明独立">唯一性证明（独立）</h5>

<p>这里通过不依赖欧几里得引理来独立证明。</p>

<p>仍然通过反证法，假设 $s$ 是最小的、至少有两个质数分解组合的正整数 $s = \prod p_m = \prod q_n$ 。</p>

<p>如果两个组合里存在一对儿相等的质数 $p_i = q_j$ ，则两边约掉相等的数后会出现一个比 $s$ 更小的多质数分解的整数，与前提相悖。</p>

<p>因此不妨可以假设 $p_1 \lt q_1$ ，令 $P=\prod_{2}^{m} p$ ，$Q=\prod_{2}^{n} q$ ，则有 $s=p_1P=q_1Q$ 。</p>

<p>又有 $p_1 \lt q_1$ ，所以 $P \gt Q$ ，不妨令 $s’$ 等于 $s$ 减去 $p_1Q$ ，得到 $s’ = p_1(P-Q) = Q(q_1-p_1)$ 。因为 $ s’ \lt s$ ，所以 $s’$ 只有唯一的质因数分解，那么 $p_1$ 要么在 $q_1 - p_1$ 的部分，要么在 $Q$ 的部分。</p>

<p>如果 $p_1$ 在 $q_1-p_1$ 的部分，则有 $p_1 | q_1$ ，与 $p_1$ 、$q_1$ 都是质数相悖；</p>

<p>如果 $p_1$ 在 $Q$ 的部分，由于前面的结论，$p_1 \not\in \lbrace q \rbrace$ ，因此就有两对儿质因数分解，这样就发现了比 $s$ 更小的多组质因数分解的正整数 $Q$ ，与假设相悖。</p>

<p>反证证毕。</p>

<h2 id="质数分布">质数分布</h2>

<h3 id="质数定理">质数定理<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">8</a></sup></h3>

<p>首先定义一个用于质数计数的函数 $\pi(N)$ ，表示 $\leqslant N$ 范围内的质数个数，那么有：</p>

\[\pi(x) \sim \frac{x}{\log x}\]

<p>据此，也可以推出第 $n$ 个质数 $p_n$ 的渐进表示：</p>

\[p_n \sim \frac{n}{\log n}\]

<p>推理过程：</p>

<p>首先这实质是在求 $\pi(x)$ 的反函数（的渐进表示），已知 $y\sim\large\frac{x}{\log x}$ ，两边取 $\log$ 得到 $ \log y \sim \log x - \log\log x \sim \log x$ <sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">9</a></sup>，带回 $\pi(x)$ 原式得到 $x \sim y\log y$ ，也即 $p_n \sim \large\frac{n}{\log n}$ ，证毕。</p>

<h3 id="伯特兰-切比雪夫定理">伯特兰-切比雪夫定理<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">10</a></sup></h3>

<p>对于 $n &gt; 3$ ，至少存在一个质数 $p$ ，满足 $n \lt p \lt 2n-2$ 。</p>

<p>更宽松、但更适用的形式是对于 $n\geqslant 2$：</p>

\[n \lt p \lt 2n\]

<p>证明很简单，首先对于 $n\gt 3$ 的情况，显然由于更宽松的形式，上式是成立的；而对于 $n=2$ 和 $n=3$ 的特殊情况，分别有 $2 \lt 3\lt 4$ 和 $3 \lt 5\lt 6$ ，也使得上式成立。</p>

<p>通过反证法还可以得出对于 $n\geqslant 1$ ，也就是所有质数：</p>

\[p_{n+1} \lt 2p_n\]

<h2 id="质性测试">质性测试</h2>

<p>这里将介绍简单的测试方法<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup> – 试除法（trial division），其中使用的技巧将在后面查找范围内所有质数的方法里得到进一步的拓展。</p>

<p>被测试的整数记为 $n$ ，试除法，顾名思义就是检查所有 $2\dots n-1$ 的值能否除 $n$ ，也就是根据原始定义进行测试。这里主要介绍常见的优化技巧：</p>

<p>首先，因数测试的上限不需要到 $n-1$ ，而只需要到 $\lfloor \sqrt{n} \rfloor$ <sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup> ，因为因数如果存在，一定是一大一小或者相等大小，只需要检查所有较小或者相等的数就行。</p>

<p>其次，可以先检测大多数情况下最常见的质因数：$2, 3$ 来快速失败。</p>

<p>更进一步地，可以排除所有与 $2,3$ 不互质的数，实质上我们是在尝试寻找 $n$ 的质因数，可以用 $3\sharp\cdot k+i = 6k+i$ <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">13</a></sup>的形式表示后面的数字，其中 $k \in N^+, 0\leqslant i \lt 3\sharp$ 。之所以选择 $3\sharp$ 作为周期长度，是因为它是这些质因子的最小公倍数，在此基础上排除那些与 $2$ 或 $3$ 不互质的 $i$ ，比如 $i=0, 2, 4$ ，也就是只需要检查 $6k+1, 6k+5$ 。如果从数字 $5$ <sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">14</a></sup>开始检查是否能除 $n$ ，那么为了方便起见，周期内的这两个位置 $x$ 可以表示为 $x \mod{6} \equiv \pm1$ 。</p>

<p>有了这样三个主要地优化，现在就可以写下试除法的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">is_prime</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n:expr</span><span class="p">;</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

            <span class="nv">'ret</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">5</span><span class="o">..=&lt;</span><span class="nv">$ty</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">isqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">break</span> <span class="nv">'ret</span> <span class="kc">false</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">break</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用宏只是因为 Rust 缺乏统一描述常见基本数字类型的 Trait ，而使用 <code class="language-plaintext highlighter-rouge">loop</code> 是为了在宏里模拟函数体行为。</p>

<h2 id="查找质数">查找质数</h2>

<p>具体来说，是这样一个问题：给定一个正整数 $n$ ，查找所有质数 $p\leqslant n$ 。<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">15</a></sup></p>

<p>方法论是通过“筛子” （Sieves）来排除合数，直到只剩质数，这种缩减问题规模的办法，也是数学上对此类问题的通解。</p>

<p>详见专篇：<a href="/algs/Prime1.html">质数筛子</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>或者另一种说法，只能被 $1$ 和 它自己整除的数字。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>记作 $a \perp b$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>质数的要求是正整数，而互质的两个数里显然可以存在负整数，其中 $1$ 和 $-1$ 是唯一的两个和所有数都互质的数，也是唯一和 $0$ 互质的数；除了 $1$ 以外，自己与自己不互质。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Euclid’s lemma，以下简称欧式引理 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>除，divide， $p$ 能被除 $a\cdot b$ 也即 $a\cdot b$ 能被 $p$ 整除，记作 $p| a\cdot b$ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>反证法，若 $n\not\perp a-n$ ，则 $n \not\perp a-n + n$ ，与前提条件相悖。 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Fundamental theorem of arithmetic，也可以形象地叫做正整数唯一分解定理，某种程度我更倾向于这个名字，因为这个名字一点儿都不故弄玄虚，是自解释的，但是作为章节标题它有点儿长了 :(，其他名字还有 Unique factorization theorem、 Prime factorization theorem 等等. 。 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Prime Number Theory，简称 PNT 。 <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>$\log\log x = o(\log x) $ <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>Bertrand-Chebyshev Theorem，一开始是由伯特兰提的猜想（postulate），最先被切比雪夫证明。 <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>还有更复杂的经验算法、概率测试算法、快速确定性测试算法等一系列计算较为复杂的方法 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>在现代编程语言里应该有名字诸如 <code class="language-plaintext highlighter-rouge">isqrt</code> 的数学函数来实现向下取整的平分根计算。 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>$c\sharp$ 指得是质数的阶乘（primorial），它可以指所有小于等于正整数 $c$ 的质数的乘积。对它的估算是 $c\sharp \leqslant 4^n$ <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>$2, 3$ 前面在前面作为快速失败的优化已经提前测过，$4$ 是 $2$ 的倍数直接跳过，于是从 $5$ 开始检测。 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>实质上是查找 $[2\dots n]$ 范围内的所有质数。 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[定义]]></summary></entry><entry><title type="html">LeetCode Packet 2</title><link href="/oth/LeetCodePacket2.html" rel="alternate" type="text/html" title="LeetCode Packet 2" /><published>2023-12-25T00:00:00+08:00</published><updated>2023-12-25T00:00:00+08:00</updated><id>/oth/LeetCodePacket2</id><content type="html" xml:base="/oth/LeetCodePacket2.html"><![CDATA[]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">0174 - Dungeon Game</title><link href="/oth/LeetCode0174.html" rel="alternate" type="text/html" title="0174 - Dungeon Game" /><published>2023-12-11T00:00:00+08:00</published><updated>2023-12-11T00:00:00+08:00</updated><id>/oth/LeetCode0174</id><content type="html" xml:base="/oth/LeetCode0174.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/dungeon-game/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>绝对标准地 <em>Hard</em> 难度的问题。</p>

<p>给一个二维的地图，从左上角走到右下角，看起来非常像之前做过的譬如 <a href="/oth/LeetCode0085.html">0085 - Maximal Rectangle</a> 这样的题目，只需要从上到下地逐行扫描，计算从起点到每一行的每个位置的子问题的解，直到最后一行的最后一个位置。</p>

<p>但是对于本题这样做是不行的，因为一般到某个位置的路线有两条，一条是从上到下的，一条是从左到右的，而有两个指标用来选择最小生命值的路线，一个是到当前位置为止整个路径上出现过的路径和的最小值，另一个是到当前位置的路径和。这两个指标可能是矛盾的，比如有一条路线的最小值较大但是路径和较小，导致选择该路线最终在后面得到了较小的最小值，从而得到了不正确的结果。</p>

<p>换句话说，前面的子问题的路线选择受后面位置数值的影响，这个 DP 的解法存在<strong>后效性</strong>，因此这个解法是不能成立的。</p>

<p>这样问题就陷入了困局，实际上我花了几天的时间去考虑这个题，终于发现我们可以从终点开始做 DP 这样就避开了后效性的问题，于是引入了新的 DP 思路：<strong>后效翻转</strong> 。</p>

<p>对于这道题来说，子问题变成从前面的位置到终点的最小生命值，这样从后向前找，路线的选择是确定的，只需要比较两条路线：下方和右方对应的解，选较大的即可，而当前位置子问题的解则是比较</p>

<ol>
  <li>后面的解加上当前位置值；</li>
  <li>当前位置的值，取这两个的最小值</li>
</ol>

<p>顺带一讲，这个解应该是路径上的最小值，而路径的选择是让这个路径最小值取到最大，这样才可以付出最小生命。最后的最小生命就是把这个最小值取反，比较它与零的大小，取一个最大值，把结果加上 1 ，这样保证最后至少有一点生命值。</p>

<h2 id="解迭代版本">解①迭代版本：</h2>

<p>或者说 BFS，比起递归版本，这个版本通常有更多地细节去深入。</p>

<p>这个解法的复杂之处在于需要考虑下受地图矩形的长度和宽度两个因素限制的坐标位置，特别是如果我们想要用一维数组来存储子问题解的话。</p>

<p>计算的整个过程是从终点倒退回起点，计算每一步可到位置的子问题解，就如下图所示：</p>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map1.svg" style="zoom:150%;" /></div>

<p>灰色线连起来的区域就是每一步可能到达的位置，这里用步数作为控制流程的变量，并为了方便以终点为原点建立坐标系，等到访问 <code class="language-plaintext highlighter-rouge">dungeon</code> 数组（以下简写作 $D$ ）时再把坐标转换为以左上角为原点的坐标系。</p>

<p>这样地话，对于 $m$ 行 $n$ 列的 $D$ 数组 假设当前步数是 $l$ ，那么</p>

<p>能够到达的最大的高度 $h=\min(m,l)$ ，最大宽度 $w=\min(n,l)$ 。</p>

<p>因此在当前步数的从左下到右上的可达范围里</p>

<p>左下位置 $(x_0,y_0): (l-w+1,w)$ ，右上位置 $(x_1,y_1): (h, l-h+1)$ 。</p>

<p>这样的话，每一步的位置范围就是从 $x_0 \rightarrow x_1$ ，记录下它的差 $d_\text{max} = x_1-x_0$ ，可以用来指示当前步数最后一个位置的在一维数组里的下标。</p>

<p>由于每步的位置数并不相同，因此交替使用两个一维的数组（$\text{low}_1$ 和 $\text{low}_0$）来存储当前步数和之前步数的子问题解，而解的计算要根据所处位置分为三个阶段、四种情况。三个阶段是随着步数的增加会出现的，矩形长宽都没有限制的<strong>前场</strong>、较短一维限制而较长一维没有限制的<strong>中场</strong>，以及两个维度都被限制的<strong>后场</strong>。</p>

<h3 id="1-矩形前场">1. 矩形前场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map5.svg" style="zoom:120%;" /></div>
<p><br /></p>

<p>矩形前场就是在从终点开始的扫描过程中，随着步数增加，$h$ 和 $w$ 增加的情况。此时最左下角只能从它的右方得到，右上角只能从它的下方得到，其余位置都可以从两边得到。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\lt d_\text{max})
\end{array}
\right.\]

<h3 id="2-宽矩形中场">2. 宽矩形中场</h3>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map2.svg" style="zoom:120%;" /></div>
</p>
<p>所谓中场，就是随着步数增加，$d_\text{max}$ 却保持不变的阶段，是在步数超过较短一维的长度时进入而在步数达到较长一维的长度时退出的一个阶段。
\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\leqslant d_\text{max})
\end{array}
\right.\)</p>

<h3 id="3-高矩形中场">3. 高矩形中场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map3.svg" style="zoom:120%;" /></div>
<p>\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\lt d_\text{max})
\end{array}
\right.\)</p>

<h3 id="4-矩形后场">4. 矩形后场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map4.svg" style="zoom:120%;" /></div>

<p>后场就是当中场结束时，也就是步长超过较长一维时进入的阶段。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\leqslant d_\text{max})\]

<p>于是我们便得到了代码。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">low0</span> <span class="o">=</span> <span class="p">[</span><span class="n">dungeon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">low1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">tot</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">d_max</span> <span class="o">=</span> <span class="n">x1</span><span class="o">-</span><span class="n">x0</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 矩形前半场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 宽矩形中间场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 高矩形中间场 (x0 != 1)
</span>            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 矩形后半场
</span>            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="n">low0</span><span class="p">,</span> <span class="n">low1</span> <span class="o">=</span> <span class="n">low1</span><span class="p">,</span> <span class="n">low0</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：69 ms (beats 81.50%, ~100%, 55 ms)，内存占用：17.5 MB (beats 63.73%, ~100%)。</p>

<h2 id="解">解②：</h2>

<p>或者说 DFS。</p>

<p>在上面的迭代版本或者BFS版本里，不管是分析还是代码都显得有些冗长，这主要是因为我们不愿意直接把判断放在循环里，而要弄清楚所有的过程细节，而对于递归版本，可以很简单地实现。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：78 ms (beats 39.60%, ~100%)，内存占用：20.21 MB (beats 5.06%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0152 - Maximum Product Subarray</title><link href="/algs/LeetCode0152.html" rel="alternate" type="text/html" title="0152 - Maximum Product Subarray" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/LeetCode0152</id><content type="html" xml:base="/algs/LeetCode0152.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-product-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>经典 <em>Medium</em> 但是 <em>Hard</em> ，这道题单独看可以算作 Medium 类型的题目，但是作为 DP 标签就显得很 Hard，因为题目和一般的 DP 思路好像有关系，实质是没有关系，如果再类比 <a href="/algs/LeetCode0053.html">0053 - Maximum Subarray</a> 的思路那就更困难了，难就难在干扰项。</p>

<p>同样也是正、负、零三种整数，而累积和累和的区别在于累积的符号会翻转而且幅度越来越大，最大数可以由正数乘积得到，或者负数的乘积遇到负数翻而来。</p>

<h2 id="解常规">解①常规：</h2>

<p>用 $0$ 把数组分段，按照负数的数量分情况讨论：</p>

<p>$=0$：直接累乘</p>

<p>$=1$：比较两边的正数的累积结果，</p>

<p>$=2$：直接累积</p>

<p>$\geqslant$ 3：</p>

<p>​	3.1. 奇数，比较从第一个负数后的正数开始乘到尾和从头开始乘到最后一个负数前的正数；</p>

<p>​	3.2. 偶数，累乘</p>

<p>这样只需要记录负数的坐标（不需要记全，对于超过了两个的，只需要记录第一个和最后一个负数的坐标即可）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#  i-zero &gt; 2
</span>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

            <span class="n">zero</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">neg</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">cand</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">cand</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：76 ms (beats 78.56%, ~100%)，内存占用：16.2 MB (beats 99.98%)。</p>

<h2 id="解正负值">解②正负值：</h2>

<p>可以在一遍的过程中计算这些数，只需要两个变量来存储状态，pos 表示最大的正数，neg 表示最小的负数（或者绝对值最大的负数。</p>

<p>这两个变量代表的子数组拥有相同的后缀，也就是扫描到的位置。</p>

<p>在开始或者遇到 $0$ 时，pos 和 neg 都设为 None，如果在 None 的时候遇到同符号的数值时，赋值给它们，否则就继续累乘；如果不为 None 则当遇到反符号的时候，就给反符号赋值（注意保存被覆盖的值，这时分组赋值就很合适）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">*=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">neg</span> <span class="o">*=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">neg</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>

                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：73 ms (beats 88.24%, ~100%), 内存占用：16.95 MB (~100%)。</p>

<h2 id="解前后缀">解③前后缀：</h2>

<p>由于实际上的差异只是由，也可以不考虑正负值的变化情况，直接从前缀和后缀两个方向计算累乘，当发现累积归为 0 时，就改乘为赋值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">postfix</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">postfix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">postfix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：80 ms (beats 54.67%, ~100%)，内存占用：16.76 MB (~100%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">最大子数组</title><link href="/algs/MaxSubArr.html" rel="alternate" type="text/html" title="最大子数组" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/MaxSubArr</id><content type="html" xml:base="/algs/MaxSubArr.html"><![CDATA[<p>收集一系列有关最大子数组的问题。</p>

<h2 id="最大子数组和"><a href="/algs/LeetCode0053.html">最大子数组和</a></h2>

<h2 id="最大子数组积"><a href="./LeetCode0152">最大子数组积</a></h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[收集一系列有关最大子数组的问题。]]></summary></entry><entry><title type="html">1458 - Max Dot Product of Two Subsequences</title><link href="/algs/LeetCode1458.html" rel="alternate" type="text/html" title="1458 - Max Dot Product of Two Subsequences" /><published>2023-10-17T00:00:00+08:00</published><updated>2023-10-17T00:00:00+08:00</updated><id>/algs/LeetCode1458</id><content type="html" xml:base="/algs/LeetCode1458.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.20/1458_max_dot_prod_of_two_seq/py1458">源代码</a></p>

<p>一般地<a href="/algs/TwoStrDP.html">两串上的DP</a>是从两个前缀子串开始的更小规模的问题扩展到全串，从而直接解决题目要求的问题，而本题特殊的地方是子序列并不是完整的前缀子串。</p>

<p>不妨把前缀子串视为 border，而譬如子序列则是  content ，它和 border之间有 padding ，其他普通的问题可以通过 border 就可以直接计算出来，而对于子序列这样的问题，需要额外考虑是否需要“填充” padding。</p>

<p>“padding” 的引入让问题稍微复杂了一点，但主要还是干扰了我们破题的思路，如果我们能把保持一个清晰的思路，解题还是很容易的。</p>

<h2 id="第一版">第一版：</h2>

<p>因为乘积存在负数，并且不允许空的点积序列，因此先排除乘积全是负数的情况。</p>

<p>之后在 DP 过程中只需要考虑是否把非负的乘积加进来即可，这也暗示了“padding”的判断方法：只有正的乘积会被加进来，负的会被视为“padding”跳过。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="k">return</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums2</span><span class="p">))</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>282 ms (beats 82.09%), 19.02 MB (beats 66.24%)</p>

<h2 id="改进">改进：</h2>

<ol>
  <li>采用了一个稍微更好一点的对于乘积全是负数的情况的判断方法，取两个极值进行比较，但是因此要分两种情况进行判断；</li>
  <li>按照前面滚动数组的思路讲空间占用压缩到一维；</li>
  <li>合并了 DP 核心算法里的分支判断</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">nums1_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_max</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_max</span> <span class="o">*</span> <span class="n">nums2_min</span>

    <span class="n">nums1_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_min</span> <span class="o">*</span> <span class="n">nums2_max</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>183 ms (beats 95.32%), 16.34 MB (beats 92.92%, ~100%)</p>

<h2 id="另版">另版：</h2>

<p>还有一点稍稍不同思路的是把全负乘积考虑进一般情况，但是对于压缩的 DP 数组来说，需要额外处理初始值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>189 ms (beats 95.32%), 16.29 MB (beats 97.06%, ~100%)</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Best Time to Buy and Sell Stock</title><link href="/oth/LeetCodeBuySellStock.html" rel="alternate" type="text/html" title="LeetCode Best Time to Buy and Sell Stock" /><published>2023-10-01T00:00:00+08:00</published><updated>2023-10-01T00:00:00+08:00</updated><id>/oth/LeetCodeBuySellStock</id><content type="html" xml:base="/oth/LeetCodeBuySellStock.html"><![CDATA[<h2 id="0121-best-time-to-buy-and-sell-stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">0121. Best Time to Buy and Sell Stock</a></h2>

<p><em>Easy</em></p>

<p>单次交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0122-best-time-to-buy-and-sell-stock-ii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">0122. Best Time to Buy and Sell Stock II</a></h2>

<p><em>Medium</em></p>

<p>不限次数交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0123-best-time-to-buy-and-sell-stock-iii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">0123. Best Time to Buy and Sell Stock III</a></h2>

<p><em>Hard</em></p>

<p>限制两次交易</p>

<h3 id="破题">破题</h3>

<p>题目的复杂程度终于提升到了有点儿意思的程度，这里的关键是搞清楚“最多两次”交易的限制条件到底对我们的模型意味着什么？</p>

<p>可以认为，做两次交易的收益总是不差于一次交易，只要在计算模型上把一次交易视为两次交易的边缘值。</p>

<h3 id="解两遍扫描">解①两遍扫描</h3>

<p>把价格表分为两部分，左边用于第一次交易，右边用于第二次交易，这样只需要检查每个位置的两次交易之和，求一个最大值即可。可以让左边分割的串从空串开始，这样就包含了一次交易的情况。</p>

<p>每次分割的左边串的最大收益可以依靠前面 <a href="#0121-best-time-to-buy-and-sell-stock">0121. Best Time to Buy and Sell Stock</a> 来计算，而分割的右边串则可以预先运用同样的算法反向扫描，保存个位置的计算结果，在从左开始扫描的时候查询表即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


    <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：760 ms (beats 98.06%)，内存占用：30.5 MB (beats 72.56%, ~100%)</p>

<h3 id="解规范解">解②规范解</h3>

<p>在上一个解的时候，我们通过组合单次求解的方法来计算两次交易得到的最大收益，而这个单次求解的方法好像扫描一个个位置就可以进行该位置的更新，（因为当天交易收益总是零，因此是否允许当天交易都不重要），这暗示我们很可能有一个扫描每个位置就可以计算出两次交易的最大收益的模型。</p>

<p>这才引出对股票买卖问题的统一模型：</p>

<p>累积计算每次买或卖的收益，买的收益是 $-\text{price}$ ，卖的收益是买的收益加上 $\text{price}$ ，下次交易的收益基础是之前的收益。</p>

<p>对于两次买卖就有：</p>

\[\begin{align}
\text{buy}_1 &amp;= \max(\text{buy}_1',\text{-price})\\
\text{sell}_1 &amp;= \max(\text{buy}_1',\text{price})\\
\text{buy}_2 &amp;= \max(\text{sell}_1',\text{-price})\\
\text{sell}_2 &amp;= \max(\text{buy}_2',\text{price})\\
\end{align}\]

<p>也就是：$\text{buy}_1 \rightarrow \text{sell}_1 \rightarrow \text{buy}_2 \rightarrow \text{sell}_2$</p>

<p>有必要解释下，按照自然流程，两次交易至少应该是第一天 $\text{buy}_1$ ，第二天 $\text{sell}_1$ ，第三天 $\text{buy}_2$，第四天 $\text{sell}_2$，是一个 $4$ 天的窗口，但是这需要额外检查下数据长度，而把这些操作压缩到一天，并不影响结果，而且可以适应长度不足 $4$ 的情况。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy1
</span>    <span class="n">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy2
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">buy1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell1</span> <span class="o">&lt;</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell1</span> <span class="o">=</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span>
        <span class="k">if</span> <span class="n">buy2</span> <span class="o">&lt;</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy2</span> <span class="o">=</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell2</span> <span class="o">&lt;</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell2</span> <span class="o">=</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell2</span>
</code></pre></div></div>

<p>运行时间：670 ms (beats 99.76%)，内存占用：30.5 MB (beats 88.72%, ~100%) 。</p>

<p>这个统一模型在一遍扫描就解决了问题，并且省掉了前面的 $O(n)$ 的内存占用<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> 。</p>

<h2 id="0188-best-time-to-buy-and-sell-stock-iv"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">0188. Best Time to Buy and Sell Stock IV</a></h2>

<p><em>Hard</em></p>

<p>上面问题的一般化，不是限制两次交易，而是给定的参数 $k$ 次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># buy[i] - sell[i+1]
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
                <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span>
            <span class="k">elif</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
                <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：59 ms (Beats 99.16%, ~100%)，内存占用：16.36MB (Beats 82.07%，~100%)。</p>

<h2 id="0309-best-time-to-buy-and-sell-stock-with-cooldown"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">0309. Best Time to Buy and Sell Stock with Cooldown</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有冷冻期</p>

<h3 id="破题-1">破题</h3>

<p>购买冷冻期机制的引入改变了整个的模型，使得我们不能像前面的那个无限次数交易那样简单统计所有增量，就可以得到答案。</p>

<p>如果遵循股票买卖整个系列的顺序来做题，题解可能格外困难，因为很容易受到前面解题思路的影响，而重构整个模型并没有那么直观，因此我认为应该把这道题标记为 Hard 难度。</p>

<p>因此，让我们先从最简单地、最基本地方法开始：一个基于递归，使用记忆化优化的，穷举所有可能的解决方法。</p>

<h3 id="解递归记忆化">解①递归记忆化</h3>

<p>逐个读取价格表，分两个模式：等待购入和等待卖出。下面分别用 $\text{Buy}$ 和 $\text{Sell}$ 表示这两个模式，在 $\text{Buy}$ 模式下有两种选择：在当前价格日卖出和下一天再说，同样地 $\text{Sell}$ 模式也有两种选择，以当前价格卖出和下一天再说。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">Buy</span> <span class="o">=</span> <span class="n">auto</span><span class="p">(),</span>
    <span class="n">Sell</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">recur</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：52 ms (beats 44.28%, ~100%)，内存占用：21.06 MB (beats 31.05%)。</p>

<h3 id="解迭代dp">解②迭代DP</h3>

<p>上面的递归实现，可以帮助我们理清普通 DP 版本的实现思路。</p>

<p>对于交易有限次数的股票模型，可以穷举所有所有轮次买和卖的状态，但是对于不限次数的模型，则不能这样穷举，只能区分买和卖，不能辨别轮次。</p>

<p>尝试从正面看这个问题，分别用 <code class="language-plaintext highlighter-rouge">buy</code> 和 <code class="language-plaintext highlighter-rouge">sell</code> 两个数组代表一个前缀价格串上的最后操作是买或卖带来的最大收益。</p>

<p>这样，</p>

<ol>
  <li>
    <p>买的最大收益是要比较前一天买的最大收益（意味着当前没有买卖）以及包含冷冻期在内的卖的最大收益加上当前价格；</p>
  </li>
  <li>
    <p>卖的最大收益则是前一天卖的最大收益（意味着当前没有买卖）或者前一天买的最大收益加上当前价格（当前卖出）</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：36 ms (beats 98.07%, ~100%)，内存占用：16.39 MB (beats 99.34%) 。</p>

<p>当然，仔细观察代码，会发现 $O(n)$ 的内存占用是不必要的，实际上只需要维护三个持久变量：$\text{buy}_0$, $\text{buy}_1$ 和 $\text{sell}_0$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">buy0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy0</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sell0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy1</span><span class="p">,</span> <span class="n">sell0</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell0</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">sell0</span> <span class="o">=</span> <span class="n">sell1</span>
        <span class="n">buy1</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">=</span> <span class="n">buy2</span><span class="p">,</span> <span class="n">buy1</span>

    <span class="k">return</span> <span class="n">sell0</span>
</code></pre></div></div>

<p>运行时间：45 ms (beats 79.16%, ~100%)，内存占用：16.56 MB (beats 87.33%. ~100%) 。</p>

<h2 id="0714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">0714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有交易费</p>

<h3 id="解状态dp">解①状态DP</h3>

<p>直接按照前面交易冻结日的股票交易模型，易得</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">,</span> <span class="n">sell</span><span class="o">-</span><span class="n">price</span><span class="p">)</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">,</span> <span class="n">buy</span><span class="o">+</span><span class="n">price</span><span class="o">-</span><span class="n">fee</span><span class="p">)</span>

        <span class="n">buy</span> <span class="o">=</span> <span class="n">buy1</span>
        <span class="n">sell</span> <span class="o">=</span> <span class="n">sell1</span>

    <span class="k">return</span> <span class="n">sell</span>
</code></pre></div></div>

<p>运行时间：566 ms (beats 77%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h3 id="解贪心">解②贪心</h3>

<p>但是还是有方法利用像 <a href="#0122-best-time-to-buy-and-sell-stock-ii">0122. Best Time to Buy and Sell Stock</a> 问题那样直接地算法来解决。</p>

<p>只需要把交易费用加在购入价格上即可。</p>

<p>注意这里的 $\text{buy}$ 区别于分状态 DP 问题里面的  $\text{buy}$ ，它表示得不是购入的最大收益，而是最低价格。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">fee</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span>
        <span class="k">elif</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">price</span><span class="o">-</span><span class="n">buy</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：495 ms (beats 99.5%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>虽然形式上压缩到了一天，但是我们的计算公式也暗示，实际上不可能同时更新，实质上全部更新还是至少需要四天，对于一次交易也至少需要两天 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>虽然在测试上也看不这个内存节省的区别来，但毕竟是 Python 嘛，内存模型并不节省 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[0121. Best Time to Buy and Sell Stock]]></summary></entry></feed>