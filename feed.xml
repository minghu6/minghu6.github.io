<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-12-04T22:13:06+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">短道水上漂（SP）</title><link href="/algs/GraphSP.html" rel="alternate" type="text/html" title="短道水上漂（SP）" /><published>2022-12-01T00:00:00+08:00</published><updated>2022-12-01T00:00:00+08:00</updated><id>/algs/GraphSP</id><content type="html" xml:base="/algs/GraphSP.html"><![CDATA[<p>像水面上打漂儿出的石头，只是“一击就弹出“地了解关于最短路径（Shortest Path，以下简称SP）问题。</p>

<h2 id="前言">前言</h2>

<p>值得强调在前面得是，一般比如从构造实现上，会假定最基础的情况无向图，但最短路径是以<strong>有向图（强连通）</strong>为基础。所有下列介绍的算法的都假定一个有向图，而在无向图上，部分结论会有所不同。</p>

<p>遵循依赖关系，将依次介绍：</p>

<ol>
  <li>Floyd 算法 （全源）</li>
  <li>Bellman-Ford 算法 （单源）</li>
  <li>Bellman-Ford 算法的著名改进： SPFA 算法 （单源）</li>
  <li>Dijkstra 算法 （单源）</li>
  <li>Johnson 算法 （全源）</li>
</ol>

<h2 id="floyd-算法">Floyd 算法</h2>

<p>/flɔid/</p>

<h3 id="算法思想">算法思想</h3>

<p>这个算法当初是作为一个动态编程的范例提出，全源地计算图上最短路径问题。</p>

<p>假如对图上所有点编号 $1…n$ ，那么图上任何一条最短路径最多经过 $n$ 个点。一开始，我们只知道直接相连的两点之间的路径权重，但可以通过检查是否有 $w[x][1] + w[1][y] &lt; w[x][y]$ 得到最多经过点 $1$ 的两点间的最小路径。在此基础上如果在检查一遍经过点 $2$ 的两点间最短路径，就可以得到最多经过 $\lbrace 1,2 \rbrace$ 的两点间最短路径，以此类推，当检查过 $n$ 轮，就得到了最多经过 $\lbrace 1,2, …, n \rbrace$ 的最短距离，也就是整个图上的最短距离。</p>

<h3 id="伪代码">伪代码</h3>

<p>对于图 $G=(V, E)$</p>

\[\begin{array}{ll}
\texttt{let}\ w[x][y]\ \text{as shortest path's weight sum from}\ x\ \text{to}\ y\\ 
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets \{1,2,..,n\}\\
\qquad\texttt{for}\ y \gets \{1,2,...,n\}\\
\qquad\qquad \texttt{if}\ x=y\\
\qquad\qquad\qquad w[x][y] \gets 0\\
\qquad\qquad\ \texttt{elif}\ (x, y)\notin |E|  \\
\qquad\qquad\qquad w[x][y] \gets \infty \\
\qquad\qquad\ \texttt{else}\\
\qquad\qquad\qquad w[x][y] \gets w_{xy}
\\
\texttt{for}\ k \gets \{1,2,..,n\}\\
\qquad\texttt{for}\ x \gets \{1,2,...,n\}\\
\qquad\qquad\texttt{for}\ y \gets \{1,2,...,n\}\\
\qquad\qquad\qquad w[x][y] = \texttt{min}(w[x][k],\ w[k][y])
\end{array}\]

<h3 id="路径构造">路径构造</h3>

<p>如果单独地为每一对儿点存储独立路径，那么空间复杂度是 $O(n^3)$ ，有时候这可能不太妙，可以使用 $\text{next}$ 数组，存储一条路径的第一步的端点，用 $O(n)$ 的时间复杂度换取 $O(n^2)$ 的空间复杂度。</p>

<p>对于一条路径 $x_1 \rightarrow x_2 \rightarrow x_3\ …\rightarrow x_n$：</p>

\[\begin{array}{ll}
\text{next}[x_1][x_n] &amp;= x_2\\
\text{next}[x_2][x_n] &amp;= x_3\\
\text{next}[x_{n-1}][x_n] &amp;= x_n
\end{array}\]

<p>每次更新权重的时候，更新 $\text{next}$ 数组：</p>

\[\text{next}[x][y] = \text{next}[x][k]\]

<p>查询 $x \rightarrow y$ 最小路径时，展开 $\text{next}$ 数组（输出一个 $(x)..y$ 的路径，下同）：</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set P as path output}.\\
\\
p\ \gets x\\
P \gets \varnothing\\
\\
\texttt{loop if}\ \ p \neq y\\
\qquad p \gets \text{next}[p][y]\\
\qquad P \gets p \\
\end{array}\]

<h3 id="负环问题">负环问题</h3>

<p><strong>负环是指一条环状路径，其权重和为负值。</strong>显然负环的存在会使最短路径问题根本上不可解，因为任何一条路径都可以通过负环使得其权重和无限地减低下去。</p>

<p>对于有向图而言，显然 Floyd 可以处理不存在负环的负边的情况。<strong>但对于无向图，负边实质上是不可能的</strong>。因为无向图必须转为有向图来应用算法，而无向图的每条负边都意味着有向图的一个两条边构成的负环。</p>

<p>所以我们下面讨论的<strong>有向图负边权情况下探测负环的问题</strong> 。</p>

<p>方法是检查对角线上元素，也就是 $w[i][i], i \in |V|$ ，是否小于 $0$ ，如果是，意味着存在 $i\rightarrow i$ 的负环。</p>

<h4 id="负环路径构造">负环路径构造</h4>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set C as cycle output}\\
\texttt{let}\ \text{c as the known cycle vertex}\\
\\
C \gets \lbrace c \rbrace \\
p \gets \text{next}[c][c] \\
\\
\texttt{loop if}\ p \neq c\\
\qquad C \gets p\\
\qquad c \gets \text{next}[p][c]
\end{array}\]

<h3 id="实现">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPFloyd</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPFloyd</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_floyd</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">next</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// (total_weight, (src), .. , k1, k2, .. dst)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)),</span>
            <span class="nf">next_to_path</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.next</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_floyd</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="n">vertexs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vertexs</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">spw</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init sp */</span>
    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w</span><span class="p">);</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">y</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="p">{</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w_xk</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                   <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w_ky</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> 
                       <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> 
                    <span class="p">{</span>
                        <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span><span class="p">);</span>
                        <span class="nd">set!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)));</span>

                        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">cycle</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>

                            <span class="k">while</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
                                <span class="n">cycle</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
                            <span class="p">}</span>

                            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">spw</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度">时间复杂度</h3>

<p>显然时间复杂度为 $O(n^3)$</p>

<h2 id="bellman-ford-算法">Bellman-Ford 算法</h2>

<p>/ˈbelmən/-/fɔrd/</p>

<h3 id="算法思想-1">算法思想</h3>

<p>对比前面的 Floyd 算法考虑最短路径经过的点，Bellman-Ford 则考虑最短路径经过的边。</p>

<p>考虑对于 $n$ 个点的图，每一条最短路径最多包含 $n-1$ 条边（否则必然存在负环），从一条边的情况开始，遍历每条边，检查每个点到源点的最短距离是否可以被这条边更新，最后得到了最多包含一条边的最短路径；第二轮迭代，解决了最多包含两条边的情况；直到第 $n-1$ 轮，所有最短路径都必然已经得到。如果此时检查还有可以被边更新的最短路径，就必然存在负环。</p>

<h3 id="伪代码-1">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
\texttt{let}\ \text{dis}[x]\ \text{as shortest path's distance from}\ s\ \text{to}\ x \\
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets |V|\\
\qquad \texttt{if}\ x = s\\
\qquad\qquad \text{dis}[x] \gets 0\\
\qquad \texttt{elif}\ (s,x) \in |E|\\
\qquad\qquad \text{dis}[x]=w_{sx} \\
\qquad \texttt{else}\\
\qquad\qquad \text{dis}[x] = \infty\\
\\
\texttt{iterate}\ \text{|V|-1 times} \\
\qquad\texttt{for}\ (x, y) \gets |E|\\
\qquad\qquad \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})
\end{array}\]

<h3 id="路径构造-1">路径构造</h3>

<p>由于是加边的构造过程，路径构造采用了反向的 $\text{pre}$ 数组。</p>

<p>对于一条路径 $(s) \rightarrow x_1 \rightarrow x_2 \rightarrow x_3\ …\rightarrow x_n$：</p>

\[\begin{array}{ll}
\text{pre}[x_n] &amp;= x_{n-1}\\
\text{pre}[x_{n-1}] &amp;= x_{n-2}\\
\text{pre}[x_{2}] &amp;= x_1
\end{array}\]

<p>每次更新权重的时候，更新 $pre$ 数组：</p>

\[\text{pre}[y] = \text{pre}[x]\]

<p>查询 $x \rightarrow y$ 最小路径时，展开 pre 数组：</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set P as path output.}\\
\\
P \gets \varnothing \\
p \gets y \\
\\
\texttt{loop if}\ p \neq x\\
\qquad P \gets p\\
\qquad p \gets \text{pre}[p]\\
\\
\texttt{reverse}\ P\\
\end{array}\]

<h3 id="负环探测">负环探测</h3>

<p>负环问题<a href="#负环问题">前面</a>已经讲过，这里只讲负环探测。</p>

<p>当 $n-1$ 轮迭代后如果仍然有可以被更新的点，那么必然存在负环，而该点要么在负环上，要么在负环的下游。</p>

<p>这样以该点开始，用 $\text{pre}$ 数组向后找 $n$ 次，可以确保点一定在负环上，然后就可以构造负环路径。</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set C as cycle output.}\\
\\
\texttt{for}\ (x, y, w_{xy}) \gets |E|\\
\qquad\texttt{if}\ \text{dis}[y] \lt \text{dis}[x] + w_{xy}\\
\qquad\qquad c \gets y  \\
\qquad\qquad \texttt{iterate}\ |V| \ \text{times}\\
\qquad\qquad\qquad c \gets \text{pre}[c]\\
\\
\qquad\qquad C \gets \lbrace c \rbrace \\
\qquad\qquad p \gets \text{pre}[c] \\
\\
\qquad\qquad\texttt{loop if}\ p \neq c\\
\qquad\qquad\qquad C \gets p\\
\qquad\qquad\qquad p \gets \text{pre}[p]\\
\\
\qquad\qquad \texttt{reverse}\ C\\
\qquad\qquad\text{exit with}\ C
\end{array}\]

<h3 id="实现-1">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPBellmanFord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPBellmanFord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_bellman_ford</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_bellman_ford</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">src</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span><span class="p">);</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// negative cycle found!</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

                <span class="c1">// 确保在环上</span>
                <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">install_cycle</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">dis</span><span class="p">,</span> <span class="n">pre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>作为单源点算法，时间复杂度 $O(nm)$ ，如果求全源最短路径，就执行 $n$ 次该算法，那么就变成 $O(n^2m)$ 。</p>

<p>这个时间复杂度显然不太妙，事实上原始的 Bellman-Ford 算法是本文介绍的这几个算法里最慢的，下面我们会介绍它的一个广为人知的变体即所谓的 “SPFA“ 算法。这个改进算法虽然没有改变最坏时间复杂度，但在实际运行中对于随机图的表现相当好。</p>

<h2 id="so-called-spfa-算法">so-called ‘SPFA’ 算法</h2>

<p>这个 Bellman-Ford 的改进算法在 OI 界可谓大名鼎鼎，对于随机图的实际运行很快，而且实现方便。它是中国的研究员提出的，被认为本质上是 Tarjan 的图上广度优先遍历的一般化版本<sup id="fnref:wiki-spfa" role="doc-noteref"><a href="#fn:wiki-spfa" class="footnote" rel="footnote">1</a></sup> ，虽然从算法思想上的没有什么直接的关系。</p>

<h3 id="算法思想-2">算法思想</h3>

<p>’‘SPFA’ 的改进在于观察到每一轮用于“松弛“操作的边都是上一轮更新过的点连接的边。这很好理解，回到算式 $ \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})$ ，如果上一轮 $\text{dis}[x]$ 没有变，那么这一轮 $\text{dis}[y]$ 也就不会变。</p>

<p>这样的话，</p>

<ol>
  <li>从源点开始，把它加入等待的集合 $R$ ；</li>
  <li>每次从 $R$ 中取出一个点，遍历更新过的点连接的边，把其中更新的点加入 $R$ 中；</li>
  <li>当 $R$ 为空时，算法终止</li>
</ol>

<h3 id="伪代码-2">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
R \gets \lbrace s \rbrace\\
\\
\texttt{loop if}\ R\ \neq \varnothing \\
\qquad\ x \gets R\\
\qquad\texttt{for}\ (x, y, w_{wy})\ \texttt{in}\ \lbrace e\ |\ e[0]=x,\ e \in |E| \rbrace \\
\qquad\qquad\text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})\\
\qquad\qquad R \gets y
\end{array}\]

<p>路径构造同原始 Bellman-Ford 算法相同</p>

<h3 id="负环探测-1">负环探测</h3>

<p>负环探测由于没有全部边的迭代，因此有一点区别</p>

<p>有两种方法：</p>

<ol>
  <li>在于使用一个集合维护每个点经过的边数，显然最多不超过 $n-1$ 条，否则一定存在负环；</li>
  <li>每迭代完 $n$ 个点，就检查一下pre数组，是否展开后超过 $n-1$ 条路径</li>
</ol>

<p>第二种方法虽然最坏时间复杂度和第一种相同，但<sup id="fnref:spfa-early-termination" role="doc-noteref"><a href="#fn:spfa-early-termination" class="footnote" rel="footnote">2</a></sup>在稀疏图和随机图情况下，可以天差地别般更快地检测到负环 。</p>

<p>另外对于第一种方法，使用 FILO 的栈结构显然有助于更快地找到负环。</p>

<h3 id="实现-2">实现</h3>

<p>特别地对于无向图，‘SPFA’ 可以有意义地求解负权边图，因为可以单独跳过两端点构成的负环，这样就避免无向图的每条负边都构成有向图的一个两端点负环的情况。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPFA</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPFA</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_fa_early_termination</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sp_fa_early_termination</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">src</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vis</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">src</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vis</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
            <span class="c1">// 无向图不存在这条路径</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">g</span><span class="py">.dir</span> <span class="o">&amp;&amp;</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span>
                   <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">=</span> <span class="nf">detect_negative_cycle</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="o">!</span><span class="n">vis</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                        <span class="n">vis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">dis</span><span class="p">,</span> <span class="n">pre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度与继续改进">时间复杂度与继续改进</h3>

<p>最坏时间复杂度不变，仍是 $O(nm)$ ，但实际运行是很好的（相对于其他能处理负边权的算法）。另外对于特定情况的一些进一步的优化，主要是关于如何根据有关条件把点加到对头还是队尾，这里就不展开了。</p>

<p>但接下来介绍的是有限制条件的更最快的算法：Dijkstra 算法 。</p>

<h2 id="dijkstra-算法">Dijkstra 算法</h2>

<p>/ˈdaɪkstrəz/</p>

<h3 id="算法思想-3">算法思想</h3>

<p>说是 Dijkstra 和妻子逛商场的时候花20分钟想出来的寻找到几个不同商场的最短路的方法<sup id="fnref:wiki-dijkstra" role="doc-noteref"><a href="#fn:wiki-dijkstra" class="footnote" rel="footnote">3</a></sup> ，是一种自然想到的利用非负权边的缩放性质进行快速查找的方法。</p>

<p>回顾前面的两个算法：</p>

<p>Floyd 算法（全源）是 $\text{dis}[u][v] = \text{min}(\text{dis}[u][v],\ \text{dis}[u][k]+\text{dis}[k][v])$</p>

<p>Bellman-Ford 算法（单源）是  $\text{dis}[v] = \text{min}(\text{dis}[v],\ \text{dis}[u]+w_{uv})$</p>

<p>它们都是基于直接的全路径的比较，适用于包括负权边在内的各种情况，而 Dijkstra 算法则利用了非负权边的缩放性质，在非负权图上可以算得更快。</p>

<p>它考虑对于图 $G$ （有向强连通），设源点为 $s$ ， $d$ 为图上任一点，$d’$ 为 $s$ 到 $d$ 最短路径上 $d$ 的前驱点（即 $s\rightarrow…\rightarrow d’\rightarrow d$）， $\text{dis}$ 图上某点为到源点 $s$ 的最短距离，由于非负权边的性质， $dis[d’] \leqslant dis[d]$ 。</p>

<p>假如对 $\text{dis}$ 按照不减的顺序求出，每求出一个就更新该点的所有出边连接的点的 $\text{dis}$ ，那么下一个得到的最小 $\text{dis}$ 也仍然是所属点的最短距离。</p>

<p>这是一个归纳法的思考方向，让我们用规整的形式来更好地说明：</p>

<ol>
  <li>
    <p>初始地情况，$\text{dis}[s]=0$ ，它是最小的 $\text{dis}$，也不妨认为它是 $s\rightarrow s$ 的最短距离；</p>
  </li>
  <li>
    <p>当 $d$ 是剩下点中 $\text{dis}$ 最小的点时，由于它的最短路径（强连通图保证至少有一条 $s$ 到 $d$ 的路径）上的前驱点 $d’$ 满足 $\text{dis}[d’] \leqslant \text{dis}[d]$ ：</p>

    <p>2.1 如果 $\text{dis}[d’] \lt \text{dis}[d]$， $d’$  之前已经被计算出最短路径，而 $d$ 已经被 $d’$  的出边更新为最短路径</p>

    <p>2.2 特别地当 $w_{d’d}=0$ ，也就是 $\text{dis}[d’]=\text{dis}[d]$ ，$d’$ 可以忽略，直接找它的前驱 $d’’$ , 直到 $d^{(n)}=s$ ，总之都是之前已经被求出的</p>

    <p>所以当之前的 $\text{dis}$ 都是最短路径时， $d$ 也是最短路径</p>
  </li>
</ol>

<p>归纳证毕。</p>

<h3 id="伪代码-3">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
\texttt{let}\ \text{dis}[x]\ \text{as shortest path's distance from}\ s\ \text{to}\ x \\
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets |V|\\
\qquad \texttt{if}\ x = s\\
\qquad\qquad \text{dis}[x] \gets 0\\
\qquad \texttt{elif}\ (s,x) \in |E|\\
\qquad\qquad \text{dis}[x]=w_{sx} \\
\qquad \texttt{else}\\
\qquad\qquad \text{dis}[x] = \infty\\
\\
T \gets |V|\\
\\
\texttt{loop if}\ T \neq \varnothing\\
\qquad u \gets \text{min}(T) \text{ by dis}[u] \\
\\
\qquad\texttt{for}\ (x, y)\ \texttt{in}\ \lbrace e\ |\ e[0]=u,\ \ e[1] \in T,\ e \in |E| \rbrace \\
\qquad\qquad \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})
\end{array}\]

<p>路径构造由于是对边的“松弛“，所以仍然采用 $\text{pre}$ 数组构造。</p>

<h3 id="实现-3">实现</h3>

<p>用上前面实现的 <a href="/algs/DaryHeap.html">d-ary 堆</a> 来优化算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPDijkstra</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPDijkstra</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_m1</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">DaryHeap5</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">infi</span> <span class="o">=</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">src</span> <span class="p">{</span>
            <span class="n">dis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">dis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">infi</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">dis_u</span><span class="p">))</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">dis_m1</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="n">dis_u</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">(</span><span class="n">dis_m1</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度与综合利用">时间复杂度与综合利用</h3>

<p>作为单源点算法，使用我们实现里的 $O(1)$  时间复杂度的 32-ary 堆优化的情况下：</p>

<ol>
  <li>初始化 $\text{dis}$ 数组，$O(n)$</li>
  <li>$\text{dis}$ 排序 + 边松弛，$O(n) + O(m)$</li>
</ol>

<p>Dijkstra 算法的时间复杂度可以优化为 $O(m)$ （非常优秀，直接去掉了一个 $n$） 。</p>

<p>如果计算全源最短路径，就是 $O(nm)$ 。</p>

<p>不过 Dijkstra 毕竟受限于非负权边的图，如何利用它的高效，改善含负权边的图的全源最短路径 $O(n^3)$ 的计算效率？ 这就是接下来的Johnson 算法做的事情。</p>

<h2 id="johnson-算法">Johnson 算法</h2>

<h3 id="算法思想-4">算法思想</h3>

<p>基本想法是通过重新调整边的权重，使得每条边的权重不小于 $0$ ，并且保持每对儿点的最短路径不会因此受到影响。</p>

<p>我们采取这样一种方法，对于图 $G=(V, E)$ ，用“势能”标记 $G$ 中的每个点：</p>

<ol>
  <li>建立基准线，增加一个特殊的点 $q$ ，使得 $q$ 到 $G$ 中每一个点都有一条边，权重为一个固定值 $c$ （具体值无所谓，只是用来建立基准）</li>
  <li>运行一次以 $q$ 为源点的 Bellman-Ford 算法（当然我们要用我们最爱的 ‘SPFA’ 算法），以每个点到 $q$ 的最小距离 $h$ 为它的势能，原 $G$ 上每条边 $(u, v)$ 的权重都加上 $u\rightarrow v$ 两点的势能差，也就是 $h(u) - h(v)$</li>
</ol>

<p>这样同时满足了两个要求：</p>

<ol>
  <li>对于G上任意两点x、y，G上每条从x到y的路径，不管中间经过了多少个点，它们的最终权重和都增加了一个固定值，也就是 h(x) -h(y)，也就是这种调整不会影响任意点对的最短路径的判定；</li>
  <li>并且由于最短路径的性质 $h[v] \leqslant h[u]  + w_{uv}$ 也就是 $w_{uv} + h[u] - h[v] \geqslant 0$</li>
</ol>

<p>这样直接在重新平衡权重的图上做 $n$ 次Dijkstra 算法，就得到了全源的最短路径。当然查询最短路径的权重和时，要把加上的权重减去，也就是 $-(h[u]-h[v])$</p>

<h3 id="实现-4">实现</h3>

<p>路径构造是 $\text{pre}$ 数组，负环探测是利用 Bellman-Ford 算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPJohnson</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">sppre</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPJohnson</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_johnson</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// (total_weight, (src), .. , k1, k2, .. dst)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">))</span> <span class="o">-</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.h</span> <span class="k">=&gt;</span> <span class="n">src</span><span class="p">)</span>
                <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.h</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span>
            <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="k">self</span><span class="py">.sppre</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_johnson</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span>
    <span class="p">(</span>
        <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="cm">/* Create a new map with special node q*/</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g2</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="n">vertexs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">vertexs</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">vertexs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">apush!</span><span class="p">(</span><span class="n">g2</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">q</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">g</span><span class="py">.dir</span> <span class="p">{</span>
            <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">apush!</span><span class="p">(</span><span class="n">g2</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Using SPFA dst calc h((q, v)) */</span>
    <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="k">match</span> <span class="nf">sp_fa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">h</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">((</span><span class="n">g2</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)),</span>
    <span class="p">};</span>

    <span class="cm">/* Reweight */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">h</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="nd">get!</span><span class="p">(</span><span class="n">h</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* Calc spw and spp usign Dijkstra */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">spw</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sppre</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">vertexs</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">sspw</span><span class="p">,</span> <span class="n">sspp</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">sspw</span><span class="p">);</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">sppre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">sspp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-2">时间复杂度</h3>

<p>$O(nm) + O(nm) = O(nm)$ ，这样在负权图上也实现了最坏时间复杂度为 $O(nm)$ 的最短路径算法！</p>

<h2 id="尾声">尾声</h2>

<p>用力地掷出 SP 问题这一块飞石，最终在时间的河流上打出了一串儿的涟漪，虽然感觉花的时间长，但实际比想象花的时间还要长一点。特别是和 <a href="/algs/GraphMST.html">无向图上最小生成树问题</a> ，还有树上问题等比较，图上的算法思想还是有很多相通之处，有一些人名也串来串去，比如 Tarjan，有点儿图界 Knuth 的意思。</p>

<p>凡事总是勃勃兴起，忽而结束。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:wiki-spfa" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm <a href="#fnref:wiki-spfa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:spfa-early-termination" role="doc-endnote">
      <p>https://konaeakira.github.io/posts/using-the-shortest-path-faster-algorithm-to-find-negative-cycles.html <a href="#fnref:spfa-early-termination" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wiki-dijkstra" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Dijkstra’s_algorithm <a href="#fnref:wiki-dijkstra" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[像水面上打漂儿出的石头，只是“一击就弹出“地了解关于最短路径（Shortest Path，以下简称SP）问题。]]></summary></entry><entry><title type="html">N叉堆实现（Rust）</title><link href="/algs/DaryHeap.html" rel="alternate" type="text/html" title="N叉堆实现（Rust）" /><published>2022-11-23T00:00:00+08:00</published><updated>2022-11-23T00:00:00+08:00</updated><id>/algs/DaryHeap</id><content type="html" xml:base="/algs/DaryHeap.html"><![CDATA[<p>一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为<a href="/algs/FibHeap.html">斐波那契堆</a>的上位替代。</p>

<p>下图 $q=2^1$</p>

<div class="sx-center"><img src="/../assets/img/daryheap/layout.svg" title="" /></div>

<h2 id="数据结构">数据结构</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Min Heap, I is unique, T is weight</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DaryHeap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">E</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">raw</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>注解：</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 是自己实现的简单堆上数组，因为需要初始化，所以包裹了 <code class="language-plaintext highlighter-rouge">Option</code></li>
  <li>直接使用“索引-权重“二元组来作为节点的结构</li>
</ol>

<h2 id="基础操作">基础操作</h2>

<p>值得稍微想一想的就是树上父、子位置与索引的换算关系。以下假设我们的叉堆的基是 $2^E$ 。</p>

<h3 id="索引">索引</h3>

<p>基本的索引与位置的换算关系靠得是等比数列前 $n$ 项和：</p>

<p>$a_1$ 为首项， $q$ 为比值</p>

\[S_n = \left\{\begin{array}{l} 
 &amp; na_1 &amp;(q=1)\\
 &amp;{\large \frac{a_1(1-q^n)}{1-q}} &amp;(q \neq 1)\\
\end{array}\right.\]

<p>对于我们的 d-ary 堆，$a_1 = 1$， $q=2^E$ ，于是有：</p>

\[S_n = \frac{2^{En} - 1}{2^E - 1}\]

<p>定义一系列宏来做索引转换的工作</p>

<h4 id="定义基">定义基</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2^E</span>
<span class="nd">macro_rules!</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">E</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// (2^E)^n</span>
<span class="nd">macro_rules!</span> <span class="n">basen</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">E</span> <span class="o">*</span> <span class="p">(</span><span class="nv">$n</span><span class="p">)</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="从编号转换到行列位置">从编号转换到行列位置</h4>

<p>编号和行列位置都从 $1$ 开始，逆转 $S_n$ 公式：</p>

\[2^{En} = S_n(2^E - 1) + 1\]

<p>得出 $n$</p>

\[n = \frac{\log_{2}({S_n(2^E - 1) + 1})}{E}\]

<p>设当前编号为 $N$，行号为 $\text{ln}$ ，列号为 $\text{col}$，则</p>

\[\begin{array}{l}
\text{ln} &amp;= \lfloor \frac{\log_{2}({N(2^E - 1) + 1})}{E} \rfloor \\
\text{col} &amp;= N - S_{\text{ln}-1}
\end{array}\]

<p>当然这里要采用<strong>整数上的数学函数</strong>进行运算</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

            <span class="c1">// = q^n</span>
            <span class="k">let</span> <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="nd">base!</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">var</span><span class="nf">.ilog2</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">/</span> <span class="n">E</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">ln</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">col</span> <span class="o">=</span> <span class="nd">basen!</span><span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// total number for lv complete d-ary</span>
<span class="nd">macro_rules!</span> <span class="n">total</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ln:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">ln</span> <span class="o">=</span> <span class="nv">$ln</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">ln</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">E</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="c1">// 1 * 1-q^n / (1-q)</span>
            <span class="p">(</span><span class="nd">basen!</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nd">base!</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$ln:expr</span><span class="p">,</span> <span class="nv">$col:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">ln</span> <span class="o">=</span> <span class="nv">$ln</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">col</span> <span class="o">=</span> <span class="nv">$col</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">ln</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">ln</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">col</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">col</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="当前位置到父母或孩子的位置">当前位置到父母或孩子的位置</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">paren_pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$pos:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pos</span><span class="p">;</span>

            <span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nd">base!</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// first child pos</span>
<span class="nd">macro_rules!</span> <span class="n">child_pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$pos:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pos</span><span class="p">;</span>

            <span class="p">(</span><span class="n">ln</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nd">base!</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="数组下标到父母或孩子下标">数组下标到父母或孩子下标</h4>

<p>最后我们就有了直接的实际数据结构里的索引到它父母或孩子的索引的最终算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">paren</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nd">paren_pos!</span><span class="p">(</span><span class="nd">pos!</span><span class="p">(</span><span class="nv">$idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

            <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nd">child_pos!</span><span class="p">(</span><span class="nd">pos!</span><span class="p">(</span><span class="nv">$idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

            <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="交换">交换</h3>

<p>交换是 d-ary 堆算法实现依赖的主要操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...     </span>

<span class="k">fn</span> <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">idx2</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">_v1</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k1</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx2</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k2</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx1</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cd">/// return insert_idx</span>
<span class="k">fn</span> <span class="nf">sift_up</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">cur</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">paren</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cur</span>
<span class="p">}</span>

<span class="cd">/// return insert_idx</span>
<span class="k">fn</span> <span class="nf">sift_down</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_child</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">break</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">min_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nd">base!</span><span class="p">());</span>

    <span class="p">(</span><span class="n">start</span><span class="o">..</span><span class="n">end</span><span class="p">)</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<ol>
  <li>当插入新节点的时候，把新节点放到尾部，然后和父节点比较，如果堆的性质发生违背，就交换两个节点，递归地进行直到到达根节点；</li>
  <li>当更新已有节点的时候，如果新值比旧值大，就向下交换，如果比旧值小，就向上交换，相等就什么都不做；</li>
  <li>删除根节点的时候，把它和序列上最后一个节点交换，然后把最后一个节点向下交换</li>
</ol>

<h2 id="核心算法实现">核心算法实现</h2>

<h3 id="insert">Insert</h3>

<p>扩容的时候和一般内存上的连续结构一样，申请新的更大内存（不必要每次扩张都有下一层完全树的内存大小，算法实现也不依赖于此），然后把旧的全部复制到新内存位置，最后释放旧内存。<em>注意，这种做法看起来比不用复制旧内存的链表结构要浪费很多，但实际上不仅摊销代价很小，通常直接代价也很小，绝大多数情况在时间效率上远优于链表结构！</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.index</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.recap</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.recap</span><span class="p">(</span><span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>

        <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">));</span>
        <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.sift_up</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">recap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">new_cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.raw</span><span class="nf">.resize</span><span class="p">(</span><span class="n">new_cap</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey">DecreaseKey</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...</span>

<span class="nd">#[inline]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.index</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">),</span> <span class="s">"No {i:?}"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">self</span><span class="py">.index</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">oldv</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.replace</span><span class="p">((</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">newidx</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.sift_up</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.sift_down</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newidx</span><span class="p">);</span>

    <span class="n">oldv</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop">Pop</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.sift_down</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// remain None, update self.len</span>
<span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.index</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="时间复杂度分析">时间复杂度分析</h2>

<p>d-ary 堆本质上当然仍是二叉堆，但当基数较大的时候，实际上原来 $\text{log} n$ 的操作就降低为常量。</p>

<p><code class="language-plaintext highlighter-rouge">insert</code>: $O(1)$</p>

<p><code class="language-plaintext highlighter-rouge">decrease-key</code>: $O(1)$</p>

<p><code class="language-plaintext highlighter-rouge">delete-min</code> (<code class="language-plaintext highlighter-rouge">pop</code>): $O(1) $</p>

<p>在 <code class="language-plaintext highlighter-rouge">pop</code> 的时候理论上还优于之前介绍过的斐波那契堆，实际上由于这是建立在连续内存上的数据，比起基于链表的结构不知道好到哪里去了！</p>

<p><strong>通常 d-ary 堆的基数是 32，也就是 E=5</strong>，这是个经验结论，在此之前，随着基数增大，时间效率呈现有意义地增加，而在此之后，时间效率几乎不增乃至减少。Clojure 自己的持久化 <code class="language-plaintext highlighter-rouge">Vector</code> 的实现里 Trie 的基数就是 $32$ 。</p>

<h2 id="引用">引用</h2>

<p>完整代码： https://github.com/minghu6/rust-minghu6/blob/master/src/collections/heap/dary.rs</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为斐波那契堆的上位替代。]]></summary></entry><entry><title type="html">速通最小生成树（MST）</title><link href="/algs/GraphMST.html" rel="alternate" type="text/html" title="速通最小生成树（MST）" /><published>2022-11-18T00:00:00+08:00</published><updated>2022-11-18T00:00:00+08:00</updated><id>/algs/GraphMST</id><content type="html" xml:base="/algs/GraphMST.html"><![CDATA[<h2 id="前言">前言</h2>

<p>介绍三种基本的最小生成树算法：</p>

<p>它们都是贪心算法</p>

<ol>
  <li>基于最小边的 Kruskal 算法</li>
  <li>基于最小距离的点（到生成树）的 Prim 算法</li>
  <li>基于连通分量最小出边的 Boruvka 算法</li>
</ol>

<p>对于它们进行简单的比较</p>

<p>实现基于<a href="/algs/GraphTheoryBasic.html">图论基础</a>里面提到的数据结构</p>

<h2 id="性质">性质</h2>

<p>介绍一下最小生成树相关的性质<sup id="fnref:mst-wiki" role="doc-noteref"><a href="#fn:mst-wiki" class="footnote" rel="footnote">1</a></sup>，可能让我们对算法的理解能拨其冗繁、摁其要务，看得更清楚一点。</p>

<h3 id="割的性质">割的性质</h3>

<p>对于连通图 $G = (V, E)$ ，如果 $U$ 为它的非平凡子图（不是空集和它自身），则存在 $U$ 的所有出边（一头在 $U$ ,一头不在 $U$ ）中权值最小的边 $e$ 一定属于某棵 $G$ 上的最小生成树。</p>

<p>记 $T$ 为 $G$ 上的一棵最小生成树，</p>

<ol>
  <li>
    <p>如果 $e$  在 $T$ 上， 性质1成立；</p>
  </li>
  <li>
    <p>如果 $e$ 不在 $T$ 上，由于 $T$ 是生成树，加入 $e$ 就会构成一个环（不妨标记这个环形路径为 $C$ ），并且一定存在C中e以外的一条U的出边 $f$ ，由于e是最小出边，那么f一定权重大于等于 $e$ 。因此 $T-f+e$ 不仅是生成树，而且由于权重小于等于 $T$ , 是最小生成树。也就是e属于一棵生成树，性质1仍然成立。</p>
  </li>
</ol>

<p>证毕。</p>

<p>进一步地，如果这条最小出边 $e$ 是唯一最小的，它一定属于所有最小生成树。</p>

<h4 id="推论1">推论1</h4>

<p>对于连通图 $G = (V, E)$ ， $U$ 是 $E$ 的子图，如果 $U$ 属于某棵 $G$ 上的最小生成树，那么在加入一条最小出边后，仍然属于某棵最小生成树。</p>

<p>设 $U$ 属于最小生成树 $T$ ，根据性质1，加入最小出边 $e$ 后，$U$ 要么仍然属于 $T$ ，要么属于 $T-f+e$ ，都仍然属于某棵最小生成树。</p>

<h4 id="推论2">推论2</h4>

<p>进一步推论，开始的时候 $G$ 中每个点构成的子图一定属于最小生成树，那么根据归纳推理，不断地加最小出边，当图中每个点都被加入后，得到一棵生成树，也就是最小生成树。这也是 Prim 算法的证明。</p>

<h3 id="环的性质">环的性质</h3>

<p>图上的环状路径 $C$ ，如果其中一条边比其它所有边都大，那么它肯定不在任何一棵最小生成树上。</p>

<p>和上面割的性质的证明是是类似的，反证如果在某棵最小生成树，则其他 $C$ 上的边可以替换产生一棵更小权重的最小生成树。</p>

<h3 id="唯一性">唯一性</h3>

<p>如果 $G$ 上每条边的权重都是唯一的，那么最小生成树也是唯一的。</p>

<p>证明也是反证，假设有两棵不同的最小生成树，二者的对称差集（symmetric difference set）里权重最小的那一条所在的环上的其他边，至少有一条边不属于这棵最小生成树，而属于另一棵最小生成树，由于边权重唯一，那条边必然大于这个最小的差边，因而可以构成去大边加小边的更小的最小生成树，矛盾，证毕。</p>

<h2 id="kruskal-算法">Kruskal 算法</h2>

<p>大概读作 /’krʌs,gol/</p>

<h3 id="描述">描述</h3>

<p>最简单的，基于最小边的贪心算法</p>

<ol>
  <li>假设开始的时候每个点都是只包括自己的连通分量；</li>
  <li>边按照权重排序，从最小边开始，若边上的两点不在同一连通分量里，就把它加入生成树，然后把两个点所在的连通分量连通为一个分量，最后就得到最小生成树；</li>
</ol>

<h3 id="实现">实现</h3>

<ol>
  <li>对边用堆或者提前排序维护从小到大的边的检查顺序；</li>
  <li>用并查集维护连通分量</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_kruskal</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cm">/* init sorted edge set */</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sorted_edges</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">sorted_edges</span><span class="nf">.sort_unstable_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.2</span><span class="p">);</span>

    <span class="cm">/* init disjoint set */</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ds</span> <span class="o">=</span> <span class="nn">UnionFind</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">MergeBy</span><span class="p">::</span><span class="n">SZ</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ds</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span> <span class="k">in</span> <span class="n">sorted_edges</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">ds</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ds</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ds</span><span class="nf">.cunion</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="证明">证明</h3>

<p>Kruskal 算法的证明并不像它看起来那么简单。</p>

<p>假设 $G$ 是加权连通图， $Y$ 是算法应用在 $G$ 上产生的子图</p>

<p><strong>是生成树</strong></p>

<ol>
  <li>$Y$ 不存在环， 这是由算法加边时的检查所保证的；</li>
  <li>$Y$ 是连通的，因为所有边都被检查了一遍，只要两个点不在同一分量里就加入</li>
</ol>

<p><strong>且是最小生成树</strong></p>

<p>首先提出一个<strong>假设</strong> $P$：</p>

<p>​	设 $F$（Forest）是算法在任意阶段生成的边集，则总有 $G$ 上的最小生成树包含 $F$ ，并且它（这棵生成树）里面的边之前阶段没有被算法拒绝过</p>

<p>用归纳法证明 $P$ 成立：</p>

<ol>
  <li>
    <p>在开始的时候，$F=\varnothing $ ，显然 $G$ 上任何最小生成树都包含 $F$ ，算法一开始也没有拒绝过任何边， $P$ 成立；</p>
  </li>
  <li>
    <p>假设 $P$ 在算法的某个非最终阶段成立，将这时包含 $F$ 的最小生成树记为 $T$ ，下一个要加入的边记为 $e$ ：</p>

    <ol>
      <li>如果 $e$  在 $T$ 上， $P$ 成立；</li>
      <li>如果 $e$ 不在 $T$ 上，由于 $T$ 是生成树，加入 $e$ 就会构成一个环（不妨标记这个环形路径为 $C$ ），而由于 $e$ 通过了算法检查，所以 $e$ 加入后，构不成 $F$ 上的环形结构，也就是说环形路径 $C$ 一定存在至少一条边不属于 $F$ 。不妨标记这样的一条边为 $f$ ，$f \neq e$。根据 $P$ 的定义， $T$ 上没有边之前被 $F$ 拒绝过， $f$ 如果不属于 $F$ ，则一定权重大于等于 $e$ 。因此 $T-f+e$ 不仅是生成树，而且由于权重小于等于 $T$ , 因此是最小生成树，而 $T-f+e$ 包含 $F+e$ ， $P$ 仍然成立。
因此我们证明了若 $P$ 在 $F$ 上成立，就有 $P$ 在 $F+e$ 上成立的递推关系。</li>
    </ol>
  </li>
</ol>

<p>归纳证毕，假设 $P$ 成立。</p>

<p>因此当 $F$ 是生成树的时候，一定有最小生成树包含它，也就是 $F$ 是最小生成树。</p>

<p>而之前我们已经证明了 $F$ 最终所生成的子图 $Y$ 是生成树， 于是有算法产生了一棵最小生成树，证毕。</p>

<h3 id="时间复杂度">时间复杂度</h3>

<p>假设 $n=|V|$，$m=|E|$</p>

<p>复杂度等于边排序 $O(m \text{log} m)$ + 并查集操作 $O(m \text{log} n)$ ，等于 $O(m (\text{log} m+\text{log} n))$ 。</p>

<h2 id="prime-算法">Prime 算法</h2>

<p>类似 Dijkstra 算法，从距既有生成树最短距离的点开始加</p>

<h3 id="描述-1">描述</h3>

<ol>
  <li>选取图中任意一点开始，作为生成树的根节点，把其余点到生成树的最短距离初始化为 $+\infty$ ，根节点的生成树最短距离初始化为 $0$ ，初始化每个点到生成树的最短边的对应点为 <code class="language-plaintext highlighter-rouge">None</code>，记为 $\texttt{pair}$ ，把所有点加入剩余点集 $R$；</li>
  <li>每次从 R 中取出到生成树距离最小的点记为 $u$ ，把边 $(u, \texttt{pair}(u))$ 加入边集 $E$ 中。检查它的邻居中不在生成树上的点 $v$ ，如果边的权重 $w_{\large uv}$ ，与生成树最短距离 $\texttt{dis}(v)$ ，有  $w_{\large uv} &lt; \texttt{dis}(v) $  ，更新 $\texttt{dis}(v)$ 为  $w_{\large uv}$ ，也更新 $\texttt{pair}(u)$  为 $u$ ；</li>
  <li>当$R = \varnothing$ 时，退出，得到的E即为一棵最小生成树</li>
</ol>

<h3 id="实现-1">实现</h3>

<p>关键显然在于维护生成树距离的堆的选择，这涉及两个堆操作，<code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，经典地是使用Fib堆（在<a href="/algs/FibHeap.html">斐波那契堆（Fibonacci Heap） </a> 一文中介绍过），这样有理论更好的 <code class="language-plaintext highlighter-rouge">decrease-key</code> 性能，但实际上，我们知道在有缓存的 CPU 架构下二叉堆实际表现好得多，如果把调整二叉堆的实现，把基数从 $2$ 提高，到比如 $32$ ，那么理论上可以认为 <code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">decrease-key</code> 都有线性表现，这是理论与实践上都最优的优化。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="证明-1">证明</h3>

<p><a href="#推论2">割的性质推论2</a></p>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>经典使用斐波那契堆： $O(\text{log}n) + O(m) = O(\text{log}n + m)$</p>

<p>使用大基数的 $k$ 叉堆： $O(1) + O(m) = O(m)$</p>

<h2 id="boruvka-算法">Boruvka 算法</h2>

<p>Borůvka (捷克语) ，大概读作 /,bros’gɑʊl/</p>

<h3 id="描述-2">描述</h3>

<p>对每个连通分量加最小出边，直到没有出边为止。</p>

<p>这本质上和 Kruskal 算法是一样的，实际上 Kruskal 算法对所有边排序是有点儿浪费比较次数了。</p>

<ol>
  <li>开始的时候，图中每个点都是一个连通分量，对所有边遍历，选取其中两头不在同一个连通分量的，用它更新两个连通分量在这一轮迭代里的最小出边；</li>
  <li>一轮结束后，把新选取的最小出边加入结果集，并连接两个分量，当没有新选任何最小出边的时候结束，否则进行下一轮遍历</li>
</ol>

<p><strong>注意：</strong></p>

<ol>
  <li>显然作为一个优化，加入结果集的边就不需要再遍历了</li>
  <li>具体的算法实现中，注意不要让权重相等的边导致结果中出现环</li>
</ol>

<h3 id="实现-2">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_boruvka</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// using lexicograph order</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dsu</span> <span class="o">=</span> <span class="nn">UnionFind</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">MergeBy</span><span class="p">::</span><span class="n">SZ</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">dsu</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// components cheapest edges: (weight, usize)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cand_edges</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">comp_min_edges</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
            <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">cand_edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pu</span> <span class="o">=</span> <span class="n">dsu</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">dsu</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pu</span> <span class="o">==</span> <span class="n">pv</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">pu_min_edge</span> <span class="o">=</span> <span class="n">comp_min_edges</span>
                <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pu</span><span class="p">)</span>
                <span class="nf">.cloned</span><span class="p">()</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pu_min_edge</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pu_min_edge</span> <span class="p">{</span>
                <span class="n">comp_min_edges</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">pv_min_edge</span> <span class="o">=</span> <span class="n">comp_min_edges</span>
                <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pv</span><span class="p">)</span>
                <span class="nf">.cloned</span><span class="p">()</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pv_min_edge</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pv_min_edge</span> <span class="p">{</span>
                <span class="n">comp_min_edges</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">continue_flag</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span> <span class="k">in</span> <span class="n">comp_min_edges</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">opt</span> <span class="p">{</span>
                <span class="n">res</span><span class="nf">.insert</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
                <span class="n">dsu</span><span class="nf">.cunion</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="n">cand_edges</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">));</span>

                <span class="n">continue_flag</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">continue_flag</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="利用属性的简单证明">利用属性的简单证明</h3>

<p>开始时 $G$ 中每个点都是一个连通分量，每次选取最小出边，连接两个分量。首先这两个分量分别属于某棵最小生成树，其中任一个分量加上出边仍然是最小生成树的一部分，<strong>显然</strong> （也许并没有显然）应当是这两个连通分量合起来仍然属于某棵最小生成树。</p>

<h3 id="完整证明">完整证明</h3>

<p>完整证明过于复杂，另行查阅资料，不介绍。</p>

<h3 id="时间复杂度-2">时间复杂度</h3>

<p>由于每次迭代后连通分量至少减半（每个新分量都没再连通过），所以最外层迭代次数是O(logn)，每次边的遍历是 $O(m)$  ，并查询是 $O(\text{log}n)$ ，所以时间复杂度为 $O(m\text{log}n\text{log}n)$ 。</p>

<h2 id="时间复杂度简单比较">时间复杂度简单比较</h2>

<p>时间复杂度涉及 $n$ 和 $m$ ，按照图的稀疏度分两个维度讨论（对于连通图，$m\geqslant n-1$ ）</p>

<p><br /></p>

<p>对于稀疏图，$m=n$ :</p>

<p>Kruskal:  $O(m(\text{log}m+\text{log}n)) = O(n\text{log}n)$</p>

<p>Prime:  $O(\text{log}n+m) = O(n+\text{log}n) = O(n)$</p>

<p>Boruvka: $O(m\text{log}n\text{log}n) = O(n\text{log}n\text{log}n)$</p>

<p>复杂度从优到劣， Prim &gt; Kruskal &gt; Boruvka</p>

<p><br /></p>

<p>对于稠密图，$m=n^2$</p>

<p>Kruskal: $O(m(\text{log}m+\text{log}n)) = O(n^2\text{log}n\text{log}n)$</p>

<p>Prime:  $O(\text{log}n+m) = O(n^2 + \text{log}n)$</p>

<p>Boruvka: $O(m\text{log}n\text{log}n) = O(n^2\text{log}n\text{log}n)$</p>

<p>复杂度从优到劣， Prim &gt; Kruskal = Boruvka</p>

<p><br /></p>

<p>好像仅从复杂度上，经典实现里 Prim都是各方最优。</p>

<p>从优化实现上，Prim 的优化和 Boruvka 算法的拓展都可以到 $O(m)$ 。</p>

<h2 id="后续">后续</h2>

<p>关于 Prim 进一步可以看看 <a href="/algs/DaryHeap.html">d-ary 堆的实现</a>；而基于 Boruvka 的线性算法<sup id="fnref:lt-mst" role="doc-noteref"><a href="#fn:lt-mst" class="footnote" rel="footnote">2</a></sup> 复杂的部分在于一个去重（zhong）边的最小生成树的验证算法（原始提出和 Targan 最近共同祖先同一篇论文里），没有具体实现的介绍，只有原始的算法的论文，大体看了以下，应该可以弄明白，但是要花不少时间，有点儿鸡肋，就这样吧。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:mst-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Minimum_spanning_tree <a href="#fnref:mst-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:lt-mst" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Expected_linear_time_MST_algorithm <a href="#fnref:lt-mst" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">指数提升（倍增，Binary Lifting）</title><link href="/algs/BinaryLifting.html" rel="alternate" type="text/html" title="指数提升（倍增，Binary Lifting）" /><published>2022-11-16T00:00:00+08:00</published><updated>2022-11-16T00:00:00+08:00</updated><id>/algs/BinaryLifting</id><content type="html" xml:base="/algs/BinaryLifting.html"><![CDATA[<h2 id="前言">前言</h2>

<p>我一定要狠狠地“婊扬“一下“倍增“这个翻译，这个翻译从字面上看是要翻倍、增加，可是翻倍已经包含增加的内涵（一般概念上的对象都是自然数的），结果实际上一般人看到这个词就只能理解到翻倍的意涵，为什么要翻倍？这么做的好处在哪儿？ 这到底是什么东西？我每次看到这个词总是一头雾水，看了几次算法介绍也不能抓到关键点，而使用倍增这个翻译的介绍的大多数作者也没能抓住关键点，可能他们也被倍增这个鬼翻译迷惑住，只能硬讲流程，却点不出关键点。</p>

<p>我是直到看到“倍增”对应的英文词 Binary Lifting ，才恍然大悟，明白它的想法到底是什么，什么叫“好“翻译增加学习曲线的陡峭度？！它显然是可类比 Binary Search 二分搜索，用指数级别增长取代线性增长概念，从而把线性时间复杂度降低为对数级时间复杂度。这又要讲这个鬼翻译，大哥你提升和增长哪个更形象？你不觉得增长过于抽象了吗？何况你又把增长缩写为“增“，很可能人一看到“增“首先联想到的是增加而不是增长，那增加就比增长更抽象了，最后更绝地是，翻译者觉得“倍增”就是把翻倍和增长结合在一起的意思，这完全没有语文素养，没意识到白话文双元词语义分主辅的使用习惯，比如“强力”，主要是“强”，“力”是对“强”的辅助修饰，而倍增一词，就是一个“倍“，增通常是辅助，是被忽略的！</p>

<p>这样我们分析了“倍增”如何犯了一系列模糊重点，翻译失准的问题，翻译三重标准–信达雅，翻译者可能觉得自己这种翻译简直“既达而雅”了，实际在第一步“信“的标准上就失败了（很多那些让人摸不着头脑的翻译比那些佶屈聱牙的直白翻译还不如）（这种翻译，令人血压升高的程度堪比那个 YGO DL 里面那个有同步协调不用，非要同“吊“ 还不加儿化音的鬼翻译）（按照这种翻译，二分搜索就可以翻成“半搜“了，让人看了也一头雾水）。</p>

<p>所以我自己使用了一个更到位，让人一眼就看清楚这个算法是做什么的<strong>直白</strong>翻译：<strong>指数提升</strong> ，这个翻译首先从全局上讲清楚了，就是指数级增长，然后是“提升“就比“增“具体地多，清楚得多。</p>

<h2 id="算法思想">算法思想</h2>

<p>指数提升在前言里已经提过了，就是用指数级增长取代线性增长，这里我们具体地描述一下场景：</p>

<p>假设有在同一直线上的两点 $A$ , $B$ ，在不知道 $|AB |$（$A$ 到 $B$ 的距离）的情况下，从 $A$ 跳到 $B$ ，每次跳幅是单位距离的整数倍。</p>

<p>我们有如下几个逐渐改进的方案：</p>

<h3 id="步行">步行</h3>

<p>一个单位一个单位的跳，每次检查是否到了 $B$ 点，这肯定可以，但这是最慢的方法。</p>

<h3 id="传统家用汽车">传统家用汽车</h3>

<p>一跳跳固定跳 $n$ 个单位，最后距离如果不足一跳就下车步行（改为一个单位一个单位跳）</p>

<p>比步行强多了，但控制太差，要么速度不够快，要么步行距离长。</p>

<h3 id="传统超跑">传统超跑</h3>

<p>前面两种方法本质都是 $O(n)$ 的时间复杂度，于是我们想，可以加快这一过程，用指数增长（或减少）的步幅来跳。</p>

<p>假设幂底是 $m$ ，用档位代指指数，那么 $n$ 档就是 $m^n$ 。</p>

<ol>
  <li>
    <p>这样我们从 $0$ 档起步，每跳一步，就加速一档： $1$ 档, $2$ 档, ……, $n$ 档，直到第 $n+1$ 步会超过 $B$ ；</p>
  </li>
  <li>
    <p>之后从 $n$ 档开始逐一降档，直到下一步不超过 $B$ ，然后尝试保持档位跳第 $n+2$ 步，仍然超过就继续降档，重复步骤2，直到降到 $0$ 档，然后下车步行，直到到达 $B$ 点</p>
  </li>
</ol>

<p>有了指数级变速器，这比传统家用汽车性能强多了，但显然一档一档地提速显得加速度不够理想。</p>

<h3 id="电动超跑">电动超跑</h3>

<p>假如我们知道 $|AB |$  最大不超过 $x$ ，那么我们可以起步挂在 $\lfloor \log_{m}x \rfloor$ 档，一步到位，之后直接进入步骤2。</p>

<p>在最后的电动超跑的方案下，挂在每档的次数， 对应相应位上的数字，这样从高到低，构成了 $|AB |$ 的 $m$ 进制表示。设挂在每档的次数为 $k$ , 则显然有  $0\leqslant k &lt; m$ 。</p>

<p>通常我们会设定 $m=2$ ，这有实现上的便利：</p>

<ol>
  <li>当 $m=2$ 时，$k \in [0, 1]$，这意味着不存在重复的档位，挂了 $n$ 档后，下一步直接从 $n-1$ 档开始检查，当挂完 $0$ 档之后，一定到达了目的地；</li>
  <li>可以直接通过右移（right shift）来做 $2$ 为底的对数运算</li>
</ol>

<p>所以我们还可以把“指数提升“叫做<strong>幂（指）2提升</strong>或<strong>二进制提升</strong>，无论它们哪一个名字都比<em>倍增</em> 要好得多。</p>

<h2 id="应用模板">应用模板</h2>

<h3 id="快速开对数-2为底">快速开对数 （2为底）</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">quick_log2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="开跳">开跳</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nf">quick_log2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// skip 2^i</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">斐波那契堆的实作 (for Rust)</title><link href="/algs/FibHeapImplRust.html" rel="alternate" type="text/html" title="斐波那契堆的实作 (for Rust)" /><published>2022-11-13T00:00:00+08:00</published><updated>2022-11-13T00:00:00+08:00</updated><id>/algs/FibHeapImplRust</id><content type="html" xml:base="/algs/FibHeapImplRust.html"><![CDATA[<p>算法理论部分，在上一篇论文 <strong><a href="/algs/FibHeap.html">Fibonacci Heap</a></strong> 已经讲完了，下面是干活的部分<sup id="fnref:rust-impl" role="doc-noteref"><a href="#fn:rust-impl" class="footnote" rel="footnote">1</a></sup>：</p>

<h2 id="语言特定">语言特定</h2>

<h3 id="数据共享可变性与非null对象">数据共享、可变性与非null对象</h3>

<p>Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针  <code class="language-plaintext highlighter-rouge">Rc</code> (reference counter) 代替直接的指针，使用 <code class="language-plaintext highlighter-rouge">RefCell</code> 来“作弊“地绕开可变性检查，使用 <code class="language-plaintext highlighter-rouge">Option</code> 取代传统含 <code class="language-plaintext highlighter-rouge">null</code> 对象。但是这不可避免地使代码显得冗长，按说应该有语法糖或者辅助结构来做这件事，但是没有，这也是 Rust1 诸多不完美地方中的一处，好在可以通过写一点儿宏来解决这个问题。</p>

<h3 id="计数指针的强弱引用">计数指针的强弱引用</h3>

<p>另外的问题在于双向索引的链表结构会造成计数指针的循环引用，这会造成内存泄露的问题。Rust 提供了 <code class="language-plaintext highlighter-rouge">Weak</code> 计数指针的弱引用来解决这个问题。使用弱引用有两个方案：</p>

<ol>
  <li>所有正向引用（从左到右，从上到下）是正常的强引用，而反向引用（从右到左，从下到上）是弱引用，唯一例外是根链表，这只要在释放的时候手动去掉一个强引用，打破强引用的循环就可以了。</li>
  <li>所有引用都是弱引用，只在堆的头部的索引里保留唯一的强引用。</li>
</ol>

<p>方案 2 的好处是不需要在算法里区分强弱引用和做强弱转换，省事省心；但方案 1 的好处在于不依赖外部维持的强引用，每个节点都可以分型地单独使用，更符合个人美感所以暂时选择方案 1 。</p>

<h3 id="宏机制">宏机制</h3>

<p>最后是展开说明 Rust 的宏机制，它是 Rust 集众家之长，也是目前为止综合起来，最令我满意的宏机制的实现方案，虽然也有应有未有的地方。</p>

<p>Rust 的宏分为两种 ： 预处理宏（procedure macro）和声明式宏（declare macro）。</p>

<p><strong>预处理宏</strong></p>

<p>预处理宏是顾名思义，展开在提前的、单独的一遍扫描过程里，可以做到声明式宏做不到的所有，比如创造新的 Token 节点，但是没有语义感知，需要放置在单独的 crate 里面，使用也麻烦一点。</p>

<p><strong>声明式宏</strong></p>

<p>声明式宏名字并没有那么直观，是嵌在源文件中，和普通代码在同一过程中展开，有特殊的 <code class="language-plaintext highlighter-rouge">$crate</code> 指名当前所属 Crate ，但是因此功能受限，无法创建新的 Token ，后面生成宏的宏又被限制在它定义的模块里，不能跨模块使用。</p>

<p>这里我们直接使用声明式宏在补充该有的语法糖。</p>

<h3 id="生命周期对引用的限制">生命周期对引用的限制</h3>

<p>同样不同于传统的编程模型，Rust 引入了生命周期的概念，区别于一般在安全点上动态运行的垃圾回收器，来作为一种静态的内存自动管理机制，属于从源头上解决了内存需要自动管理而传统垃圾回收器有运行期性能“毛刺“的问题。但是这又对提出了新问题：由于 <code class="language-plaintext highlighter-rouge">Rc</code> 所有权是 <code class="language-plaintext highlighter-rouge">GlobalAllocator</code> ，而不是 <code class="language-plaintext highlighter-rouge">FibHeap</code> ，因此它创建的引用，由于生命周期的限制，无法用在 <code class="language-plaintext highlighter-rouge">FibHeap</code> 返回引用的接口上。这个问题也是 <code class="language-plaintext highlighter-rouge">Rc</code> 、 <code class="language-plaintext highlighter-rouge">RefCell</code> 另一个比冗繁更要命的缺点，阅读了 Rust 和标准库内部组件的实现，看它们基本上都不使用这两个公开组件而是用 unsafe 的传统指针另写一套，功能上和这两个组件基本类似，唯一额外作用就是能绕开生命周期的限制。</p>

<p>在这里我们直接使用 <code class="language-plaintext highlighter-rouge">Box</code> 把需要导出引用的数据放到堆上而不是 <code class="language-plaintext highlighter-rouge">RefCell</code> 中，在 <code class="language-plaintext highlighter-rouge">RefCell</code> 里只保留原始指针，通过这种 unsafe 操作，绕过生命周期的限制（实际也可以绕过所有权、可变性等等所有 Rust 额外的检查）</p>

<h3 id="克隆clone与复制copy">克隆（clone）与复制（copy）</h3>

<p>这里对应的是内存模型里的<strong>值对象</strong>与<strong>引用对象</strong>，copy 针对的是值对象，clone 针对的是引用对象。二者的区别首先是概念上的、语义上的，值对象就是它本身只是内存里的一个数值，可以任意地在任何地方使用，没有任何其他语义上或物理上的外部关系；而引用对象就像广泛的用于传统面向对象语言里的普通对象，这里二者在概念上直接构成互补的关系。</p>

<p>从实现角度，copy 为了严格语义不被违反，限制了只能自动实现，基本的数值类型是可 copy 的，任何派生的可 copy 对象必须保证所有字段都是可 copy 的。从语义上讲，分配内存空间的对象都应该是不可 copy 的，什么 <code class="language-plaintext highlighter-rouge">Vec</code>，<code class="language-plaintext highlighter-rouge">array</code>， <code class="language-plaintext highlighter-rouge">String</code> … 都不行，因为分配内存本身就不能随意复制。</p>

<p>注意区别于传统上世纪 90 年代的那一批面向对象语言什么 Java、Python、Ruby、C# 等等，在这种传统编程模型里，所有对象都是引用，没有值对象的概念，更重要的是前面提到的数据共享上缺乏设计，于是在对象克隆的时候有深和浅的区别，有的也称 deep “copy” 和 swallow “copy”。</p>

<p>这种在数据共享上设计的匮乏是它们并发痛点的根源， 只熟悉那些语言的人可能会把这个东西和上面的 clone 与 copy 的概念错误地对应起来。实际上对于 Rust 而言并不常用到那些语言里常见的克隆深与浅的问题，因为 Rust 有一套新的安全编程模型，所有权、可变性、生命周期等等保证你要么转移对象所有权，要么克隆就是完全克隆。</p>

<p>但原则的城墙大门紧闭，但在总有几扇窗户是开着的，就像 <code class="language-plaintext highlighter-rouge">Rc</code>、<code class="language-plaintext highlighter-rouge">RefCell</code> 这种“怪胎“的存在，当我们不得不用它们在更高层面模拟传统编程模型的时候，就必须考虑自己有区分的实现深浅克隆的问题了。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="heap-node">Heap Node</h3>

<h4 id="structure--wrappers">Structure &amp;&amp; Wrappers</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="cd">/// Used for reverse reference to avoid circular-reference</span>
<span class="cd">///</span>
<span class="cd">/// So we can easy auto drop</span>
<span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// children number</span>

    <span class="cd">/// rev ref</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// rev ref</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Indicate that it has lost a child</span>
    <span class="n">marked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="sugar-macros">Sugar Macros</h4>

<p>谈到 Rust 的声明式宏，总是离不开 <a href="https://danielkeep.github.io/tlborm/book/index.html">黑小书</a> 和 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">基础文档</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////////////////////////////////////////</span>
<span class="c1">//// Attr macros</span>

<span class="cd">/// Clone attr</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">_unr</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">mattr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="n">mname</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">mattr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nd">attr!</span><span class="p">(</span><span class="nv">$node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">marked</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="heap-head">Heap Head</h3>

<h3 id="structure">Structure</h3>

<ol>
  <li>$\texttt{len}$ 和 $\texttt{rcnt}$ ，分别是节点数和根节点个数，它们只是额外的基本统计信息，可以省略；</li>
  <li>$\texttt{min}$ 是最小根；</li>
  <li>$\texttt{nodes}$ 是索引，这里专注主要功能的使用，所以使用 HashMap ，如果要实现 $O(1)$ 的 Union 方法就需要换成别的分型结构，比如二叉搜索树或者B-树</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">CollKey</span> <span class="o">=</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// roots count</span>
    <span class="n">rcnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// index of nodes</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sugar-macros-1">Sugar Macros</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">node!</span><span class="p">(</span><span class="nv">$i</span><span class="p">,</span> <span class="nv">$k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$rank:expr</span><span class="p">,</span> <span class="nv">$marked:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">:</span> <span class="nv">$i</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$k</span><span class="p">),</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nv">$rank</span><span class="p">,</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">marked</span><span class="p">:</span> <span class="nv">$marked</span><span class="p">,</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="算法无关的基础方法">算法无关的基础方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">WeakNode</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">node</span><span class="na">.0</span><span class="p">;</span>
        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">children</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="cd">/// replace with new val, return old val</span>
    <span class="k">fn</span> <span class="nf">replace_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">oldk</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">newk</span> <span class="o">=</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="nd">mattr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="n">newk</span><span class="p">;</span>

        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldk</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// from self.min go through all roots</span>
    <span class="k">fn</span> <span class="nf">roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sibs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sibs</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="n">sib</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sibs</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">I</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="n">k</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// break circle dependency to enable drop</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.nodes</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法相关的基础方法">算法相关的基础方法</h3>

<h4 id="摘儿子">摘儿子</h4>

<p>在 update-key 的时候，需要把违背堆性质或者失去超过一个孩子的非根节点从父结点摘除。这就是这个方法的作用，需要仔细考虑，每一步都不能忽略：</p>

<p>假设被摘的节点为 $\texttt{x}$</p>

<ol>
  <li>如果 $\texttt{x}$ 的左邻居不为空，把左邻的右邻连接到 $\texttt{x}$ 的右邻，否则 $\texttt{x}$ 就是父节点的第一个孩子，这时还需要更新父节点的孩子到 $\texttt{x}$ 的右邻；</li>
  <li>如果 $\texttt{x}$ 的右邻居不为空，还把右邻的左邻更新为 $\texttt{x}$ 的左邻；</li>
  <li>父节点的 $\texttt{rank–}$ ；</li>
  <li>摘出来的节点去头和左右邻，只保留它的孩子</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cut_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">mchild!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">mrank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">rank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="cd">/// remove paren, left and right</span>
    <span class="k">fn</span> <span class="nf">purge_as_root</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">mparen!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="锄根">锄根</h4>

<p>在执行 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候，需要把一个根节点从根链表中移除：</p>

<ol>
  <li>根数自减，如果不为 $0$ ，意味着根链表还存在，就把左邻的右邻连接到右邻，右邻的左邻连接到左邻；</li>
  <li>purge</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...    </span>
<span class="k">fn</span> <span class="nf">remove_from_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.rcnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="插苗">插苗</h4>

<p>锄根的逆过程，把一个节点 $\texttt{x}$ 插入到根链表中：</p>

<ol>
  <li>根数 $\texttt{rcnt}$ 自增，保护性地 purge 节点 $\texttt{x}$ ；</li>
  <li>如果根链表不存在，把 $\texttt{x}$ 作为根链表的唯一节点，让它成为最小根并且左右邻指向自己；</li>
  <li>否则，头插法插入 $\texttt{x}$ ， $\texttt{x}$ 的右邻链接到最小根的右邻， $\texttt{x}$ 左邻链接到最小根，然后最小根的右邻链接到 $\texttt{x}$ ， $\texttt{x}$ 的右邻的左邻链接到  $\texttt{x}$</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">fn</span> <span class="nf">push_into_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>

        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...  </span>
</code></pre></div></div>

<h2 id="高空台-atf">高空台 （ATF）</h2>

<p>欲要善其事，必先利其器</p>

<p><strong>任何有一定复杂度的实现都非一蹴而就，而越是复杂度高的实现，越是需要测试与调试的部分先行，越是由测试的全面性、彻底性与调试工具的效率决定其进程速度。</strong></p>

<h3 id="打印方法">打印方法</h3>

<p>一个全面而又简洁的打印方法是进行状态观察的基础手段。</p>

<ol>
  <li>
    <p>对于 Fib 堆，简单遍历根节点地逐树打印，表明最小根；</p>
  </li>
  <li>
    <p>树的打印遵循 BFS 顺序，每层一行，同层不同父节点的由分号分开， 并且在开头表明父节点序号；</p>
  </li>
  <li>
    <p>单个节点打印它的权重（key）和索引（idx），如果被标记还要打印标记</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="k">self</span><span class="py">.rcnt</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}  ({i:03})  {}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="c1">// writeln!(f)?;</span>
            <span class="k">if</span> <span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"M=&gt;"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">sib</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">sib</span><span class="nf">.is_some</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}&gt;&gt; end &lt;&lt;{}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"R({:?}) "</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">curq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="k">self</span><span class="nf">.children</span><span class="p">())];</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxtq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="k">in</span> <span class="n">curq</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">children</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"P({:?}) "</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">childlen</span> <span class="o">=</span> <span class="n">children</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childlen</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">nxtq</span><span class="nf">.push</span><span class="p">((</span><span class="n">child</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">child</span><span class="nf">.children</span><span class="p">()));</span>
                <span class="p">}</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">nxtq</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="n">curq</span> <span class="o">=</span> <span class="n">nxtq</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"None"</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="s">"{:?}[{:?}]{}"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.idx</span><span class="p">,</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.key</span> <span class="p">},</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.marked</span> <span class="p">{</span> <span class="s">" X"</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="s">""</span> <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="克隆方法">克隆方法</h3>

<p>测试的时候，需要验证某一个状态是否正确，而当验证过程会影响测试对象本身状态时，就需要一个克隆方法来克隆一个被测试对象来进行这种有副作用地验证。</p>

<ol>
  <li>创建新的索引目录，对根链表逐根完全克隆，每克隆完一个，就和前一个克隆的节点双向链接起来，最后把头尾相连，构成一个循环链表；</li>
  <li>对于根链表上的每棵树克隆的时候，先创建新的根节点，并把新创建的节点加入新的索引目录里，然后对它孩子递归地调用节点的完全克隆方法，创造出的孩子左右相连，每个孩子的父节点也要指向自己创建的新的根节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rcnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rcnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">min</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">roots_iter</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_min</span><span class="p">)</span> <span class="o">=</span> <span class="n">roots_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">_min</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">root</span> <span class="k">in</span> <span class="n">roots_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newroot</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newroot</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newroot</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newroot</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">,</span>
            <span class="n">min</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">overall_clone</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// overall clone node body</span>
        <span class="k">let</span> <span class="n">newx</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">rank!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="c1">// update index reference</span>
        <span class="n">nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">newx</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// recursive call it</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">childen_iter</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="n">childen_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

            <span class="nd">mchild!</span><span class="p">(</span><span class="n">newx</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mparen!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">newx</span><span class="nf">.downgrade</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">childen_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">newx</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="主要算法方法">主要算法方法</h2>

<p>Fib 堆核心的算法就是三个：</p>

<ol>
  <li>Push</li>
  <li>Pop</li>
  <li>DecreaseKey</li>
</ol>

<h3 id="push-方法">Push 方法</h3>

<p>根据算法，创建新的节点和索引后，直接插入到根链表中； 如果 $\texttt{key}$ 比最小根小，就更新最小根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop-方法">Pop 方法</h3>

<p>（这里从使用的接口上讲，实际上需要的是 <code class="language-plaintext highlighter-rouge">pop_item</code> ）</p>

<ol>
  <li>如果长度为 $0$ ，不存在最小根，直接返回 <code class="language-plaintext highlighter-rouge">None</code>；</li>
  <li>否则长度自减，从最小根的右邻开始，遍历所有邻居，找到新的最小节点，如果最小根没有邻居（除它以外），就得到一个空节点；</li>
  <li>把旧的最小根指向的节点从根链表摘除，最小根指向新的最小节点（包括可能是空节点），开启树的规整，合并同秩树；</li>
  <li>树规整：创建一个 $\texttt{rank =&gt; node}$ 的 Map，遍历根链表，对于每个根，递归地查询 Map 是否有同秩的节点已经加入，有就合并两棵树，然后更新当前根节点为合并后的树的根节点，递归查询合并结束后，就插入当前树的秩和节点到 Map 中</li>
  <li>把旧的最小根节点从索引删除，返回旧的最小根的节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.1</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* push children of oldmin into roots */</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* update min */</span>

    <span class="k">let</span> <span class="n">newmin</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">sib</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span>
    <span class="nf">.cloned</span><span class="p">()</span>
    <span class="nf">.unwrap_or_default</span><span class="p">();</span>

    <span class="cm">/* just del old min */</span>

    <span class="k">self</span><span class="nf">.remove_from_roots</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">oldmin</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.replace</span><span class="p">(</span><span class="n">newmin</span><span class="p">);</span>


    <span class="k">self</span><span class="nf">.consolidate</span><span class="p">();</span>

    <span class="nf">Some</span><span class="p">((</span>
        <span class="k">self</span><span class="nf">.remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmin</span><span class="p">),</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">oldmin</span><span class="p">)</span><span class="py">.key</span><span class="p">),</span>
    <span class="p">))</span>
<span class="p">}</span>


<span class="cd">/// merge same rank trees recusively</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">consolidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rank</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">hashmap!</span><span class="p">();</span>

    <span class="k">for</span> <span class="k">mut</span> <span class="n">sib</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">rank</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.merge_same_rank_root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">rank</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">),</span> <span class="n">sib</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey-方法">DecreaseKey 方法</h3>

<p>对节点 $\texttt{x}$ 降 $\texttt{key}$ ，首先检查一下索引（检查是否 $\texttt{x}$ 的新 $\texttt{key}$ 确实较小），检查一下是否不是根节点并且堆性质违背（比父节点的 $\texttt{key}$ 更小），如果是，标记 $\texttt{x}$ ，设置 <em>cut-meld-unmark</em> 递归的起始点为 $\texttt{x}$ ，假装 $\texttt{x}$ 本身也是符合<em>cut-meld-unmark</em> 条件的一个父节点，否则设置起始点为空节点。最后由于是降 $\texttt{key}$ ，还要检查最小根是否需要更新为 $\texttt{x}$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">oldv</span><span class="p">,</span>
                <span class="s">"decrease violated! {:?} !(&lt;) {:?}"</span><span class="p">,</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="o">&amp;</span><span class="n">oldv</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"Empty index {i:?}"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decrease_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">unmeld_ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 假装x节点本身也是一个符合条件的父节点</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">unmeld_ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>cut-meld-unmark to roots :</strong></p>

<p>如果起始节点是空节点，就退出；递归地检查当前节点是否不为根节点并且被标记，是，就取消标记，从父节点被摘出，推进根链表，然后以父节点为新的起始节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">cut_meld_unmark_to_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ent</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">while</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">strongp</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="n">strongp</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">strongp</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 定义上不标记根，但这应该是无所谓的，标记对于可能的pop导致的树规整后的树情况更精确</span>
    <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="额外算法方法">额外算法方法</h2>

<h3 id="update-方法">Update 方法</h3>

<p>从语义上可以把 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的方法拓展为完整的更新key的方法 。</p>

<ol>
  <li>如果索引不存在，就插入节点，否则替换节点；</li>
  <li>如果 $\texttt{key}$ 相等，什么都不做；</li>
  <li>如果 $\texttt{key}$ 降低，就 <code class="language-plaintext highlighter-rouge">decrease-key</code> ；</li>
  <li>如果增加，就 <code class="language-plaintext highlighter-rouge">increase-key</code></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.increase_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>increase-key</strong> :</p>

<p>注意： 由于当对最小根 <code class="language-plaintext highlighter-rouge">increase-key</code> 的时候需要重新搜索最小根，时间复杂度为 $O(\texttt{rank})$ ，在不保证严格二项堆的性质时，最坏时间复杂度为 $O(\texttt{n})$  , 会破坏了整个 <code class="language-plaintext highlighter-rouge">update</code> 其他部分的 $O(\texttt{logn})$ 的性质。</p>

<p><code class="language-plaintext highlighter-rouge">increase-key</code> 的时候，同样地，当堆性质违背的时候（新的 $\texttt{key}$ 大于孩子节点）递归地执行 <em>cut-meld-unmark</em> 操作，区别在于升 $\texttt{key}$ 的是 $\texttt{x}$ 而要扫描的是x的孩子节点，好像是 $\texttt{x}$ 的孩子们降 $\texttt{key}$ 造成的堆性质违背。统计 $\texttt{x}$ 总共因为堆违背失去的孩子数（如果 $\texttt{x}$ 已被标记，初始化为 $1$ 否则为 $0$ ）。</p>

<p>检查失去的孩子节点数，如果没有，就把启动点设置为空节点；如果恰好为 $1$ ，确认标记x，以 $\texttt{x}$ 的父节点为启动点；如果大于 $1$ ，标记 $\texttt{x}$ ，以 $\texttt{x}$ 本身为启动点。</p>

<p><em>cut-meld-unmark</em>  递归地操作完成后，如果升 $\texttt{key}$ 的节点是最小根指向的节点，还要遍历根链表，更新最小根</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">increase_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">children_lost</span> <span class="o">=</span> <span class="k">if</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="n">children_lost</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="n">children_lost</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">min_node</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">min_node</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="典例片段">典例片段</h2>

<h3 id="prim-最小生成树">Prim 最小生成树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:rust-impl" role="doc-endnote">
      <p>https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs <a href="#fnref:rust-impl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[算法理论部分，在上一篇论文 Fibonacci Heap 已经讲完了，下面是干活的部分1： https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs &#8617;]]></summary></entry><entry><title type="html">斐波那契堆（Fibonacci Heap）</title><link href="/algs/FibHeap.html" rel="alternate" type="text/html" title="斐波那契堆（Fibonacci Heap）" /><published>2022-10-27T00:00:00+08:00</published><updated>2022-10-27T00:00:00+08:00</updated><id>/algs/FibHeap</id><content type="html" xml:base="/algs/FibHeap.html"><![CDATA[<p>Fibonacci Heap<sup id="fnref:fib" role="doc-noteref"><a href="#fn:fib" class="footnote" rel="footnote">1</a></sup><sup id="fnref:fib2" role="doc-noteref"><a href="#fn:fib2" class="footnote" rel="footnote">2</a></sup> <sup id="fnref:fib-wiki" role="doc-noteref"><a href="#fn:fib-wiki" class="footnote" rel="footnote">3</a></sup>是一个基于链表结构的，理论时间复杂度很优的数据结构。</p>

<p>常用于Dijkstra最短路径、Prim最小生成树等贪心算法，使用 <code class="language-plaintext highlighter-rouge">push</code> - <code class="language-plaintext highlighter-rouge">decrease-key</code>，都是 $O(1)$ 的时间复杂度。</p>

<h2 id="前言">前言</h2>

<p>一点儿啰嗦，可以跳过。说实话本来看图例， 看着各种相比最优的时间复杂度颇为心动但仔细看下去，发现完全是典型的基于链表结构的算法，代意词是理论很好但实际性能和最好的比要差一到两个数量级。那谁是最好的？</p>

<p>其中之一就是Rust标准库里本家实现的堆–<a href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#268">BinaryHeap</a> 。这个堆不看不知道，一看我的天，整个基础结构就是一块儿连续内存，什么叫完美？！！你一看这个就知道性能比较可以不用做了，你F堆拿什么跟人家比，比都没法儿比！除非说，使用的CPU没有碗口大的高速缓存，否则你链表结构，就一个字，拉！</p>

<h2 id="预备知识">预备知识</h2>

<h3 id="二项式树-binomial-tree">二项式树 （Binomial Tree）</h3>

<h4 id="秩阶度-rankorderdegree">秩、阶、度 （rank/order/degree）</h4>

<p>$\texttt{order}$ ，通常指允许的最大孩子数量，常用于B树，二叉树的 $\texttt{order}$ 为 $2$ ；</p>

<p>$\texttt{degree}$ ，具体地某个节点的孩子的数量；</p>

<p>$\texttt{rank}$ ，一般指排名，但这里用作 $\texttt{degree}$ 的别名；</p>

<p>以下统称 $\texttt{rank}$ ，指称直接孩子的个数。</p>

<h4 id="性质与定义">性质与定义</h4>

<ol>
  <li>
    <p>二项树的节点数为 ${\large 2^{\text{rank}}}$ ；</p>
  </li>
  <li>
    <p>显然单节点树的 $\texttt{rank=0}$ ，而合并两棵单节点树可以得到 $\texttt{rank=1}$ 的树，合并两棵 $\texttt{rank=1}$ 的树可以得到 $\texttt{rank=2}$ 的树，由此可归纳得到 $\texttt{rank=k, (k&gt;0)}$ 可以由两棵 $\texttt{rank=k-1}$ 的树合并得到，这就是二项式树的构造；</p>
  </li>
  <li>
    <p>特别地，从实现上讲，每次同 $\texttt{rank}$ 的树合并，都是其中一棵作为另一棵的最左子树，这样构造出的二项式树的子树也是二项式树，假设 $\texttt{rank=k} $，而且从左到由的 $\texttt{rank}$ 分别为 $\texttt{k-1, k-2, …, 0} $ 。</p>
  </li>
</ol>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_01.svg" zoom="200%" /></div>

<p>二项式堆（Binomial Heap）就是由多棵二项式树构成，每棵树都是小顶堆（Min Heap），并且每棵子树的 $\texttt{rank}$ 独特。</p>

<p>每个二项式堆都可以这样构造出来，二项式堆的结点数 $\texttt{n}$ 的二进制表示的每一位对应一个 $\texttt{rank}$ 数值。</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_02.svg" zoom="200%" /></div>

<p><em>而二项堆里的每棵二项树的孩子构成的森林都可以理解为完全二项堆。</em></p>

<h2 id="定义">定义</h2>

<p>斐波那契堆类似于二项式堆，是一个二项式树的森林，但并不严格要求 $\texttt{rank}$ 独特。</p>

<p>执行 <code class="language-plaintext highlighter-rouge">push</code> 操作的时候新节点直接作为单节点的二项式树，插入到根链表中。只有在 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候递归合并同 $\texttt{rank}$ 的树，才得到严格的二项式堆。</p>

<h2 id="数据结构">数据结构</h2>

<p>堆的结构：一个指向森林中最小根的指针，以及其他必要元数据；</p>

<p>树根的存储结构：双头循环链表；</p>

<p>树的结构：经典带反向引用的 <code class="language-plaintext highlighter-rouge">child-sibling</code> 链表。</p>

<h2 id="push-操作">Push 操作</h2>

<h3 id="算法">算法</h3>

<p>根据定义，直接把单个节点插入到根链表中即可，必要的话更新堆指针。</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_push1.png" title="" /></div>
<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_push2.png" title="" /></div>

<h3 id="复杂度分析">复杂度分析</h3>

<p>时间复杂度显然为 $O(1)$ 。</p>

<h2 id="pop-操作">Pop 操作</h2>

<h3 id="算法-1">算法</h3>

<p><code class="language-plaintext highlighter-rouge">pop</code>算法分为几步：</p>

<ol>
  <li>
    <p>把 <code class="language-plaintext highlighter-rouge">min</code> 所指向根的树的所有孩子插入到根链表中，然后遍历根列表找到下一个最小根，最后把旧根从根链表中删除；</p>
  </li>
  <li>
    <p>从更新后的最小根出发，再次遍历根链表，在这个过程中构建 $\texttt{rank =&gt; root}$ 的 $\texttt{Map}$ ，当发现新的根的 $\texttt{rank}$ 已在 $\texttt{Map}$ 中存在时，递归地合并同 $\texttt{rank}$ 的树。<em>显然整个过程一遍扫描就可以完成，结果是规整成了一棵严格二项式树</em></p>
  </li>
</ol>

<p>举例来看：</p>

<p><em>图中黑色节点为标记节点，decrease-min 操作中使用，表示该树失去过孩子</em></p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop01.png" title="" /></div>

<p>当前最小根指向 $\texttt{node(3)}$，它的孩子有 $\texttt{node(18), node(52), node(41)}$  ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop02.png" title="" /></div>

<p>把它的 $3$ 个孩子插入到根链表中，更新最小根为 $7$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop03.png" title="" /></div>

<p>从当前最小根节点开始递归地合并同 $\texttt{rank}$ 的树；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop04.png" title="" /></div>

<p>扫描到 $\texttt{node(7)}$ ， $\texttt{rank = 1}$ ，插入当前 $\texttt{rank =&gt; root}$ 对儿到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop05.png" title="" /></div>

<p>扫描到 $\texttt{node(24)}$ ， $\texttt{rank = 2}$ ，Map中没有同 $\texttt{rank}$ 项，插入当前 $\texttt{rank =&gt; root}$ 对儿到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop06.png" title="" /></div>

<p>扫描到 $\texttt{node(23)}$ ， $\texttt{rank = 0}$ ，Map中没有同 $\texttt{rank}$ 项，把 $\texttt{0 =&gt; node(23)}$ 插入到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop07.png" title="" /></div>

<p>扫描到 $\texttt{node(17)}$ ，$\texttt{rank = 0}$ ，Map中发现同 $\texttt{rank}$ 的 $\texttt{node(23)}$ ，把该项从 $\texttt{Map}$ 取出， 把较大的 $\texttt{node(23)}$ 插入到 $\texttt{node(17)}$ ，检查同 $\texttt{rank}$ 项 <em>显然这个同 rank 树的合并不影响后面没扫描过的根节点</em>；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop08.png" title="" /></div>

<p>更新后的 $\texttt{17}$ 的 $\texttt{rank += 1}$ ，为 $1$ ，与 $\texttt{node(7)}$ 相同，继续合并，较大的 $\texttt{node(17)}$ 插入到 $\texttt{node(7)}$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop09.png" title="" /></div>

<p>更新后的 $\texttt{node(7)}$ 的 $\texttt{rank += 1} $，为 $2$ ，与 $\texttt{node(24)}$ 相同，继续合并，较大的 $\texttt{rank += 1}$ 插入到 $\texttt{node(7)}$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop10.png" title="" /></div>

<p>更新后的 $\texttt{node(7)}$ 的 $\texttt{rank += 1} $，为 $3$ ， 没有同 $\texttt{rank}$ 项，把 $\texttt{3 =&gt; node(7)}$ 插入到 $\texttt{Map}$ 中，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop11.png" title="" /></div>

<p>扫描到 $\texttt{node(18)}$ ，$\texttt{rank = 1}$，没有同 $\texttt{rank}$ 项，把 $\texttt{1 =&gt; node(18)}$，插入到 $\texttt{Map}$ 中，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop12.png" title="" /></div>

<p>扫描到 $\texttt{node(52)}$ ，$\texttt{rank = 0}$，没有同 $\texttt{rank}$ 项，继续向下；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop13.png" title="" /></div>

<p>扫描到 $\texttt{node(41)}$ ，$\texttt{rank = 1}$，与 $\texttt{node(18)}$ 的 $\texttt{rank}$ 相同，合并；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop14.png" title="" /></div>

<p>更新后的树 $\texttt{rank = 2}$ ，没有同 $\texttt{rank}$ 项，插入 $\texttt{Map}$ ，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop15.png" title="" /></div>

<p>发现所有节点已被扫描完，规整结束 <em>堆的数据结构里维护一个根节点数的变量，用它来指示扫描何时结束</em> 。</p>

<h3 id="复杂度分析-1">复杂度分析</h3>

<p>由于每棵树都是二项式树， 扫描最小根孩子节点的实际花费为 $\texttt{rank(H)}$ ，$\texttt{H}$为最小根节点的树。扫描根节点链表的实际花费为根节点数，标记为 $\texttt{trees}$ ，所以有实际花费为 $O(\texttt{trees + rank})$  。</p>

<p>而由于每次规整后的，不存在相同 $\texttt{rank}$ 的树，所以标记 $\texttt{H’}$ 为 $\texttt{rank}$ 最大的树，有 $\texttt{trees} \leqslant \texttt{rank(H’) + 1}$ 。</p>

<p>对于不涉及 <code class="language-plaintext highlighter-rouge">decrease-key</code> 操作的F堆来说，每棵树都是严格二项式树，而根据二项式树的性质，标记 $\texttt{H’}$ 的节点数为 $n’$ ， $n’ \lt n$，有 $\texttt{rank(H’) = } {\log_2 n’ \lt log_2 n}$ 。</p>

<p>所以摊销时间复杂度为 $O(\text{log n})$ 。</p>

<p>而对于 <code class="language-plaintext highlighter-rouge">decrease-key</code> 操作后的不严格二项式树，由于每棵孩子最多丢失一个孩子，应该仍然保持 $\texttt{rank(H’)}$ ~ ${O(\text{log n})}$ 的性质，后面的性质理论分析部分对此进行了证明，所以摊销时间复杂度仍为 ${O(\text{log n})}$ 。</p>

<h2 id="decreasekey-操作">DecreaseKey 操作</h2>

<h3 id="算法-2">算法</h3>

<p>实现 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，需要一个额外的编号对节点的索引目录，</p>

<p><em>同时为了在pop操作时维护这一结构并不破坏时间复杂度，还需要一个反向的节点对编号的目录，进行 O(1) 时间的反查</em></p>

<p>假设需要更新 $\texttt{key}$ 的节点为 $x$ ，首先检查情况堆的性质是否被破坏：</p>

<p>对于 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，堆的性质被破坏的情况就是，节点 $x$ 的 $\texttt{key}$ 比父节点小，<em>对于increase-key，就要检查节点x的子节点的key是否有比其小的</em> 。</p>

<p>如果堆的性质被破坏：</p>

<ol>
  <li>
    <p>把 $x$ 节点从父节点的孩子中删除，然后推到堆的根的链表上，取消 $x$ 节点的标记（<em>已被规整</em>） ，然后标记父节点（<em>表明它失去过一个孩子</em>节点），姑且把这个操作称为 <em>cut-meld-unmark</em>；</p>
  </li>
  <li>
    <p>向上递归地执行 <em>cut-meld-unmark</em> ，直到一个未被标记或者是根节点的父节点，然后标记它。</p>
  </li>
</ol>

<p>最后检查最小根是否需要被更新。</p>

<p><em>decrease-key</em> 流程：</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk1.png" title="" /></div>

<p><em>cut-meld-unmark</em> 流程：</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk2.png" title="" /></div>

<p>图例是一个 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的非平凡情况</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_01.png" title="" /></div>

<p>对节点 $x$ 的 $\texttt{key}$ 从 $35$ 降到 $5$</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_03.png" title="" /></div>

<p>发现堆性质被破坏，先对 $x$ 执行 <em>cut-meld-unmark</em></p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_04.png" title="" /></div>

<p>向上递归，发现 $p$ 被标记，意味着 $p$ 之前已经失去过一个孩子，加上这次，已经失去了两个孩子，</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_05.png" title="" /></div>

<p>对 $p$ 执行 <em>cut-meld-unmark</em> ，</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_06.png" title="" /></div>

<p>递归地检查 $p$ 的父节点 $p’$ ， $p’$ 也被标记</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_07.png" title="" /></div>

<p>对 $p’$ 执行 <em>cut-meld-unmark</em> ，到了根节点，cut-meld-unmark 整个过程停止，检查最小根，发现 $\texttt{x = 5 &lt; 7}$ ，于是把最小根更新到 $x$ 。</p>

<h3 id="复杂度分析-2">复杂度分析</h3>

<p>由于每次操作最多增加一个标记节点，那么平均每次取消的标记节点也是 $1$ ，也就是摊销复杂度是 $O(1)$ 。</p>

<h2 id="其他操作">其他操作</h2>

<h3 id="union-操作-optional">Union 操作 （Optional）</h3>

<p>直接连接两个根链表，不考虑维护索引目录的情况下，那操作就是 $O(1)$ 。</p>

<p>如果需要维护索引目录，索引目录的合并也应该是 $O(1)$ 的时间复杂度。</p>

<h3 id="remove-操作-specific">Remove 操作 （Specific）</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">decrease-key</code> 到 $-\infty$</li>
  <li><code class="language-plaintext highlighter-rouge">pop</code></li>
</ol>

<p>复杂度显然为 $O(\text{log n})$ 。</p>

<h2 id="性质的理论分析">性质的理论分析</h2>

<p>在对斐波那契堆的性质进行分析之前，先要引入几个相关的概念。</p>

<h3 id="黄金比率-golden-ratio">黄金比率 （Golden Ratio）</h3>

<p>对于两个数 $a$ ，$b$    $a&gt;b&gt;0$ ，有</p>

\[\large\frac{a+b}{a} = \frac{a}{b} = \varphi\]

<p>则称这两个数处于黄金比率，而这个黄金比率 $\varphi$ 可以通过定义</p>

<p>$1 + \frac{b}{a} = \frac{a}{b} = \varphi\$</p>

<p>$1 + \frac{1}{\large \varphi} = \varphi $</p>

<p>得到它的二次方程 $\varphi + 1 = \varphi^2$</p>

<p>解出两个根，正根 $\varphi = {\large \frac{1+\sqrt{5}}{2}} \approx 1.618$ ，以及负根 $\psi = {\large \frac{1-\sqrt{5}}{2}} \approx -0.618$</p>

<h3 id="斐波那契数-fibonacci-number">斐波那契数 （Fibonacci Number）</h3>

\[F_n =
\left\{\begin{array}{l}
\ 0&amp; &amp;(n = 0) \\
\ 1&amp; &amp;(n = 1) \\ 
\ F_{n-2} + F_{n-1}&amp; &amp;(n \ge 2) \\
\end{array}\right.\]

<table>
  <thead>
    <tr>
      <th>$i$</th>
      <th>$0$</th>
      <th>$1$</th>
      <th>$2$</th>
      <th>$3$</th>
      <th>$4$</th>
      <th>$5$</th>
      <th>$6$</th>
      <th>$7$</th>
      <th>$…$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$F_i$</td>
      <td>$0$</td>
      <td>$1$</td>
      <td>$1$</td>
      <td>$2$</td>
      <td>$3$</td>
      <td>$5$</td>
      <td>$8$</td>
      <td>$13$</td>
      <td>$…$</td>
    </tr>
  </tbody>
</table>

<p>它的封闭表达式</p>

\[F_n = \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5}\]

<p>显然它的增长速度也是指数级的。</p>

<h4 id="性质1">性质1</h4>

<p>基础：</p>

\[\begin{array}{l}
&amp;F_2 = 1 = 1 + \sum_{i=0}^{0} F_i\\
&amp;F_3 = 2 = 1 + \sum_{i=0}^{1} F_i
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l} 
F_{n+2} &amp;=\ F_n + F_{n+1}\\
&amp;=\ F_n + 1 + \sum_{i=0}^{n-1} F_i\\
&amp;=\ 1 + \sum_{i=0}^{n} F_i
\end{array}\]

<p>得到 $F_{n+2} = 1 + \sum_{i=0}^{n} F_i$</p>

<h4 id="性质2">性质2</h4>

<p>基础：</p>

\[\begin{array}{l}
&amp;F_2 =\ 1 \geqslant 1 = \varphi^0\\
&amp;F_3 =\ 2 \geqslant \varphi = \varphi^1
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l}
F_{n+2} &amp;=\ F_{n+1} + F_{n}\\
&amp;\geqslant \ \varphi^{n-1} + \varphi^{n-2}\\
&amp;=\ \varphi^{n-2}(1 + \varphi)\\
&amp;=\ \varphi^{n-2}\varphi^2\\
&amp;=\ \varphi^n
\end{array}\]

<p>得到 $F_{n+2} \geqslant \varphi^n$</p>

<h3 id="斐波那契堆的性质">斐波那契堆的性质</h3>

<h4 id="性质1-1">性质1</h4>

<p>对一个 $\texttt{rank}$ 为 $n$ 的节点 $x$ ，按照插入顺序，编号它的孩子 $y_1, y_2, …, y_n$ 。</p>

<p>那么根据二项式树的性质，有 $\texttt{rank(} y_i \texttt{)}= i-1$ 。</p>

<p>考虑到 <code class="language-plaintext highlighter-rouge">decrease-key</code> 导致 $y_i$ 最多失去一个孩子</p>

<p>于是有</p>

\[\texttt{rank}({\large y_i}) \geqslant
\ \left \{\begin{array}{l}
\ 0 &amp;(i=1)\\
\ i - 2  &amp;(i \geqslant 2)\\
\end{array}\right.\]

<h4 id="性质2-1">性质2</h4>

<p>假设 $\texttt{size(k)}$ ，为 $\texttt{rank}$ 为 $k$ 的节点的可能的最小结点数</p>

<p>基础：</p>

\[\begin{array}{l}
&amp;\texttt{size}(0) =\ 1 = F_2 \geqslant F_2 \\
&amp;\texttt{size}(1) =\ 2 = F_3 \geqslant F_3 \\
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l}
size(k) &amp;\geqslant 1 + \sum_{i=1}^{k} \texttt{size(rank(}y_i\texttt{))}\\
&amp;= 1 + \texttt{size(rank(}y_1\texttt{))} + \sum_{i=2}^{k} \texttt{size(rank(}y_i\texttt{))}\\
&amp;\geqslant 1 + \texttt{size(0)} + \sum_{i=2}^{k} \texttt{size(rank(i-2))}\\
&amp;\geqslant 1 + 1 + \sum_{i=2}^{k} \texttt{size(} F_i \texttt{)}\\
&amp;= 1 + \sum_{i=0}^{k} \texttt{size(} F_i\texttt{)}\\
&amp;= F_{k+2}\\
&amp;\geqslant \varphi^{k}
\end{array}\]

<p>于是有</p>

\[\texttt{size(k)} \geqslant F_{k+2} \geqslant \varphi^{k}\ \ \ (k \geqslant 0)\]

<p>根据这个性质，两边取 $log$ ，得到  $log_{\varphi}^{size(k)} \geqslant k = rank$ 。</p>

<p>回顾前面 <code class="language-plaintext highlighter-rouge">pop</code> 的时间复杂度分析，$\texttt{rank}$ ~ $O(log_{\varphi}^{\texttt{size(k)}})$ ~ $O(log\ n)$，也就是说我们在理论上证明了 <code class="language-plaintext highlighter-rouge">decrease-key</code> 导致的不严格二项式树，仍然不影响它的 $O(\text{log n})$ 的时间复杂度。</p>

<h2 id="后续具体实现rust">后续：<strong><a href="/algs/FibHeapImplRust.html">具体实现（Rust）</a></strong></h2>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fib" role="doc-endnote">
      <p>https://www.cs.princeton.edu/~wayne/teaching/fibonacci-heap.pdf <a href="#fnref:fib" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fib2" role="doc-endnote">
      <p>http://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/FibonacciHeaps.pdf <a href="#fnref:fib2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fib-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Fibonacci_heap <a href="#fnref:fib-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[Fibonacci Heap12 3是一个基于链表结构的，理论时间复杂度很优的数据结构。 https://www.cs.princeton.edu/~wayne/teaching/fibonacci-heap.pdf &#8617; http://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/FibonacciHeaps.pdf &#8617; https://en.wikipedia.org/wiki/Fibonacci_heap &#8617;]]></summary></entry><entry><title type="html">图理论基础</title><link href="/algs/GraphTheoryBasic.html" rel="alternate" type="text/html" title="图理论基础" /><published>2022-10-09T00:00:00+08:00</published><updated>2022-10-09T00:00:00+08:00</updated><id>/algs/GraphTheoryBasic</id><content type="html" xml:base="/algs/GraphTheoryBasic.html"><![CDATA[<h2 id="概念">概念</h2>

<p>假设图 G = {V, E}， V是顶点集，E是边集</p>

<ol>
  <li>
    <p>边，无向边（edge）</p>
  </li>
  <li>
    <p>有向边（arc）
tail(起点) -&gt; head（终点）</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>V</td>
          <td>: 点的个数，图的阶（order）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>无根树，连通无向图</p>
  </li>
  <li>
    <p><strong>简单图 (simple graph)</strong>：若一个图中没有自环和重边，它被称为简单图。具有至少两个顶点的简单无向图中一定存在度相同的结点。因为最多n-1个不同的度，而有n个点，这叫做抽屉原理或者鸽巢原理。</p>

    <p>反过来，如果一张图中有自环或重边，则称它为 <strong>多重图 (multigraph)</strong>。</p>
  </li>
</ol>

<p>参考<a href="/lang/c_trap.html">这里</a></p>

<h2 id="实现">实现</h2>

<p>本篇实现是诸多相关算法基础数据结构：</p>

<p>额外依赖<a href="https://gist.github.com/minghu6/e8b6236c745489be489317088e70e24f">EasyColl gist</a></p>

<script src="https://gist.github.com/minghu6/e8b6236c745489be489317088e70e24f.js"></script>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Adjacent link formed simple (directed) connected graph</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Graph</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">e</span><span class="p">:</span> <span class="n">MV</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">w</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Graph</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="cd">/// The length of the shortest path between the most distanced nodes.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">diameter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
        <span class="nf">diameter_dp</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// O(|E|)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">vertexs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">vertexs</span><span class="nf">.insert</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="n">vertexs</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">vertexs</span><span class="nf">.into_iter</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">edges</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">edges</span> <span class="o">=</span> <span class="k">self</span><span class="py">.e</span><span class="na">.0</span><span class="nf">.iter</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">subedges</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">subedges</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">from</span><span class="p">,</span> <span class="n">tos</span><span class="p">))</span> <span class="o">=</span> <span class="n">edges</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">subedges</span> <span class="o">=</span> <span class="n">tos</span>
                        <span class="nf">.into_iter</span><span class="p">()</span>
                        <span class="nf">.cloned</span><span class="p">()</span>
                        <span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                        <span class="nf">.rev</span><span class="p">()</span>
                        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[概念]]></summary></entry><entry><title type="html">Linux上把大文件夹移动到其他存储设备上来释放空间</title><link href="/os/mv-large-size-dir-to-another-dev.html" rel="alternate" type="text/html" title="Linux上把大文件夹移动到其他存储设备上来释放空间" /><published>2022-09-10T00:00:00+08:00</published><updated>2022-09-10T00:00:00+08:00</updated><id>/os/mv-large-size-dir-to-another-dev</id><content type="html" xml:base="/os/mv-large-size-dir-to-another-dev.html"><![CDATA[<h2 id="问题背景">问题背景</h2>

<p>一个常见的问题是发现某个文件夹比如<code class="language-plaintext highlighter-rouge">/var</code>, <code class="language-plaintext highlighter-rouge">/opt</code> 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。</p>

<h2 id="约定">约定</h2>

<p>不妨假设根系统<code class="language-plaintext highlighter-rouge">/</code>挂载在磁盘分区<code class="language-plaintext highlighter-rouge">sda4</code>，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为<code class="language-plaintext highlighter-rouge">sdb</code>。</p>

<h2 id="思路1">思路1<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2>

<p>一个体面的思路是在<code class="language-plaintext highlighter-rouge">sdb</code>上创建一个分区，假设为<code class="language-plaintext highlighter-rouge">sdb1</code>，创建LargeDir的同级根目录LargeDir2，把<code class="language-plaintext highlighter-rouge">sdb1</code>挂载到LargeDir2，把LargeDir的内容复制到LargeDir2</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>LargeDir2
mount /dev/sdb1 LargeDir2
rsync <span class="nt">-a</span> LargeDir/ LargeDir2
</code></pre></div></div>

<p>在文件系统表单<code class="language-plaintext highlighter-rouge">/etc/fstab</code>里添加对应项,比如
<code class="language-plaintext highlighter-rouge">/dev/sdb1    LargeDir    ext4    defaults      2 2</code></p>

<p>重启后生效，但是这个思路是后一个文件系统隐藏了前一个文件系统的子目录，<strong>如何删除原文件系统的子目录内容呢？</strong></p>

<p>由于<strong>Linux允许同一文件系统有多个挂载点</strong>，所以只需要把<code class="language-plaintext highlighter-rouge">sda4</code>再次挂载到一个新的目录，然后就可以找到原LargeDir，然后删除。</p>

<h2 id="思路2">思路2<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2>

<p>重启进入单用户模式，安全移动内容，然后删除，然后重新命名回来</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://askubuntu.com/questions/39536/how-can-i-store-var-on-a-separate-partition <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://www.suse.com/support/kb/doc/?id=000018399 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[问题背景]]></summary></entry><entry><title type="html">kernel crash dump</title><link href="/os/kernel-crash-dump.html" rel="alternate" type="text/html" title="kernel crash dump" /><published>2022-09-01T00:00:00+08:00</published><updated>2022-09-01T00:00:00+08:00</updated><id>/os/kernel-crash-dump</id><content type="html" xml:base="/os/kernel-crash-dump.html"><![CDATA[<h2 id="ubuntu">Ubuntu</h2>

<p><a href="https://ubuntu.com/server/docs/kernel-crash-dump">install linux-crashdump</a></p>

<h2 id="dump-output">Dump Output</h2>

<p><code class="language-plaintext highlighter-rouge">alias crash="crash /usr/lib/debug/boot/vmlinux-$(uname -r)"</code></p>

<p><code class="language-plaintext highlighter-rouge">crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;</code></p>

<p>bt: backtrace
log: kernel log</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[Ubuntu]]></summary></entry><entry><title type="html">Compile Linux Kernel</title><link href="/os/compile-linux-kernel.html" rel="alternate" type="text/html" title="Compile Linux Kernel" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/os/compile-linux-kernel</id><content type="html" xml:base="/os/compile-linux-kernel.html"><![CDATA[<p>编译实践1：
学习Linux内核模块开发，需要增加一个<code class="language-plaintext highlighter-rouge">FORCE_UNLOADING</code> feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。</p>

<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"><strong>Linux上游源代码（git地址在其页面下方）</strong></a></p>

<p><strong>默认环境</strong>
当前目录： kernel源目录</p>

<h2 id="ubuntu">Ubuntu</h2>

<p>注意源文件的下载，不要在系统目录比如<code class="language-plaintext highlighter-rouge">/usr/src</code>下进行，而要在用户空间内进行，而<code class="language-plaintext highlighter-rouge">apt source</code>，<code class="language-plaintext highlighter-rouge">apt-get source</code>, 不需要也不能使用<code class="language-plaintext highlighter-rouge">sudo</code>, 会错误得造成源文件的用户组变为root。对于&gt;= 20.04,没有官方更新的wiki讲如何使用debian/rules，直接从linux上游源代码处获取。</p>

<p>= 18.04</p>

<p>参考<a href="https://askubuntu.com/questions/1085411/unable-to-follow-kernel-buildyourownkernel">这篇文章</a></p>

<p>= 19.04</p>

<p>参考<a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">官方wiki</a></p>

<p>= 20.04 (or maybe upper than it)</p>

<p>参考<a href="https://discourse.ubuntu.com/t/how-to-compile-kernel-in-ubuntu-20-04/20268/10">这篇文章</a></p>

<ol>
  <li>
    <p>下载源代码</p>
  </li>
  <li>
    <p>安装依赖<code class="language-plaintext highlighter-rouge">sudo apt install asciidoc autoconf bc binutils-dev bison build-essential crash dkms fakeroot flex gawk gcc kernel-wedge kexec-tools libelf-dev libiberty-dev libncurses5-dev libncurses-dev libssl-dev libudev-dev makedumpfile openssl pciutils-dev</code></p>

    <p>(<code class="language-plaintext highlighter-rouge">pciutils-dev</code> is replaced by <code class="language-plaintext highlighter-rouge">libpci-dev</code> in the later version)</p>
  </li>
  <li>
    <p>配置参考下面tips</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">make -jn deb-pkg</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cd .. &amp;&amp; sudo apt ./linux-*.deb</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sudo update-grub</code></p>
  </li>
</ol>

<p><strong>Tips:</strong></p>

<ol>
  <li>
    <p>Linux 68%的代码是驱动相关代码，当然大部分的编译时间也是在编译驱动上，而这一部分也是容易出问题，往往花了几个小时编译发现，后来发现在这里出了错误，这就很难受，需要提前仔细配置。个人经验是不使用 <code class="language-plaintext highlighter-rouge">/boot/config-`uname -r` </code> 作为初始配置，而是使用<code class="language-plaintext highlighter-rouge">make localmodconfig</code> 创建初始配置:<code class="language-plaintext highlighter-rouge">.config</code>文件，使用默认的配置，确保驱动的编译不出问题。然后使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>(shell text) or <code class="language-plaintext highlighter-rouge">make xconfig</code>(qt5 gui) 配置内核其他部分。</p>
  </li>
  <li>
    <p>make 使用<code class="language-plaintext highlighter-rouge">-j</code>启用多核编译很重要，如果宿主机器在编译的同时需要运行其他任务，建议少用一个核心，避免机器down掉(然后比如当前用户直接被强制logout)。</p>
  </li>
  <li>
    <p>如果make过程中因为什么原因中途停掉了，可以再次启动，但是第一次会报错: <code class="language-plaintext highlighter-rouge">"dpkg-source: unrepresentable changes to source"</code>, 只要把相关报错文件删除掉重新运行即可。</p>
  </li>
  <li>
    <blockquote>

      <p>= 20.04, 可能需要的额外依赖包:</p>
    </blockquote>
  </li>
</ol>

<p>dwarves # tmp_vmlinux.btf: pahole (pahole) is not available</p>

<h2 id="select-kernel">Select Kernel</h2>

<p>重启的时候按住<code class="language-plaintext highlighter-rouge">shift</code>进入grup界面，选择需要的版本内核启动。
修改默认启动内核，参考<a href="https://support.huaweicloud.com/intl/en-us/trouble-ecs/ecs_trouble_0327.html">华为云的这篇文章</a>和<a href="https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version/1393019#1393019">askubuntu的这个回答</a>
修改配置文件<code class="language-plaintext highlighter-rouge">/etc/default/grub</code>的 <code class="language-plaintext highlighter-rouge">GRUB_DEFAULT</code> 的值为启动项的序号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0，正常启动
1&gt;y， 高级启动项，y start from 0
</code></pre></div></div>

<p>查看高级启动项的序号(Ubuntu为例)：
<code class="language-plaintext highlighter-rouge">sudo grub-mkconfig | grep -iE "menuentry 'Ubuntu, with Linux" | awk '{print i++ " : "$1, $2, $3, $4, $5, $6, $7}'</code>
不要忘记最后运行<code class="language-plaintext highlighter-rouge">sudo update-grup</code>来更新配置。</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[编译实践1： 学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。]]></summary></entry></feed>