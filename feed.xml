<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-08-20T10:56:42+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">0053 - Maximum Subarray</title><link href="/algs/LeetCode0053.html" rel="alternate" type="text/html" title="0053 - Maximum Subarray" /><published>2023-08-18T00:00:00+08:00</published><updated>2023-08-18T00:00:00+08:00</updated><id>/algs/LeetCode0053</id><content type="html" xml:base="/algs/LeetCode0053.html"><![CDATA[<h2 id="前言">前言</h2>

<p>这篇的重点在于讲述从启发式算法到对 <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm">Kadane算法</a> 的独立再发现的过程。</p>

<h3 id="难度定位">难度定位</h3>

<p>对于 LeetCode 来说，本题的定位在 Medium 难度，只能说这是一个令人不满意的折中的结果。</p>

<p>首先这实在是一道太经典的题目，有很简单的解决方法，对于那些接触过它的人来说，只需要不到一分钟的时间就能写完，从这个角度上说，可以直接定位在 Easy 。</p>

<p>但对于那些并没有正式接触过的人来说，就题论题，从输入的数据规模来看，这道题的难度是非常高的，对于运行时语言来说，实际上只有 $O(n)$ 的解法能过，而且还必须是不太慢的 $O(n)$ 解法，而其他类似类型题目，通常 $O(n^2)$ 就能过，但从这一点，这就一定是 Hard 难度的题目。</p>

<p>总地来说，我们没有任何理由去假设用户的学习履历，而这道题本身就是一道 Hard 难度的题目，因此它定位就应该在 Hard 。</p>

<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.14/0053_max_subarr/py0053">源代码</a></p>

<p>求一个数组的最大值子序列。</p>

<p>首先可以想到<a href="/algs/SegmentTree.html">分段树</a>上有一个经典应用，就是计算最大子段和，这个时间复杂度是最优的，但一定不是最快的，在纯运行时语言里，这种复杂数据结构的表现都不会太好，因为本来可以忽略掉的无关操作都对时间有显著地影响。</p>

<p>何况这种方法写起来也不是很简单，因此先把这种方法放到最后，作为比较。</p>

<h2 id="解简单dptle">解⓪简单DP：TLE：</h2>

<p>最简单地记录两头索引的 DP，用前缀和数组 $O(1)$ 地计算区间和，时间复杂度为 $O(n^2)$ ，即使做了很多优化，比如压缩数组，排除负数（需要处理全是负数的情况），也仍然过不了关。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">accumulate</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">pref_sum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pref_sum</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">pref_sum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pref_sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>

<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">nums2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">nums2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nums2</span>
</code></pre></div></div>

<h2 id="解启发式算法">解①启发式算法：</h2>

<p>这一节是本篇的重点，讲述我个人如何一步步从一个直觉地和局部经验地算法设计出本质上就是 Kadane 算法的过程。</p>

<h3 id="1-观察">1. 观察：</h3>

<p>最大子段和如果都是正数，那么整个数组的和就是最大子段和，这个题目就没有意义了，一定是有负数才让问题具有复杂性，当然如果全都是负数那么问题也很简单，就是最大的那一个单个负数（或者说绝对值最小的那个负数），而更多地应该是正数和负数混合的情况（零总是可以被简单忽略掉）。</p>

<p>这样地话，排除全负数地情况后考虑，如果数组结尾的的数字是非正数，那么它可以直接被忽略掉；但如果结尾是正数，那就要看它后面可能存在的来自负数的减益与来自正数的增益哪一个更大。</p>

<p>为了考虑方便和编写代码，可以就像前面算法一样对数组进行压缩：<code class="language-plaintext highlighter-rouge">compress</code>，合并临近的正值和非正值，这样总是可以得到一个正负相间的数组。</p>

<p>在这个基础上考虑什么时候能够保留结尾的正数呢？就是正数邻接的负数的绝对值小于这个正数，这样正负加起来一定对最大和有增益。反之，如果正负加起来小于等于零，那么显然这一段儿就可以被扔掉，因为没有任何增益。</p>

<h3 id="2-问题">2. 问题：</h3>

<p>那么如果一个正负组之后还有一个正负组该怎么样呢：</p>

<ol>
  <li>如果那个正负组仍然是非负收益，那么仍然可以保留；</li>
  <li>可是如果是负收益，又该如何判断是否该保留呢？</li>
</ol>

<p>试着考虑在数组的另一端也如此处理来压缩问题规模，但是这样仍然会遇到一个正收益的正负组后面的一个负收益的正负组问题。</p>

<h3 id="3-解决方法">3. 解决方法：</h3>

<p>看来不得不正面考虑正收益的正负组后面的出现负收益的正负组的问题，考虑直接合并我们遇到的正负组，就像我们压缩数组一样，如果是正收益就保留，如果是非负收益就抛弃，这样好像问题就解决了！</p>

<h3 id="4-观察">4. 观察：</h3>

<p>这样如果从两边开始一层层剥掉两头的正负组，是不是问题就能在 $O(n)$ 的时间内解决？！我们现在好像已经从对问题局部的优化开始，窥得了最优解的思路。我自己就把这个思路称为“洋葱变换”（Onion Transform）</p>

<p>像这样剥下去，最后应该得到：</p>

<ol>
  <li>一个“去核”洋葱，也就是剥到最后，发现里面什么都没有；</li>
  <li>或者带芯儿洋葱，最后剩下一个孤正数，因为前面都是正负组，而整个压缩后的数组是正负相间的。</li>
</ol>

<p>这样好像只要计算最后剩下的皮加上可能存在的芯的值，就能得到整个数组的最大子序列和。</p>

<h3 id="5-问题">5. 问题：</h3>

<p>但是，两头剥洋葱实际还有第三种情况，就是这根本是个“假洋葱”（Fake Onion），剥到最后发现里面剩一个负数，这应该是不存在的情况，但就是发生了，因为两头的正负组存在重叠，这样我们就不能正确计算了。</p>

<h3 id="6-解决方法">6. 解决方法：</h3>

<p>由于存在负芯儿的“假洋葱”，不能从两头剥，考虑直接从一头剥，这样肯定就不会出现正负组重叠的情况。</p>

<h3 id="7-观察">7. 观察：</h3>

<p>但这样好像就得到了一个未曾设想的局面：一段段儿由负数隔开的正值的最大子序列，也就是说在压缩正负组的过程就可以计算得到最大子序和。</p>

<p>至此为止我们得到了一个可运行的算法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">max_unit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># get max unit
</span>
    <span class="c1"># Onion Transform
</span>
    <span class="n">max_seq</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">layer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layer</span>

            <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_unit</span><span class="p">,</span> <span class="n">max_seq</span><span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：622 ms (beats 74.97%)，内存占用：30.42 MB (beats 83.1%) 。</p>

<p>（后来发现这个运行时间已经相当好了）</p>

<h3 id="8-思路推广">8. 思路推广：</h3>

<p>这个算法应该有更简洁、更一般化地表示，不需要数组压缩、也不必考虑正负组，只要能带来非负收益，就可以进行压缩。</p>

<h3 id="9-思路推广">9. 思路推广：</h3>

<p>使用一个追踪边的累积变量 <code class="language-plaintext highlighter-rouge">acc</code>，用它来代替对输入的边缘点的修改，同时也不需要直接检测收益是否为负，先计算加和，取它与新的边缘点的最大值。</p>

<p>这样可以得到一个非常简洁地形式：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>总是使用前一个计算的值作为状态，也就是 <code class="language-plaintext highlighter-rouge">x</code> ，<code class="language-plaintext highlighter-rouge">y</code> 是当前的边缘点</p>

<p>这个版本并不是我写的，因为它使用 <code class="language-plaintext highlighter-rouge">itertools</code> 里面的工具虽然让代码看起来很简单，但根据以往经验，我就知道这个性能表现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>并不怎么样，实际果然如此：</p>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：592 ms (beats 87.39%)，内存占用：30.56 MB (beats 51.70%) 。</p>

<p>运行时间相比前一个朴素版本不仅提升有限，内存占用甚至还更多了！足可见 <code class="language-plaintext highlighter-rouge">itertools</code> 有非常大的优化空间。</p>

<p>更适合当前版本的应该是：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">acc</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：537 ms (beats 99.80%)，内存占用：26.77 MB (beats 99.95%) 。</p>

<p>核心有三点：</p>

<ol>
  <li>普通循环替代 <code class="language-plaintext highlighter-rouge">itertools</code></li>
  <li>普通条件判断替代 <code class="language-plaintext highlighter-rouge">max</code></li>
  <li>预先计算一个变量也有有意义地性能提升</li>
</ol>

<p>实在是有些无语<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="与kadane算法">与Kadane算法：</h3>

<p>到了这一步，这可以发现，这就是 Kadane 算法做的事，我们只是独立地重新发明了它<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup></p>

<h3 id="与其他思路">与其他思路：</h3>

<p>这个最终的解决方法还可以通过 DP 或者说其他地算法思想推导得到，但总是实质一样，我并不考虑这里一定要使用什么思想来解决，就是一步步地想，如果最终要对它总结，我更愿意把它归类为在时间上进行 DP 的算法。</p>

<h2 id="解分段树">解②分段树：</h2>

<p>经典地一个分段树应用的题目，因为求得是整个数组的最大子序列和，因此只需要写建树的代码即可，返回根节点的值即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">min_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="s">""" DFS型 """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_build</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" pref  0 # max prefix sum
        suff  1 # max suffix sum
        sum   2 # all sum
        ans   3 # max range sum
    """</span>

    <span class="k">if</span> <span class="n">tl</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span><span class="o">+</span><span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sub_lf</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="n">tl</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i_lf</span><span class="o">+</span><span class="n">sub_lf</span>

    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">)</span>

    <span class="n">data_lf</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">]</span>
    <span class="n">data_rh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">]</span>

    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：1067 ms (beats 5.02%)，内存占用：53.78 MB (beats 6.15%) 。</p>

<p>同样没有使用 Python 的类，而是元组，来保存每个点的 4 个基本信息，因为类实在是太慢啦！</p>

<h3 id="与其他思想">与其他思想</h3>

<p>如果不从分段树地角度看，也可以直接使用分治地思想做类似地操作，但是也依赖递归，区别是我们把递归需要保存的堆栈信息显式地存储到了起来。</p>

<h2 id="注解">注解</h2>

<p>###</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>至少是当前的 Python 3.10 版本 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>我认为从根本上讲，是原作者的观念保守，为了维持 Python 的纯解释性，从而放弃了很多更进一步地优化，并且也没有引进 JIT 的机制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>可能区别是原始的 Kadane 算法面对的问题是只返回非负值，如果全都是负数就返回 $0$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">1340 - Jump Games V</title><link href="/oth/LeetCode1340.html" rel="alternate" type="text/html" title="1340 - Jump Games V" /><published>2023-08-10T00:00:00+08:00</published><updated>2023-08-10T00:00:00+08:00</updated><id>/oth/LeetCode1340</id><content type="html" xml:base="/oth/LeetCode1340.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/jump-game-v/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.12/1340_jump_games_5/py1340">源代码</a></p>

<p>这个题的描述非常别扭，啰嗦还不得要领，配得示例图也抓不到展示的重点，让人很难进入这个题目，单就这个题目文本的编写我就要给出差评！</p>

<p>简而言之，还是跳一个范围 $d$，双向都可以，但是只能从高跳到低，包括中途经过的位置也要比起点低。</p>

<h3 id="数据限制">数据限制：</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= arr.length &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= arr[i] &lt;= 105</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= d &lt;= arr.length</code></li>
</ul>

<h2 id="解原始解">解①原始解：</h2>

<p>开始观察数据的特点，发现 $d$  的大小是整个给定数组 $\text{arr}$ 同级别的，而 $\text{arr}$ 的规模非常小，只有 $10^3$ ，这暗示了 $O(n^2)$ 的解决方法可能不是最优解，但应该足以通过。</p>

<p>在思考这个题的时候，由于没见过这个跳的方法，题目说明得又很蹩脚，头脑混沌不清，充斥着各种可能地思路，又看见了本题有一个排序的标签，觉得排序很可能在最优解里有扮演关键角色，于是构思出了一个相当蹩脚的原始实现，后来证明了大概是能通过的最慢解了。</p>

<p>思路如下：</p>

<ol>
  <li>先暴力找到每个位置左右能跳的范围，可以分别用 $\text{forward}$ 和 $\text{backward}$ 两个数组进行保存，花费 $O(d\cdot n)$；</li>
  <li>对 $\text{arr}$ 进行排序，花费 $O(n\text{log}n)$ ；</li>
  <li>对排序后的 $\text{arr}$ 进行遍历，因为只能从高到地跳，因此每个位置 $i$ 的下一跳的位置一定在它的前面，于是暴力地检查前面的每个位置，如果它的原始位置是能够一步跳到的，就进行比较，更新 $i$ 处索引最大能跳到的位置，花费 $O(n^2)$</li>
</ol>

<p>总的时间复杂度 $O(n^2)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">forward</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">backward</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">forward</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：4348 ms (beats 5.24%)， 内存占用：16.66 MB (90.32%)</p>

<h2 id="解记忆化">解②记忆化：</h2>

<p>这个解是官方给出的，也是最常见的正解：</p>

<p>就是直接在原序列上计算，同样地暴力查找 $d$ 范围内符合条件的下一步位置，保存每个位置的计算结果，像这样时间复杂度也只有 $O(d\cdot n)$ ，比我们之前的方法 $O(n^2)$ 的复杂度要好，即使明明我们的思路看起来要聪明一些。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>这个思路能够成立是因为我们总是从高跳到低，不存在回路。</p>

<p>如果按照 DFS 的顺序计算，非常适合用递归地形式简单解决，配合上 Python 的函数式工具 <code class="language-plaintext highlighter-rouge">cache</code> 缓存所有同参数的调用，代码非常简洁：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">takewhile</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                      <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                      <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">subs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>  <span class="c1"># n &gt;= 1
</span></code></pre></div></div>

<p>运行时间：351 ms (beats 88.49%) ，内存占用：20.99 MB (beats 17.46%)</p>

<h3 id="概念解剖">概念解剖</h3>

<p>这里提到了“记忆化搜索”的概念，它是一个单独的分类，但从实质上讲也可以认为是 DP 的一类特定情况，这里就不特别区分二者了。</p>

<h3 id="语言责难">语言责难</h3>

<p>在我们当前的环境，Python 3.10 ，如果不使用 <code class="language-plaintext highlighter-rouge">cache</code> 而是手动保存结果的话，如下所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>

        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">subs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</code></pre></div></div>

<p>内存占用不出所料地降低到了：19.17 MB (beats 54.37%) ，但是运行时间也提高到了： 421 ms  (beats 80.95%) ，性能损失达到了 20% ，换言之，使用 <code class="language-plaintext highlighter-rouge">cache</code> 虽然增加了内存占用，但相比手动缓存，性能有明显提升。</p>

<p>如果说 <code class="language-plaintext highlighter-rouge">cache</code> 作为 <code class="language-plaintext highlighter-rouge">functools</code> 这个函数式编程辅助模块的一个代表<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，表现还是不错的，那另一个函数式编程的辅助模块 <code class="language-plaintext highlighter-rouge">itertools</code> 的表现就有些拉胯了：这些迭代器上的函数的性能可观察地不如普通地 <code class="language-plaintext highlighter-rouge">for</code> 循环。</p>

<p>比如把上面的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
    <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
    <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>替换成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">subs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">subs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>就有有 10% 级别的性能提升，这在像 Rust 这样的语言里是难以想象的！</p>

<h2 id="解排序反向构建">解③排序+反向构建：</h2>

<p>继续考虑上面的记忆化方法，DFS 的搜索顺序配合递归地实现只是说是一种实现方案，它很简洁很容易写，因此通常我们默认采用这种方法，但实际上当然也可以采用 BFS 的顺序以及迭代地实现，区别只是：</p>

<p>DFS 的迭代版本需要手动保存每一级的迭代器状态，而 BFS 需要保存某一级的所有孩子（当然还有该级的级数，也就是之前已经跳了多少步），不管怎样，实际问题地解决总是要到没有后代的节点，才能解决。</p>

<p>如果一个节点本身就是最小的高度，那么它一定没有子节点，或者周围 $d$ 范围内都是不低于它的节点，或者倒过来想，如果知道了所有高度严格小于某个节点的的节点信息（最大访问数、前向范围和后向范围），那么该节点的信息也可以利用这些信息<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>来直接得到：</p>

<ol>
  <li>
    <p>最大访问数是前一级节点的最大访问数加一，然后取它们的最大值；</p>
  </li>
  <li>
    <p>前一级节点的前向（顺扫描的方向）或后向（逆扫描的方向）范围，以后向为例，先选取后向的第一个元素，只要它小于当前元素，那么在不超过 $d$ 的范围，就可以直接把它的后向距离加入到当前位置的后向距离，然后从那个距离处继续向后扫描，直到超出 $d$ 的范围或者发现不小于当前元素的元素</p>
  </li>
</ol>

<p>有必要特别说明下这个前向或后向的范围，缓存这个值，可以减少位置值的比较次数<sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，虽然在求解最大访问数的时候复杂度仍然是 $O(d\cdot n)$ ，但实际证明这个做法让性能提高了 40% 以上。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">ans_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">forward_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># d &gt;= 1
</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">forward_cache</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">forward_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span><span class="o">-</span><span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="n">backward_cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">backward_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans_cache</span><span class="p">)</span>
</code></pre></div></div>

<p>这个方法本质上是记忆化方法的改进，省去了堆栈的开销，时间复杂度是 Better $O(d\cdot n)$ 。</p>

<p>运行时间：199 ms (beats 88.3%)，内存占用：16.9 MB (beats 73.24%)</p>

<p>实际结果看相当好了，与最优解相差不大了。</p>

<h2 id="解贪心记忆化">解➃贪心+记忆化：</h2>

<p>贪心思想地应用是时间复杂度最终能降低到 $O(n)$ 的关键<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>。</p>

<p>如之前 Jump Games 所示，$d$ 既然是连续的，就有贪心算法应用的空间，只不过还有一个限制条件，高度也要更低。</p>

<p>从反方向来考虑那些最长访问次数的位置序列，每个位置 $i$ 的前一个位置一定是距离它最近的更高的位置（当然左右方向分别考虑），否则如果不是最近的高度，要么从这个高度要么跳不到 $i$ ，因为中间还有不低于这个高度的位置，要么可以先跳到中间的一个高度的位置，然后跳到 $i$ ，总之都不是 $i$ 的直接前驱。</p>

<p>于是可以在 $O(n)$ 的时间复杂内找到每个位置的可能的直接前驱（分前向后向两个方向），然后可以在另一个 $O(n)$ 的复杂度内带记忆化地遍历每个位置，通过它的最多两个前驱，计算该位置的最大访问数，最后取最大值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">forward</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="nb">range</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">storage</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">storage</span><span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">build</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">forward</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">backward</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">backtrace</span><span class="p">(</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">backtrace</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：152 ms (beats 98.41%)，内存占用：19.52 MB （beats 42.46%）</p>

<h2 id="解贪心单调栈双指针dp">解➄贪心+单调栈+双指针+DP：</h2>

<p>前面的 $O(n)$ 复杂度的实现已经够好了，但是还有同复杂度但是更快的方法。</p>

<p>这个方法是从最快的样本代码里扒出来的，这个实现不仅融汇贯通了这些算法思想，而且代码细节上也是 Python 最优，几乎让人无法增删一笔，实在是优秀。</p>

<p>它区别于前一个方法的地方在于它把计算<strong>两个方向上的最近更高位置</strong>和<strong>求解最大访问次数</strong>能够放在一趟遍历过程中同时解决！</p>

<p>它的方法是这样：</p>

<ol>
  <li>使用单调栈至少可以计算后向的最近更高位置，而利用出栈的元素，又可以更新栈里前向的最近更高位置；</li>
  <li>实际上不需要维护最近更高位置，可以直接更新某个位置的最大访问次数</li>
</ol>

<p>具体过程：</p>

<p>扫描输入数组 $\text{arr}$ ，只要栈顶元素小于当前元素，就出栈；同时每次出栈时都把连带着所有与栈顶相等元素一同出栈，除了用栈顶元素从后向更新当前位置的最大访问数，还要利用所有连同出栈的相等的元素来前向更新新的栈顶元素的最大访问数（由于是单调不减栈，而且与旧栈顶相等的元素都出栈了，所以新栈顶一定严格大于出栈的所有元素）。</p>

<p>这样有一个问题，当扫描完成时，栈里的元素不一定都全部出栈了，因为最后一个元素不一定是最大的元素，这时要像前面一样，继续弹出栈顶元素，来前向地更新栈里后面的元素。</p>

<p>单独再加一段儿处理代码会很啰嗦，更合适地方法是在原数组尾部插入一个确定一定比所有元素都大的值，只是在求最大访问次数时排除尾部就行了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">max_int</span> <span class="o">=</span> <span class="mi">100_000</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_int</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">isoheight</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span>

            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">isoheight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="n">isoheight</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">isoheight</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">j</span><span class="o">-</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<p>时间复杂度 Better $O(n)$</p>

<p>运行时间：120 ms (beats 100%)，内存占用：16.6 MB (beats 96.6%)</p>

<p>这段代码不仅从算法方法上，而且从代码编写上，实在已经是 Python 下面最快地写法了，任何比如拆分两个更新，使用迭代器都比这个实现更慢。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这实在暗示了其实思路还是没有走通，有很大的优化空间 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>可能所有 DP 相关算法的 Python 实现都会用到它 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>可以证明它的摊销最坏时间复杂度是 $O(1)$，想象每一级增加一个扫描位置，邻接位置的后一级就可以减少一个扫描位置，而且最终不超过 $n$ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:3:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>本解直接来源于 LeetCode 用户 <em>gd303</em> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Jump Games</title><link href="/oth/LeetCodeJumpGames.html" rel="alternate" type="text/html" title="LeetCode Jump Games" /><published>2023-08-02T00:00:00+08:00</published><updated>2023-08-02T00:00:00+08:00</updated><id>/oth/LeetCodeJumpGames</id><content type="html" xml:base="/oth/LeetCodeJumpGames.html"><![CDATA[<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.13/1871_">源代码</a></p>

<h2 id="44-jump-games-ii">44 Jump Games II</h2>

<p><em>虽然名字上第二个，但题目编号反而要比1要早</em></p>

<p><a href="https://leetcode.com/problems/jump-game-ii/description/">问题描述</a></p>

<p>求跳到尾部的最小步数<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<h3 id="解dp">解①DP</h3>

<p>这个题目本身带有 DP 的标签，首先也就想到了简单的 DP 思路：记录跳到每个位置所需要的最小步数，从左到右扫描，每到一个位置，就用当前步数加一来更新该位置下一步所能到达的那一些位置。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>这个算法的时间复杂度在官解和很多题解里直接标了 $O(n^2)$ ，但这是不准确的，因为根据题目标明的数据范围 <code class="language-plaintext highlighter-rouge">nums[i]</code> 的最大值与 <code class="language-plaintext highlighter-rouge">len(nums)</code> 的最大值不同，前者要小一个数量级，实际上是 1000 ，很多情况这可能只是一个稍微大一点的常数。</p>

<p>实际运行 3862 ms  (beats 25.91%)</p>

<p>说差也差，说不差，还有 10000+ ms 通过的朋友。</p>

<h3 id="解greedy">解②Greedy：</h3>

<p>做多了 DP 的题目，再想 Greedy 思路反而变得不太直观，所谓看山不是山。</p>

<p><strong>算法推论：</strong></p>

<p>探测每个位置下一步能够跳到的所有位置，比较它们下一步能够跳到的最远的位置，最远的那一个就是下一步要跳到的地方，这样直到可以等于或者超过终点。</p>

<p><strong>贪心的归纳法证明：</strong></p>

<p>定义：把用最小步数跳到终点的一个跳法儿称作一个<em>最短序列</em>。</p>

<p>只需要证明，这个算法的跳的每一个位置都在同一个<em>最短序列</em>里：</p>

<ol>
  <li>
    <p>初始时刻，起始位置显然一定在<em>最短序列</em>里</p>
  </li>
  <li>
    <p>假如上一个位置 $i_0$ 在最短序列里，那么从该位置出发，比较所有下一步可以跳到的位置，假如下一步跳最远的位置是 $j$ ，而存在另一个位置 $j_1\neq j$ 是这个最短序列里的下一步:</p>

    <p>定义通过 $j_1$ 的最短序列上的下一个位置为 $j_1’$ ，则：</p>

    <p>2.1. 如果 $j_1’ \geqslant j$ ，那是不是说明通过 $j_1$ 能够跳到的位置，通过 $j$ 也能跳到</p>

    <p>2.2. 如果 $j_1’ \lt j$ ，则有 $i \lt j_1 \lt j_1’$ ，那为什么不直接一步从 $i_0$ 跳到 $j_1’$ ，而是要花两步跳？ 这又和最短序列矛盾了</p>
  </li>
</ol>

<p>证毕。</p>

<p><strong>贪心成立关键在于：</strong></p>

<ol>
  <li>跳的步数是一个连续地范围</li>
  <li>跳的步数是非负值</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prev i
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">])],</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">step</span>
</code></pre></div></div>

<p>扫描了多长的候选位置，就至少跳过多少候选位置，时间复杂度为 $O(n)$ 。</p>

<p>运行时间：120 ms (beats 96.35%)，绝对地最优解。</p>

<h2 id="55-jump-games-i">55 Jump Games I</h2>

<p><em>虽然名字上第一个，但题目编号反而要比2要晚</em></p>

<p><a href="https://leetcode.com/problems/jump-game/description/">问题描述</a></p>

<h3 id="解greedy-1">解①Greedy-1：</h3>

<p>这个问题和上面 Games II 的题干看起来非常像，可以用一模一样的方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i0</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">i0</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">i0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">])),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>但是数据的规模发生了变化，<code class="language-plaintext highlighter-rouge">nums[i]</code> 的最大值反而要比 <code class="language-plaintext highlighter-rouge">len(nums)</code> 的最大值大一个数量级，时间复杂度应该类似于上面 Games II 的 DP 解法。</p>

<p>实际运行时间：6041 ms (beats 8.5%)</p>

<h3 id="解-greedy-2">解② Greedy-2：</h3>

<p>由于本题 <code class="language-plaintext highlighter-rouge">len(nums)</code> 比 <code class="language-plaintext highlighter-rouge">nums[i]</code> 有较小的数据规模，何况追求得最小步数而是最大可达位置，最好是可以只扫描 <code class="language-plaintext highlighter-rouge">nums</code> 数组。</p>

<p>可以这样考虑：如果终点是不可达的，那么在 <code class="language-plaintext highlighter-rouge">nums</code> 上一定存在一个真正的终点位置，如果能够找到这个终点位置，就可以进行判断了。</p>

<p>可是终点是什么样的呢？</p>

<p>首先终点的步长应该是零，否则从它就可以跳到更右边的位置，而它也就不是终点了。</p>

<p>其次，任何终点左边的位置一步之内都最多跳到终点。</p>

<p>如果从 <code class="language-plaintext highlighter-rouge">nums</code> 的尾部开始向左扫描，如果一个位置可以一步到达尾部，那么就可以把尾部设置到该位置，如果在结束的时候尾部没有归为零，终点就是尾部前一个位置。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">lf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lf</span><span class="p">:</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">lf</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>运行时间：394 ms (beats 98.95%)</p>

<p>也可以从正面开始扫描，寻找终点，但除了让代码更复杂一点没有任何好处。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">to</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">to</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>运行时间：428 ms (beats 96.53%)</p>

<h2 id="1306-jump-games-iii">1306 Jump Games III</h2>

<p><a href="(https://leetcode.com/problems/jump-game-iii/)">问题描述</a></p>

<p>从给定位置开始跳，每次有左右两个方向，不是跳一个范围，而是一个固定地步长。</p>

<p>谈不到什么算法的简单题目。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">""" false: unvisited, true: visited """</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>运行时间：249 ms (beats 98.79%)，内存占用： 23.6 MB (beats 47.8%， ~ 100%)</p>

<p>题目很简单，但是有两点细节很值得一提：</p>

<ol>
  <li>这个题目内存占用最低地情况就是 23 MB ，如果不创建新的结构，而是直接在 <code class="language-plaintext highlighter-rouge">arr</code> 上就地修改<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，几乎不会节约任何内存占用，只少了大概 0.3 MB ，不知道造成这个原因的技术细节是什么，可能只是 Python 的内存分配器一次性地申请了很大的内存<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>；</li>
  <li>而更令人意想不到地是这个题目的解的内存占用可以达到 80 MB！粗略地看了一下，它们全都是使用了基于哈希表的数据结构（<code class="language-plaintext highlighter-rouge">set</code>，<code class="language-plaintext highlighter-rouge">map</code>，<code class="language-plaintext highlighter-rouge">default_dict</code>，etc.）而不是数组来标记访问，一方面它们的访问速度相较于列表并没有明显地更慢，另一方面它们占用了有点儿意料之外地更多的内存。</li>
</ol>

<p>对于第一点，CPython 显然不如 JVM 那样有很详细或者冗繁地参数控制，更不如编译型语言对内存使用那样地节约，这没什么好说的。</p>

<p>对于第二点，必须申明地是，必须实际地考虑哈希表的实现，由于负载因子（fill factor）的存在<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>，至少内部的空间容量就是原数组的倍数，再考虑存储碰撞元素的列表甚至树形结构指针的开销，实际地哈希表占据的空间如果有个数组的两倍也毫不奇怪（但是像 Python 这样确实有些夸张，内存开销大概是普通列表的 1000 倍的级别，只能说完全地对象语言是这样的）。</p>

<p><strong>因此一个很重要地原则是，如果是追踪一个已知列表的每个元素状态，直接使用列表无论时间还是空间性能都要优于使用哈希表。</strong></p>

<h2 id="1345-jump-game-iv">1345. Jump Game IV</h2>

<p><a href="https://leetcode.com/problems/jump-game-iv/description/">问题描述</a></p>

<p>固定跳点，每个点可以跳到三类地方，+1/-1/同值点，求从头跳到尾的最小步数。</p>

<p>非常类似于 Games III ，前者被标定为 Medium 难度，现在只不过又缝了一个哈希表的使用，难度就被定位到 Hard 级了。<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup><sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>运用哈希表统计同值点，用 BFS 求取最小步数，需要注意得是哈希表上的元素在被访问过后必须弹出，否则时间复杂度会劣化到 $O(n^2)$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">val</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">nxt_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">step</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">val</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">pop</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">step</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">nxt_queue</span>

    <span class="k">return</span> <span class="n">step</span>
</code></pre></div></div>

<p>运行时间：549 ms (beats 98.59%)，内存占用：29.6 MB （beats 94.3%）</p>

<p>关于使用什么样的算法和数据结构来对同值位置进行统计，可以继续 Games  III 的讨论，当一般地值域比元素数大一个数量级，就是一定要使用哈希表的情况。</p>

<h2 id="1340-jump-game-v">1340. Jump Game V</h2>

<p>有单独一篇博文来讨论： <a href="/oth/LeetCode1340.html">LeetCode1340</a></p>

<h2 id="1696-jump-game-vi">1696. Jump Game VI</h2>

<p><a href="https://leetcode.com/problems/jump-game-vi/description/">问题描述</a></p>

<p>乍看起来很简单，但是做起来令人有些不快，因为它作为中等难度的题，但寻找 $O(n)$ 的解决方案并不如我预计得那样容易。</p>

<p>题目求解最大的跳的位置和，也是跳一个连续范围，看起来就是利用贪心地思想寻找一个简单方法就 OK 了，但是没有这样的方法，想了很长时间，就是发现在所有位置的值中，如果是正的，一定在序列里，但如果是负的，就存在一个更少的步数但更大（绝对值）的负值与更多的步数而更小的负值，这就不适合贪心算法了。</p>

<h3 id="解分治dp">解①分治+DP：</h3>

<p>只能一步一步考虑，从索引 $0$ 的位置，第一步跳到的位置，有 $k$ 个，可以线性地计算出它们的最大值，包括这个长度为 $k$ 数组的后缀最大值，那么对于下一个 $k$ 长度的区间，它们每个位置的最大访问和就可以通过前 $k$ 个的后缀最大值和当前 $k$ 个的前缀最大值计算得出，这样一直到计算出了到最后一个位置的最大访问和，整个时间复杂度都是线性的。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">prev_postfix_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">cur_prefix_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>

    <span class="n">blk_rem</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">k</span>
    <span class="n">max_blks</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">blk_rem</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">k</span><span class="p">]):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">acc</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">+=</span> <span class="n">v</span>

    <span class="k">for</span> <span class="n">blk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_blks</span><span class="p">):</span>
        <span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">cur_prefix_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_postfix_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">blk</span><span class="o">*</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">blk</span> <span class="o">==</span> <span class="n">max_blks</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">blk_rem</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">blk_rem</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">blk</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>
            <span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">init</span> <span class="o">+</span> <span class="n">cache</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="n">blk_rem</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">]</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：826 ms (beats 80.95%)，内存占用：30.50 MB (beats 52.38%)</p>

<h3 id="解双头单调栈dp">解②双头单调栈+DP：</h3>

<p>本方法是上面方法的规整解，可以使用优先级队列维护之前最大的统计和的位置，当堆顶的元素过期（即与当前位置差距超过 $k$ ）就弹出，不过这样每次弹出栈顶元素需要的时间复杂度就是 $O(\text{log}n)$ ，总共的时间复杂度 $O(n\text{log}n)$ 。</p>

<p>可以用双头的单调栈，从头到尾严格减的顺序，每次检查栈头最大值，如果“过期”就弹出（$i$ 最多增加一次，因此只需要检测一次），用栈顶的访问最大值和当前值加和计算出当前位置的访问最大值，把栈尾所有不超过当前访问最大值的索引位置弹出，然后把当前索引位置插入尾部。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">while</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：773 ms (beats 97.14%)，内存占用：30.53 MB (beats 52.38%)</p>

<h2 id="1871-jump-game-vii">1871 Jump Game VII</h2>

<p><a href="https://leetcode.com/problems/jump-game-vii/description/">问题描述</a></p>

<p><em>首先吐槽下这个题的测试用例很不健全，导致有些 $O(n^2)$ 复杂度的算法甚至比 $O(n)$ 的算法都快</em> 。</p>

<p>这个题目是单向跳，跳的步长是一个固定的范围： <code class="language-plaintext highlighter-rouge">[minJump, maxJump]</code> ，而且只能跳到值为 <code class="language-plaintext highlighter-rouge">‘0’</code> 的位置，从头开始跳，看能否跳到最后一个。</p>

<p>又是一个跳的这个范围不是从 $1$ 开始，但仍然是连续的，这就启发我们仍然可能找到一个基于贪心地思想的 $O(n)$ 的解决方案。</p>

<p>把值为 <code class="language-plaintext highlighter-rouge">‘0’</code> 的位置称为可跳位置，事实上，这个题目破题的关键是向前查找可跳位置是否可以跳到。</p>

<h3 id="解贪心序">解🄋贪心：序</h3>

<p>可以用一个列表保存所有可跳到的位置，然后使用最多两次二分搜索就可以判断出 <code class="language-plaintext highlighter-rouge">[minJump, maxJump]</code> 范围内是否有可跳到的位置跳到当前位置：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span> <span class="o">&lt;=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">r</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">continue</span>

    <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>时间复杂度是 $O(n\text{log}n)$</p>

<p>运行时间：439 ms (beats 36.99%)，内存占用：21.1 MB (beats 25.62%)</p>

<h3 id="解贪心双头栈">解①贪心：双头栈</h3>

<p>如果能悟出了贪心算法，那么马上就能想到前面 Jump Game VI 里面使用过的双头单调栈，只不过这里更简单，序号本来就是自然增长的，不需要特别维护单调性，弹出头部所有小于 <code class="language-plaintext highlighter-rouge">i-maxJump</code> 的索引。</p>

<p>因为之后永远都不会检查到这些位置了，然后检查新的栈头是否大于等于 <code class="language-plaintext highlighter-rouge">i-minJump</code> ，成立的话就说明存在前面一个可跳到的位置能够跳到当前位置，这就把当前位置索引插入到尾部，当然如果所有栈已经空了，就提前返回失败，因为已经没有任何可跳到的位置能继续向前跳了。</p>

<p>最后检查栈的尾是否有最后一个索引编号。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：201 ms (beats 96.49%)，内存占用：20.50 MB (beats 48.76%)</p>

<h3 id="解贪心其他">解②贪心：其他</h3>

<p>这里介绍本质相同地另外几个 $O(n)$ 的算法：</p>

<h4 id="dp--滑动窗口">DP + 滑动窗口</h4>

<p>利用一个数组 <code class="language-plaintext highlighter-rouge">dp</code> 记录扫描过的位置是否可跳达，使用一个变量 <code class="language-plaintext highlighter-rouge">cnt</code> 来追踪当前位置$i$ 的 <code class="language-plaintext highlighter-rouge">[i-maxJump, i-minJump]</code> 范围里可跳达位置的数量，到时候检查这个变量是否为零，就可以判断当前可跳位置是否可以跳到。</p>

<p>维护 <code class="language-plaintext highlighter-rouge">cnt</code>：</p>

<ol>
  <li>当 <code class="language-plaintext highlighter-rouge">dp[i-minJump]</code> 是 <code class="language-plaintext highlighter-rouge">true</code> 时，说明随着窗口滑动新进来了一个可跳到的位置，<code class="language-plaintext highlighter-rouge">cnt</code> 就加一；</li>
  <li>当 <code class="language-plaintext highlighter-rouge">dp[i-maxJump-1]</code> 是 <code class="language-plaintext highlighter-rouge">false</code> 时，说明随着窗口滑动，原本尾部的可跳到的位置出去了，<code class="language-plaintext highlighter-rouge">cnt</code> 就减一</li>
</ol>

<p>基本代码和下面方法一样，这里就不赘写了。</p>

<h4 id="前缀和">前缀和</h4>

<p>这个是官解，只不过用了一个记录可跳到位置的数量和的前缀数组 <code class="language-plaintext highlighter-rouge">prefix</code> 代替 <code class="language-plaintext highlighter-rouge">dp</code>，用前缀和之差代替对 <code class="language-plaintext highlighter-rouge">cnt</code> 的追踪。</p>

<p>这个有点儿意思得地方是，它用了 <code class="language-plaintext highlighter-rouge">prefix[i-minJump] - prefix[i-maxJump-1]</code> 来计算 <code class="language-plaintext highlighter-rouge">[i-maxJump, i-minJump]</code> 范围内可跳到位置的数量，让人想起了树状数组也采用同样的方法来计算区间值。</p>

<p>有一点让人不爽地是，必须单独处理 <code class="language-plaintext highlighter-rouge">[0, maxJump+1]</code> 部分的内容来初始化前缀树组。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'0'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">maxJump</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">it</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">minJump</span><span class="p">,</span> <span class="n">maxJump</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span> <span class="ow">and</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>算法复杂度 $O(n)$ 。</p>

<p>运行时间：173 ms (beats 97.52%)，内存占用：21.07 MB (beats 25.62)</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>题目确保一定会跳到结尾 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>比如取负值表示访问过的状态 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>黑箱测试结果比较支持这个看法 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>为了避免在内部数组接近填满时哈希性能地急速下降 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>可能是知识体系的不同，这些前面的 LeetCode 的题目难度普遍不高，这和我最初做图上的问题以及扫描线的问题的难度感完全不是一个等级的 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>在做了一些题后，我对 LeetCode 出题思路也有了一些把握，Medium 难度题目只涉及单一知识点，而 Hard 难度题目就是两个独立的知识点缝在一起，一般还是一大一小 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[源代码]]></summary></entry><entry><title type="html">Why Greedy？</title><link href="/algs/Greedy.html" rel="alternate" type="text/html" title="Why Greedy？" /><published>2023-08-01T00:00:00+08:00</published><updated>2023-08-01T00:00:00+08:00</updated><id>/algs/Greedy</id><content type="html" xml:base="/algs/Greedy.html"><![CDATA[<h2 id="前言">前言</h2>

<p>“贪心”的这个概念根本就有问题：</p>

<ol>
  <li>从适用条件上讲，它过于地宽泛而没有用；</li>
  <li>从内容上讲，它只是机械地总结了结果，而缺乏提示最关键的思考过程</li>
</ol>

<p>真正地问题在于为什么 Greedy 成立，以及成立的内在核心条件是什么？<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">1</a></sup></p>

<p>这是一个两步递进的问题，首先是证明 Greedy 成立，Greedy 形式上总是由一个阶段的局部最优解来得到全局最优解，这天然适合用归纳法<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup>来进行证明，只要证明初始条件的成立<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>和前一个阶段的局部最优解能够导出下一个阶段的局部最优解。</p>

<p>然后可以发现 Greedy 成立的条件会有类似之处，进行真正有意义地总结。</p>

<p>下面我们介绍一些贪心算法的实例，来进行观察。</p>

<h2 id="树上直径">树上直径</h2>

<p>求解非负权树形图的直径。</p>

<p>树形图（Tree Graph），就是像树一样的无向连通图，也就是无环地无向连通图。</p>

<p>树上的直径就是两点间最长的简单路径<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">4</a></sup>。</p>

<h3 id="算法推论">算法推论</h3>

<p>这时图上任意一点 $v_0$ ，以它为起点，距离最远的一个点是 $v_1$，则 $v_1$ 一定是直径的两个端点之一，然后再以 $v_1$ 为起点寻找距它最远的点 $v_2$ 就得到了直径。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup></p>

<h3 id="贪心证明">贪心证明</h3>

<p>考虑树的直径一定横跨左右子树<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>，而 $P_{v_0\rightarrow v_1}$ 只有两种可能：  与直径有交点或者没有交点 。</p>

<p>如果没有交点，就是 $P_{v_0\rightarrow v_1}$ 只在一侧的子树上的情况，那么如果连接树的根节点和 $P_{v_0\rightarrow v_1}$ 上最近根的一个点 $v_1’$ ，假设根节点是 $v_R$ ，同侧子树的直径的端点是 $v_d$ ，那么根据直径的性质，$|v_1’ \rightarrow v_1| \leqslant |v_R\rightarrow v_1’ \rightarrow v_1| \leqslant |v_R\rightarrow v_d|$ ，这样就有 $|v_0\rightarrow v_1’ \rightarrow v_1| \leqslant |v_0\rightarrow v_R\rightarrow v_d|$ 。</p>

<ol>
  <li>如果 $|v_0\rightarrow v_1’ \rightarrow v_1| \lt |v_0\rightarrow v_R\rightarrow v_d|$ ，构造出的新路径 $P_{v_0\rightarrow v_R\rightarrow v_d}$ 就是更长的距离 $v_0$ 的路径，这就与前提条件相悖；</li>
  <li>否则 $|v_0\rightarrow v_1’ \rightarrow v_1| = |v_0\rightarrow v_R\rightarrow v_d|$ ，这意味着 $P_{v_R\rightarrow v_0\rightarrow v_1’\rightarrow v_1}$ 要么比原路径 $P_{v_R\rightarrow v_d}$ 更长，这就和前提条件相悖，要么相等<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup>，$|v_1’ \rightarrow v_1| = |v_R\rightarrow v_1’ \rightarrow v_1| = |v_R\rightarrow v_d|$ 这就说明 $P_{v_R\rightarrow v_1’\rightarrow v_1}$ 也是一条可选的直径（的一部分），此时 $v_1$ 当然就是直径的一个端点。</li>
</ol>

<p>如果存在交点，假设交点是 $v_1’$ ，直径的与 $v_0$ 异侧的端点是 $v_{d}$ ，假如 $v_1 \neq v_d$，那么总能构造出更长的距离 $v_0$ 的路径或者树的直径，否则就是存在多条相等的直径，$v_1$ 是另一条直径的端点。</p>

<p>因此证明了 $v_1$ 总是直径的一个端点，当然也证明了 $v_2$ 也是直径的一个端点<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>。</p>

<h3 id="成立条件">成立条件</h3>

<p>这个贪心算法能够成立的核心条件有两个：</p>

<ol>
  <li>树形图不存在环，两个点之间的简单路径有且只有一条；</li>
  <li>非负权边，这让数学上的“不等式缩放”（scaling）能够成立。</li>
</ol>

<h2 id="dijkstra-最短路径">Dijkstra 最短路径</h2>

<p>一提到贪心算法，可能是很多人第一时间想到 dijkstra 算法，以前在学校时，数据结构课的老师总是喜欢强调它是一种贪心算法，当时就觉得这是句干话，因为我们完全不会因为它是贪心算法就理解它的原理或者清楚它的工作过程，现在我们来重新回顾下<a href="/algs/GraphSP.html">这个算法</a>：</p>

<p>非负权边的无向连通图，求解从某个点 $v_0$ 出发到其他所有点的最短路径。</p>

<h3 id="算法推论-1">算法推论</h3>

<p>可以依次求出距离 $v_0$ 最短、次短、第三短。。。。。。的点的路径，每求出一个点，就用这个最短路径更新与它直接相连的那些点。</p>

<p>初始可以认为与 $v_0$ 直接相连点的最短路径就它们的直接路径长度，而其他点的最短路径是无穷大。</p>

<h3 id="贪心证明-1">贪心证明</h3>

<ol>
  <li>由于是非负路径，初始时首先可以依次确定与 $v_0$ 直接相连的那些点的最短距离</li>
  <li>同样由于是非负路径，到某个点 $v_1$ 的最短路径上的前驱点 $v_1’$ 的最短路径一定更小，首先会被求出，而 $v_1$ 的最短路径因此会被正确更新<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup></li>
</ol>

<h3 id="成立条件-1">成立条件</h3>

<p>显然最重要的就是边的权重是非负值，这再次允许我们进行非比较地不等式缩放。</p>

<h2 id="jump-games">Jump Games</h2>

<p><a href="/oth/LeetCodeJumpGames.html"></a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:10" role="doc-endnote">
      <p>贪心算法就总是第一眼看上去感觉好像是对的，但是又不能 100% 确定，证明它或者理解它为什么是对的比实现它要复杂得多 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Inductive Reasoning，也许用诱导推理这个词更能把握它的内核，而且总是可以联想到后缀数组的诱导排序（Induced Sorting）算法，反过来归纳一词总让人误以为这是一种经验猜测而不是逻辑推理 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>这通常是显而易见的 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>没有重复点的路径 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>两步地贪心算法 QAQ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>不这样的话，假如只在其中一棵子树上，通过连接另一侧子树上的点、根节点和直径的近端的点，就能构造出更长的直径 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>存在零权重的边 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Deductive Reasoning，诱导推理的反过程–演绎推理 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>如果存在零权边，那么总可以等价地交换这些零权边连接的点的位置，并不影响结论 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LeetCode Packet 1</title><link href="/oth/LeetCodePacket1.html" rel="alternate" type="text/html" title="LeetCode Packet 1" /><published>2023-07-29T00:00:00+08:00</published><updated>2023-07-29T00:00:00+08:00</updated><id>/oth/LeetCodePacket1</id><content type="html" xml:base="/oth/LeetCodePacket1.html"><![CDATA[<h2 id="44-wildcard-matching"><a href="https://leetcode.com/problems/wildcard-matching/">44. Wildcard Matching</a></h2>

<p>各方面都更像 <a href="/oth/LeetCode0010.html">0010 - Regular Expression Matching</a> II ，前者是正则匹配，后者则是一般 shell 上文件名的匹配，而且后者（也就是本题）的 DP 实现可以把时间和空间性能很好地结合在一起。</p>

<p>把模式串的遍历放在外循环，唯一需要仔细考虑下的就是每一轮 DP 的初始化：</p>

<ol>
  <li>第一轮的 DP，$\text{dp}[0] = \text{true}$ ，也就是空串匹配空串，其他位置是非空文本串匹配空模式串，显然全都是 $\text{false}$ ；</li>
  <li>第二轮及之后的 DP，如果对应位置是 <code class="language-plaintext highlighter-rouge">*</code> 符号，$\text{dp}[0]$ 就等于前一轮的 $\text{dp}[0]$ ，否则就排除了模式串前缀全是星符号的情况，就一定是 $\text{false}$</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># j = 0
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">:</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prev1</span> <span class="o">=</span> <span class="n">prev1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prev1</span> <span class="o">=</span> <span class="n">prev1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>和一个直接使用 <code class="language-plaintext highlighter-rouge">fnmatch.fnamtch</code> 的运行时间一致。</p>

<h2 id="403-frog-jump"><a href="https://leetcode.com/problems/frog-jump/">403. Frog Jump</a></h2>

<p>一个最优时间复杂度为 $O(n^2)$ 的动态规划的题目，有点儿无语了。</p>

<p>分为自顶向下（渐进递归），和自底向上两个实现方法，这种时间复杂度 $O(n^2)$ 的题目实在没什么好讲的。</p>

<p>使用哈希表而不是二维数组的好处是可以直接把值放进表里，而不需要额外的值的哈希表来查找值对应的索引<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">k_candicates</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_candicates</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>时间复杂度：$O(n^2)$ 。</p>

<p>运行时间：164 ms (beats 74.64%)，内存占用：17.6 MB (beats 98.33%)</p>

<h2 id="2498-frog-jump-ii"><a href="https://leetcode.com/problems/frog-jump-ii/">2498. Frog Jump II</a></h2>

<p>从头跳到尾，跳过去再跳回来，每次不能跳跳过的石头，每一跳的最大值即为整个路径的值，求最小的路径值。</p>

<p>既然是跳过去再跳回来，那么可以在一遍扫描的时候直接找两条最短的路径，由于没有任何跳跃的限制，因此不存在某一跳较大但因此其他跳较小的情况，因为总是可以通过较小的跳跳到该位置，这就可以使用贪心地思想，直接寻找最小的下一跳。</p>

<p>可以直接从序号一开始，两两一组，1跳3，2跳4，如此，这就是最小的路径值的跳法儿。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：558 ms (beats 98.8%)，内存占用：31.12 MB (beats 44.23%) 。</p>

<p>必须吐槽下，这个完全是 $O(1)$ 的内存使用内存占用居然不是最好的，因为还有处理过程中直接修改输入数组（弹出元素）的情况。</p>

<p>可以用一种混合地写法看起来更简洁：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>但由于 <code class="language-plaintext highlighter-rouge">ans</code> 的比较次数多了一倍，性能要稍差些。</p>

<p>运行时间：580 ms</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这实在有些脱裤子放屁 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[44. Wildcard Matching]]></summary></entry><entry><title type="html">0042 - Trapping Rain Water</title><link href="/oth/LeetCode0042.html" rel="alternate" type="text/html" title="0042 - Trapping Rain Water" /><published>2023-07-27T00:00:00+08:00</published><updated>2023-07-27T00:00:00+08:00</updated><id>/oth/LeetCode0042</id><content type="html" xml:base="/oth/LeetCode0042.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/trapping-rain-water/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.11/0042_trapping_rain_water/py0042">源代码</a></p>

<p>如果能知到每个单位区间左边和右边的最大高度，取其最小值，就是该单位的存雨量。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="链接题目">链接题目</h3>

<p><a href="/oth/LeetCode0032.html">0032 - Longest Valid Parentheses</a></p>

<h2 id="解双向扫描">解①双向扫描：</h2>

<p>可以认为下降和上升是需要匹配的两个阶段，如果事先记录下降前的高度，在一个下降-上升周期结束的时候，就可以回溯计算这个“坑道”的存雨量，不过这有一个前提，就是上升达到的最大高度不小于下降前的最大高度，确保我们正确计算了这个坑道的雨量。但这就带来了一个问题，可能一直到结束，后面都找不到匹配的高度，于是可以参照 <a href="/oth/LeetCode0032.html">0032</a> 里面的双向扫描，再次地从后向前扫描到最后一个下降的“峰”位。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">h</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># peak
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">mode</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">oldk</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">oldk</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">mode</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">mode</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>但是必须吐槽得是本来 <code class="language-plaintext highlighter-rouge">mode</code> 采用得是枚举类型：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
	<span class="n">Down</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Up</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>但是 Python 的 Enum ，或者说一般地对类的封装是如此地消耗内存，只这一个类的定义，就直接让测试结果的内存消耗从排名靠前掉到了排名靠后！于是替换成了布尔类型。</p>

<p>相比于下面介绍的同复杂度但是一遍扫描的算法，双向扫描的算法要稍微慢一点。</p>

<h2 id="解双指针">解②双指针：</h2>

<p>假设我们事先找到序列里的最大高度<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup> $h_\text{max}$：</p>

<p>那么在它的左边，从头开始扫描，维护一个到当前位置 $i$ 为止的前缀最大值 $h_\text{left} = \max\lbrace {h_0 \dots h_i}\rbrace$，每个位置的积水就是 $h_\text{left}-h_i$ ；</p>

<p>在它的右边，从尾开始扫描，维护一个到当前位置 $j$ 为止的前缀最大值 $h_\text{right} = \max\lbrace{h_{n-1} \dots h_j}\rbrace$，每个位置的积水就是$h_\text{right}-h_j$ 。</p>

<p>实际上我们不需要真的取寻找这个最大高度，我们只需要确定 $h_\text{left}$ 和 $h_\text{right}$ 不是最大值即可，只要从两边同时开始扫描，比较  $h_\text{left}$ 和 $h_\text{right}$ ，其中较小的那一个计算该位置积水，然后继续前进，直到完成整个序列的扫描，也就是两端相遇。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">h</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">lf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rh</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">lf_max</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">lf</span><span class="p">]</span>
    <span class="n">rh_max</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">rh</span><span class="p">]</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">lf</span> <span class="o">&lt;</span> <span class="n">rh</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">lf</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">[</span><span class="n">rh</span><span class="p">]:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">lf_max</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">lf</span><span class="p">]</span>

            <span class="n">lf</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">lf_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lf_max</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">lf</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">rh_max</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">rh</span><span class="p">]</span>

            <span class="n">rh</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">rh_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rh_max</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">rh</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>测试时的实际性能足够快，取样表上最快的就是这个版本。</p>

<h2 id="解单调栈">解③单调栈：</h2>

<p>单调栈，Monotonic Stack，这是第一次遇到可以恰当地套用这个算法思想的题目。</p>

<p>回到双向扫描的思路，只要序列一直保持不增<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup>，就（把索引位置）入栈，直到遇到一个大于栈顶元素（对应高度）的值 $h_i$，然后弹出所有（对应高度）不超过 $h_i$ 的栈元素，于是可以利用这些元素<strong>水平地</strong>计算积雨。</p>

<p>每一层的高度是（弹出的）相邻栈元素对应的高度差，长度是每个栈元素 $k_0$ 的前一个栈元素 $k_1$ 与当前位置 $i$ 的差减一：$i-k_1-1$ 。</p>

<p>并且注意，如果在弹出不超过 $h_i$ 的元素后，栈中还有元素，那么弹出的最后一个元素到栈顶元素还有一段积雨，高度差则是 $h[i]-h_\text{last}$。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">pairwise</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">h</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span>

            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">cache</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">pairwise</span><span class="p">(</span><span class="n">cache</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
               <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">h</span><span class="p">[</span><span class="n">cache</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>测试时的实际性能不错。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>由此可以推出，当用两个数组分别记录某个位置的前缀的高度最大值和后缀的高度最大值，然后分别从左扫描和从右扫描，计算完这个数组，这就是所谓 DP 的思路，真是什么玩意儿！ <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>这个背景看起来就像是扫描线问题会经常出现的，不过扫描线问题的关键是存在多栋区间重叠的建筑，查询某个点的数据 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>若高度不唯一，任选其一即可 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>相等元素也需要入栈，为了正确计算每一层的积水 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0032 - Longest Valid Parentheses</title><link href="/oth/LeetCode0032.html" rel="alternate" type="text/html" title="0032 - Longest Valid Parentheses" /><published>2023-07-25T00:00:00+08:00</published><updated>2023-07-25T00:00:00+08:00</updated><id>/oth/LeetCode0032</id><content type="html" xml:base="/oth/LeetCode0032.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/longest-valid-parentheses/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.10/0032_longest_valid_parans/py0032">源代码</a></p>

<p>考虑合法的括号序列的性质：</p>

<ul>
  <li>开括号可以任意数量地出现，但是串结束的时候括号可能没有匹配完</li>
  <li>闭括号不能超出开括号的数量</li>
  <li>括号序列是对称的，从反方向来看，闭括号就是开括号，开括号就是闭括号</li>
</ul>

<p>给出一个 <strong>括号单元</strong> 的递归定义：<code class="language-plaintext highlighter-rouge">unit ::= () | (unit+)</code></p>

<p>一个合法的括号串： <code class="language-plaintext highlighter-rouge">s=unit*</code></p>

<h3 id="链接题目">链接题目</h3>

<ul>
  <li><a href="/oth/LeetCode0022.html">0022 - Generate Parentheses</a></li>
</ul>

<h2 id="解双向扫描">解①双向扫描：</h2>

<p>一个只包含左右括号的串总是由三部分组成：括号单元、失配的闭括号、尾部的未完成的括号单元。</p>

<ol>
  <li>与前面出现的开括号数量匹配的闭括号属于括号单元；</li>
  <li>其余的闭括号属于失配的闭括号；</li>
  <li>而多余的开括号如果一直到最后都没有被匹配，就会形成未完成的括号单元</li>
</ol>

<p>对于括号单元和失配闭括号，一遍扫描就可以解决：统计开括号和闭括号，当数量相等时就是一个括号单元的结束，当遇到失配闭括号时就重置开括号闭括号数量。</p>

<p>但是对于尾部可能存在的未完成的括号单元，用子串 $s_1$ 表示，因为需要统计未完成的括号单元内的最长括号序列，前面的算法处理不了<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，但是如果从反方向看<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>它尾部的未完成单元，它的尾部一定不存在未完成单元<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，因此可以一遍扫描计算得到这一部分的最长的合法括号序列。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="nb">open</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">close</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">open</span> <span class="o">==</span> <span class="n">close</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
            <span class="nb">open</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s">')'</span><span class="p">:</span>
            <span class="n">close</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">close</span> <span class="o">&gt;</span> <span class="nb">open</span><span class="p">:</span>
                <span class="c1"># reset
</span>                <span class="nb">open</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">close</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">close</span> <span class="o">==</span> <span class="nb">open</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="nb">open</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">open</span> <span class="o">&gt;</span> <span class="n">close</span><span class="p">:</span>
        <span class="n">rev_open</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rev_close</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rev_ans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">')'</span><span class="p">:</span>
                <span class="n">rev_open</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
                <span class="n">rev_close</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">rev_close</span> <span class="o">&gt;</span> <span class="n">rev_open</span><span class="p">:</span>
                    <span class="c1"># reset
</span>                    <span class="n">rev_open</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">rev_close</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">rev_close</span> <span class="o">==</span> <span class="n">rev_open</span><span class="p">:</span>
                    <span class="n">rev_ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rev_ans</span><span class="p">,</span> <span class="n">rev_open</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">rev_ans</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ ，是空间复杂度最优的解。</p>

<h2 id="解dp">解②DP：</h2>

<p>按照扫描方向看，用后缀数组 $\text{dp}[i]$ 表示结尾在 $i$ 处的最长合法括号序列的长度。</p>

<ol>
  <li>如果结尾字符是 <code class="language-plaintext highlighter-rouge">(</code> ，对应 $\text{dp}$ 一定为 $0$ ；</li>
  <li>否则结尾字符是 <code class="language-plaintext highlighter-rouge">)</code> ，这时需要检查前一个字符对应的最长合法括号序列，如果在那个括号序列的前一个字符 $s[i-\text{dp}[i-1]-1]$ 又是 <code class="language-plaintext highlighter-rouge">(</code> ，则此时的 $\text{dp}[i] = 2+\text{dp}[i-1]$ ，如果此时 $i-\text{dp}[i-1]-1 \gt 0$ ，就再加上 $\text{dp}[i-\text{dp}[i-1]-2]$ ，否则没有匹配的开括号，对应 $\text{dp}$ 也为 $0$ 。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">')'</span> <span class="ow">and</span> <span class="n">i</span><span class="o">-</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$</p>

<p>前面双向扫描也可以叫做两遍扫描，而 DP 方法只需要扫描一遍，时间性能更优。</p>

<h2 id="解stack">解③Stack：</h2>

<p>如果保存开括号的索引位置，那么当遇到闭括号弹出的时候，就可以计算这一对儿括号序列的长度，但有一个问题是<strong>如何计算顶层连续的括号单元？</strong></p>

<p>这里使用了一个简单、但是 Tricky 的方法，保持第一个入栈的开括号前一个字符的位置在栈里，遇到闭括号时弹出开括号，当遇到失配的闭括号时，就弹出这个位置，如果栈为空，那就把当前位置入栈，如果下一个字符不是开括号就继续弹出并压入新的失配闭括号，直到遇到新的开括号，开启新的括号单元的序列。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 保存两个信息，记录连续信息
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$</p>

<p>单位比较次数更少，时间性能最佳。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>可以对尾部的未完成匹配的部分的第二个字符开始再次应用算法，但这带来的了 $O(n^2)$ 的最坏时间复杂度。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>顺序从右到左，把右括号视为开括号，左括号视为闭括号 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>$s_1$ 至少开头的的那个开括号，从反向看是失配的闭括号，因此反向看尾部一定不存在未完成匹配 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Map</title><link href="/oth/LeetCodeMap.html" rel="alternate" type="text/html" title="LeetCode Map" /><published>2023-07-25T00:00:00+08:00</published><updated>2023-07-25T00:00:00+08:00</updated><id>/oth/LeetCodeMap</id><content type="html" xml:base="/oth/LeetCodeMap.html"><![CDATA[<h2 id="app-themes">App Themes</h2>

<p>按照特定应用场景的分类</p>

<h3 id="linesweep">LineSweep</h3>

<ul>
  <li><a href="/oth/LeetCode0218.html">0218 - The Skyline Problem</a></li>
  <li><a href="/oth/LeetCode0391.html">0391 - Perfect Rectangle</a></li>
  <li><a href="/oth/LeetCode0850.html">0850 - Rectangle Area II</a></li>
  <li><a href="/oth/LeetCode1851.html">1851 - Minimum Level to Include</a></li>
</ul>

<h3 id="graph">Graph</h3>

<ul>
  <li><a href="/algs/LeetCode0685.html">0685 - Redundant Connection II</a></li>
</ul>

<h3 id="palindrome">Palindrome</h3>

<ul>
  <li><a href="/oth/LeetCode0005.html">0005 - Longest Palindromic Substring</a></li>
  <li><a href="/algs/LeetCode0336.html">0336 - Palindrome Pairs</a></li>
</ul>

<h3 id="words-comparison">Words Comparison</h3>

<ul>
  <li><a href="/algs/LeetCode0336.html">0336 - Palindrome Pairs</a></li>
</ul>

<h3 id="parentheses">Parentheses</h3>

<ul>
  <li><a href="/oth/LeetCode0022.html">0022 - Generate Parentheses</a></li>
  <li><a href="/oth/LeetCode0032.html">0032 - Longest Valid Parentheses</a></li>
</ul>

<h2 id="tech-themes">Tech Themes</h2>

<p>按照算法思想的分类</p>

<h3 id="dp">DP</h3>

<ul>
  <li><a href="/oth/LeetCode0005.html">0005 - Longest Palindromic Substring</a></li>
  <li><a href="/oth/LeetCode0010.html">0010 - Regular Expression Matching</a></li>
  <li><a href="/oth/LeetCode0032.html">0032 - Longest Valid Parentheses</a></li>
  <li><a href="/oth/LeetCode1340.html">1340 - Jump Games V</a></li>
  <li><a href="/oth/LeetCodePacket1.html">0403 - Frog Jump</a></li>
</ul>

<h4 id="recursive-dp">Recursive DP</h4>

<p>一类很特殊的 DP ，是在递归状态上的 DP</p>

<ul>
  <li><a href="/algs/LeetCode0053.html">0053 - Maximum Subarray</a></li>
</ul>

<h3 id="monotonic-stack">Monotonic Stack</h3>

<ul>
  <li><a href="/oth/LeetCode0042.html">0042 - Trapping Rain Water</a></li>
  <li><a href="/oth/LeetCode1340.html">1340 - Jump Games V</a></li>
  <li><a href="/oth/LeetCodeJumpGames.html">1696. Jump Game VI</a></li>
</ul>

<h3 id="greedy">Greedy</h3>

<ul>
  <li><a href="/oth/LeetCode1340.html">1340 - Jump Games V</a></li>
</ul>

<h2 id="lang-themes">Lang Themes</h2>

<p>有语言优化相关的主题</p>

<h3 id="python">Python</h3>

<ul>
  <li><a href="/oth/LeetCode1340.html">1340 - Jump Games V</a></li>
</ul>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[App Themes]]></summary></entry><entry><title type="html">0022 - Generate Parentheses</title><link href="/oth/LeetCode0022.html" rel="alternate" type="text/html" title="0022 - Generate Parentheses" /><published>2023-07-24T00:00:00+08:00</published><updated>2023-07-24T00:00:00+08:00</updated><id>/oth/LeetCode0022</id><content type="html" xml:base="/oth/LeetCode0022.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/generate-parentheses/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.9/0022_gen_paren/py0022">源代码</a></p>

<p>额，测试用例就是题目限制的 $8$ 个。</p>

<h2 id="解直接构造">解①直接构造：</h2>

<p>直接构造所有可能的字符串，从空串开始逐个增加字符，<code class="language-plaintext highlighter-rouge">(</code> 和 <code class="language-plaintext highlighter-rouge">)</code>  ，直到字符串长度达到 $2n$ 。</p>

<ul>
  <li>左括号可以随意增加，只要总数不超过 $n$</li>
  <li>右括号必须匹配一个左括号，不能随意增加，它的数量不能超过当前左括号的数量</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">open</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">close</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">close</span> <span class="o">==</span> <span class="nb">open</span><span class="p">:</span>
            <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s">'('</span><span class="p">,</span> <span class="nb">open</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">close</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">open</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s">')'</span><span class="p">,</span> <span class="nb">open</span><span class="p">,</span> <span class="n">close</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s">'('</span><span class="p">,</span> <span class="nb">open</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">close</span><span class="p">)</span>
            <span class="n">build</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="s">')'</span><span class="p">,</span> <span class="nb">open</span><span class="p">,</span> <span class="n">close</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">build</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>思路是本题最佳实现，$45$ ms ，虽然没有 beats 100% ，但和最快的例子没有区别</p>

<h2 id="解树级构造">解②树级构造：</h2>

<p>本题有一个 DP 的标签，从一开始考虑得是如果利用之前的构造进行构造。</p>

<p>发现了这样一个办法：每个可能的串都由并列的几个括号单元组成，比如 <code class="language-plaintext highlighter-rouge">(()())(())</code> 就有两个括号单元 <code class="language-plaintext highlighter-rouge">(()())</code> 和 <code class="language-plaintext highlighter-rouge">(())</code> ，长度为 $n$ 的括号组合可以由长度为 $n-1$ 的括号组合按照每一个括号单元外面镶嵌一层括号，每两个括号单元外镶嵌括号，… ，每 $n$ 个括号单元外镶嵌括号，以及不镶嵌括号，增加一个新的并列括号单元。</p>

<p>不过这种构造方法会构造出重复的情况，而且没法儿简单判断，最佳方法还是放入 <code class="language-plaintext highlighter-rouge">set</code> 里过滤一遍。</p>

<h3 id="数据结构">数据结构：</h3>

<p>考虑下括号单元的表示形式，最简单地是 <code class="language-plaintext highlighter-rouge">Leaf()</code> ，表示最基本的 <code class="language-plaintext highlighter-rouge">()</code>，直接使用单例模式（singleton）表示，而括号单元列表的括号嵌套就是 <code class="language-plaintext highlighter-rouge">Branch</code> ，为了用哈希集合过滤重复元素，特别定义了 <code class="language-plaintext highlighter-rouge">Branch</code> 的哈希方法 <code class="language-plaintext highlighter-rouge">__hash__</code> 和正确处理哈希冲突需要的判等方法 <code class="language-plaintext highlighter-rouge">__eq__</code> 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">'()'</span>


<span class="k">class</span> <span class="nc">Branch</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Branch</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Leaf</span> <span class="o">|</span> <span class="n">Branch</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">repr</span> <span class="o">=</span> <span class="s">'({})'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
            <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">children</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">repr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">repr</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


<span class="n">leaf</span> <span class="o">=</span> <span class="n">Leaf</span><span class="p">()</span>
<span class="n">parens</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{(</span><span class="n">leaf</span><span class="p">,)},</span> <span class="c1"># {()}
</span>    <span class="p">{(</span><span class="n">Branch</span><span class="p">([</span><span class="n">leaf</span><span class="p">]),),</span> <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)}</span>  <span class="c1"># {(()), ()()}
</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="计算过程">计算过程：</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parens</span><span class="p">),</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">parens</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">gen_paren_comb</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">])</span> <span class="k">for</span> <span class="n">parts</span> <span class="ow">in</span> <span class="n">parens</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">gen_paren_comb</span><span class="p">(</span><span class="n">prev_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">parts</span> <span class="ow">in</span> <span class="n">parens</span><span class="p">[</span><span class="n">prev_i</span><span class="p">]:</span>
        <span class="c1"># nested on each parens units: 1~n
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">parts</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">Branch</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">]),)</span> <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">:]</span>

    <span class="k">yield</span> <span class="p">(</span><span class="n">leaf</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">prev_i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>在本题情况下不如直接递归地构造，运行时间 $59$ ms 。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0010 - Regular Expression Matching</title><link href="/oth/LeetCode0010.html" rel="alternate" type="text/html" title="0010 - Regular Expression Matching" /><published>2023-07-21T00:00:00+08:00</published><updated>2023-07-21T00:00:00+08:00</updated><id>/oth/LeetCode0010</id><content type="html" xml:base="/oth/LeetCode0010.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/regular-expression-matching/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.8/0010_regular_expr_matching/rs0010">源代码</a></p>

<p>这道题令人有些五味杂陈，说它是一道不好的题有它不好的理由，说它是一道好的题有好的理由，它好还是不好可能取决于你做题的流程。</p>

<p>不好的说，这道题并不是那种抽象得非常干净的题目，它更像是现实中的问题，有开放式的解决方法，可能涉及多方面知识，主要时间需要用在考虑核心算法无关的处理细节。作为那种习惯性地先成功提交，然后才回去看解析和答案的人来说这种题是非常煎熬的而且花费时间的，除非你已经很熟悉了这个套路<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。</p>

<p>好的说，如果你实现就清楚这个套路，做过类似的题目，那么标准答案至少在形式上也是很简洁的<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>另外，当看到文本串与模式串的长度都不超过 $20$ 的条件时，就可以想到，不管这道题的本意如何，标准解法是什么，几乎一定存在一种自然解法，性能不劣于标准解法。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p><strong>Tips：</strong></p>

<p>题目保证了 <code class="language-plaintext highlighter-rouge">*</code> 字符前面一定会有一个合法的字符，否则我们还需要检查下模式串的合法性。</p>

<h2 id="解固定串匹配">解①固定串匹配：</h2>

<p><strong>基于固定串匹配的自然解法</strong></p>

<p>这是我的自然解法，考虑得并不是标准解法里的字符匹配的模型<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，而是考虑模式匹配或者子串匹配的思路，这也应该是初学者自然的思路。</p>

<p><strong>模式串</strong>里有两种模式匹配，一种是长度固定的串，就是所有普通字符加上 <code class="language-plaintext highlighter-rouge">.</code> 符号，匹配这种长度固定的串是很容易的，可以用如下的方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[inline]</span>
<span class="k">fn</span> <span class="nf">match_pat</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()</span>
        <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.zip</span><span class="p">(</span><span class="n">pat</span><span class="nf">.iter</span><span class="p">())</span>
            <span class="nf">.all</span><span class="p">(|(</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">)|</span> <span class="n">c2</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">||</span> <span class="n">c2</span> <span class="o">==</span> <span class="n">c1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一种是长度不定的串，就是后面带 <code class="language-plaintext highlighter-rouge">*</code> 字符的双字符串，像 <code class="language-plaintext highlighter-rouge">.*</code> ,  <code class="language-plaintext highlighter-rouge">a*</code> 等等，长度不定的串的匹配是问题的难度所在，或者也是时间复杂度飙升的地方。</p>

<p>于是我们的思路就很清楚，首先匹配掉固定串，然后再用回溯剪枝的方法检查不定串。</p>

<p>给定文本串 <code class="language-plaintext highlighter-rouge">s: String</code> 和模式串 <code class="language-plaintext highlighter-rouge">p: String</code></p>

<h3 id="step-1搜索不定串">Step-1：搜索不定串</h3>

<p><strong>在模式串上搜索所有不定串的位置</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">p_bytes</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.as_bytes</span><span class="p">();</span>
<span class="k">let</span> <span class="n">s_bytes</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">();</span>

<span class="k">let</span> <span class="n">random_pats</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">p</span>
	<span class="nf">.match_indices</span><span class="p">(</span><span class="sc">'*'</span><span class="p">)</span>
	<span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="step-2划分固定串">Step-2：划分固定串</h3>

<p><strong>划分出模式串中中间的固定串</strong></p>

<p>我们真正关心得应该是夹在不定串之间的那些固定串，因为模式串两端的固定串是可以简单匹配确定的<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>在搜索固定串的位置之前，需要先检查所有其他的情况：有零个不定串或者一个不定串</p>

<h4 id="零个不定串">零个不定串：</h4>

<p>最简单的情况，直接使用固定串的匹配方法即可。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">random_pats</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">match_pat</span><span class="p">(</span><span class="n">s_bytes</span><span class="p">,</span> <span class="n">p_bytes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="一个不定串">一个不定串：</h4>

<p>这种情况下，需要做两端固定串的匹配，然后比较文本串两端中间的部分是否匹配这个唯一地不定串。</p>

<p>在做两端固定串的匹配时，首先要检查长度是否匹配，来防止计算头尾固定串时发生算术溢出问题。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// s_bytes head i inclusive</span>
<span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="n">random_pats</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">let</span> <span class="n">tail_slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p_bytes</span><span class="p">[</span><span class="n">random_pats</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="o">..</span><span class="p">];</span>

<span class="k">if</span> <span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">random_pats</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// s_bytes tail i exclusive</span>
<span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">tail_slice</span><span class="nf">.len</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">head</code> 表示头部固定串的长度，也是其余部分的起始位置，<code class="language-plaintext highlighter-rouge">tail</code> 表示尾部固定串的起始位置，因此 <code class="language-plaintext highlighter-rouge">s_bytes[head..tail]</code> 才是我们真正要做模式匹配的地方。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">!</span><span class="nf">match_pat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_bytes</span><span class="p">[</span><span class="o">..</span><span class="n">head</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">p_bytes</span><span class="p">[</span><span class="o">..</span><span class="n">head</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="o">!</span><span class="nf">match_pat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_bytes</span><span class="p">[</span><span class="n">tail</span><span class="o">..</span><span class="p">],</span> <span class="n">tail_slice</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ONE '*' */</span>

<span class="k">if</span> <span class="n">random_pats</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">random_pats</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>

    <span class="k">return</span> <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="k">true</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">s_bytes</span><span class="p">[</span><span class="n">head</span><span class="o">..</span><span class="n">tail</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="至少两个不定串">至少两个不定串：</h4>

<p>固定串划分就是：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fixed_pats</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">random_pats</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">.scan</span><span class="p">(</span><span class="n">random_pats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">last_i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p_bytes</span><span class="p">[</span><span class="o">*</span><span class="n">last_i</span><span class="o">..</span><span class="n">i</span><span class="p">];</span>
        <span class="o">*</span><span class="n">last_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="step-3搜索固定串">Step-3：搜索固定串</h3>

<p><strong>在文本串上预搜索所有固定串的位置</strong></p>

<p>比起在文本匹配时动态地搜索每个固定串的位置，不如预先地搜索完所有固定串可能在文本串上出现的位置。</p>

<p>这里还有一个限制，可以用来减少可能性地空间，就是固定串的先后顺序和它们自身的长度，不过在此之前需要先确保整个文本串的空余长度足以容纳所有固定串：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fixed_pats_tot</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">fixed_pats</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.sum</span><span class="p">();</span>

<span class="k">if</span> <span class="n">fixed_pats_tot</span> <span class="o">&gt;</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">head</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用一个嵌套的数组 <code class="language-plaintext highlighter-rouge">fixed_pats_pos</code> 来依次保存每个固定串的可能在文本串上的可能位置<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>，如果发现有个固定串没有合适的位置，那就可以提前返回失败了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">fixed_pats_tot</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">fixed_pats_pos</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

<span class="k">for</span> <span class="n">pat</span> <span class="k">in</span> <span class="n">fixed_pats</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">..=</span><span class="n">end</span><span class="p">)</span>
    	<span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">j</span><span class="p">|</span> <span class="nf">match_pat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_bytes</span><span class="p">[</span><span class="n">j</span><span class="o">..</span><span class="n">j</span> <span class="o">+</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()],</span> <span class="n">pat</span><span class="p">))</span>
    	<span class="nf">.collect</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">pos</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fixed_pats_pos</span><span class="nf">.push</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>

    <span class="n">start</span> <span class="o">+=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">();</span>
    <span class="n">end</span> <span class="o">+=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用了简单地匹配搜索，因为模式和文本都非常地短，如果是其他的情况在串上地多模式搜索，就有 AC 自动机，或者简单高效地 Sunday 算法。</p>

<h3 id="step-4回溯剪枝">Step-4：回溯剪枝</h3>

<p>一般来说回溯剪枝比较简洁的实现形式是递归，不过我习惯性地写非递归的版本，它在 Debug 的时候看得更清楚。</p>

<p>根据不定模式与文本的匹配情况，确定一个对应固定模式的起始范围，遍历这个起始范围，分别收集固定模式的可能位置，然后来到下一级。</p>

<p>让我们澄清一下这个比较方法：首先是前面的不定串，然后是后面的固定串，这样不定串与它后面的固定串两两划分，直到最后一个不定串，对应得是尾部的固定串。</p>

<p>这样一直到尾部的固定串都匹配时，就匹配成功，否则返回上一级，选取下一个可能位置，如果上一级为空，就继续向上返回。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">search_stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="n">head</span><span class="p">]];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">loop</span> <span class="p">{</span>
    <span class="c1">// check fail condition</span>
    <span class="k">while</span> <span class="n">search_stack</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">search_stack</span><span class="nf">.pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">search_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">search_stack</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">random_pats</span><span class="p">[</span><span class="n">lv</span><span class="p">]];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">s_c</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">s_c</span> <span class="o">!=</span> <span class="n">c</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">scale</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// big enough</span>
    <span class="p">}</span>

    <span class="c1">// check succeed condition</span>
    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="n">fixed_pats_pos</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">tail</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fixed_pats_pos</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="p">|</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">scale</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">j</span><span class="p">|</span> <span class="n">j</span> <span class="o">+</span> <span class="n">fixed_pats</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.len</span><span class="p">())</span>
        <span class="nf">.collect</span><span class="p">();</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">pos</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">search_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>至此为止就是原始版本的匹配算法，它的运行时间在 273 ms (beats 10.49%)，可以通过，但还不够好，可以通过一点点改进显著地提高性能。</p>

<h3 id="step-5记录失败">Step-5：记录失败</h3>

<p>可以直观地发现，有大量可以简单避免的无效匹配，如果某级从某个位置开始的后面所有可能匹配都失败了，那么下次再有从这一级的该位置开始的搜索就可以直接跳过。</p>

<p>可以直接用一个全局数组<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>记录失败情况，并用栈追踪级别和位置，以在全局数组上更新：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">MAX_S_LEN</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MAX_LV</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">MAX_S_LEN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">static</span> <span class="k">mut</span> <span class="n">FAILED</span><span class="p">:</span> <span class="p">[</span><span class="nb">bool</span><span class="p">;</span> <span class="n">MAX_LV</span> <span class="o">*</span> <span class="n">MAX_S_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="k">false</span><span class="p">;</span> <span class="n">MAX_LV</span> <span class="o">*</span> <span class="n">MAX_S_LEN</span><span class="p">];</span>

<span class="c1">// ...</span>

<span class="c1">// i, scale</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">bak_range</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
</code></pre></div></div>

<p>修改后的回溯版本：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">search_stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="n">head</span><span class="p">]];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// i, scale</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">bak_range</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>

<span class="k">unsafe</span> <span class="p">{</span> <span class="n">FAILED</span><span class="nf">.fill</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">};</span>

<span class="k">loop</span> <span class="p">{</span>
    <span class="c1">// check fail condition</span>
    <span class="k">while</span> <span class="n">search_stack</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">search_stack</span><span class="nf">.pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">search_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span> <span class="o">=</span> <span class="n">bak_range</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">base</span> <span class="o">=</span> <span class="n">lv</span><span class="o">*</span><span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">FAILED</span><span class="p">[</span><span class="n">base</span><span class="o">..=</span><span class="n">base</span><span class="o">+</span><span class="n">scale</span><span class="p">])</span><span class="nf">.fill</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">search_stack</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">FAILED</span><span class="p">[</span><span class="n">lv</span><span class="o">*</span><span class="n">MAX_S_LEN</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="p">}</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">random_pats</span><span class="p">[</span><span class="n">lv</span><span class="p">]];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">s_c</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">s_c</span> <span class="o">!=</span> <span class="n">c</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">scale</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// big enough</span>
    <span class="p">}</span>

    <span class="c1">// check succeed condition</span>
    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="n">fixed_pats_pos</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">tail</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">fixed_pats_pos</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="p">|</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">scale</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">j</span><span class="p">|</span> <span class="n">j</span> <span class="o">+</span> <span class="n">fixed_pats</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="nf">.len</span><span class="p">())</span>
        <span class="nf">.collect</span><span class="p">();</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">pos</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">search_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
            <span class="n">bak_range</span><span class="nf">.push</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">scale</span><span class="p">));</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果不计预先搜索固定串的开销<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>，那么有失败记录的实现的时间复杂度就是 $O(nm)$ ，与标准实现的一样。</p>

<p>它的运行时间稳定在 $0$ ms，还要优于简单形式的标准实现。</p>

<h2 id="解dp">解②DP：</h2>

<p>标准实现，不细究地话形式还是很简洁的。</p>

<p>把文本串与模式串逐字符比较，模式串中的不定串前面的字符当做普通字符处理，后面的星号才当做不定串特别处理。</p>

<p>分别用 $i$ 和 $j$ 表示文本串和模式串的匹配的前缀，二维地布尔数组 $\texttt{dp}[i][j]$ 表示 $s[0..i-1]$ 和 $p[0..j-1]$ 是否匹配。</p>

<p>当 $s[i-1] \neq *$ 时，如果 $\texttt{dp}[i-1][j-1]$ 匹配，并且 $s[i-1] = p[i-1]$ ，那么 $\texttt{dp}[i][j]$ 就是匹配的；</p>

<p>当$s[i-1] = *$ 时：</p>

<ul>
  <li>假设这个不定串匹配了零次，此时 $\texttt{dp}[i][j]=\texttt{dp}[i][j-2]$；</li>
  <li>假设这个不定串至少匹配了一次，此时 $\texttt{dp}[i][j]=\texttt{dp}[i-1][j] \land s[i-1] = p[i-2]$</li>
</ul>

<p>最后匹配了整个文本串和模式串的 $i$， $j$ 的 $\texttt{dp}[i][j]$ 就是需要的匹配结果。</p>

<p>另外需要考虑的一点是状态数组的初始状态：</p>

<ul>
  <li>当两个串都是空串时，状态是匹配的；</li>
  <li>当其中一个串为空，另一个不为空时，应该是不匹配的，除了一个特殊情况；</li>
  <li>特殊情况是，当文本串为空，模式串不为空，但全都是不定串时，比如 <code class="language-plaintext highlighter-rouge">a*b*.*</code> 时，也是匹配的</li>
</ul>

<h3 id="基本实现">基本实现</h3>

<p>假如用文本串作为外循环：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">dp</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()];</span> <span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()]</span>

<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="k">as</span> <span class="n">_</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> 
            <span class="p">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nd">char_match!</span><span class="p">(</span><span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nd">char_match!</span><span class="p">(</span><span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>

<span class="nd">macro_rules!</span> <span class="n">char_match</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$s:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$p</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="n">_</span> <span class="p">||</span> <span class="nv">$p</span> <span class="o">==</span> <span class="nv">$s</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这是形式上最简洁的实现，但运行时间稳定在 $2$ ms，明显不如上面的自然实现，而 $O(nm)$ 的空间复杂度虽然在本题上可以忽略不计，但也有进一步优化的可能。</p>

<h3 id="外分组实现">外分组实现</h3>

<p>像上面一样在内循环里做模式串的字符检查： <code class="language-plaintext highlighter-rouge">p_bytes[j-1]</code> 是否为 <code class="language-plaintext highlighter-rouge">*</code> 符号的检查，以及 <code class="language-plaintext highlighter-rouge">p_bytes[j-2]</code> 和 <code class="language-plaintext highlighter-rouge">p_bytes[j-2]</code> 是否为 <code class="language-plaintext highlighter-rouge">.</code> 符号的检查，主要是为了代码简洁，其实不太合适，应当放到外循环里，而从实际测试看，这两者也是有可观地性能差距。</p>

<p>把模式串的字符检查放在外循环也就是把模式串作为主迭代，使用 $\texttt{dp}[j][i]$，在这种情况下观察 $\texttt{dp}$ 数组的使用，可以发现实际上每轮都只会使用最近三行的数据：$\texttt{dp}[j][..]$ , $\texttt{dp}[j-1][i]$ ,  $\texttt{dp}[j-2][i]$ ，于是我们可以只用三个数组保存数据，每次循环结束就依次交换。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve_time_saving</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">p_bytes</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.as_bytes</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">s_bytes</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre2</span> <span class="o">=</span> <span class="p">[</span><span class="k">false</span><span class="p">;</span> <span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre1</span> <span class="o">=</span> <span class="p">[</span><span class="k">false</span><span class="p">;</span> <span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="p">[</span><span class="k">false</span><span class="p">;</span> <span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="n">pre1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="c1">// The valid pattern has guaranteed that j &gt;= 2</span>
            <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="p">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
                            <span class="o">&amp;&amp;</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">pre1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pre2</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">pre1</span><span class="p">);</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pre1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cur</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pre1</span><span class="p">[</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意最后 <code class="language-plaintext highlighter-rouge">pre1</code> 代表得才是 <code class="language-plaintext highlighter-rouge">cur</code> 。</p>

<p>本实现的运行时间稳定在 $0$ ms ，堪比前面自然实现。</p>

<h3 id="最省内存实现">最省内存实现</h3>

<p>如果仍然将文本串作为外循环的实现，$\texttt{dp}[i][j]$ 数组可以进一步压缩，因为此时只会使用三种数据： $\texttt{dp}[i-1][j-1]$ , $\texttt{dp}[i-1][j]$ ,  $\texttt{dp}[i][j-2]$ ，也就是本行的数据以及上一行本列和上一行前一列的数据。</p>

<p>因此只需要在迭代时复用一行的数据，某个位置数据在计算新的之前，保存的就是上一行的数据，可以用两个变量动态保存需要的上一行本列 $\texttt{dp}[i-1][j]$ ，和上一行前一列 $\texttt{dp}[i-1][j-1]$ 。</p>

<p>不过因此初始状态 $\texttt{dp}[0]$ 需要分情况处理，第一行的初始状态是 $1$ ，而其余行的初始位置是 $0$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">DP</span><span class="p">:</span> <span class="p">[</span><span class="nb">bool</span><span class="p">;</span> <span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="k">false</span><span class="p">;</span> <span class="n">MAX_S_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve_mem_saving</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p_bytes</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.as_bytes</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">s_bytes</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">();</span>

        <span class="n">DP</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="nf">.fill</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
        <span class="n">DP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="k">as</span> <span class="n">_</span> <span class="p">{</span>
                <span class="n">DP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">DP</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// ..i</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">s_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">pre_1</span> <span class="o">=</span> <span class="n">DP</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">DP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">pre_0</span> <span class="o">=</span> <span class="n">DP</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

                <span class="k">if</span> <span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'*'</span> <span class="k">as</span> <span class="n">_</span> <span class="p">{</span>
                    <span class="n">DP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">DP</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="p">||</span> <span class="n">pre_0</span>
                            <span class="o">&amp;&amp;</span> <span class="nd">char_match!</span><span class="p">(</span><span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">DP</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>
                        <span class="n">pre_1</span> <span class="o">&amp;&amp;</span> <span class="nd">char_match!</span><span class="p">(</span><span class="n">p_bytes</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s_bytes</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="n">pre_1</span> <span class="o">=</span> <span class="n">pre_0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">DP</span><span class="p">[</span><span class="n">p_bytes</span><span class="nf">.len</span><span class="p">()]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于本质上与基本实现一致，运行时间也是 $2$ ms 。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>或者用一个该题目下某用户的留言– “脑子充满了 DP” <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>这道题有 10k 的支持，但也有 1k 的反对 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>只有一种可能你会做得很利落，那就是你之前根本就做过类似的，这能称得上是好的题目吗？ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>这就更把人引到沟里去了，因为自然解法考虑的细节就更多了 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>因为事先我并不熟悉这个套路，应该说套路记得我，但我不记得它 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>不存在可以认为是空串的情况 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>显然它的长度比之前保存不定串位置的数组 <code class="language-plaintext highlighter-rouge">random_pats</code> 少 $1$ <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>它至少应该在上一个固定串的后面，并且保证后面有足够的空间放置其他的固定串 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>可以在多个测试用例里共享使用 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>这个开销显然很小 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry></feed>