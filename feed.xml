<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-01-28T10:16:18+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">BST(2) - RB(1) - 左偏红黑树</title><link href="/algs/BST-2-RB-Tree-1-LLRB-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(1) - 左偏红黑树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%201%20-%20LLRB%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-1-LLRB-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>LLRB 是简化后红黑树，基本来源是一个 <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> 的教学 PPT ，和红黑树一样，基本也不太行（指得是实现复杂，不直观，而且不体面（指得是删除操作依靠节点内容的交换））</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(2) - AA树</title><link href="/algs/BST-2-RB-Tree-2-AA-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(2) - AA树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%202%20-%20AA%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-2-AA-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<h3 id="专属辅助">专属辅助</h3>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<h2 id="总装">总装</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(0) - 原始红黑树</title><link href="/algs/BST-2-RB-Tree-0-Origin.html" rel="alternate" type="text/html" title="BST(2) - RB(0) - 原始红黑树" /><published>2023-01-19T00:00:00+08:00</published><updated>2023-01-19T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%200%20-%20Origin</id><content type="html" xml:base="/algs/BST-2-RB-Tree-0-Origin.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>红黑树是一种对平衡的要求比前面介绍的 AVL 树宽松一些的自平衡二叉搜索树，因此虽然查询性能稍差，但有更少的 插/删 所需要的旋转次数，也就是写的性能更加优秀。</p>

<p>它把节点分为红色和黑色（空节点视为黑色），规定新增的节点都是红色，而红色节点的父节点不能也是红色节点，在这种情况下保持每个节点的所有叶子节点到该节点的路径上黑色结点数相等，或者简称黑高相等，这样就能保持树的平衡性。另外应该是出于减少不必要重平衡的操作，特别规定根节点应设为黑色。</p>

<p>在红色节点不能连续的情况下，如果黑高相等，那意味着最大的树高的差距不超过1倍。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="p">});</span>
<span class="nd">impl_tree!</span><span class="p">(</span><span class="n">RB</span> <span class="p">{});</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">RB</span><span class="p">);</span>
<span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">RB</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_black_balance</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}({:?})"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="k">self</span><span class="nf">.color</span><span class="p">())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil({:?})"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.color</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="专属辅助">专属辅助</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Static Stats</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">color</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Color</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">Black</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">is_red</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.is_red</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">is_black</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.is_black</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">color_flip</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_some</span><span class="p">(),</span> <span class="s">"Color flip on None"</span><span class="p">);</span>

        <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.rev</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Validation Helper</span>

    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_rb_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.is_black</span><span class="p">())</span>
        <span class="p">}</span>

        <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
        <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cd">/// 应该给每个节点校验，但是存储黑高是一个问题，单独搞一个数据结构又太费</span>
    <span class="cd">/// 于是多次总体校验的方式</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_black_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">itertools</span><span class="p">::</span><span class="n">Itertools</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">is_black_blance</span> <span class="o">=</span>
        <span class="k">self</span>
            <span class="nf">.leafs</span><span class="p">()</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.black_depth_to</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
            <span class="nf">.tuples</span><span class="p">()</span>
            <span class="nf">.all</span><span class="p">(|(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">is_black_blance</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">black_depth_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">depth</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">leafs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">leafs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">leafs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="k">self</span><span class="nf">.clone</span><span class="p">()];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">leafs</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">leafs</span>
    <span class="p">}</span>

<span class="p">}</span>

</code></pre></div></div>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<p>插入节点后的重平衡是比较容易的。</p>

<p>无非是如何处理新增节点导致的红违背（red violation），也就是父子两个节点都是红色节点的情况。</p>

<p>这时主要有三种情况：</p>

<p>假设插入的红节点为 $\texttt{i}$ ，$\texttt{i}$ 的父节点为 $\texttt{p}$ ， $\texttt{p}$ 的父节点为 $\texttt{pp}$ ， $\texttt{p}$ 的邻居节点是 $\texttt{psib}$</p>

<h4 id="case-1">case-1</h4>

<p>$\texttt{psib}$ 是红节点，只需要把 $\texttt{pp}$ , $\texttt{p}$ , $\texttt{psib}$ 反色，并一路向上修复，这样既修复了红违背又保持了黑平衡</p>

<p><img src="/../assets/img/bst_rb/insert_case1_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case1_end.png" alt="修复" /></p>

<h4 id="case-2">case-2</h4>

<p>$\texttt{psib}$ 是黑节点，并且 $\texttt{p} \rightarrow \texttt{i}$ 的方向与 $\texttt{pp} \rightarrow \texttt{p}$ 的方向相反，向 $\texttt{p} \rightarrow \texttt{i}$ 的反方向旋转，到 <strong>case-3</strong></p>

<p><img src="/../assets/img/bst_rb/insert_case2_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case2_end.png" alt="修复" /></p>

<h4 id="case-3">case-3</h4>

<p>$\texttt{psib}$ 是黑节点，并且 $\texttt{p} \rightarrow \texttt{i}$ 的方向与 $\texttt{pp} \rightarrow \texttt{p}$ 的方向相同，向 $\texttt{p} \rightarrow \texttt{i}$ 的反方向旋转，并且把 $\texttt{p}$ 和 $\texttt{pp}$ 反色</p>

<p><img src="/../assets/img/bst_rb/insert_case3_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case3_end.png" alt="修复" /></p>

<p><em>case-2 可以直接双旋，然后反色一步到位地解决</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// impl ...</span>

<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">p</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">i</span><span class="nf">.is_red</span><span class="p">());</span>

    <span class="cm">/* Both p and pp is RED */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">pp</span><span class="nf">.is_some</span><span class="p">(),</span> <span class="s">"color red p shouldnt be root"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">red_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">psib_dir</span> <span class="o">=</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">psib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">psib</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">p_dir</span> <span class="o">==</span> <span class="n">red_dir</span> <span class="p">{</span>
            <span class="cm">/* case-3 */</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-2 */</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">p</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="n">pp</span><span class="nf">.color_flip</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>  <span class="c1">// psib is red</span>
    	<span class="cm">/* case-1 */</span>

        <span class="n">p</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="n">pp</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="n">psib</span><span class="nf">.color_flip</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">Black</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// impl ...</span>
</code></pre></div></div>

<h3 id="删除重平衡">删除重平衡</h3>

<p>RB 的删除操作没有一个既体面又简明的实现方法，有两个思路：</p>

<h4 id="思路1">思路1</h4>

<p>由于传统 <code class="language-plaintext highlighter-rouge">bst_delete</code> 实现的那种删除方法当被删除节点的左右孩子都不为空时，情况会变得很复杂。</p>

<p>这种思路的实现很少，能找到的就是 <a href="https://www.programiz.com/dsa/deletion-from-a-red-black-tree">这里</a> 讲的情况（不过实现上遵循了Knuth B树的定义，有单独的空节点层，空节点保留了对父节点的索引，与本文的实现有差别），复杂且难以理解，不适合作为算法学习的示例。</p>

<h4 id="思路2">思路2</h4>

<p>不采取传统的如前文提过的像 <code class="language-plaintext highlighter-rouge">bst_remove</code> 实现的那种删除方法，而是向下交换节点内容，确保被删除的节点至少有一个孩子为空。这样大大简化了重平衡需要考虑的情况。但是交换节点内容而不是节点本身，这本质上是非常 tricky的，会带来隐含的逻辑bug，不能称之为一个体面的解决办法。</p>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">RB</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">color</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">Black</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">Red</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="n">color</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
     	<span class="nd">unimplemented!</span><span class="p">()</span>   
    <span class="p">}</span>
  
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(3) -（惰性）替罪羊树</title><link href="/algs/BST-3-LSG-Tree.html" rel="alternate" type="text/html" title="BST(3) -（惰性）替罪羊树" /><published>2023-01-19T00:00:00+08:00</published><updated>2023-01-19T00:00:00+08:00</updated><id>/algs/BST%20-%203%20-%20LSG%20Tree</id><content type="html" xml:base="/algs/BST-3-LSG-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<h3 id="平衡校验">平衡校验</h3>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<h3 id="删除重平衡">删除重平衡</h3>

<h2 id="总装">总装</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(4) - 伸展树（Splay Tree）</title><link href="/algs/BST-4-Splay-Tree.html" rel="alternate" type="text/html" title="BST(4) - 伸展树（Splay Tree）" /><published>2023-01-19T00:00:00+08:00</published><updated>2023-01-19T00:00:00+08:00</updated><id>/algs/BST%20-%204%20-%20Splay%20Tree</id><content type="html" xml:base="/algs/BST-4-Splay-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<h3 id="平衡校验">平衡校验</h3>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<h3 id="删除重平衡">删除重平衡</h3>

<h2 id="总装">总装</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(5) - 树堆（Treep）</title><link href="/algs/BST-5-Treep.html" rel="alternate" type="text/html" title="BST(5) - 树堆（Treep）" /><published>2023-01-19T00:00:00+08:00</published><updated>2023-01-19T00:00:00+08:00</updated><id>/algs/BST%20-%205%20-%20Treep</id><content type="html" xml:base="/algs/BST-5-Treep.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<h3 id="平衡校验">平衡校验</h3>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<h3 id="删除重平衡">删除重平衡</h3>

<h2 id="总装">总装</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(1) - AVL树</title><link href="/algs/BST-1-AVL-Tree.html" rel="alternate" type="text/html" title="BST(1) - AVL树" /><published>2023-01-17T00:00:00+08:00</published><updated>2023-01-17T00:00:00+08:00</updated><id>/algs/BST%20-%201%20-%20AVL%20Tree</id><content type="html" xml:base="/algs/BST-1-AVL-Tree.html"><![CDATA[<p>前文介绍了<a href="./BST - 0 - Basic.md">二叉搜索树基础</a> ，这里是第一个自平衡的二叉搜索树 – AVL树，它是在1962年由前苏联的科学家 <a href="https://en.wikipedia.org/wiki/Georgy_Adelson-Velsky">Georgy Adelson-Velsky</a> 和 <a href="https://en.wikipedia.org/wiki/Evgenii_Landis">Evgenii Landis</a> 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。</p>

<p>顺带一提，有的地方讲 AVL 实现比红黑树复杂，这令人费解，因为不管相比原始红黑树还是左偏红黑树，AVL的实现都足够简单，而且易于理解。</p>

<h2 id="基本概念">基本概念</h2>

<p>AVL 对树平衡的要求是（每个节点）左右树高的差距不超过 1 。</p>

<p>定义 $\texttt{BF}$（Balance Factor）= 右子树高 - 左子树高，于是有 $\texttt{BF} \in $ { -1, 0, 1 } 。</p>

<p>于是我们需要一个额外的节点字段 $\texttt{height}$ 来辅助记录。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">height</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">});</span>
<span class="nd">impl_tree!</span><span class="p">(</span><span class="n">AVL</span> <span class="p">{});</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">AVL</span> <span class="k">-&gt;</span>
    <span class="k">fn</span> <span class="nf">rotate_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* update height */</span>
        <span class="n">x</span><span class="nf">.update_height</span><span class="p">();</span>
        <span class="n">z</span><span class="nf">.update_height</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}(h: {})"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="nd">height!</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="专属辅助">专属辅助</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">height!</span><span class="p">(</span>
                <span class="k">self</span><span class="p">,</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span>
                    <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">(),</span>
                    <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Static Stats</span>

    <span class="k">fn</span> <span class="nf">height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">height!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">bf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">-</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">AVL</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.recalc_height</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_bf</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Recursively validate BF:</span>
    <span class="cd">///</span>
    <span class="cd">/// BF(X): H(right(X)) - H(left(X))</span>
    <span class="cd">///</span>
    <span class="cd">/// BF(X) in {-1, 0, 1}</span>
    <span class="cd">///</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_bf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span>
            <span class="k">self</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_bf</span><span class="p">();</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_bf</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Recursively calculate height stats dynamically instead of using static height</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">recalc_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.recalc_height</span><span class="p">();</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.recalc_height</span><span class="p">();</span>

            <span class="k">self</span><span class="nf">.update_height</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="重平衡">重平衡</h2>

<p><strong>一般的重平衡操作</strong></p>

<p>从入口节点开始，一路向上直到根节点，检查每个节点是否失衡，如果失衡根据前文讲的情况：</p>

<ol>
  <li>较高的子树的方向与子树较高子树的方向一致，一次单旋；</li>
  <li>方向不一致，双旋</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl&lt;K: Ord, V&gt; AVL&lt;K, V&gt; </span>
<span class="c1">// ...</span>

<span class="cd">/// Bottom up fixing</span>
<span class="k">fn</span> <span class="nf">retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">p</span><span class="nf">.update_height</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">high</span> <span class="o">=</span>
            <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nd">left!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="p">{</span>
                <span class="nb">Right</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nb">Left</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">())</span><span class="nf">.height</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>对于插入操作简化后的重平衡：</strong></p>

<p>对于插入操作的重平衡操作，可以简化检查较高子树的方向这一步，因为总是检查重平衡所在的节点较高：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl ...</span>

<span class="nd">#[allow(unused)]</span>
<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">y</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* x
       |
       z
       |
       y
    */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">z</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">z</span><span class="nf">.update_height</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">index_of_z</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">index_of_y</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">index_of_z</span> <span class="o">==</span> <span class="n">index_of_y</span> <span class="p">{</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index_of_z</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index_of_z</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">AVL</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// self.insert_retracing(z);</span>
        <span class="k">self</span><span class="nf">.retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">retracing_entry</span> <span class="o">=</span> <span class="nd">bst_delete!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.retracing</span><span class="p">(</span><span class="n">retracing_entry</span><span class="p">);</span>

            <span class="nf">Some</span><span class="p">(</span><span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="py">.val</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前文介绍了二叉搜索树基础 ，这里是第一个自平衡的二叉搜索树 – AVL树，它是在1962年由前苏联的科学家 Georgy Adelson-Velsky 和 Evgenii Landis 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。]]></summary></entry><entry><title type="html">BST(0) - 二叉搜索树基础</title><link href="/algs/BST-0-Basic.html" rel="alternate" type="text/html" title="BST(0) - 二叉搜索树基础" /><published>2023-01-14T00:00:00+08:00</published><updated>2023-01-14T00:00:00+08:00</updated><id>/algs/BST%20-%200%20-%20Basic</id><content type="html" xml:base="/algs/BST-0-Basic.html"><![CDATA[<p>作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。</p>

<h2 id="定义">定义</h2>

<p>二叉搜索树是二叉树，但是额外需要每个节点满足：左孩子（如果有的话）的 key 比它的小，而右孩子的 key 比它的大 。</p>

<h2 id="实现前言">实现前言</h2>

<p>考虑如何在实现上（Rust）把本文介绍的二叉搜索树的基础操作作为后面实现的具体种类的带自平衡的二叉搜索树的基础 ，也就是怎么用一种比较好的方式复用这些代码。</p>

<p>对于像 C++/C#/Java 风格的同时继承数据和行为的面向对象语言，可以使用同心圆套圈儿的 “继承“ 来复用代码 。而对于 Rust 这种只有行为共享而没有数据共享的纯粹的抽象机制（Trait机制），由于不能对属性进行直接的访问，只能使用方法来访问属性，这会使实现的代码非常啰嗦（每次具体类型都需要实现一遍属性访问的方法）。另外一个问题在于由于对象需要放在堆上（避免定义上的循环引用和做对象的向上（upcast）或向下（downcast）地转换），实际上是使用 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;Node&gt;&gt;</code>，每次调用都要复杂解引用，这一点在前面 FibHeap 实现问题上已经讲过。</p>

<p>这里采取了完整包装（复杂包装）和重度使用宏机制来做代码复用 。</p>

<h3 id="完整包装">完整包装</h3>

<p>假定树的实际的内部节点为 <code class="language-plaintext highlighter-rouge">Node_</code>，包装器的节点为 <code class="language-plaintext highlighter-rouge">Node</code> ，为避免智能指针（<code class="language-plaintext highlighter-rouge">Rc</code>）造成的循环引用，还引入了包装器的弱引用版本 <code class="language-plaintext highlighter-rouge">WeakNode</code>，最后树结构为 <code class="language-plaintext highlighter-rouge">Tree</code> 。</p>

<h4 id="内部节点-node_-伪代码">内部节点 <code class="language-plaintext highlighter-rouge">Node_</code> 伪代码：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node_</span> <span class="p">{</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="p">,</span>
    
    <span class="n">key</span><span class="p">,</span>
    <span class="n">val</span>
<span class="p">}</span>
</code></pre></div></div>

<p>反向引用使用弱节点类型</p>

<h4 id="包装的节点-node-伪代码">包装的节点 <code class="language-plaintext highlighter-rouge">Node</code> 伪代码：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nf">Node</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>包装器可能是一个实际的节点，或者是 none</p>

<h4 id="弱引用的节点-weaknode">弱引用的节点 <code class="language-plaintext highlighter-rouge">WeakNode</code>：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nf">WeakNode</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>把强引用 <code class="language-plaintext highlighter-rouge">Rc</code> 替换成弱引用 <code class="language-plaintext highlighter-rouge">Weak</code></p>

<h4 id="树本身的结构">树本身的结构：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种完整包装的优点在于可以完美地上位替代传统的基于指针结构的树结构的实现，但是肉眼可见地过于复杂，比如如果我们要访问节点x 的左孩子：</p>

<p><code class="language-plaintext highlighter-rouge">x.0.clone().unwrap().as_ref().borrow().left</code></p>

<p>写这样出的代码简直是地狱！</p>

<p>好在可以用几乎完美的 Rust 宏来解决这件事</p>

<h3 id="用宏抽象">用宏抽象</h3>

<p><strong>关于使用宏来拓展语言的抽象机制主要有以下几个类别：</strong></p>

<ol>
  <li>函数分发：函数根据参数个数进行函数分发；</li>
  <li>代码 Mixin：定义语法 Item（结构体、函数、宏） ，实现方法；</li>
  <li>嵌套压缩：省略掉每次固定的一长串儿连续的属性访问与方法调用</li>
</ol>

<h4 id="压缩包装">压缩包装</h4>

<p>关于节点的访问的简化，是在前文 FibHeap 实现里面使用的那一套宏的升级。</p>

<p><strong>访问与修改节点的指定属性的宏：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="cm">/* to pass runtime borrow check  */</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
                <span class="n">_attr</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
            <span class="p">}</span>
    	<span class="p">}</span> 
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bor</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
                <span class="n">bor</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span> <span class="o">=</span> <span class="nv">$val</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>生成属性访问宏的宏：</strong></p>

<p>由于从 API 设计的角度，部分属性需要使用指针来绕过生命周期的限制，从而返回引用，所以生成宏特制了这一部分</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">ptr</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">}</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

            <span class="nn">concat_idents</span><span class="p">::</span><span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">name_mut</span> <span class="o">=</span> <span class="nv">$name</span><span class="p">,</span> <span class="n">_mut</span> <span class="p">{</span>
                <span class="nd">macro_rules!</span> <span class="n">name_mut</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">}</span>
                    <span class="p">};</span>
                <span class="p">}</span>
                <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="n">name_mut</span><span class="p">;</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>生成属性访问宏：</strong></p>

<p>显然其中节点的 key 和 val 都是存储在堆上（通过 Box），节点里保存唯一的指针</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro!</span><span class="p">(</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">height</span>
<span class="p">);</span>
<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">ptr</span> <span class="p">|</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>堆上数据封装与解包的宏：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>对内部节点封装与解包：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">BST</span> <span class="p">{</span> <span class="nv">$key:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">)</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>

            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$key</span><span class="p">),</span>
            <span class="n">val</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$val</span><span class="p">),</span>

            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span><span class="p">,</span>
            <span class="p">)</span><span class="o">*</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">FREE</span> <span class="p">{</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="辅助定义">辅助定义</h4>

<p><strong>实现内部节点：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_node_</span> <span class="p">{</span>
    <span class="p">({</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span><span class="p">)</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">left</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">K</span><span class="p">,</span>
            <span class="n">val</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">V</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span><span class="p">,</span>
            <span class="p">)</span><span class="o">*</span>
        <span class="p">}</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}: {:?}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.key</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.val</span> <span class="p">})</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>实现节点包装（强和弱）：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_node</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="cd">/// Used for reverse reference to avoid circular-reference</span>
        <span class="cd">///</span>
        <span class="cd">/// So we can easy auto drop</span>
        <span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="nf">WeakNode</span><span class="p">(</span>
                    <span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">}</span>

            <span class="nd">#[allow(unused)]</span>
            <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">rc</span><span class="nf">.as_ptr</span><span class="p">(),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="nd">#[allow(unused)]</span>
            <span class="k">fn</span> <span class="nf">replace_val</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">oldvptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldvptr</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="kc">false</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="o">=</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">strong</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"weak node upgrade failed"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">))</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>实现树：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_tree</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span> <span class="nv">$treename:ident</span> <span class="p">{</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span><span class="p">)</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
        <span class="nd">#[derive(Debug)]</span>
        <span class="k">pub</span> <span class="k">struct</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span><span class="p">,</span>
            <span class="p">)</span><span class="o">*</span>
        <span class="p">}</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span>
            <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span>
            <span class="p">{</span>
                <span class="cm">/* print header */</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>


                <span class="cm">/* print body */</span>

                <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
                <span class="p">}</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()];</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

                    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{x:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{x:?} | L-&gt; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{left:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                                <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                            <span class="p">}</span>

                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; R-&gt; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                            <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                            <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{right:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                                <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
                    <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                <span class="nf">Ok</span><span class="p">(())</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

                <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里在树的实现里的 <code class="language-plaintext highlighter-rouge">get</code> 方法，有 Trait 条件 <code class="language-plaintext highlighter-rouge">where K: Borrow&lt;Q&gt;, Q: Ord + ?Sized</code> ，这也是 Rust 标准库里对于数据结构的 <code class="language-plaintext highlighter-rouge">get</code> 方法普遍采取的约束条件。</p>

<p>在这里有必要说明一下关于 <strong>Borrow</strong> 与 <strong>AsRef</strong> 的区别有，这两个广泛使用的类型表示的 Trait 有相同的签名：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">Borrowed</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Borrowed</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">trait</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实现了上面的 Trait 比如 <code class="language-plaintext highlighter-rouge">Borrow</code> 就有 <code class="language-plaintext highlighter-rouge">K: Borrow&lt;Q&gt; =&gt; K.borrow(): &amp;Q</code></p>

<p>常见的都实现了两个 Trait 的比如 <code class="language-plaintext highlighter-rouge">String -&gt; &amp;str</code> , <code class="language-plaintext highlighter-rouge">PathBuf -&gt; &amp;Path</code></p>

<p>这两个 Trait 的区别在于：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Borrow</code> 有一个对于 <code class="language-plaintext highlighter-rouge">T</code> 的笼统类型实现（blanket implementation）：</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span> 
<span class="k">where</span> 
   <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span>
</code></pre></div></div>

<p>这让我们可以直接把 <code class="language-plaintext highlighter-rouge">&amp;K</code> 作为 <code class="language-plaintext highlighter-rouge">K.borrow()</code> 的返回类型，而 <code class="language-plaintext highlighter-rouge">AsRef</code> 由于类型系统的限制（为了避免另一个用于自动解引用的 blanket implementation 的重叠）</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">&amp;</span><span class="n">T</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="n">U</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
</code></pre></div></div>

<p>这个笼统实现是说任何 <code class="language-plaintext highlighter-rouge">T.as_ref() -&gt; &amp;U</code> 都有 <code class="language-plaintext highlighter-rouge">&amp;T.as_ref() -&gt; &amp;U</code> ，但其中 <code class="language-plaintext highlighter-rouge">AsRef&lt;U&gt;</code> 与 <code class="language-plaintext highlighter-rouge">AsRef&lt;T&gt;</code> 存在语义重叠的部分，而现有的类型系统没法儿进行区分（这非常可惜，也极大地限制了 Rust 充满想法的类型系统的生态发展）</p>

<ol>
  <li>Borrow 需要保证 <code class="language-plaintext highlighter-rouge">Hash, Eq, Ord</code> 与原类型的一致性</li>
</ol>

<p>对以上用于压缩包装和辅助定义的宏的具体用例不清楚的，可以参考后续的关于具体自平衡二叉搜索树介绍的博文</p>

<h4 id="错误定位">错误定位</h4>

<p>重度使用宏的编码方式的最大的问题在于，对几乎所有已知的编程语言，缺乏系统完整好用的调试手段，这是有待发展的领域，特别考虑到很多上世纪90年代创建的主流语言根本就没有宏机制 。</p>

<p>对于 Rust 宏代码最大问题在于无法准确定位宏中的错误和 Debug ，宏展开后的代码没法能还原为在原宏中的位置 。</p>

<p>所以为了缓解这个问题，需要我们手动的插入锚点，当调用失败的时候打印错误信息 。</p>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="左右方向">左右方向</h3>

<p>不管是左右孩子还是左右旋转，都需要一个指示方向是左还是右的结构</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">enum</span> <span class="n">Dir</span> <span class="p">{</span>
    <span class="nb">Left</span><span class="p">,</span>
    <span class="nb">Right</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nn">Dir</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="k">impl</span> <span class="n">Dir</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nb">Left</span> <span class="k">=&gt;</span> <span class="nb">Right</span><span class="p">,</span>
            <span class="nb">Right</span> <span class="k">=&gt;</span> <span class="nb">Left</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_left</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="访问孩子">访问孩子</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="nv">$p</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">right!</span><span class="p">(</span><span class="nv">$p</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="连接孩子">连接孩子</h3>

<p><strong>需要注意使用中会出现可能孩子或父母都是 none 的情况</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">conn_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$dir:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nv">$child</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nv">$paren</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paren</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">paren</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="nv">$dir</span><span class="p">,</span> <span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">conn_left</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">conn_child!</span><span class="p">(</span><span class="nv">$paren</span><span class="p">,</span> <span class="nv">$child</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">conn_right</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">conn_child!</span><span class="p">(</span><span class="nv">$paren</span><span class="p">,</span> <span class="nv">$child</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="索引孩子的方向">索引孩子的方向</h3>

<p>根据引用的相等性判断一个节点的孩子是它的左孩子还是右孩子</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">index_of_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$paren</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">Left</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">Right</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">unreachable!</span><span class="p">()</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="替换节点">替换节点</h3>

<p>这个操作可以称为：subtree_shift 或者 transplant ，就是把一个节点 u 从它的父节点那里替换为另一个节点 v 。</p>

<p>这需要检查节点 u ，如果是根节点，直接替换根节点，这时注意</p>

<ol>
  <li>替换的节点 v 的父节点仍然需要设置（设置为 none），因为有时要检查父节点是否为 none 来判断是否为根节点；</li>
  <li>当 u 为根节点时设置 v 的父节点时仍然需要检查 v 是否为 none</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">subtree_shift</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree:expr</span><span class="p">,</span> <span class="nv">$u:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nv">$u</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nv">$v</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">v</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="n">tree</span><span class="py">.root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                <span class="k">match</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">Left</span> <span class="k">=&gt;</span> <span class="nd">conn_left!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                    <span class="nb">Right</span> <span class="k">=&gt;</span> <span class="nd">conn_right!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小-vs-最大">最小 vs 最大</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Leftmost</span>
<span class="nd">macro_rules!</span> <span class="n">bst_minimum</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">while</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Right most</span>
<span class="nd">macro_rules!</span> <span class="n">bst_maximum</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">while</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最小/最大 一个是用于前驱/后继的查询，还可以用在从一个有序的数据集里快速构建搜索二叉树的时候（这时候每次插入节点时可以跳过逐层比较，直接找到最大值，插入它的右节点）</p>

<h3 id="前驱-vs-后继">前驱 vs 后继</h3>

<p>**Predecessor: **</p>

<p>该节点有左孩子，那么显然是左孩子（做为根的树）的最大值就是直接前驱；</p>

<p>否则，向上查询，如果节点恰好是是父节点的右孩子，那么父节点就是直接前驱，否则一路到根为止，向上 left-most ，直到一个是右孩子关系是父节点，这样要么找到一个节点，要么返回一个 none 节点</p>

<p><strong>Successor:</strong></p>

<p>该节点有右孩子，那么显然是右孩子（做为根的树）的最小值就是直接后继；</p>

<p>否则，向上 right-most 直到一个左孩子关系的节点或者返回一个 none 节点</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return predecessor-node or none-node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_predecessor</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="cm">/* child: left, right-most */</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">bst_maximum!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="cm">/* paren: left-most-up, right */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="k">while</span> <span class="n">y</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">left!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">y</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Return successor-node or none-node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_successor</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="cm">/* child: right, left-most */</span>
        <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">bst_minimum!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="cm">/* paren: right-most-up, left */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="k">while</span> <span class="n">y</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">y</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础操作">基础操作</h2>

<h3 id="递归-vs-展开">递归 vs 展开</h3>

<p>关于二叉搜索树的基础操作实现有递归的版本和展开的版本，传统上认为，递归的版本由于存在函数栈展开时的开销（保存/恢复 上下文），在时间效率上总是不如展开的版本，但实际上由于现代编译器的优化，情况可能相反。</p>

<p>比如在 C++ OJ 测试的时候，（插入新节点时）递归版本实际更快一点 。</p>

<p>由于递归的实现总是很简单，这里重点列出展开版本的代码</p>

<h3 id="搜索">搜索</h3>

<p>显然就是简单的二叉搜索，直到找到匹配的 key 或者节点耗尽</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">bst_search</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$k</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nv">$k</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="插入">插入</h3>

<ol>
  <li>先查询节点，直达找到同 key 的节点或者等下一层节点耗尽；</li>
  <li>同 key 节点更新，不同 key 按照大小关系插入，需要特别考虑根节点为空的情况</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return Option&lt;V&gt;</span>
<span class="nd">macro_rules!</span> <span class="n">bst_insert</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$z</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
	<span class="p">{</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$tree</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nv">$tree</span><span class="py">.root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="nf">.replace_val</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>相对复杂的一个操作，最后返回（可选地）需要执行重平衡操作的起始节点。</p>

<p>如果节点的左孩子或右孩子为空，直接用不为空的那一个孩子代替被删除的节点（这时重平衡的点就是被删节点的父节点）；</p>

<p>如果节点的孩子都不为空，就找它的直接后继，这又要分两种情况：</p>

<ol>
  <li>如果被删节点的右孩子没有左孩子，也就是右孩子本身就是直接后继，这样直接做右孩子对被删节点的 <code class="language-plaintext highlighter-rouge">subtree-shift</code> ，然后右孩子的左枝连接到被删节点的左孩子（重平衡点为右孩子）；</li>
  <li>如果有右孩子有左孩子，那么直接后驱就是右孩子的 left-most 假设为 y，这样相比第一种情况，首先还要额外处理 y 节点的右孩子的（left-most 没有左孩子），<code class="language-plaintext highlighter-rouge">subtree-shift</code> y 用 y 的右孩子，而让 y 的右枝连接被删节点的右孩子（重平衡点为 y 节点）</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return retracing node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_delete</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$z</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">retracing_entry</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">retracing_entry</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">retracing_entry</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-1       case-2

                 z            z
                  \            \
                   y            z.right
                               /
                              / (left-most)
                             y
                              \
                              y.right
            */</span>

            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// just ok</span>
                <span class="n">retracing_entry</span> <span class="o">=</span> <span class="n">y</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">y</span><span class="nf">.is_some</span><span class="p">());</span>
                <span class="n">retracing_entry</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                <span class="c1">// replace y with y.right</span>
                <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>

                <span class="c1">// connect z.right to y.right</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">retracing_entry</span>
    <span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="惰性插查删">惰性插/查/删</h3>

<p>对于一些没有严格平衡因素约束的二叉搜索树，可以采用另一种删除的方式，就是删除时只标记节点，当被标记的节点到达阈值时，重构整棵树，典型的比如替罪羊树（Scapegoat Tree）。</p>

<p>这样的话，当插入同 key 的新节点时可以恢复旧的被删节点，而查询时要排除被标记的节点。</p>

<h2 id="自平衡基础">自平衡基础</h2>

<p>二叉搜索树自平衡的基础是树的旋转（rotation），从模式上，又可以分为单旋和双次单旋 ，从方向上又可以分为左和右。</p>

<h3 id="单旋">单旋</h3>

<p>旋转的作用在于在保持 key 的大小关系的情况下调整某左右树的树高差距。如果右树过高，就向左旋转；如果左树过高，就向右旋转。</p>

<p>旋转完成后，根据不同种类的自平衡二叉树的需要，执行定制的用于收尾更新的 <code class="language-plaintext highlighter-rouge">rotate_cleanup</code> 操作，传入参数是旧的根 x 和旋转后新的根 z 。</p>

<p>以左旋为例子，根节点 x 变为左孩子，而让 x 的右孩子 z 变为根节点；源 z 的左孩子变为 x 的右节点；</p>

<p>右旋则是一个镜像相反的过程</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Simple Rotation (return new root)</span>
<span class="cd">/// ```no_run</span>
<span class="cd">///             left rotate</span>
<span class="cd">///    x        =========&gt;          z</span>
<span class="cd">///  /  \                          / \</span>
<span class="cd">/// t1   z                        x   t4</span>
<span class="cd">/// |   / \                      / \   |</span>
<span class="cd">///   t23 t4                    t1 t23 |</span>
<span class="cd">///     |  |                     |   |</span>
<span class="cd">///        |</span>
<span class="cd">///            right rotate</span>
<span class="cd">///     x      ==========&gt;           z</span>
<span class="cd">///   /  \                         /   \</span>
<span class="cd">///  z    t4                      t1    x</span>
<span class="cd">/// /  \   |                      |    /  \</span>
<span class="cd">///t1 t23                         |  t23  t4</span>
<span class="cd">/// |  |                              |    |</span>
<span class="cd">/// |</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="nd">macro_rules!</span> <span class="n">rotate</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$rotation</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rotation</span> <span class="o">=</span> <span class="nv">$rotation</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">z</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">t23</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">rotation</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">t23</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t23</span><span class="p">);</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">t23</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t23</span><span class="p">);</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">tree</span><span class="nf">.rotate_cleanup</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="n">z</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从模式上讲，当根节点 x 比较高的子树 y 的方向（左或右）与 y 较高子树的方向一致，只需要做一次单旋。</p>

<p>但如果不是这样呢，也就是两个较高子树的方向相反，就需要两次旋转，先在较高子树上旋转，使得两个较高子树的方向一致，然后再在根节点上旋转。</p>

<h3 id="双旋">双旋</h3>

<p>假设根节点 x 较高的子树 z 是 x 的右子树，而 z 的较高子树 y 是 z 的左子树：</p>

<ol>
  <li>先以 z 为根，向右旋转，结果是 y 代替了 z ，而 z 成了 y 的右孩子，于是根为 x 的树变成了都是右子树较高；</li>
  <li>以 x 为根，向左旋转，旋转完成</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Double Rotation (return new root)</span>
<span class="cd">/// ```no_run</span>
<span class="cd">///             rotate [right]-left         rotate right-[left]</span>
<span class="cd">///    x        =========&gt;         x        =========&gt;       y</span>
<span class="cd">///  /   \                        /  \                      / \</span>
<span class="cd">/// t1    z                      t1   y                    x   z</span>
<span class="cd">/// |   /  \                     |   / \                  / \ / \</span>
<span class="cd">///    y   t4                      t2   z                t1 t2t3t4</span>
<span class="cd">///   / \   |                       |  / \                |  | | |</span>
<span class="cd">///  t2 t3                            t3 t4</span>
<span class="cd">///   |  |                            |   |</span>
<span class="cd">/// ```</span>
<span class="nd">macro_rules!</span> <span class="n">double_rotate</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$snd_rotation</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">snd_rotation</span> <span class="o">=</span> <span class="nv">$snd_rotation</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="简单测试">简单测试</h2>

<p>其中 <code class="language-plaintext highlighter-rouge">balance_validation</code> 是每个特例定制的平衡校验方法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="nd">macro_rules!</span> <span class="n">test_dict</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$dict</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">get_one</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">rand</span><span class="p">::</span><span class="nn">random</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">dict</span> <span class="o">=</span> <span class="nv">$dict</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">batch_num</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">elems</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">keys</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

            <span class="cm">/* Verify Create */</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nf">get_one</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">;</span>

                <span class="k">if</span> <span class="n">keys</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">keys</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
                <span class="n">elems</span><span class="nf">.push</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

                <span class="nd">assert!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">(),</span> <span class="s">"insert res invalid"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">),</span> <span class="s">"insert query failed"</span><span class="p">);</span>

                <span class="c1">// println!("{i}. insert: ");</span>

                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">dict</span><span class="nf">.balance_validation</span><span class="p">();</span>

            <span class="cm">/* Verify Update */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">));</span>

                <span class="k">let</span> <span class="n">newv</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">500</span><span class="p">;</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newv</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
                <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newv</span><span class="p">);</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newv</span><span class="p">));</span>
            <span class="p">}</span>


            <span class="cm">/* Verify Remove */</span>

            <span class="k">use</span> <span class="nn">rand</span><span class="p">::{</span><span class="nn">prelude</span><span class="p">::</span><span class="n">SliceRandom</span><span class="p">,</span> <span class="n">thread_rng</span><span class="p">};</span>

            <span class="n">elems</span><span class="nf">.shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nf">thread_rng</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">),</span> <span class="s">"[dict remove] Assure get Some"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s">"[dict remove] Assert remove failed"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"[dict remove] Assure get None"</span><span class="p">);</span>

                <span class="c1">// sample to save time</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">dict</span><span class="nf">.balance_validation</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>

        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="后续">后续</h2>

<p>接下来介绍具体的自平衡二叉搜索树：</p>

<ol>
  <li>
    <p>AVL 树；</p>
  </li>
  <li>
    <p>Red-black 树（简称 RB）：</p>

    <ol>
      <li>原始红黑树 （部分实现）</li>
      <li>左偏红黑树 （Left-leaning Red-black Tree, LLRB）（介绍）</li>
      <li>AA 树 （完整实现）</li>
    </ol>
  </li>
  <li>
    <p>替罪羊树（（Lazy）Scapegoat Tree）；</p>
  </li>
  <li>
    <p>Splay 树；</p>
  </li>
  <li>
    <p>Treap</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。]]></summary></entry><entry><title type="html">编译器前端基础</title><link href="/algs/CompilerFrontEndBasic.html" rel="alternate" type="text/html" title="编译器前端基础" /><published>2022-12-23T00:00:00+08:00</published><updated>2022-12-23T00:00:00+08:00</updated><id>/algs/CompilerFrontEndBasic</id><content type="html" xml:base="/algs/CompilerFrontEndBasic.html"><![CDATA[<h2 id="关于龙书">关于龙书</h2>

<p>本篇介绍的基本概念来自于经典的龙书（<em>Compilers Principles, Techniques and Tools</em>））。而整个龙书，不幸地是，很多技术概念完全是以 类C 语言为前提做的介绍，从名字上，从章节目录上感到应该有帮助，实际没用。</p>

<p>另外对于 LR，LL 这些，似乎专注于做一个通用编译器的生成器，而不是编译器，而现在既然已有大量的通用生成器，但21世纪以来编程语言的发展趋势，是手写编译器，这背后一个重要原因机器性能的发展带来的质的变化：编译器性能得到了释放，手写可以得到更定制化地，更丰富特性地满足语言要求目标的复杂编译器。</p>

<p>在完成对于这些概念学习后，我得到的最大收获是这些东西确实没什么用。这里就不得不提一下计算机科学领域和某些领域一样，很喜欢把一些平常的概念，易见的规律冠以专有名词，搞得明明一眼明了的简单事情变得特别抽象，下面就有一个鲜活的例子。</p>

<p>因此我们对于这些概念的介绍也将专注于背后的算法思想，而不是照本宣科。</p>

<h2 id="再探-first-set--follow-set">再探 First Set &amp;&amp; Follow Set</h2>

<p>显然，但有必要强调，不管是 First Set 还是 Follow Set 针对得都是 <strong>非终结符（non-terminal）</strong></p>

<p>在提这两个概念的时候，我们假设语法规则以巴科斯范式（Backus Normal Form）的形式给出</p>

<h3 id="first-set">First Set</h3>

<p>是指，对于一个非终结符号，它的每条产生式（production）的首个（first）终结符（terminal）的集合 （包括特殊的 ε 符号）</p>

<h3 id="follow-set">Follow Set</h3>

<p>是指，对于一个非终结符号，在所有产生式构成的语法上，紧跟在该非终结符后面的终结符（包括特殊的 $ 符号表示语法的终结）</p>

<h2 id="shift-reduce">Shift-reduce</h2>

<p>LR（Leftmost rightmost-derivation）parsing 的核心操作是 shift-reduce ，它是一个有栈结构的优先状态机，要么暂时处理不了推入栈中，要么弹出栈中元素向上合并。</p>

<p>在手写编译器过程中，LR完全是用不上的，但可以在一点上发挥重要作用，就是按照操作符的优先级处理中缀表达式：就是把用二元中缀操作符处理成树型结构。</p>

<p>可以用后缀表达式也就是逆波兰式（Reverse Polish Notation，RPN）也就是后根序（Post-order，LRN（left right node））遍历的形式方便地表示这棵树。</p>

<p>如下是代码片段，完整见<sup id="fnref:m6parser-kit" role="doc-noteref"><a href="#fn:m6parser-kit" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return Reverse Polish Notation (RPN) form (or Post-order, LRN(left right node) traversal)</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">parse_infix_expr</span><span class="o">&lt;</span><span class="n">O</span><span class="p">:</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bops</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">O</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">pris</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">InfixExpr</span><span class="o">&lt;</span><span class="n">O</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">bops</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pris</span><span class="nf">.len</span><span class="p">());</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">bops</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Resort the Infix expression by precedence (they don't change left most expr srcloc)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">out_bop_stack</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">bops</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">out_pri_stack</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">pris</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">staging_bop_stack</span><span class="p">:</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">O</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">stack!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">expr_stack</span> <span class="o">=</span> <span class="nd">stack!</span><span class="p">[</span><span class="nn">InfixExpr</span><span class="p">::</span><span class="nf">E</span><span class="p">(</span><span class="n">out_pri_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())];</span>

    <span class="c1">// out_bop_stack would be same with out_pri_stack in size.</span>
    <span class="k">while</span> <span class="o">!</span><span class="p">(</span><span class="n">out_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">staging_bop_stack</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// Reduce</span>
        <span class="k">if</span> <span class="n">out_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span>
            <span class="p">||</span> <span class="o">!</span><span class="n">staging_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="n">staging_bop_stack</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.precedence</span><span class="p">()</span>
                    <span class="c1">// &gt;= for left associative operator</span>
                    <span class="o">&gt;=</span> <span class="n">out_bop_stack</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.precedence</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">bop</span> <span class="o">=</span> <span class="n">staging_bop_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">rhexpr</span> <span class="o">=</span> <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">lfexpr</span> <span class="o">=</span> <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="n">expr_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">lfexpr</span><span class="nf">.combine</span><span class="p">(</span><span class="n">bop</span><span class="p">,</span> <span class="n">rhexpr</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="c1">// Shift</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">staging_bop_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">out_bop_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="n">expr_stack</span><span class="nf">.push</span><span class="p">(</span><span class="nn">InfixExpr</span><span class="p">::</span><span class="nf">E</span><span class="p">(</span><span class="n">out_pri_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="ll">LL</h2>

<p>LL （Leftmost leftmost derivation）parsing 是一个从上到下的解析过程。</p>

<p>最常见的问题是左递归，就是某个非终结符的某个产生式的第一项是一个非终结符，这个非终结符直接或间接地会导会这个非终结符本身。</p>

<p>但这些都是形式推导方面的问题，通过重构生成式，使得终结符出现在产生式第一项可以解决这个问题。</p>

<h3 id="ll1">LL(1)</h3>

<p>参考<sup id="fnref:rust-ll1engine" role="doc-noteref"><a href="#fn:rust-ll1engine" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="lln">LL(n)</h3>

<p>基于状态机而不是形式符号推导</p>

<p>在手写编译器过程中，几乎不会考虑到形式推导里面的什么左递归什么二元歧义。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:m6parser-kit" role="doc-endnote">
      <p>https://github.com/minghu6/m6parserkit <a href="#fnref:m6parser-kit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rust-ll1engine" role="doc-endnote">
      <p>https://github.com/minghu6/rust-ll1engine <a href="#fnref:rust-ll1engine" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[关于龙书]]></summary></entry><entry><title type="html">字符编码（Character Encoding）</title><link href="/algs/CharEncoding.html" rel="alternate" type="text/html" title="字符编码（Character Encoding）" /><published>2022-12-20T00:00:00+08:00</published><updated>2022-12-20T00:00:00+08:00</updated><id>/algs/CharEncoding</id><content type="html" xml:base="/algs/CharEncoding.html"><![CDATA[<h2 id="序言">序言</h2>

<p>每次谈到技术标准的问题，就一定要探究一下相关历史，这样才能搞清楚一堆相关概念到底是什么意思，才能理解这个标准的意义到底在哪儿。</p>

<p>通常这个历史发展有三个阶段：</p>

<ol>
  <li>蛮荒时期，各参与实体相对独立开发，各有各的标准；</li>
  <li>过渡时期，为适应相关领域的发展，开始有一个统一的标准，但各实体的标准还继续起作用；</li>
  <li>大一统时期，统一的标准已经统一了应用，蛮荒时期的标准被废弃，只存在于个别非常旧的应用里</li>
</ol>

<p>对于字符编码这一领域，形成的统一标准是 Unicode<sup id="fnref:unicode-wiki" role="doc-noteref"><a href="#fn:unicode-wiki" class="footnote" rel="footnote">1</a></sup> ，它首先是一个抽象字符的码点（code point）方案，就是对每个字符编一个对应的数字编号。另外还提供了如何把字符编号转换成二进制的字节数据的官方编码方案 (Unicode Transformation Format)： UTF-8，UTF-16</p>

<p>Unicode 里的字符指得是“同义“而不是“同象“，“象”问题交给排版渲染系统，不过也存在为了兼容做出的特例，比如 CJK（中日韩）字符集里的宽字符标点符号等等，也就是仍然重复编码了一些抽象上同语义的字符。</p>

<h2 id="unicode-码点方案">Unicode 码点方案</h2>

<h3 id="码点空间">码点空间</h3>

<p>码点编号的空间是 $[0, \text{0x10FFFF}]$ ，也就是 $[0, 16]$ 共 $17$ 个 $\text{0xFFFF}$ ，也就是 $17 * 2^{16}$ 。</p>

<h3 id="码点平面plane">码点平面（plane）</h3>

<p>每个 $2^{16}$ 代表一个平面，这样编号了 $17$ 个平面，其中标号 $0$ 的平面用于基本字符的分配，这个平面也被叫做基本平面（BMP，Basic Multilingual Plane），而其他的平面叫做补充平面（Supplementary Planes）。</p>

<h3 id="码点块block">码点块（Block）</h3>

<p>每个平面又可以划分成块儿并唯一命名，每个块大小不一，但都是 $16$ 的倍数，也就是起始点都是十六进制的 $0$ ，也就是 $\text{XXX0}$ 。</p>

<h2 id="utf-8-编码">UTF-8 编码<sup id="fnref:utf8-wiki" role="doc-noteref"><a href="#fn:utf8-wiki" class="footnote" rel="footnote">2</a></sup></h2>

<p>以单字节为单位的变长编码</p>

<table>
  <thead>
    <tr>
      <th>Bytes Number</th>
      <th>Patten</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>one byte</td>
      <td>$\text{0xxxxxxx}$</td>
    </tr>
    <tr>
      <td>two bytes</td>
      <td>$\text{110xxxxx 10xxxxxx}$</td>
    </tr>
    <tr>
      <td>three bytes</td>
      <td>$\text{1110xxxx 10xxxxxx 10xxxxxx}$</td>
    </tr>
    <tr>
      <td>four bytes</td>
      <td>$\text{11110xxx 10xxxxxx 10xxxxxx 10xxxxxx}$</td>
    </tr>
  </tbody>
</table>

<h3 id="实现范例">实现范例</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">BitLen</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF8CharSt</span> <span class="p">{</span>
    <span class="n">First</span> <span class="p">{</span> <span class="n">partial</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">nbyte</span><span class="p">:</span> <span class="nb">u8</span> <span class="p">},</span>
    <span class="nf">Continue</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF8DecodeError</span> <span class="p">{</span>
    <span class="cd">/// Invalid Unicode</span>
    <span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>

    <span class="cd">/// &gt; 1111_0xxx</span>
    <span class="nf">OutRange</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span>

    <span class="cd">/// 10xx_xxxx</span>
    <span class="nf">TrailAtCodePoint</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span>

    <span class="cd">///</span>
    <span class="n">UnexpectedCodePoint</span> <span class="p">{</span>
        <span class="n">expect</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="n">found</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="p">},</span>

    <span class="n">UnexpectedEOF</span> <span class="p">{</span>
        <span class="n">expect</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="n">found</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF8EncodeError</span> <span class="p">{</span>
    <span class="cd">/// Invalid Unicode</span>
    <span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="nb">u16</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">UTF8Str</span> <span class="p">{</span>
    <span class="n">inner</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UTF8CharSt</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="n">UTF8DecodeError</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0x007F</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span>
                <span class="n">partial</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span>
                <span class="n">nbyte</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 10xx_xxxx, 0x80 - 0xBF</span>
        <span class="k">else</span> <span class="k">if</span> <span class="mi">0x80</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0xBF</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="nf">Continue</span><span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="c1">// 0011_1111</span>
        <span class="p">}</span>
        <span class="c1">// 110x_xxxx, 0xC0 - 0xDF</span>
        <span class="k">else</span> <span class="k">if</span> <span class="mi">0xC0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0xDF</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span>
                <span class="n">partial</span><span class="p">:</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mi">0x1F</span><span class="p">,</span> <span class="c1">// 0001_1111</span>
                <span class="n">nbyte</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 1110_xxxx, 0xE0 - 0xEF</span>
        <span class="k">else</span> <span class="k">if</span> <span class="mi">0xE0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0xEF</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span>
                <span class="n">partial</span><span class="p">:</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mi">0x0F</span><span class="p">,</span> <span class="c1">// 0000_1111</span>
                <span class="n">nbyte</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 1111_0xxx, 0xF0 - 0xF7</span>
        <span class="k">else</span> <span class="k">if</span> <span class="mi">0xF0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0xF7</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span>
                <span class="n">partial</span><span class="p">:</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mi">0x07</span><span class="p">,</span> <span class="c1">// 0000_0111</span>
                <span class="n">nbyte</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8DecodeError</span><span class="p">::</span><span class="nf">OutRange</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">UTF8Str</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">_c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="p">{}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="k">self</span><span class="py">.inner</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// Write order (Big endian)</span>
<span class="cd">/// -&gt; (step, char)</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_utf8_unicode</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">char</span><span class="p">),</span> <span class="n">UTF8DecodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ch_1st</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="nd">#[allow(unused)]</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0u32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">match</span> <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">ch_1st</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
        <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span> <span class="n">partial</span><span class="p">,</span> <span class="n">nbyte</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">partial</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">nbyte</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="nf">Continue</span><span class="p">(</span><span class="n">_partial</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8DecodeError</span><span class="p">::</span><span class="nf">TrailAtCodePoint</span><span class="p">(</span><span class="n">ch_1st</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">as</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8DecodeError</span><span class="p">::</span><span class="n">UnexpectedEOF</span> <span class="p">{</span>
            <span class="n">expect</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
            <span class="n">found</span><span class="p">:</span> <span class="n">bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="k">as</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">?</span> <span class="p">{</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="n">First</span> <span class="p">{</span> <span class="n">partial</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span> <span class="n">nbyte</span><span class="p">:</span> <span class="n">_</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8DecodeError</span><span class="p">::</span><span class="n">UnexpectedCodePoint</span> <span class="p">{</span>
                    <span class="n">expect</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
                    <span class="n">found</span><span class="p">:</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span>
                <span class="p">});</span>
            <span class="p">}</span>
            <span class="nn">UTF8CharSt</span><span class="p">::</span><span class="nf">Continue</span><span class="p">(</span><span class="n">partial</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">|</span> <span class="n">partial</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="mi">0xD800</span> <span class="o">&lt;=</span> <span class="n">acc</span> <span class="o">&amp;&amp;</span> <span class="n">acc</span> <span class="o">&lt;=</span> <span class="mi">0xDFFF</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8DecodeError</span><span class="p">::</span><span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="n">acc</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">char</span><span class="p">::</span><span class="nf">from_u32_unchecked</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="p">};</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decode_utf8_bytes</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UTF8DecodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">chars</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="nf">next_utf8_unicode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="n">step</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span>

        <span class="n">step</span> <span class="o">+=</span> <span class="n">nbytes</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="n">bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span> <span class="k">break</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode_utf8_char</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ch</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">UTF8EncodeError</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">if</span> <span class="mi">0xD800</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="mi">0xDFFF</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF8EncodeError</span><span class="p">::</span><span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">bitlen</span> <span class="o">=</span> <span class="n">ch</span><span class="nf">.bit_len</span><span class="p">();</span>

    <span class="c1">// 7</span>
    <span class="k">if</span> <span class="n">bitlen</span> <span class="o">&lt;=</span> <span class="mi">7</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// 5 + 6 = 11</span>
    <span class="k">if</span> <span class="n">bitlen</span> <span class="o">&lt;=</span> <span class="mi">11</span> <span class="p">{</span>
        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_2nd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b110x_xxxx, patch 5 bit, or 0xC0</span>
        <span class="k">let</span> <span class="n">byte_1st</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0x1F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0xC0</span><span class="p">;</span>

        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_1st</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_2nd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 4 + 6 * 2 = 16</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">bitlen</span> <span class="o">&lt;=</span> <span class="mi">16</span> <span class="p">{</span>
        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_3rd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_2nd</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b1110_xxxx, patch 4 bit, or 0xE0</span>
        <span class="k">let</span> <span class="n">byte_1st</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0xF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0xE0</span><span class="p">;</span>

        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_1st</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_2nd</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_3rd</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 3 + 6 * 3 = 21</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">bitlen</span> <span class="o">&lt;=</span> <span class="mi">21</span> <span class="p">{</span>
        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_4th</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_3rd</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b10xx_xxxx</span>
        <span class="k">let</span> <span class="n">byte_2nd</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0x3F</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0x80</span><span class="p">;</span>

        <span class="c1">// + 0b1111_1xxx, patch 4 bit, or 0xE0</span>
        <span class="k">let</span> <span class="n">byte_1st</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0x7</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span> <span class="p">|</span> <span class="mi">0xF8</span><span class="p">;</span>

        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_1st</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_2nd</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_3rd</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_4th</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"ch: {}, ({})"</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">bitlen</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="utf-16">UTF-16</h2>

<ol>
  <li>
    <p>对于基本平面中的码点，可以直接用对应 16 bit 单元表示的数字代表，不过实际的表示范围要小一点，是 $\text{0000 - DFFF}$ 和 $\text{E000 - FFFF}$</p>
  </li>
  <li>
    <p>对于补充平面上的码点，用两个 16 bit 单元构造，方法如下：</p>
  </li>
</ol>

\[\begin{array}{l}
\texttt{let}\ \text{codepoint U}\\
\texttt{let}\ \text{U'} \gets \text{U - 0x10000}\\
\texttt{let}\ \text{yyyyyyyyyyxxxxxxxxxx} \gets \text{U'}\\
\\
\texttt{Encode Into:} \\
\\
\text{110110yy yyyyyyyy} \\
\text{110111xx xxxxxxxx}
\end{array}\]

<p>共 $20$ 位，覆盖 $16$ 个补充平面</p>

<h3 id="实现范例-1">实现范例</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">const</span> <span class="n">BOM_U16_LE</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">0xFFFE</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">BOM_U16_BE</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">0xFEFF</span><span class="p">;</span>

<span class="nd">macro_rules!</span> <span class="n">split_u16</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">((</span><span class="nv">$name</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">,</span> <span class="p">(</span><span class="nv">$name</span> <span class="o">&amp;</span> <span class="mi">0xFF00</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF16EncodeError</span> <span class="p">{</span>
    <span class="cd">/// Invalid Unicode</span>
    <span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Overflow</span><span class="p">(</span><span class="nb">u32</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF16DecodeError</span> <span class="p">{</span>
    <span class="nf">Overflow</span><span class="p">(</span><span class="nb">u32</span><span class="p">),</span>
    <span class="n">UnexpectedEOF</span><span class="p">,</span>
    <span class="n">UnfinishedUnits</span><span class="p">,</span>
    <span class="n">ExpectHiFoundLow</span><span class="p">,</span>
    <span class="n">ExpectLowFoundHi</span><span class="p">,</span>
    <span class="n">ExpectHiFoundBMP</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">UTF16UnitSt</span> <span class="p">{</span>
    <span class="cd">/// Basic Multilingual Plane</span>
    <span class="nf">BMP</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>

    <span class="cd">/// Low surrogates, second unit, W2</span>
    <span class="nf">Lo</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>

    <span class="cd">/// Hign surrogates, first unit, W1</span>
    <span class="nf">Hi</span><span class="p">(</span><span class="nb">u16</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">UTF16UnitSt</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="n">UTF16DecodeError</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">unit</span><span class="p">:</span> <span class="nb">u16</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="k">if</span> <span class="n">unit</span> <span class="o">&lt;=</span> <span class="mi">0xD7FF</span> <span class="p">{</span>
            <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">BMP</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="mi">0xD800</span> <span class="o">&lt;=</span> <span class="n">unit</span> <span class="o">&amp;&amp;</span> <span class="n">unit</span> <span class="o">&lt;=</span> <span class="mi">0xDFFF</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="o">&lt;=</span> <span class="mi">0xDBFF</span> <span class="p">{</span>  <span class="c1">// 0b_1101_10xx_xxxx_xxxx</span>
                <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Lo</span><span class="p">(</span><span class="n">unit</span> <span class="o">&amp;</span> <span class="mi">0x03FF</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>               <span class="c1">// 0b_1101_11xx_xxxx_xxxx</span>
                <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Hi</span><span class="p">(</span><span class="n">unit</span> <span class="o">&amp;</span> <span class="mi">0x03FF</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 0xE000 &lt;= unit</span>
            <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">BMP</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">encode_utf16_le</span><span class="p">(</span>
    <span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ch</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">UTF16EncodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="mi">0xD800</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="mi">0xDFFF</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16EncodeError</span><span class="p">::</span><span class="nf">UTF16Surrogates</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="k">if</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">0x01_00_00</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">byte_1st</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">byte_2nd</span> <span class="o">=</span> <span class="p">((</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u8</span><span class="p">;</span>

        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_1st</span><span class="p">);</span>
        <span class="n">bytes</span><span class="nf">.push</span><span class="p">(</span><span class="n">byte_2nd</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="mi">0x1_00_00</span> <span class="o">&lt;=</span> <span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span> <span class="o">&lt;=</span> <span class="mi">0x10_FF_FF</span> <span class="p">{</span>
        <span class="c1">// U' = yyyyyyyyyyxxxxxxxxxx  // U - 0x10000</span>
        <span class="c1">// W1 = 110110yyyyyyyyyy      // 0xD800 + yyyyyyyyyy</span>
        <span class="c1">// W2 = 110111xxxxxxxxxx      // 0xDC00 + xxxxxxxxxx</span>

        <span class="c1">// low bits</span>
        <span class="c1">// 0b_1101_10_00_0000_0000 (10 bit) ..., 0xD800</span>
        <span class="k">let</span> <span class="n">unit_1st</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">0xDC00</span> <span class="p">|</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;</span> <span class="mi">0x3FF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>

        <span class="c1">// high bits 0b_1101_11_00_0000_0000, 0xDC00</span>
        <span class="k">let</span> <span class="n">unit_2nd</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">0xD800</span> <span class="p">|</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span> <span class="o">&amp;</span> <span class="mi">0x3FF</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">=</span> <span class="nd">split_u16!</span><span class="p">(</span><span class="n">unit_1st</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">)</span> <span class="o">=</span> <span class="nd">split_u16!</span><span class="p">(</span><span class="n">unit_2nd</span><span class="p">);</span>

        <span class="n">bytes</span><span class="nf">.extend_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16EncodeError</span><span class="p">::</span><span class="nf">Overflow</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>
    <span class="p">})</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">next_u16_unit</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">UTF16UnitSt</span><span class="p">,</span> <span class="n">UTF16DecodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16DecodeError</span><span class="p">::</span><span class="n">UnexpectedEOF</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">unit</span> <span class="o">=</span> <span class="p">((</span><span class="n">b1</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">|</span> <span class="n">b0</span> <span class="k">as</span> <span class="nb">u16</span><span class="p">;</span>

    <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// -&gt; (nbytes, utf16st)</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_u16_le_unicode</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="nb">char</span><span class="p">),</span> <span class="n">UTF16DecodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="k">match</span> <span class="nf">next_u16_unit</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
        <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">BMP</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nn">char</span><span class="p">::</span><span class="nf">from_u32</span><span class="p">(</span><span class="n">ch</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">())</span>
        <span class="p">},</span>
        <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Lo</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nf">next_u16_unit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">])</span><span class="o">?</span> <span class="p">{</span>
                <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">BMP</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16DecodeError</span><span class="p">::</span><span class="n">ExpectHiFoundBMP</span><span class="p">);</span>
                <span class="p">},</span>
                <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Lo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16DecodeError</span><span class="p">::</span><span class="n">ExpectHiFoundLow</span><span class="p">);</span>
                <span class="p">},</span>
                <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Hi</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">char</span><span class="p">::</span><span class="nf">from_u32</span><span class="p">((</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="p">|</span> <span class="n">lo</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">())</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="nn">UTF16UnitSt</span><span class="p">::</span><span class="nf">Hi</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">UTF16DecodeError</span><span class="p">::</span><span class="n">ExpectLowFoundHi</span><span class="p">);</span>
        <span class="p">},</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decode_utf16_le</span><span class="p">(</span>
    <span class="n">bytes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UTF16DecodeError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">chars</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="nf">next_u16_le_unicode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="n">step</span><span class="o">..</span><span class="p">])</span><span class="o">?</span><span class="p">;</span>

        <span class="n">step</span> <span class="o">+=</span> <span class="n">nbytes</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="n">chars</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="n">bytes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span> <span class="k">break</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个实现是考虑已知字节序是小段序的情况，关于 Unicode 有一个 BOM的概念，用来暗示字节序，如下面介绍 。</p>

<h2 id="bombyte-order-mark">BOM（Byte order mark）</h2>

<p>BOM 是放在文本流的开头，有特殊用途特别的 Unicode 字符：</p>

<ol>
  <li>声明字节序</li>
  <li>表明文本具有很高置信水平地采用了 Unicode 编码</li>
  <li>声明具体的 Unicode 编码方案</li>
</ol>

<p>UTF-16 ：UTF-16 小端序 FF FE ，UTF-16 大端序 FE FF</p>

<p>UTF-8：EF BB BF</p>

<p>GB18030：84 31 95 33</p>

<p>主要有用的是 UTF-16，因为对基本平面上的码点使用了双字节的数字表示，需要明确字节序才能正确编码，而诸如 UTF-8 通常就加 BOM ，因为显然字节序可以很容易地探测出来。</p>

<h2 id="gb18030">GB18030</h2>

<ol>
  <li>最早的码点并编码方案是1980年的 GB2312，双字节，构成，主要是简体和部分繁体以及其他国语言<sup id="fnref:gb2312-wiki" role="doc-noteref"><a href="#fn:gb2312-wiki" class="footnote" rel="footnote">3</a></sup>；</li>
  <li>在1984年，台湾地区的五家厂商退出了繁体字编码的 Big5 ，这两个编码的转换问题是早期繁体中文游戏经常面临的问题；</li>
  <li>在1993年，随着 Unicode 1.1 的出现，国标推出了对应的 GB13000.1-93 ， GBK 就是一个利用 GB2312 未使用码点装载 GB13000.1-93 中字符的 GB2312 拓展；</li>
  <li>在2000年，GB18030 第一版发布，到最新版，已经实现了 Unicode 所有码点： 单字节用于英欧字符，双字节用于兼容 GBK ，四字节用于 编码其他 Unicode</li>
</ol>

<h2 id="比较">比较</h2>

<p>首先虽然具体码点不一样，但 GB18030 毕竟编码了 Unicode 标准下的所有字符，也可以算非官方的 UTF 实现。</p>

<p>比较 UTF-8、UTF-16、GB18030：</p>

<ol>
  <li>UTF-16首先出局，它在任何情况下的空间性能都差于 GB18030；</li>
  <li>对于东亚字符 GB18030 显然是最好的选择；</li>
  <li>其他，It depends ，如果字符在拓展 GBK 中，那么 GB18030 仍然是最好的，否则如果在 UTF-8 下能用三字节表示，那就是 UTF-8 更优，如果 UTF-8 也是四字节表示，那就相当</li>
</ol>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:unicode-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Unicode <a href="#fnref:unicode-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:utf8-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/UTF-8 <a href="#fnref:utf8-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:gb2312-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/GB_2312 <a href="#fnref:gb2312-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[序言]]></summary></entry></feed>