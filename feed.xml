<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-03-27T16:26:23+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">加速 Rust 构建</title><link href="/lang/SpeedupRustBuilding.html" rel="alternate" type="text/html" title="加速 Rust 构建" /><published>2023-03-22T00:00:00+08:00</published><updated>2023-03-22T00:00:00+08:00</updated><id>/lang/SpeedupRustBuilding</id><content type="html" xml:base="/lang/SpeedupRustBuilding.html"><![CDATA[<p>阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow</p>

<p>总结了加速的注意事项：</p>

<ol>
  <li>拆分过大的 crate ，一个基本编译单元至少是一个 crate，拆分 crate 可以利用多核优势</li>
  <li>检查不必要的依赖，某些依赖可能会大幅拖慢编译时间</li>
  <li>避免不必要的多态，缩减编译时间</li>
  <li>为 release 也开启增量编译 <code class="language-plaintext highlighter-rouge">incremental = true</code> ，这会让cold build 慢一点，但是大幅加速 hot build，</li>
  <li>是对于被工具压缩的 crate，debug 策略会非常慢，需要对这些包<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides">单独设置 debug 策略</a></li>
</ol>

<p>​</p>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow]]></summary></entry><entry><title type="html">基于前缀树的持久化向量（TrieVec）</title><link href="/algs/TrieVec.html" rel="alternate" type="text/html" title="基于前缀树的持久化向量（TrieVec）" /><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><id>/algs/TrieVec</id><content type="html" xml:base="/algs/TrieVec.html"><![CDATA[<p>在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下<a href="./SpeedupRustBuilding">另篇关于降低构建时间的笔记</a>。</p>

<h2 id="前言">前言</h2>

<p>本篇作为一个阶段性的总结篇，介绍一个基于前缀树（Trie）的持久化向量（Vector）的实现<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ，以下用 TrieVec 简称。</p>

<p>一方面，Vector 作为函数式编程语言里的允许随机读写的数据结构，本身有很重要的意义，没有它，传统的用类 C 描述的算法就无法落地；</p>

<p>另一方面，讲到持久化数据结构，其实大部分都已涉及，只有持久化向量比较陌生并且比较复杂，有必要专门看一下；</p>

<p>最后，在看这个实现的过程中，会发现这是一个总体概念陌生但局部细节熟悉的数据结构，它可以串起之前介绍过的诸多数据结构，不管是结构特点、设计方案还是实现方法，是一个合适的阶段尾声。</p>

<h2 id="概念基础">概念基础</h2>

<p>TrieVec 本质上就像我们在<a href="/algs/DaryHeap.html">多叉堆</a>上那样的做法，只不过多叉堆建立在数组上，而 TrieVec 则以树的的形式组织。</p>

<p>比如对于一棵节点数宽度为 $2$ ，也就是 $2^2 = 4$ 阶的树，访问 idx = 54</p>

\[\begin{array}{l}
54 &amp;=\underbrace{11}\ \underbrace{01}\ \underbrace{10}\\
&amp;=\ \ \ 3\quad\ \ \ 1\quad\quad 2
\end{array}\]

<p>情况如下图：</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_exp.svg" width="65%" /></div>

<p>这要求树的完全平衡，也就是每个叶子到根的高度都一样，然后把数据存储在每个叶子上，这一点又和我们在<a href="/algs/BT-1-BPT.html">B+ 树</a>上的情况相似。</p>

<p>而对树层级的定义又和 <a href="./BST-2-RB-Tree-2-AA">AA 树</a> 是一样，用 level 的概念来描述是非常恰当的，叶子层的 level 是 $1$ ，空树的 level 是 $0$ 。</p>

<p>对于持久化的要求来讲，每次操作，Push/Pop/Update etc. 只需要复制从根节点到叶子一条路径的节点，对数级别的开销是一个可以接受的代价。</p>

<p>另外，对于某些时间敏感的任务，Clojure 还允许把持久化的结构转变为易变的结构（Transient）来做就地修改，然后再转回持久性结构，以避免复制开销。这样的话需要在每个节点上做出标识来追踪节点的创建者，在下一部分的<a href="#标记">标记</a>一节具体讨论。</p>

<p>与易变向量的节点，以及区分历史上由不同线程创建的节点。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>这里有一个优化的小改动<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup>，就是把 TrieVec 最后一个节点（Bucket）从 Trie 中单独拿出来，作为尾节点，这会使得 Clojure 里像 <code class="language-plaintext highlighter-rouge">conj</code> 这样等价于 push 的操作在常量时间里完成。我们计算 TrieVec 的结构时候需要把尾部节点的长度扣除。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="常量定义">常量定义</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">BIT_WIDTH</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="n">NODE_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MASK</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">NODE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="从-trie-size-反推-trie-height">从 Trie size 反推 Trie height</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">h</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">trie_height</span><span class="p">(</span><span class="nd">tailoff!</span><span class="p">(</span><span class="nv">$self</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">fn</span> <span class="nf">trie_height</span><span class="p">(</span><span class="n">trie_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">trie_size</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">x</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.ilog2</span><span class="p">()</span> <span class="o">/</span> <span class="n">BIT_WIDTH</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">h</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">h</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="根据总索引和当前层得到索引位置">根据总索引和当前层得到索引位置</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">idx</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$lv:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Precedence: '*' &gt; '&gt;&gt;' &gt; '&amp;'</span>
        <span class="nv">$idx</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nv">$lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BIT_WIDTH</span> <span class="o">&amp;</span> <span class="n">MASK</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="尾部偏移量">尾部偏移量</h4>

<p>也就是尾节点之前的元素数，也就是实际 Trie 的大小</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">tailoff</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">((</span><span class="nv">$self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">BIT_WIDTH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="标志">标志</h3>

<p>由于存在持久与易变版本间的转换，一个节点可能是持久版本的节点，也可能是历史上不同线程创建的易变节点。</p>

<p>这里使用 <code class="language-plaintext highlighter-rouge">u64</code> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>表示的 Thread id 作为标志，表示历史上创建易变节点的线程，Thread id 都大于 0 ，于是我们可以用 0 来表示持久版本的节点。</p>

<p>这样对于可编辑节点需要满足：</p>

<ol>
  <li>不是持久化节点</li>
  <li>不是历史上其他线程创建的节点</li>
</ol>

<p>不满足条件就需要复制节点，创造属于当前线程的节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.id</span><span class="p">()</span><span class="nf">.as_u64</span><span class="p">()</span><span class="nf">.get</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">no_edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">ID</span> <span class="o">=</span> <span class="nb">u64</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ID</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 使用的是前面 <code class="language-plaintext highlighter-rouge">DaryHeap</code> 使用过的分配在堆上的静态数组；</li>
  <li><code class="language-plaintext highlighter-rouge">def_node__heap_access</code> 宏使用的之前 B+ 树里面使用过的宏</li>
</ol>

<h3 id="节点包装">节点包装</h3>

<p>考虑到持久化数据结构的跨线程使用的情况，节点包装里面的引用计数器将不再采用之前的 <code class="language-plaintext highlighter-rouge">std::rc::Rc</code> ，而改用同步版本的 <code class="language-plaintext highlighter-rouge">std::sync::Arc</code> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup> 。</p>

<p>但即使如此，由于 Rust 的严格限制，我们仍然不能把 <code class="language-plaintext highlighter-rouge">Node</code> 跨线程使用，即使我们确信作为持久化的结构时，是可以这样安全使用的。在 <code class="language-plaintext highlighter-rouge">std::sync</code> 的包里有各种各样的同步手段：</p>

<ol>
  <li>临界区（Exclusive）</li>
  <li>惰性锁（LazyLock）</li>
  <li>单写锁（OnceLock）</li>
  <li>栅栏（Barrier）</li>
  <li>条件变量（CondVar）</li>
  <li>锁（Mutex）</li>
  <li>单次锁 （Once）</li>
  <li>读写锁 （RwLock）</li>
</ol>

<p>看了让人直呼好家伙，上世纪的那点儿古董玩意儿都让它给复活了😅，但是这里面没有我们需要的，我们的持久化结构实际避免了同步的需求，但是需要有一种机制让编译器知道这个情况以便能通过 Trait 检查，而显然标准库里没有提供这种手段。</p>

<p>不过我们自己可以通过定义一个新的包装结构，为它实现 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Send</code> 两个 Trait 来实现持久化结构需要的 Trait 语义，<a href="https://github.com/bamidev/unsafe-send-sync">已经有人干得很好了</a>，我们在它的基础上按照我们的需求改进，得到一个告知编译器通过同步检查的包装结构，<code class="language-plaintext highlighter-rouge">UnsafeSendSync</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="cd">/// 一个自动实现Trait的宏，细节不展开了</span>
<span class="nd">impl_unpack!</span><span class="p">(</span><span class="n">UnsafeSendSync</span> <span class="p">|</span> <span class="nb">AsRef</span><span class="p">,</span> <span class="nb">AsMut</span><span class="p">,</span> <span class="n">Deref</span><span class="p">,</span> <span class="n">DerefMut</span><span class="p">,</span> <span class="nb">From</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_ref_mut_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">_</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是我们重新修改了前面定义节点包装器的 <code class="language-plaintext highlighter-rouge">impl_node</code> 的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_node</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span><span class="p">(</span><span class="k">self</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="nv">$vis</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">rc</span><span class="nf">.as_ptr</span><span class="p">(),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
                    <span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="nf">.into_inner</span><span class="p">()</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="nv">$rc:ty</span><span class="p">,</span> <span class="nv">$wk:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$vis</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="cd">/// Used for reverse reference to avoid circular-reference</span>
        <span class="cd">///</span>
        <span class="cd">/// So we can easy auto drop</span>
        <span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$wk</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">WeakNode</span><span class="p">(</span>
                    <span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                            <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="kc">false</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="o">=</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">strong</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"weak node upgrade failed"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}))</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">oth</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">oth</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并更新节点包装的访问宏，增加新的用例：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span><span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ref_mut_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是得到我们自己定义的节点的访问宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div></div>

<p>并用它们定义一些节点包装上的方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">values!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="简单方法">简单方法</h2>

<p>首先定义下向量的持久化版本和易变版本共通的一些方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_trie_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
                <span class="n">tail</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="p">}</span>

        <span class="c1">// Alias as search to leaf, array_for, etc</span>
        <span class="k">fn</span> <span class="nf">down_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">)];</span>
                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>不同于 Clojure 里面的实现，我们检查尾节点的 <code class="language-plaintext highlighter-rouge">id</code> 而不是根节点的，因为尾节点才是首先被插入的节点</li>
</ol>

<h2 id="创建节点">创建节点</h2>

<p>定义一个创建节点的宏可以极大地方便我们后续持久性以及易变性数据结构推入或弹出节点的过程。</p>

<h3 id="基础创建">基础创建</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">single</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">);</span>
        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>
        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new_with_clone</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="带有容积参数的复制">带有容积参数的复制</h3>

<p>创建一个指定大小的数组，并在允许范围内复制一个既有节点。这既可以用在 <code class="language-plaintext highlighter-rouge">push</code> 时创建一个扩容的新节点，也可以用在 <code class="language-plaintext highlighter-rouge">pop</code> 时创建一个缩容的新节点，当然也可以原封不动地复制节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...    </span>
   <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">nod</span>
    <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>       
</code></pre></div></div>

<h3 id="复制时容量-1-1">复制时容量 +1/-1</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...        </span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
		
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">dec</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>

<p>值得注意的是，对 +1 复制与 -1 复制的实现行为有些不同，+1 复制要单独分为两种情况，这是因为它有一个额外的参数 <code class="language-plaintext highlighter-rouge">$v</code> ，也就是需要插入节点的值，而值的类型是异构的，不能动态地分发，只能手动静态地分发。</p>

<h2 id="push">Push</h2>

<h3 id="主流程">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建新路径">创建新路径</h3>

<p>创建一条从某 $\text{lv}$ 开始直到叶子( $\text{lv}=1$ )的新路径：</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_new_path.svg" width="40%" /></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Top-down clone new path from lv (1..h)</span>
<span class="k">fn</span> <span class="n">new_path</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">lv</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="n">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用了递归的实现，在原版的作为 Clojure 标准库的 Java 实现里所有 Trie 上的操作都采用了类似结构的递归的实现，这或许能简化一些代码，但是严重牺牲了代码的可读性：一方面接口丑陋，作为递归函数的代价，包含了过多不应该属于接口而是栈上临时的参数；另一方面递归本身又隐藏了细节，让人难以看清楚到底这个过程做了什么事情。因此后面我们将使用我们自己的展开版本的实现作为替代。</p>

<h3 id="推入尾节点">推入尾节点</h3>

<p>当 <code class="language-plaintext highlighter-rouge">push</code> 时发现尾节点已满时，需要把旧的尾节点推入 Trie 里面，按照 Trie 树高可以分为三种情况：</p>

<ol>
  <li>$\text{lv}=0$ ，也就是 Trie 为空的情况，把旧尾节点作为 Trie 的根；</li>
  <li>$\text{lv}=1$ ，此时发现根溢出，于是创建一个新的节点包含原来的旧根和推入的尾节点。但是更进一步地，可以推广到包含 $\text{lv}=1$ 在内的全部根溢出的情况，此时新根插入的不是原来的尾节点，而是 <code class="language-plaintext highlighter-rouge">new_path</code> 创建的包含尾节点的一整条路径；</li>
  <li>$\text{lv} \ge 2$ ，从根节点开始复制，注意选择合适的数组容量，当中间节点超过一层时，自顶向下地复制每一层的节点，并把上一层中间节点里对本层节点的引用更新为新创建的节点，当发现新的节点在一个还未创建的路径时，可以直接使用 <code class="language-plaintext highlighter-rouge">new_path</code> 创建到叶子的新路径，然后插入到上一层节点。</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Complete trie including case lv == 1</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">p_i</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span>
                <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// Go down through the branch</span>
        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">cur</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">old_cur</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">cur_i</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                        <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                        <span class="n">old_cur</span><span class="p">,</span>
                        <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="assoc">Assoc</h2>

<p>按照索引更新向量，如果索引和长度相等，就顺势插入。</p>

<p>和前面 <code class="language-plaintext highlighter-rouge">push_tail_into_trie</code> 同样自顶向下地复制一条只到叶子的路径，只不过前者相当于访问的索引是 <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> ，而这里使用的是传入的索引。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// idx in `[0, self.len()]` (update or push)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>

                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="pop">Pop</h2>

<h3 id="主流程-1">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// Get empty vec</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// Get non-empty tail</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">dec</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// the last two idx</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="弹出尾节点">弹出尾节点</h3>

<p>与 <code class="language-plaintext highlighter-rouge">push</code> 的操作相对的，当弹出尾部元素后发现尾节点为空时，需要把 Trie 最后一个节点弹出来作为尾节点。</p>

<p>有两点值得一讲：</p>

<ol>
  <li>
    <p>使用 <code class="language-plaintext highlighter-rouge">self.cnt - 2</code> 作为对 Trie 上最后一个节点的访问索引，因为此时原尾节点上只有一个元素，因此 Trie 上有 <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> 个元素；</p>
  </li>
  <li>
    <p>弹出尾节点可能会产生空路径，也就是唯一的子节点为空的节点，空路径可能会一路向上延伸，直到根节点<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>。对应推入尾节点时有根溢出的情况，这时应该叫做根不足吧😀。</p>

    <p>从结构上进行判断的话，需要从尾部再回溯到根，由于 Trie 节点没有对父节点的反向引用，所以在自顶向下过程中还要保存一下整条节点路径，然后进行检查。</p>

    <p>不过有更简单的，就是直接检查 Trie 的大小，是否弹出尾节点后后高度会下降</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// Get empty tail</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// tail size 1</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* pop root */</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="易变版本实现">易变版本实现</h2>

<h3 id="数据结构-1">数据结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Send</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>由于 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Send</code> 是自动 Trait，由于 Node 因为我们定义的 <code class="language-plaintext highlighter-rouge">UnsafeSendSync</code> 自动实现了这两个 Trait ，因此 <code class="language-plaintext highlighter-rouge">PTrieVec</code> 和 <code class="language-plaintext highlighter-rouge">TTrieVec</code> 也都自动实现了这两个 Trait ，但我们不喜欢让 <code class="language-plaintext highlighter-rouge">TTrieVec</code> 能后被跨线程的分发与访问，于是通过“负实现”取消这两个 Trait 的自动实现。</p>

<h3 id="transient">transient</h3>

<p>把持久向量变为属于当前线程的可变向量。</p>

<p>不会马上复制整棵树的所有节点，而只是 TrieVec 的根节点和尾节点。</p>

<p>使用宏 <code class="language-plaintext highlighter-rouge">ensure_editable</code> 作为警戒哨，确保最后得到一个属于当前线程的可变的节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">ensure_editable</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nv">$id</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">id</span> <span class="o">==</span> <span class="n">x</span><span class="nf">.id</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">ensure_editable!</span><span class="p">(</span><span class="nd">edit!</span><span class="p">(),</span> <span class="nv">$x</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">transient</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">TTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push-1">push</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">}</span>

	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="nd">edit!</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="c1">// WARNING: neq `tail.len` for it's array capcity</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">leaf_i</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span>
                    <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="n">leaf_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>


        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
   	<span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基本过程和持久化版本高度一致，有一个区别是：</p>

<ol>
  <li>持久化版本扩容时容量最多增加 $1$ ，而易变版本直接分配满额的节点；</li>
  <li>直接修改 TrieVec 头，<code class="language-plaintext highlighter-rouge">self.root</code>, <code class="language-plaintext highlighter-rouge">self.tail</code></li>
</ol>

<h3 id="assoc-1">assoc</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>      
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>


        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.id</span><span class="p">());</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-1">pop</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="persistent">persistent</h3>

<p>把易变版本转换回持久化版本。改一下头尾节点的标记就可以。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">persistent</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="nd">id_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span> <span class="o">=</span> <span class="nd">no_edit!</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="n">PTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 Rust 的编程模型，易变版本持久化后原来的易变版本保证无法访问，相比 Clojure 的 Java 实现会简化很多过程。</p>

<h2 id="调试方法">调试方法</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[cfg(test)]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_trie_test_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[allow(unused)]</span>
        <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
        <span class="k">where</span>
            <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="p">{</span>
            <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">fn</span> <span class="n">debug_print</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">tail</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"MAIN TRIE:"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">root</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {} #############</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{i:02}. {child:?}"</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">child_group</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">())</span>
                        <span class="nf">.collect</span><span class="p">();</span>
                    <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_group</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">println!</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// print tail</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"###################################</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"TAIL: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="尾声">尾声</h2>

<p><a href="">代码参考</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>参考自 <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">hyPiRion 介绍的系列博文</a> 和 <a href="https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha2/src/jvm/clojure/lang/PersistentVector.java">Clojure 源代码</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>https://hypirion.com/musings/understanding-persistent-vector-pt-3#the-rationale-for-tails <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>在原版 Clojure 的 Java 里，标志使用了原子类型，这主要是担心易变类型在跨线程使用时重新变为持久类型时的竞争问题，但是由于 Rust 的编程模型限制了易变类型不允许跨线程使用，因此就不需要变为原子类型 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Atomic Rc <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>对于树高至少为 $2$ 作为的 Trie 来讲，空路径应该是根节点的第二个孩子， <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下另篇关于降低构建时间的笔记。]]></summary></entry><entry><title type="html">BT(2) - B+树（TreeMap）</title><link href="/algs/BT-2-BPT2.html" rel="alternate" type="text/html" title="BT(2) - B+树（TreeMap）" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-2-BPT2</id><content type="html" xml:base="/algs/BT-2-BPT2.html"><![CDATA[<p>对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。</p>

<p>没错，现在我们就是要用前文实现的 B+ 树作为我们新 B+ 树的节点基础。当然这是一个递归的概念，我们也可以继续下去把这个新的 B+ 树的实现作为节点基础实现 B+ 树，如此 $3$ 层、$4$ 层的嵌套。但从 $m$ 常数的角度，两层就够了，再多也没有意义，通常 $m$ 也就是一百左右，次级的 B+ 树的 $m$ 最多也就是就是十几，已经什么空间了，何况因此获得的性能增长也呈指数级下降。</p>

<p>但是实现用前面实现的 B+ 树作为节点的基础，还需要实现额外的一些 public method ，包括增加字段，比如统计键值总数的 cnt 字段等等。但是如何扩写 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树一时难以论说，事实上扩写&amp;重构改动的代码比原代码还长，所以就把它放到下一篇介绍，那时将得到一个相对完整的 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树。</p>

<p>这里会列出一个作为节点实现 B+ 树的 <a href="#方法统计">TreeMap 需要实现的方法</a>，既作为下一篇的索引，也作为用其他 TreeMap 代替实现时的参考。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>这里增加了 <code class="language-plaintext highlighter-rouge">cnt</code> 统计字段和 <code class="language-plaintext highlighter-rouge">min_node</code> 用于快速范查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees powered by B+ tree</span>
    <span class="cd">///</span>
    <span class="n">BPT2</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>TreeMap 实现的 B+ 树和数组实现的 B+ 树在内部节点的设计上有质的不同。</p>

<p>数组版本的，键值和孩子是按照索引来排的，而 TreeMap 则是按照唯一的键值来排列的。这既省了事儿又另一方面多了事儿，整个节点状态维护的逻辑都发生了变化。</p>

<p>首先从节点布局上，内部节点的 <code class="language-plaintext highlighter-rouge">keys</code> 字段没有存在的意义，直接使用 <code class="language-plaintext highlighter-rouge">children</code> map，但是这样对 map 的键的维护就成了一个关键。如何选取一个合适的键来代表孩子呢？</p>

<p>有两种明显的思路：</p>

<ol>
  <li>就用节点的最小值作为键，这样查询起来非常快，可以快速失败，但是当节点的最小键发生变化时，必须向上更新 map 来维护这一性质；</li>
  <li>那么用任意孩子节点的任一一个键就不需要始终维护了，但这样的话查询的时候就不知道到底要落到哪一个键上，就查询左右两个键的孩子的所有键值也解决不了问题，因为它们也不一定都是最小键</li>
</ol>

<p>于是显然，我们采用把最小键最为子节点在父节点上的键的设计。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SUB_M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础方法">基础方法</h2>

<h3 id="搜索到叶子">搜索到叶子</h3>

<p>这里会用到 TreeMap 里面的一个配合方法，<code class="language-plaintext highlighter-rouge">low_bound_search</code> ，是搜索 $\geqslant k$ 的第一个节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf_r</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.low_bound_search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点访问">节点访问</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">min_key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.min_key</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">k</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"No min-key {:?}"</span><span class="p">,</span> <span class="nv">$x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点">创建节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">BPT</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">entries</span><span class="nf">.insert</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">);</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="一般公开方法">一般公开方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min_node</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="范围查询">范围查询</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
                <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span> <span class="o">=</span> <span class="n">entries</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">fst</span><span class="p">;</span>

                    <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="n">ent</span>
                    <span class="p">}</span>

                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="插入">插入</h2>

<h3 id="主流程">主流程</h3>

<p>插入的时候，检查是否需要更新 map 的索引。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* new min none */</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* insert into leaf */</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<p>索引更新需要一路向上检查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">old_k</span> <span class="o">!=</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* update x key */</span>

            <span class="k">let</span> <span class="n">old_p_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_p_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升">节点提升</h3>

<p>到目前位置 TreeMap 的节点实现给我们增加了很多麻烦，但当分裂节点的时候，就很简单了<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，这里的 <code class="language-plaintext highlighter-rouge">split_off</code> 的表现和 <code class="language-plaintext highlighter-rouge">Vec</code> 的一致。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span>
                <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">((</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x2_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">bpt!</span> <span class="p">{</span>
                <span class="n">x_k</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">x2_k</span> <span class="k">=&gt;</span> <span class="n">x2</span>
            <span class="p">};</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="c1">// insert new or update</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x2_k</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="删除">删除</h2>

<h3 id="主流程-1">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">remove_on_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<p><strong>在本方法和后面的重平衡方法里更新索引时很容易出错，需要仔细考虑，比如同时更新两个索引时可能会出现键值覆盖的问题。</strong></p>

<p><code class="language-plaintext highlighter-rouge">rank</code>：查询键排名，从 $0$ 开始</p>

<p><code class="language-plaintext highlighter-rouge">nth</code>：根据排名，返回键值，从 $0$ 开始</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.rank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">old_k</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// merge with left_sib (no need to update index)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sib_lf</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for right_sib (merge into left)</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="c1">// 由于没有prev，只能总是合并到左节点，好在此时叶子节点只有一个元素</span>
            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">));</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// remove x from p</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

                <span class="c1">// 不需要更新索引，因为 sib_rh 值更大</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_key_sib_rh</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_key_sib_rh</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.1</span><span class="p">;</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_key</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// try to redistribute with left</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// try to redistribute with right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// WARNING： it wll replace sib_rh with x</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">),</span> <span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">sib_rh_old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// 不需要像叶子节点那样两段儿更新是因为在叶子更新的时候，已经对 x 向上更新过了</span>
                <span class="c1">// Self::update_index(old_k, x);</span>
                <span class="c1">// children_mut!(p).insert(min_key!(sib_rh), sib_rh);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">sib_rh_old_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="测试">测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT2"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Internal</span> <span class="p">{</span> <span class="n">children</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">f</span>
                <span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Internal"</span><span class="p">)</span>
                <span class="nf">.field</span><span class="p">(</span><span class="s">"children"</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
                <span class="nf">.finish</span><span class="p">(),</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Leaf"</span><span class="p">)</span><span class="nf">.field</span><span class="p">(</span><span class="s">"entries"</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span><span class="nf">.finish</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{self:?}"</span><span class="p">);</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {lv} #############"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">println!</span><span class="p">();</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="校验方法">校验方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">);</span>

                        <span class="c1">// children!(child).validate();</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="c1">// entries!(child).validate();</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="方法统计">方法统计</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">BPT</th>
      <th style="text-align: center">Tree Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">select/select_mut</td>
      <td style="text-align: center">select_mut</td>
    </tr>
    <tr>
      <td style="text-align: center">remove etc.</td>
      <td style="text-align: center">remove</td>
    </tr>
    <tr>
      <td style="text-align: center">insert etc.</td>
      <td style="text-align: center">insert</td>
    </tr>
    <tr>
      <td style="text-align: center">search_to_leaf_r</td>
      <td style="text-align: center">low_bound_search</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">len</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min</td>
    </tr>
    <tr>
      <td style="text-align: center">promote</td>
      <td style="text-align: center">split_off</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">nth</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">rank</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">push_back</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">pop_first/pop_last</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min_key</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="总结">总结</h2>

<p>运行一个简单的基准测试，结果符合预期：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">环境</th>
      <th style="text-align: left">值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CPU</td>
      <td style="text-align: left">Intel Haswell Core i5-4590</td>
    </tr>
    <tr>
      <td style="text-align: left">Memory</td>
      <td style="text-align: left">16 GB</td>
    </tr>
    <tr>
      <td style="text-align: left">Key Size</td>
      <td style="text-align: left">8 Bytes</td>
    </tr>
  </tbody>
</table>

<p>最优配置：</p>

<p>$\text{SUB_M} = 20$</p>

<p>$10 \leqslant M \leqslant 20$</p>

<ol>
  <li>查询性能非常好，<strong>比 Rust 标准库里 HashMap 的查询速度还要快25%！</strong>但是这种加速不是 B+ 树结构本身所导致的，而是 Map 的使用使得节点的内存布局在缓存上更有利，也就是单一数组的 TreeMap 比起分离的两个数组更有利，换言之，<strong>直接使用单一数组实现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的 Map 性能会更好！</strong></li>
  <li>插、删的性能介于传统 BST 和 B 树、B+ 树之间</li>
</ol>

<p>这个结果符合了理论和经验上的预期，最后再补充一个对比测试：</p>

<p>B+ Tree <code class="language-plaintext highlighter-rouge">push_back</code>-<code class="language-plaintext highlighter-rouge">pop_first</code> vs Vec <code class="language-plaintext highlighter-rouge">push</code>-<code class="language-plaintext highlighter-rouge">remove(0)</code> on <code class="language-plaintext highlighter-rouge">u64</code></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M</th>
      <th>batch CroSS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">105</td>
      <td>1150</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td>2500</td>
    </tr>
  </tbody>
</table>

<p>也就是说当数据量要足够大才能发挥出算法上的性能才能抵消缓存的优势，而在最佳 M 范围下，数组实现具有明显优势。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>只不过看起来 <code class="language-plaintext highlighter-rouge">split_off</code> 大概也是得自己实现 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">比如 Vec&lt;KVEntry&lt;K, V&gt;&gt;</code> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。]]></summary></entry><entry><title type="html">BT(3) - B+树完整版以及B*性质</title><link href="/algs/BT-3-BPT_complete_with_star.html" rel="alternate" type="text/html" title="BT(3) - B+树完整版以及B*性质" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-3-BPT_complete_with_star</id><content type="html" xml:base="/algs/BT-3-BPT_complete_with_star.html"><![CDATA[<p>继承前两篇 <a href="/algs/BT-1-BPT.html">B+树(Vec)</a> 和 <a href="/algs/BT-2-BPT2.html">B+树(TreeMap)</a> 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在<a href="https://github.com/minghu6/rust-minghu6/tree/snapshot-2">这里</a></p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>为了 <code class="language-plaintext highlighter-rouge">pop_first</code> / <code class="language-plaintext highlighter-rouge">pop_last</code> 增加了最小、最大节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">max_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="新增简单方法">新增简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">entries</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.nodes</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">values</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">drop</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// collect all item without drop itself used for BPT2::remove</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">drain_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.min_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.max_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.max_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="修改的既有方法">修改的既有方法</h2>

<h3 id="插入">插入</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">x2</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* merge node */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_internal</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"min_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"max_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="新增方法">新增方法</h2>

<h3 id="push_back">push_back</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into max</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push_front">push_front</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into min</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="c1">// self.insert_into_leaf(x, k, v);</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_first">pop_first</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* min-key has no internal index */</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_last">pop_last</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_last</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">internal_and_idx</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rank">rank</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Start from 0 O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">rank</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>
                <span class="n">is_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">rem</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">rem</span> <span class="o">+=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">rk</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">is_err</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nth">nth</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return Nth child (start from 0), O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="split_off">split_off</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return [at, ...)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">split_off</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">oth</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">at</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">oth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">oth</span><span class="nf">.bulk_push_front</span><span class="p">(</span><span class="k">self</span><span class="nf">.bulk_pop</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">at</span><span class="p">));</span>

        <span class="n">oth</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="b-性质">B* 性质</h2>

<p>B* 就是在键值插入的时候如果发生节点溢出时，不急着先分裂节点，而是和删除时一样，首先尝试从邻居节点进行平衡操作。</p>

<h3 id="try_balacing">try_balacing</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution_eager</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vec_even_up</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">left_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">right_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left_old_len</span> <span class="o">&lt;</span> <span class="n">right_old_len</span>  <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_old_len</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span><span class="o">-</span><span class="n">right_old_len</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vec_even_up">vec_even_up</h3>

<p>保持左右的顺序前提下，平分左右两个数组。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Even up two vector using clone</span>
<span class="cd">///</span>
<span class="cd">/// (This implementation is inspired by Vec::remove)</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">/// use m6_common::vec_even_up;</span>
<span class="cd">///</span>
<span class="cd">/// /* case-0 left max for pop is easy (odd) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..7).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-1 the left is samller (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..8).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-2 the left is larger (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..4).collect();</span>
<span class="cd">/// let mut v1 = (4..6).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2]);</span>
<span class="cd">/// assert_eq!(v1, vec![3, 4, 5]);</span>
<span class="cd">///</span>
<span class="cd">///</span>
<span class="cd">/// /* case-3-0 the left is larger (given more than old_len) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..7).collect();</span>
<span class="cd">/// let mut v1 = (7..9).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2, 3, 4,]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7, 8]);</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">vec_even_up</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v0</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v0_old_len</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">v1_old_len</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">tnt</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">+</span> <span class="n">v1_old_len</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">cnt_lf</span> <span class="o">=</span> <span class="n">tnt</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">cnt_rh</span> <span class="o">=</span> <span class="n">tnt</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

    <span class="cm">/* Check if it's balanced? */</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">==</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">v1</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cnt_rh</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">v0_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">v1_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::{</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy_nonoverlapping</span><span class="p">,</span> <span class="n">read</span> <span class="p">};</span>

    <span class="c1">// V0 is smaller</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">&lt;</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="c1">// let v0_get = cnt_lf - v0_old_len;</span>
        <span class="k">let</span> <span class="n">v1_given</span> <span class="o">=</span> <span class="n">v1_old_len</span> <span class="o">-</span> <span class="n">cnt_rh</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">v0</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">v</span>
        <span class="p">});</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v1_given</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">cnt_rh</span>
            <span class="p">);</span>

            <span class="n">v1</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// V0 is larger</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0_given</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v0_ptr</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="n">v1</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Fill with dirty data</span>
            <span class="c1">// read(v0_ptr)</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">zeroed</span><span class="p">()</span>
        <span class="p">});</span>

        <span class="c1">// get ptr after resize to avoid realloc issue</span>
        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v0_given</span><span class="p">),</span>
                <span class="n">v1_old_len</span>
            <span class="p">);</span>

            <span class="nf">copy_nonoverlapping</span><span class="p">(</span>
                <span class="n">v0_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v0_given</span>
            <span class="p">);</span>

            <span class="n">v0</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>B* 没什么用，对插入的性能改进没有什么帮助</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[继承前两篇 B+树(Vec) 和 B+树(TreeMap) 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在这里]]></summary></entry><entry><title type="html">BT(1) - B+树（Vec）</title><link href="/algs/BT-1-BPT.html" rel="alternate" type="text/html" title="BT(1) - B+树（Vec）" /><published>2023-03-13T00:00:00+08:00</published><updated>2023-03-13T00:00:00+08:00</updated><id>/algs/BT-1-BPT</id><content type="html" xml:base="/algs/BT-1-BPT.html"><![CDATA[<p>在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。</p>

<p>如果说之前好不容易把观念从二叉搜索树转换到了 B 树，那么从现在开始，从 B 树到 B+ 树又需要有一个很大的观念转变。不过请放心，本文讲得是依靠 <code class="language-plaintext highlighter-rouge">Vec</code> 实现的 B+ 树，后面还会介绍用 <code class="language-plaintext highlighter-rouge">TreeMap</code> 实现的 B+ 树，那时又需要一个很大的观念转变。</p>

<p>整个 B 树系列计划了四篇文章，即使层层铺叠，每篇间的学习曲线都很陡峭，可谓是一山四绝弯！</p>

<h2 id="概念基础">概念基础</h2>

<p>B+ 树区别于普通 B 树的主要特点是中间节点有键无值<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ，而在最底层的叶子上存储数据。另外叶子节点存储有 next 指针，指向它的后继节点，为得是高效的范围查询。</p>

<p>由于更好的缓存适应性，B+ 树的基础操作 查/增/删 都明显快于普通 B 树，完全可以当做普通 B 树的上位替代。</p>

<h3 id="观念挑战">观念挑战</h3>

<p>虽然看起来只是一个小小的改变，但又一次颠覆了习惯的概念。</p>

<ol>
  <li>从二叉搜索树到 B 树，我们一直习惯的是键就是键值的代名词，但正如前面节点不再是键的代名词，这里键与值的关系也分开了；</li>
  <li>进一步考虑，这就出现了叶子上必然存在一个键，而中间节点里可能还存在一个重复的键；</li>
  <li>也就是说父节点的键与子节点键的大小关系也不同了，不仅是大于或者小于，还有可能是相等的关系</li>
</ol>

<p>因此这里还要明确一下：B+ 树父节点的键可能与子节点的最小键相等，这符合左闭右开的惯例。</p>

<h3 id="索引的重要性质">索引的重要性质</h3>

<p>不是叶子节点上的每一个键值都在内部节点上有一个键，在内部节点的键有两种情况：</p>

<p><img src="/assets/img/bt_bpt_vec/dupidx.png" alt="" /></p>

<ol>
  <li>每个根的叶子节点，除了第一个以外，每个叶子的最小键，都在这个这个根上有对应的键，就是左键<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>；</li>
  <li>第一个叶子节点除了最小的根以外，在根或者根的祖先上也有对应的键</li>
</ol>

<p>也就是说，<strong>所有中间节点的键由且仅由除了第一个节点以外的每个叶子节点的最小键组成</strong></p>

<p>在我做调查的过程中发现这个索引的性质在有的实现里并没有被尊重，这不会直接影响功能的实现，却破坏了 B+ 树的性质，引入了潜在的 Bug ：删除会导致中间节点存在废弃的键。</p>

<h3 id="重平衡">重平衡</h3>

<p>过程与 B 树一致，只是分裂节点时由弹出中间的键改为克隆中间的键，合并节点的时候只删除父节点对应键而不是并入节点，因此这里就不再赘述。</p>

<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">在线的 B+ 树的模拟页面</a></p>

<h2 id="实现-数据结构">实现-&gt;数据结构</h2>

<h3 id="树">树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>B+ 树叶子节点和内部节点的字段区别还是很大的，是否沿用之前的同构的设计是个值得思考的问题。</p>

<p>我们比较这两种设计的 drawback：</p>

<p>如果采用同构：</p>

<ol>
  <li>会有冗余字段，每个字段都占了至少是指针宽度的空间；</li>
  <li>节点看起来有些杂乱，严重降低代码可读性</li>
</ol>

<p>如果采用异构：</p>

<ol>
  <li>由于使用了枚举，导致之前积累的宏没法儿使用，需要重写一套，另外还要编写配套的内部节点的属性访问代码</li>
</ol>

<p>看起来没有哪一个是写起来又好又快的，但是我们再仔细考虑发现：</p>

<ol>
  <li>同构的设计还是需要一个单独字段来内省地判断自己是叶子节点还是中间节点，它和异构的枚举实现的区别本质上只是一个是手搓的、特化的，一个是系统的、泛化的；</li>
  <li>编程也有一个不可能三角：</li>
</ol>

<p><img src="/assets/img/bt_basic/prog_triangle.png" alt="" /></p>

<p>一般地，条件允许下，是牺牲部分代码简洁性，来保障另外的两个目标。</p>

<p>因此这里我还是采用了异构的设计：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">keys</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<p>内部节点的属性访问方法：</p>

<p>使用宏来统一描述这个方法，来避免无谓的代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Node_ heap data field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__heap_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Node_ WeakNode field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__wn_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是属性访问就可以写成：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这就可以写 B+ 树 专属的生成宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro_bpt</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="nv">$$val</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用它来生成节点包装 <code class="language-plaintext highlighter-rouge">Node</code> 的属性访问的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="实现-基础方法">实现-&gt;基础方法</h2>

<h3 id="搜索到叶子节点">搜索到叶子节点</h3>

<p>和 B 树的节点上的递归搜索方法一样，只是当在中间节点遇到相等的键时不是直接退出而是在它的右孩子上继续搜索。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询节点属性">查询节点属性</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小最大节点">最小/最大节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">min_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">max_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点包装">创建节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$keys:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">keys</span><span class="p">:</span> <span class="nv">$keys</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-简单方法">实现-&gt;简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-范围查询">实现-&gt;范围查询</h2>

<p>使用前面二叉搜索树里的 <code class="language-plaintext highlighter-rouge">mut_self</code> 宏来少些一点儿代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                <span class="c1">// Nil</span>
                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c1">// Leaf</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                        <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                    <span class="p">};</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_node</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">==</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="o">..</span><span class="p">];</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">range</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ent</span><span class="na">.1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="o">..</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-插入">实现-&gt;插入</h2>

<h3 id="插入主流程">插入主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升方法">节点提升方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-删除">实现-&gt;删除</h2>

<p>这里特别需要注意的是，</p>

<h3 id="删除主流程">删除主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>    

	<span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_internal_key</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">internal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">i_idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">new_key</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="cm">/* check remain node */</span>

            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="c1">// right sib</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="cm">/* use default (left first)*/</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">internal</span><span class="p">)[</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Exclude leaf node and nil node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="c1">// Left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">);</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="合并节点">合并节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="c1">// update pred</span>
            <span class="k">if</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">pred!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-测试">实现-&gt;测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
	<span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">writeln!</span><span class="p">(</span>
                            <span class="n">f</span><span class="p">,</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性质校验">性质校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
    <span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert_eq!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                            <span class="s">"{child:?}"</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                            <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nd">assert_eq!</span><span class="p">(</span>
                                    <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span>
                                <span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="cm">/* search obsoleted key */</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nd">search_to_leaf!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">leaf</span><span class="nf">.is_none</span><span class="p">()</span>
                                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span>
                                    <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span>
                                <span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span>
                            <span class="p">{</span>
                                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Found obsoleted key: {k:?}"</span><span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                            <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="nd">last_key!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">last_key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这是等价转换后的说法，原始说法是所有的节点都只保留键，而在底部额外加一层数据节点 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>反证法，如果那个左键与叶子节点上的不相等，那么那个左键就找不到对应的键值了 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。]]></summary></entry><entry><title type="html">单词与短语</title><link href="/oth/WordAndPhase.html" rel="alternate" type="text/html" title="单词与短语" /><published>2023-02-27T00:00:00+08:00</published><updated>2023-02-27T00:00:00+08:00</updated><id>/oth/WordAndPhase</id><content type="html" xml:base="/oth/WordAndPhase.html"><![CDATA[<h2 id="a">A</h2>

<h3 id="a-grinding-halt">a grinding halt</h3>

<p>陷入停顿</p>

<ol>
  <li>Memory-hogging programs can deplete the system’s memory, bringing the whole system to <strong>a grinding halt</strong>.</li>
</ol>

<h2 id="b">B</h2>

<h2 id="c">C</h2>

<h3 id="contemporary">Contemporary</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈtempəˌrerē/</code></p>

<p>当代的</p>

<ol>
  <li>Such devices are hard to find on <strong>contemporary</strong> computers.</li>
</ol>

<h3 id="consensus">Consensus</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈsensəs/</code></p>

<p>noun</p>

<p>共识</p>

<ol>
  <li>However, it may take some time to come to a <strong>consensus</strong> on a final control solution.</li>
</ol>

<h2 id="d">D</h2>

<h3 id="deplete">Deplete</h3>

<p><code class="language-plaintext highlighter-rouge">/dəˈplēt/</code></p>

<p>verb</p>

<p>耗尽</p>

<ol>
  <li>Memory-hogging programs can <strong>deplete</strong> the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h3 id="dedicate">Dedicate</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkāt/</code></p>

<p>verb</p>

<p>奉献</p>

<h3 id="dedicated">Dedicated</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkādəd/</code></p>

<p>adj</p>

<p>专用的</p>

<p>This enables batch managers monitoring jobs running in <strong>dedicated</strong> cpusets to efficiently detect what level of memory pressure that job is causing。</p>

<h2 id="e">E</h2>

<h2 id="f">F</h2>

<h2 id="g">G</h2>

<h2 id="h">H</h2>

<h3 id="hog">Hog</h3>

<p><code class="language-plaintext highlighter-rouge">/hôɡ,häɡ/</code></p>

<p>verb</p>

<p>抢占</p>

<ol>
  <li><strong>Memory-hogging</strong> programs can deplete the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h2 id="i">I</h2>

<h3 id="imminent">Imminent</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈimənənt/</code></p>

<p>adj</p>

<p>迫在眉睫的</p>

<ol>
  <li>This can include the cgroup oom notifier behavior when a collection of tasks is completely out of memory, but can also warn when such a condition may be <strong>imminent</strong>.</li>
</ol>

<h3 id="initiative">Initiative</h3>

<p><code class="language-plaintext highlighter-rouge">/iˈniSHədiv/</code></p>

<p>noun</p>

<p>积极性、倡议</p>

<ol>
  <li>these new <strong>initiatives</strong> of offering better control to the user in selecting the process to be the sacrificial lamb are steps to a robust design to give more control to the user.</li>
</ol>

<h2 id="j">J</h2>

<h2 id="k">K</h2>

<h3 id="keep-account-of">keep account of</h3>

<p>记录</p>

<ol>
  <li>This chapter describes the structures used to <strong>keep account of</strong> memory banks, pages and the flags that affect VM behaviour.</li>
</ol>

<h2 id="l">L</h2>

<h2 id="m">M</h2>

<h3 id="metric">Metric</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈmetrik/</code></p>

<p>adj</p>

<p>noun</p>

<p>（系统、标准）衡量</p>

<ol>
  <li>The memory_pressure of a cpuset provides a simple per-cpuset <strong>metric</strong> of the rate that the tasks in a cpuset are attempting to free up in use memory on the nodes of the cpuset to satisfy additional memory requests.</li>
</ol>

<h2 id="n">N</h2>

<h2 id="o">O</h2>

<h3 id="out-of-curiosity">out of curiosity</h3>

<p>出于好奇</p>

<ol>
  <li><strong>Out of curiosity</strong> I compiled both versions and ran objdump on the binaries, to see how many bytes were saved.</li>
</ol>

<h3 id="overlook">Overlook</h3>

<p>verb</p>

<p>忽视</p>

<ol>
  <li>The primary reason is that they have been run passively, “fire and forget” style, with no additional analysis, and all problems were <strong>overlooked</strong>.</li>
</ol>

<p>从上面看</p>

<h2 id="p">P</h2>

<h3 id="put-simply">put simply</h3>

<p>简单说</p>

<ol>
  <li><strong>Put simply</strong>, it costs less to balance between two smaller sched domains than one big one, but doing so means that overloads in one of the two domains won’t be load balanced to the other one.</li>
</ol>

<h3 id="proper">Proper</h3>

<p>adj</p>

<p>正确的</p>

<p>合适的</p>

<ol>
  <li>Active benchmarking helps you accurately test the true target of the benchmark, and <strong>properly</strong> understand its results</li>
</ol>

<p>adv</p>

<ol>
  <li>令人满意地、正确地</li>
</ol>

<h3 id="properly">Properly</h3>

<p>adv</p>

<p>正确地</p>

<p>properly understand vs understand proper</p>

<h2 id="q">Q</h2>

<h2 id="r">R</h2>

<h3 id="rule-out">rule out</h3>

<p>排除</p>

<ol>
  <li>This approach can specify only one name at a time, <strong>ruling out</strong> the possibility of a hierarchy</li>
</ol>

<h2 id="s">S</h2>

<h3 id="substantial">Substantial</h3>

<p><code class="language-plaintext highlighter-rouge">/ˌsəbˈstan(t)SHəl/</code></p>

<p>adj</p>

<ol>
  <li>
    <p>相当数量的</p>
  </li>
  <li>
    <p>实质性的</p>
  </li>
  <li>
    <p>This policy can provide <strong>substantial</strong> improvements for jobs that need to place thread local data on the corresponding node</p>
  </li>
</ol>

<h3 id="stall">Stall</h3>

<p><code class="language-plaintext highlighter-rouge">/stôl/</code></p>

<p>n.</p>

<p>（市场）摊位、隔间</p>

<p>（马厩、谷仓中动物的）隔间</p>

<p>verb</p>

<p>（引擎）停止运行</p>

<ol>
  <li>It’s intended to be simple, minimizing variation caused by cache misses, <strong>stall cycles</strong>, and branch misprediction.</li>
</ol>

<p>停滞（取得进展）</p>

<h2 id="t">T</h2>

<h3 id="tame">Tame</h3>

<p><code class="language-plaintext highlighter-rouge">/tām/</code></p>

<p>adj 温顺的</p>

<p>verb 驯服</p>

<ol>
  <li>This calls for a different design to <strong>tame</strong> the OOM killer.</li>
</ol>

<h2 id="u">U</h2>

<h3 id="utilize">Utilize</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈyo͞odlˌīz/</code></p>

<p>verb</p>

<p>利用</p>

<p>underutilize 未利用</p>

<ol>
  <li>If one CPU is <strong>underutilized</strong>, kernel code running on that CPU will look for tasks on other more overloaded CPUs and move those tasks to itself,</li>
</ol>

<h2 id="v">V</h2>

<h2 id="w">W</h2>

<h2 id="x">X</h2>

<h2 id="y">Y</h2>

<h2 id="z">Z</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[A]]></summary></entry><entry><title type="html">BT(0) - B树</title><link href="/algs/BT-0-BT.html" rel="alternate" type="text/html" title="BT(0) - B树" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/algs/BT-0-BT</id><content type="html" xml:base="/algs/BT-0-BT.html"><![CDATA[<p>B 树是波音实验室的 <a href="https://en.wikipedia.org/wiki/Rudolf_Bayer">Rudolf Bayer</a> and <a href="https://en.wikipedia.org/wiki/Edward_M._McCreight">Edward M. McCreight</a> 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。</p>

<p>本系列将介绍 B 树以及 B+ 树、B+ 树的 TreeMap 实现、 B+* 树等一些列算是 B 树的变种。</p>

<h2 id="概念基础">概念基础</h2>

<p>B 树是<strong>完全平衡</strong>的<strong>多路搜索树</strong>，基本上已经是传统红黑树的上位替代。</p>

<ol>
  <li>节点数的减少，极大地节省了内存；</li>
  <li>在 Intel 这样的大缓存 CPU 架构下，性能明显高于传统二叉搜索树</li>
</ol>

<p><strong>完全平衡</strong>指得是每个叶子节点到根节点的深度相等。</p>

<p>B 树节点一般可以分为最后一层的叶子节点（leaf）和中间的节点（internal），当B 树只有一层的时候，那就只有叶子节点。</p>

<p>对于 $m$ 阶 B 树（最多有 $m$ 个孩子）有这样的性质：</p>

<ol>
  <li>中间节点的键数 $N_{\large\text{key}} \in [\lceil {\large\frac{m}{2}}\rceil-1,m)$</li>
  <li>叶子节点的键数 $N_{\large\text{key}} \in [1,m)$</li>
</ol>

<p>其中根节点比较特殊，对于高度大于 $1$ 的 B 树，根节点显然属于是中间节点，但它可以像叶子节点一样最少只有单键<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。因此一些介绍里把 internal 节点的概念定义为不包括根节点，而另外的介绍里则保留这种矛盾，这是让初学者很困惑的一个地方。</p>

<p>而中间节点的最小键数 $\lceil {\large\frac{m}{2}}\rceil-1$  ，是由一个溢出节点的分裂过程推导出的：</p>

<p>假设一个节点溢出了，则此时它有 $m$ 个键，此时应该取出中间的一个键，推到父节点上，然后把左右两边的键平分为两个节点。这种情况下 $\lceil{\large\frac{m}{2}}\rceil + \lceil{\large\frac{m}{2}}\rceil - 2 = m + 1 - 2 = m - 1$ 。</p>

<p>并且显然，应该有 $m \geqslant 3$ ，二叉树一个节点里只有一个键，没有节点分裂与合并的空间。</p>

<h2 id="重平衡">重平衡</h2>

<p>我们把对插入时节点键值溢出和删除时节点键值不足的情况的处理操作，按照前文二叉搜索树的惯例，也一样地称之为重平衡。</p>

<p>文字说明未必直观，可以通过<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">在线的 B 树的模拟页面</a>直观地体验算法过程</p>

<h3 id="插入">插入</h3>

<p>当插入某个键后发现节点溢出了，就要分裂节点：</p>

<ol>
  <li>把中间的一个键提升到父节点，其余的键分到左右两个新节点<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> ；</li>
  <li>递归地在父节点上调用，直到根节点；</li>
  <li>当根节点溢出时，中间的键单独构成一个新节点，作为新的根节点<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，算法终止</li>
</ol>

<h3 id="删除">删除</h3>

<p>当删除某个键后发现节点不足，就要<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">4</a></sup>：</p>

<ol>
  <li>尝试<strong>节点重平衡</strong>；</li>
  <li>如果平衡失败，递归地<strong>合并节点</strong></li>
</ol>

<p>尝试<strong>节点重平衡</strong>（try rebalancing）：</p>

<ol>
  <li>如果有左邻居，检查左邻居节点是否有多余的键：
    <ol>
      <li>如果有，弹出最大的键替换父节点的键，而把原父节点的键插入到目标节点，分配成功；</li>
      <li>否则，继续检查</li>
    </ol>
  </li>
  <li>如果有右邻居，检查右邻居节点是否有多余的键：
    <ol>
      <li>如果有，弹出最小的键替换父节点的键，而把原父节点的键插入到目标节点，分配成功；</li>
      <li>否则，重平衡失败</li>
    </ol>
  </li>
</ol>

<p>下图假设了一个 $m=3$ 的 B 树删除情况，空白节点是被删除的 $4$ ：</p>

<p><img src="/assets/img/bt_basic/rebalancing_1.png" alt="" /></p>

<p>之后情况变为如下所示：</p>

<p><img src="/assets/img/bt_basic/rebalancing_2.png" alt="" /></p>

<p>递归地<strong>合并节点</strong>：</p>

<ol>
  <li>把左邻居节点、对应父节点的键和目标节点合并<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup>；</li>
  <li>递归地在父节点上调用，直到根节点；</li>
  <li>当根节点的键不足时，弹出它的孩子<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>作为新的根节点<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup></li>
</ol>

<h2 id="实现-数据结构">实现-&gt;数据结构</h2>

<h3 id="辅助宏">辅助宏</h3>

<p>就像前文二叉搜索树那样，我们首先通过一个宏，来描述这个系列的 B 树的代码结构，来避免无谓的重复<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>：</p>

<p>其中 M 表示阶数，这也暗示我们的节点将不再像二叉搜索树那样在字段名上分出键和孩子的顺序，而是采用更一般化地安排。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_tree</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span>
        <span class="nv">$treename:ident</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr:meta]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="k">=&gt;</span>
    <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
        <span class="k">pub</span> <span class="k">struct</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_low_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_high_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>节点包装 <code class="language-plaintext highlighter-rouge">Node&lt;K, V&gt;</code> 沿用<a href="/algs/BST-0-Basic.html#完整包装">二叉搜索树里的实现</a>。</p>

<p>而我对属性访问相关的宏 <code class="language-plaintext highlighter-rouge">attr</code> 和 <code class="language-plaintext highlighter-rouge">def_attr_macro</code> ，为了更加丰富的功能和完整一致的语义而进行了重构：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Evil hack for Rc&lt;RefCell&lt;T&gt;&gt;</span>
<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bor</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="n">bor</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span> <span class="o">=</span> <span class="nv">$val</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$</span><span class="p">((</span><span class="nv">$name:ident</span><span class="p">,</span><span class="nv">$ty:ty</span><span class="p">)),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">];</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="b-树结构">B-树结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B-Trees</span>
    <span class="cd">///</span>
    <span class="cd">/// Panic: M &gt; 2</span>
    <span class="cd">///</span>
    <span class="cd">/// Recommend: maybe 60, 90, 250</span>
    <span class="cd">/// (Rust use M=12 (B=6, M=2B-1+1) maybe increase it in the futer)</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="n">BT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="b-树节点">B-树节点</h3>

<p>前面都是公共的代码，而对于真正节点的定义 <code class="language-plaintext highlighter-rouge">Node_</code> 的定义是真正独特设计的体现，这里有两点需要注意的：</p>

<ol>
  <li>普通的 B 树就像二叉搜索树一样直接把键值存在一起，这里用 <code class="language-plaintext highlighter-rouge">KVEntry</code> 把它们直接放到一起便于集中管理，<code class="language-plaintext highlighter-rouge">KVEntry</code> 是一个以第一个元素为排序键的二元组。</li>
  <li>对节点内键的存储使用了连续地址的向量结构，这是我在实现时的第一选择，在经典的 CPU 架构下，这样不超过 $100$ 个 指针宽度的数组的读写是最优的<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">9</a></sup></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">clone</span><span class="p">|</span>
    <span class="n">paren</span>
<span class="p">);</span>
<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="k">ref</span><span class="p">|</span>
    <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="cd">/// 即使是叶子节点，也要保持孩子数量 = k-v 数量 + 1</span>
    <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="kventry">KVEntry</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="n">K</span><span class="p">,</span> <span class="k">pub</span> <span class="n">V</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">drain</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialEq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">==</span> <span class="n">other</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialOrd</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-基础方法">实现-&gt;基础方法</h2>

<p>如果是从二叉搜索树第一次接触到 B 树这样的 $m$ 路搜索树（$m \geqslant 3$），会感到很多观念上的不适应，一些基础操作到底怎么实现，难以想得很清楚<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">10</a></sup>。</p>

<p>一个关键的区别在于二叉搜索树一个节点只有一个键，在这种情况下，键就是节点，节点就是键，找到了节点就找到了键，反之亦然。</p>

<p>而 B 树这样的多路搜索树不止有一个键，找到了节点后还要在节点里寻找键，不仅考虑得是节点间的关系，还要考虑节点内键之间的关系，以及某个键的对应的左右孩子的索引位置。</p>

<p>因此这里我们首先要点出键和孩子在节点内的布局。</p>

<h3 id="节点布局">节点布局</h3>

<ol>
  <li>对于键，按向量的地址增长顺序从小到大排列；</li>
  <li>对于孩子，也按照同样地顺序排列</li>
</ol>

<p>这样有 $\text{len(keys) + 1 = len(children)}$ ，并且节点内索引为 $i$ 的键对应的左右孩子分别为 $\text{children}[i]$ 和 $\text{children}[i+1]$ 。</p>

<p>也就是说，与孩子同编号的是右邻居键，每个键与它的左孩子同编号：</p>

<p><img src="/assets/img/bt_basic/key_children_idx.png" alt="" /></p>

<h3 id="创建节点">创建节点</h3>

<p>我们同样可以使用二叉搜索树那里用过的 <code class="language-plaintext highlighter-rouge">node</code> 宏来简化节点的创建。</p>

<p>创建新节点的情景有两种：</p>

<ol>
  <li>树为空的时候，从新开始创建一个叶子节点，这时只需要指明键值对儿即可；</li>
  <li>节点分裂以及 <code class="language-plaintext highlighter-rouge">push_new_level</code> 的时候，这时需要指明节点的各个属性</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">coll</span><span class="p">::{</span> <span class="o">*</span><span class="p">,</span> <span class="n">node</span> <span class="k">as</span> <span class="n">aux_node</span> <span class="p">};</span>

<span class="c1">// ...</span>

<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">;</span> <span class="mi">2</span><span class="p">];</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="求取子节点索引">求取子节点索引</h3>

<p>在二叉搜索树的系列里常用到一个给出子节点，求它是父节点的左孩子还是右孩子的操作，使用这个 <code class="language-plaintext highlighter-rouge">index_of_child</code> 宏。</p>

<p>在 B 树上更有这样需求，不管是获取键还是孩子。</p>

<p><strong>最普遍性的方法是遍历父节点的孩子索引</strong>：</p>

<p>显然它的时间复杂度是线性的，是 $O(m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(M)</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child_by_rc</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">idx</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"There are no matched child"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>虽然 $m$ 也不会很大，但是线性时间复杂度显然有改进的余地。</p>

<p>我们可以直接通过利用孩子节点里任一一个<strong>键在父节点上执行二分查找</strong>：</p>

<p>时间复杂度就变成对数级的，是 $O(\text{log}\ m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(logM) search by key</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Dup key on {oldidx}"</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">inseridx</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[track_caller]</span>
    <span class="k">fn</span> <span class="nf">last_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">ent</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"EMPTY entries"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这个方法存在限制，无法适用于空节点的情况，在删除键的一些情境下只能回归到普遍性的算法上。</p>

<h3 id="搜索到叶子节点">搜索到叶子节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// 漂亮的尾递归</span>
    <span class="k">fn</span> <span class="n">search</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-一般公开方法">实现-&gt;一般公开方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-插入方法">实现-&gt;插入方法</h2>

<h3 id="搜索插入">搜索、插入</h3>

<p>这个插入的主流程和二叉搜索树的插入结构上是类似的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span>
                <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">y</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升">节点提升</h3>

<p>Rust 标准库里的 <code class="language-plaintext highlighter-rouge">Vec</code> 为我们提供了一切的便利方法，从二分查找到向量分割（<code class="language-plaintext highlighter-rouge">split_off</code>）。不过与其说是 Rust 为我们提供了便利，不如说是它的 API 设计指导了我们的代码风格。</p>

<p>回顾之前的<a href="#插入">节点提升的算法</a>，对比下这里的代码实现：</p>

<h4 id="分离节点">分离节点</h4>

<ol>
  <li>目标节点的键值按照 $\lceil {\large\frac{m}{2}}\rceil$ 分出右半部分，左半部分弹出尾部的键值作为提升；</li>
  <li>目标节点的孩子按照 $\lceil {\large\frac{m}{2}}\rceil$ 分出右半部分，把分出的这些键值和孩子组合成新的右邻居节点；</li>
  <li>不要忘记更新新节点的孩子的反向引用指向自己</li>
</ol>

<h4 id="检查是否停止">检查是否停止</h4>

<ol>
  <li>如果到达根节点，把提升的键值，和分裂出的两个孩子组合成新的根节点；</li>
  <li>否则把提升的键值和右邻节点插入到对应的父节点中，检查父节点是否溢出，递归地进行提升</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// 漂亮的尾递归</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">split_pos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entries_x</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entry_head</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
        <span class="nd">children_revref!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* push new level */</span>

            <span class="k">let</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">entry_head</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into paren node */</span>

            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">entry_head</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.downgrade</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>   
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">children_revref</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$x</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-删除方法">实现-&gt;删除方法</h2>

<h3 id="搜索删除">搜索、删除</h3>

<p>删除的主流程，同样类似于二叉搜索树的算法，找到目标键，和后继键交换，确保最终要删除的键位于叶子节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="k">mut</span> <span class="n">x</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>

            <span class="cm">/* Swap with its successor leaf node */</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">succ</span><span class="p">,</span> <span class="n">succ_idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="nf">.minimum</span><span class="p">();</span>

                <span class="nf">swap</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">succ</span><span class="p">)[</span><span class="n">succ_idx</span><span class="p">],</span>
                <span class="p">);</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">succ</span><span class="p">;</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">succ_idx</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="n">popped</span><span class="na">.1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Left most</span>
    <span class="k">fn</span> <span class="nf">minimum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下沉">节点下沉</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Exclude leaf node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* merge with sib node (rebalance failed means that each node are small) */</span>

            <span class="c1">// merge left child</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// merge right child</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">());</span>
                    <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<p>这里使用了二叉搜索树里定义的 <code class="language-plaintext highlighter-rouge">Dir</code> 枚举结构，提供方向标识。</p>

<p>对节点的重平衡当初是用宏来描述的，但完全可以替换成一般的方法。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">bst</span><span class="p">::{</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">};</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// (parent, left-idx, sib_dir)</span>
<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
	<span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="合并节点">合并节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// (parent, left-idx)</span>
<span class="nd">macro_rules!</span> <span class="n">merge_node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// merge right's children to the left</span>

        <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// merge entries</span>
        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="实现-测试方法">实现-&gt;测试方法</h2>

<p>这里介绍了测试与调试相关的代码</p>

<h3 id="打印节点">打印节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="nv">$x</span><span class="p">)[</span><span class="nv">$idx</span><span class="p">]</span><span class="na">.0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">kn</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}, "</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="打印树">打印树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    	<span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}</span>

                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: {p:?})"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性质校验">性质校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="nd">assert_eq!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                        <span class="s">"{child:?}"</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                        <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="p">);</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                        <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这是为了让插入提升能够在根节点处终止 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>当然实际上其中一个节点可以是旧节点的重新利用 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>这个过程在很多实现里被惯例地称为 <code class="language-plaintext highlighter-rouge">push_new_level</code> 之类的名字 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>也可以采用惰性删除的方法，但这里就不介绍了 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>当然也可以合并目标节点、父节点键和右邻居节点 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>根节点键不足的时候也就是只有空节点和一个孩子的情况 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>这个降低树高的过程可以称为 <code class="language-plaintext highlighter-rouge">pop_level</code> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>如果可以，我不愿意多打哪怕一个重复的字符 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>后面的以一种实现的性能测试实际完全验证了我的这种认识 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>对于我来讲，想不清楚的就躺床上慢慢想，这也是笛卡尔思考问题的办法，当初解析几何的想法就是在床上想出来的 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[B 树是波音实验室的 Rudolf Bayer and Edward M. McCreight 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。]]></summary></entry><entry><title type="html">疑难杂症备忘录</title><link href="/oth/BackNotes.html" rel="alternate" type="text/html" title="疑难杂症备忘录" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/oth/BackNotes</id><content type="html" xml:base="/oth/BackNotes.html"><![CDATA[<h4 id="q1">Q1:</h4>

<p>Ubuntu 22.04 叠加几次需要重启的更新后重启发现WiFi模块找不到了</p>

<p>A: 再次重启或关机重启都没有用，最后是重新关闭和启用了WiFi驱动（在软件更新里）解决的问题</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[Q1:]]></summary></entry><entry><title type="html">存储介质（0）- 基础</title><link href="/oth/StorageMedium-0-Basic.html" rel="alternate" type="text/html" title="存储介质（0）- 基础" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%200%20-%20Basic</id><content type="html" xml:base="/oth/StorageMedium-0-Basic.html"><![CDATA[<h2 id="分类">分类</h2>

<p>按照记录数据的载体，可以分为<strong>磁性存储（magnetic）</strong>、<strong>光学存储（optical）</strong>和<strong>集成电路存储</strong></p>

<h2 id="磁性存储">磁性存储</h2>

<ol>
  <li>机械硬盘</li>
  <li>软盘（floppy disk）</li>
  <li>磁带鼓</li>
</ol>

<p>一个比一个老，磁带鼓更是老资格</p>

<h2 id="光学存储">光学存储</h2>

<ol>
  <li>光盘</li>
</ol>

<h2 id="集成电路存储">集成电路存储</h2>

<p>集成电路（Integrated Circuit， IC），不管有没有晶体管，都是有有半导体材料，也直接叫做半导体存储。</p>

<p>在这样电路实现分为：<strong>RAM</strong> 和 <strong>ROM</strong></p>

<h2 id="ram">RAM</h2>

<p>RAM（Random-access memory） 分为：<strong>SRAM</strong> 和 <strong>DRAM</strong></p>

<h3 id="sram">SRAM</h3>

<p>传统上使用 $6$ 个晶体管，是“真”半导体存储。</p>

<p>更低的封装密度，更快的访问速度，更少的耗电。</p>

<h4 id="应用实例">应用实例</h4>

<p>CPU 缓存、CPU 寄存器</p>

<h3 id="dram">DRAM</h3>

<p>需要脉冲刷新，很少的晶体管，大部分是电容（各种各样绝缘材料制作）</p>

<h4 id="应用实例-1">应用实例</h4>

<p>电脑的内存条</p>

<h2 id="rom">ROM</h2>

<p>ROM（Read-only memory）</p>

<p>ROM分为：<strong>EPROM</strong>、<strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>可擦除、电可擦除、另一个电可擦除的改版</p>

<p>实际上只有 <strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>重编程 ROM 重写入的次数是有限制的</p>

<p>从概念上讲，Flash 属于 E2PROM 的范畴，但是一般而讲，Flash Memory 高速高密度，有更大的擦除块和更有限的写入次数。现在一般 E2PROM 都被 Flash 替代了。</p>

<h3 id="flash">Flash</h3>

<p>分为 <strong>NOR</strong> 型 和后面发展的 <strong>NAND</strong> 型</p>

<h4 id="nor">NOR</h4>

<p>贴近原始的E2PROM，支持随机存取</p>

<h4 id="nand">NAND</h4>

<p>只支持按页存取，目标是代替固态硬盘（U盘，固态硬盘，内存卡）</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[分类]]></summary></entry><entry><title type="html">Disk上的存储结构</title><link href="/oth/StorageMedium-1-Disk.html" rel="alternate" type="text/html" title="Disk上的存储结构" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%201%20-%20Disk</id><content type="html" xml:base="/oth/StorageMedium-1-Disk.html"><![CDATA[<p>介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。</p>

<h2 id="盘片划分">盘片划分</h2>

<p>一个盘片的基本两级结构是： 轨道（Track）- 扇区（Sector）。</p>

<p>轨道是盘片上的同心圆（考虑到轨道的宽度，实际上是很窄的同心圆环）</p>

<p>而扇区则是一条轨道上按照一定角度划分的弧，是最基本的存储单元。</p>

<p>注意这个概念显然有别于几何学上的扇区，这里的扇区实际是几何意义上的扇区在某一轨道上的交集。</p>

<h2 id="轨道">轨道</h2>

<h3 id="编号习惯">编号习惯</h3>

<p>轨道的编号传统上从小到大按照从外到内的顺序。</p>

<h3 id="pmr-vs-smr">PMR vs SMR</h3>

<p>现在业界现在有两种主流的与轨道排布相关的磁记录方式：<strong>垂直式磁记录（Perpendicular magnetic recording，PMR）</strong>、<strong>叠瓦式磁记录（Shingled magnetic recording，SMR）</strong></p>

<p><strong>PMR</strong> 也可以称为<strong>传统式磁记录（Conventional magnetic recording，CMR）</strong>有着数十年的悠久历史。</p>

<p><strong>SMR</strong> 是为了增加 PMR 的存储密度上限而发明的，使用了更窄的轨道排布布局，代价是安全性和访问效率都有所下降。</p>

<h2 id="扇区">扇区</h2>

<p>传统 HDD 的扇区是 512 bytes，CD-ROM 和 DVD-ROM 是 2048 bytes，现代 HDD 的扇区是 4096 bytes。</p>

<h3 id="物理扇区和逻辑扇区">物理扇区和逻辑扇区</h3>

<p>为了向后兼容，扇区还分了<strong>逻辑扇区</strong>和<strong>物理扇区</strong>两个概念。</p>

<p><strong>物理扇区</strong>是实际上的扇区划分比如 4096 bytes。</p>

<p><strong>逻辑扇区</strong>实际上是划分了物理扇区，比如 512 bytes，以提供更小的扇区的访问的后向兼容性，但这种访问显然是低效的，因为每次都要取出整个物理扇区修改后再重新写回去。因此除非必要，默认都采取逻辑扇区和物理扇区一样大小。</p>

<h3 id="扇区结构">扇区结构</h3>

<p>header area（so-called ID） + data area</p>

<h4 id="header">header</h4>

<p>同步字节+地址标志符+缺陷标志（flaw flag）+错误检查和纠正信息，如果数据区不可靠，还可一包含备用地址</p>

<h4 id="data">data</h4>

<p>同步字节+存储的数据+错误纠正码（ECC）</p>

<h3 id="区位记录">区位记录</h3>

<p>Zero bit recording，ZBR。</p>

<p>按照传统磁盘扇区的划分方式，显然越靠外面的弧越长，磁密度越小，相对最里面的弧，显然存在严重的数据容量上的浪费。</p>

<p>如果按照半径范围，把盘上所有的轨道归为几个不同的分区（Zone），把不同的分区上的轨道的弧划分成从1到n不等数量的扇区，越靠外的弧划分出的轨道越多。</p>

<p>下图来自 <a href="https://en.wikipedia.org/wiki/Zone_bit_recording">wiki</a> ，其中红绿灰三色就是三个分区，不同分区的弧分别可以有 $1$、$2$、$4$ 个扇区。</p>

<p><img src="/assets/img/disk/zone.svg" alt="" /></p>

<p>ZBR实际上是把原来的固定角速度转变为固定线速度，带来了数据容量的提高和外部扇区访问速度的提升。</p>

<p>不过由于系统编号管理是从到内，这就带来一个系统初创测试时期和后续使用过程中较大的性能差异的问题，有的drive会故意减慢读外周时的转速来避免这种差异。</p>

<p>现代的HDD普遍使用了 ZBR 的设计</p>

<h2 id="文件系统映射">文件系统映射</h2>

<p>block 或 allocation unit 或 cluster ，指得是文件系统存储的基本单位，对应一般从 $1$ 个扇区 ($512$ bytes) 到 $128$ 个扇区 ($64$ Kbytes )。</p>

<p>这样的 cluster 包含的扇区不一定要在物理上是连续的。<em>注意：它们不是碎片，因为在逻辑上它们是连续的</em></p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。]]></summary></entry></feed>