<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-02-20T11:14:16+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">BT(0) - B树</title><link href="/algs/BT-0-BT.html" rel="alternate" type="text/html" title="BT(0) - B树" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/algs/BT%20-%200%20-%20BT</id><content type="html" xml:base="/algs/BT-0-BT.html"><![CDATA[]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">疑难杂症备忘录</title><link href="/oth/BackNotes.html" rel="alternate" type="text/html" title="疑难杂症备忘录" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/oth/BackNotes</id><content type="html" xml:base="/oth/BackNotes.html"><![CDATA[<h4 id="q1">Q1:</h4>

<p>Ubuntu 22.04 叠加几次需要重启的更新后重启发现WiFi模块找不到了</p>

<p>A: 再次重启或关机重启都没有用，最后是重新关闭和启用了WiFi驱动（在软件更新里）解决的问题</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[Q1:]]></summary></entry><entry><title type="html">存储介质（0）- 基础</title><link href="/oth/StorageMedium-0-Basic.html" rel="alternate" type="text/html" title="存储介质（0）- 基础" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%200%20-%20Basic</id><content type="html" xml:base="/oth/StorageMedium-0-Basic.html"><![CDATA[<h2 id="分类">分类</h2>

<p>按照记录数据的载体，可以分为<strong>磁性存储（magnetic）</strong>、<strong>光学存储（optical）</strong>和<strong>集成电路存储</strong></p>

<h2 id="磁性存储">磁性存储</h2>

<ol>
  <li>机械硬盘</li>
  <li>软盘（floppy disk）</li>
  <li>磁带鼓</li>
</ol>

<p>一个比一个老，磁带鼓更是老资格</p>

<h2 id="光学存储">光学存储</h2>

<ol>
  <li>光盘</li>
</ol>

<h2 id="集成电路存储">集成电路存储</h2>

<p>集成电路（Integrated Circuit， IC），不管有没有晶体管，都是有有半导体材料，也直接叫做半导体存储。</p>

<p>在这样电路实现分为：<strong>RAM</strong> 和 <strong>ROM</strong></p>

<h2 id="ram">RAM</h2>

<p>RAM（Random-access memory） 分为：<strong>SRAM</strong> 和 <strong>DRAM</strong></p>

<h3 id="sram">SRAM</h3>

<p>传统上使用 $6$ 个晶体管，是“真”半导体存储。</p>

<p>更低的封装密度，更快的访问速度，更少的耗电。</p>

<h4 id="应用实例">应用实例</h4>

<p>CPU 缓存、CPU 寄存器</p>

<h3 id="dram">DRAM</h3>

<p>需要脉冲刷新，很少的晶体管，大部分是电容（各种各样绝缘材料制作）</p>

<h4 id="应用实例-1">应用实例</h4>

<p>电脑的内存条</p>

<h2 id="rom">ROM</h2>

<p>ROM（Read-only memory）</p>

<p>ROM分为：<strong>EPROM</strong>、<strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>可擦除、电可擦除、另一个电可擦除的改版</p>

<p>实际上只有 <strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>重编程 ROM 重写入的次数是有限制的</p>

<p>从概念上讲，Flash 属于 E2PROM 的范畴，但是一般而讲，Flash Memory 高速高密度，有更大的擦除块和更有限的写入次数。现在一般 E2PROM 都被 Flash 替代了。</p>

<h3 id="flash">Flash</h3>

<p>分为 <strong>NOR</strong> 型 和后面发展的 <strong>NAND</strong> 型</p>

<h4 id="nor">NOR</h4>

<p>贴近原始的E2PROM，支持随机存取</p>

<h4 id="nand">NAND</h4>

<p>只支持按页存取，目标是代替固态硬盘（U盘，固态硬盘，内存卡）</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[分类]]></summary></entry><entry><title type="html">Disk上的存储结构</title><link href="/oth/StorageMedium-1-Disk.html" rel="alternate" type="text/html" title="Disk上的存储结构" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%201%20-%20Disk</id><content type="html" xml:base="/oth/StorageMedium-1-Disk.html"><![CDATA[<p>介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。</p>

<h2 id="盘片划分">盘片划分</h2>

<p>一个盘片的基本两级结构是： 轨道（Track）- 扇区（Sector）。</p>

<p>轨道是盘片上的同心圆（考虑到轨道的宽度，实际上是很窄的同心圆环）</p>

<p>而扇区则是一条轨道上按照一定角度划分的弧，是最基本的存储单元。</p>

<p>注意这个概念显然有别于几何学上的扇区，这里的扇区实际是几何意义上的扇区在某一轨道上的交集。</p>

<h2 id="轨道">轨道</h2>

<h3 id="编号习惯">编号习惯</h3>

<p>轨道的编号传统上从小到大按照从外到内的顺序。</p>

<h3 id="pmr-vs-smr">PMR vs SMR</h3>

<p>现在业界现在有两种主流的与轨道排布相关的磁记录方式：<strong>垂直式磁记录（Perpendicular magnetic recording，PMR）</strong>、<strong>叠瓦式磁记录（Shingled magnetic recording，SMR）</strong></p>

<p><strong>PMR</strong> 也可以称为<strong>传统式磁记录（Conventional magnetic recording，CMR）</strong>有着数十年的悠久历史。</p>

<p><strong>SMR</strong> 是为了增加 PMR 的存储密度上限而发明的，使用了更窄的轨道排布布局，代价是安全性和访问效率都有所下降。</p>

<h2 id="扇区">扇区</h2>

<p>传统 HDD 的扇区是 512 bytes，CD-ROM 和 DVD-ROM 是 2048 bytes，现代 HDD 的扇区是 4096 bytes。</p>

<h3 id="物理扇区和逻辑扇区">物理扇区和逻辑扇区</h3>

<p>为了向后兼容，扇区还分了<strong>逻辑扇区</strong>和<strong>物理扇区</strong>两个概念。</p>

<p><strong>物理扇区</strong>是实际上的扇区划分比如 4096 bytes。</p>

<p><strong>逻辑扇区</strong>实际上是划分了物理扇区，比如 512 bytes，以提供更小的扇区的访问的后向兼容性，但这种访问显然是低效的，因为每次都要取出整个物理扇区修改后再重新写回去。因此除非必要，默认都采取逻辑扇区和物理扇区一样大小。</p>

<h3 id="扇区结构">扇区结构</h3>

<p>header area（so-called ID） + data area</p>

<h4 id="header">header</h4>

<p>同步字节+地址标志符+缺陷标志（flaw flag）+错误检查和纠正信息，如果数据区不可靠，还可一包含备用地址</p>

<h4 id="data">data</h4>

<p>同步字节+存储的数据+错误纠正码（ECC）</p>

<h3 id="区位记录">区位记录</h3>

<p>Zero bit recording，ZBR。</p>

<p>按照传统磁盘扇区的划分方式，显然越靠外面的弧越长，磁密度越小，相对最里面的弧，显然存在严重的数据容量上的浪费。</p>

<p>如果按照半径范围，把盘上所有的轨道归为几个不同的分区（Zone），把不同的分区上的轨道的弧划分成从1到n不等数量的扇区，越靠外的弧划分出的轨道越多。</p>

<p>下图来自 <a href="https://en.wikipedia.org/wiki/Zone_bit_recording">wiki</a> ，其中红绿灰三色就是三个分区，不同分区的弧分别可以有 $1$、$2$、$4$ 个扇区。</p>

<p><img src="/../assets/img/disk/zone.svg" alt="" /></p>

<p>ZBR实际上是把原来的固定角速度转变为固定线速度，带来了数据容量的提高和外部扇区访问速度的提升。</p>

<p>不过由于系统编号管理是从到内，这就带来一个系统初创测试时期和后续使用过程中较大的性能差异的问题，有的drive会故意减慢读外周时的转速来避免这种差异。</p>

<p>现代的HDD普遍使用了 ZBR 的设计</p>

<h2 id="文件系统映射">文件系统映射</h2>

<p>block 或 allocation unit 或 cluster ，指得是文件系统存储的基本单位，对应一般从 $1$ 个扇区 ($512$ bytes) 到 $128$ 个扇区 ($64$ Kbytes )。</p>

<p>这样的 cluster 包含的扇区不一定要在物理上是连续的。<em>注意：它们不是碎片，因为在逻辑上它们是连续的</em></p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。]]></summary></entry><entry><title type="html">BST(5) - 树堆（Treep）</title><link href="/algs/BST-5-Treep.html" rel="alternate" type="text/html" title="BST(5) - 树堆（Treep）" /><published>2023-02-02T00:00:00+08:00</published><updated>2023-02-02T00:00:00+08:00</updated><id>/algs/BST%20-%205%20-%20Treep</id><content type="html" xml:base="/algs/BST-5-Treep.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>树堆的概念首次是由 <a href="https://en.wikipedia.org/wiki/Raimund_Seidel">Raimund Seidel</a> and <a href="https://en.wikipedia.org/wiki/Cecilia_R._Aragon">Cecilia R. Aragon</a> 在 1989 年提出，它意思是节点用两个属性分别维护了二叉搜索树的性质和堆的性质。从二叉搜索树的角度看，可以类比前面的 <code class="language-plaintext highlighter-rouge">Splay树</code>，<code class="language-plaintext highlighter-rouge">Splay</code> 平衡性好要依赖于输入的数据具有随机性，而树堆干脆利用随机生成的权重来手动制造这种随机性。实质上都是通过随机化的输入来达到树结构的平衡。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Treap</span> <span class="p">{</span> <span class="n">improve_search</span><span class="p">:</span> <span class="nb">bool</span> <span class="p">});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="堆校验">堆校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Validate MaxHeap</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">));</span>
            <span class="n">left</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="n">right</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基本操作">基本操作</h2>

<p>树堆基本操作有两种方式，就像讲到一般二叉搜索树的基础方法时，一种是展开型，一种是递归型 。在常见的树堆的文章里介绍得是递归型的方法，依靠 <code class="language-plaintext highlighter-rouge">Split</code> 和 <code class="language-plaintext highlighter-rouge">Join</code> 这两个基础型方法（这两个方法本身也是递归实现的）。</p>

<p>我们这里介绍展开型的实现方法，而这种方法就像一般堆的实现一样，依赖 <code class="language-plaintext highlighter-rouge">Sift-up</code> 和 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作来维护堆修改后的性质 ，而这两个操作背后又通过树的旋转实现。树的旋转不仅保持了二叉搜索树的性质，也保留了既有的堆的权重大小关系 。</p>

<h3 id="sift-up">Sift-up</h3>

<p>把一个权重较大的节点试着向上提升，直到符合堆的性质。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">fn</span> <span class="nf">siftup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="sift-down">Sift-down</h3>

<p>把权重较小的节点向下沉，直到符合堆的性质。选择左右孩子中权重最大的那一个，把它旋转到根，如此反复直到堆的性质得到维护。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="cd">/// rotate down if MaxHeap violation</span>
<span class="k">fn</span> <span class="nf">siftdown</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_child</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_dir</span><span class="p">)</span> <span class="o">=</span> <span class="n">max_child</span> <span class="p">{</span>
            <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">child_dir</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="搜索">搜索</h3>

<p>和一般的二叉搜索树的搜索方法没什么不同。唯一特别的是两位原作者建议可以在搜索的时候给经常访问的节点更高的权重，来加快搜索效率。这样就结合了伸缩树的特点，但是没有那么直接，没有访问一次就直接提到根。我们实现这个做法是采用了 wiki 上建议，每次访问给一个随机数，当超过当前节点的权重时，就赋予这个权重然后 <code class="language-plaintext highlighter-rouge">Sift-up</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// https://en.wikipedia.org/wiki/Treap</span>
<span class="k">fn</span> <span class="nf">aragon_seidel_search_suggestion</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">neww</span> <span class="o">=</span> <span class="nf">random</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">neww</span> <span class="o">&gt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">neww</span><span class="p">);</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="插入">插入</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">Sift-up</code> 修复新节点插入时可能造成的对堆的性质的破坏</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nf">random</span><span class="p">()</span> <span class="p">});</span>

    <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>和标准的二叉搜索树的删除方法一致。有一点需要额外调整，就是当被删除的节点左右孩子都不为空的时候。这时候 <code class="language-plaintext highlighter-rouge">y</code> 与 <code class="language-plaintext highlighter-rouge">y.left</code> , <code class="language-plaintext highlighter-rouge">y.right</code></p>

<p>的权重大小关系就不确定了，需要对 <code class="language-plaintext highlighter-rouge">y</code> 进行 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-1       case-2

                    z            z
                    \            \
                    y            z.right
                                /
                                / (left-most)
                                y
                                \
                                y.right
                */</span>

            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>

            <span class="cm">/* Only y and y.left and maybe y.right violate weight */</span>
            <span class="k">self</span><span class="nf">.siftdown</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="创建">创建</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="n">improve_search</span><span class="p">:</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">improve_search</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.improve_search</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">self</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>树堆是一个相对来讲容易理解，实现简单（相对红黑树家族），性能表现令人满意的二叉搜索树的数据结构。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(3) - 伸展树（Splay Tree）</title><link href="/algs/BST-3-Splay-Tree.html" rel="alternate" type="text/html" title="BST(3) - 伸展树（Splay Tree）" /><published>2023-01-30T00:00:00+08:00</published><updated>2023-01-30T00:00:00+08:00</updated><id>/algs/BST%20-%203%20-%20Splay%20Tree</id><content type="html" xml:base="/algs/BST-3-Splay-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">伸缩树</code>（<code class="language-plaintext highlighter-rouge">Splay Tree</code>）是 <a href="https://en.wikipedia.org/wiki/Daniel_Sleator">Daniel Sleator</a> and <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a> 在 1985 年提出，它的想法就是一个，把最近访问的节点 roll 到根节点。</p>

<p>它的性质与 CPU 缓存机制非常契合，又不需要存储额外字段，常用于缓存和垃圾回收器的实现。</p>

<p>但是这样的性质也导致</p>

<ol>
  <li>查询的时候也会修改自身的结构，这在多线程环境和纯函数编程语言里会造成很大的麻烦；</li>
  <li>这不是很“体面“的平衡方法，依赖于数据访问的有一定的随机性，顺序访问会造成数据结构蜕化为链表（前一个根节点总是成为当前根节点的右子树）</li>
</ol>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Splay</span> <span class="p">{});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Splay</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="基础操作">基础操作</h2>

<h3 id="splay">Splay</h3>

<p><code class="language-plaintext highlighter-rouge">Splay树</code> 最基础的操作当然就是 <code class="language-plaintext highlighter-rouge">Splay</code> 操作，就是把树中的一个节点旋转到根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">splay</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="split">Split</h3>

<p>给定树中一个节点 <code class="language-plaintext highlighter-rouge">x</code> ，把树分为比 <code class="language-plaintext highlighter-rouge">x</code> 小（包含 <code class="language-plaintext highlighter-rouge">x</code> ）和比 <code class="language-plaintext highlighter-rouge">x</code> 大的两部分。方法是把 <code class="language-plaintext highlighter-rouge">x</code> 旋转到根，然后分出 <code class="language-plaintext highlighter-rouge">x</code> 的右子树和 <code class="language-plaintext highlighter-rouge">x</code> 的其余部分。</p>

<p>需要注意的是分割的时候需要断开连接。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">x_right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">disconn!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_right</span><span class="p">);</span>

    <span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="n">x_right</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="join">Join</h3>

<p>给两个节点，把节点代表的子树合并为一棵完整的树。能够合并前提是这两棵子树其中一棵的最大值小于另一棵的最小值，方法是把较小子树的最大值 <code class="language-plaintext highlighter-rouge">splay</code> （最大值节点的右子树为空），然后把另一棵较大的子树放到根节点的右子树位置。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">join</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">trees</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">s</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s_max</span> <span class="o">=</span> <span class="nd">bst_maximum!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_max</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">s_max</span><span class="nf">.clone</span><span class="p">();</span> <span class="c1">//  s maybe not root node</span>
        <span class="nd">conn_right!</span><span class="p">(</span><span class="n">s_max</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>注意，对<strong>子树</strong> <code class="language-plaintext highlighter-rouge">Splay</code> 的时候不会更新所属母树的根节点（左子树的根不一定是母树的根），需要手动保证树的根节点为左子树的根节点。</p>

<h2 id="总装">总装</h2>

<h4 id="搜索">搜索</h4>

<p>找到节点后额外执行 <code class="language-plaintext highlighter-rouge">Splay</code> 操作。在 Rust 实现里，如 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏所示，我们使用一个 tricky 的方法绕过可变性检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="cd">/// Hack method convert self to self_mut</span>
<span class="nd">macro_rules!</span> <span class="n">mut_self</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self</span><span class="p">:</span> <span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="nv">$self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="k">Self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>这里对 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏稍微展开讲一下：</p>

<p>作为一门现代性的语言（发明于21世纪的第二个十年，比传统主流编程语言年轻20岁），Rust 有很多编程模型上的新的探索（或者说从先锋性语言身上吸收了很多成熟的特性），前面的博文比如 Fib 堆的Rust实作、BST基础等等都谈过这里不赘述 。</p>

<p>这些特性在内存安全方面，在多线程环境下，有巨大的好处，但当编程对象是传统的树、图上的算法时，就显得非常不兼容，按照编程模型，这些传统算法都要重新设计！而另一方面， Rust 作为一门系统级编程语言，不管是出于对运行效率的极致追求还是对 C 库的向下兼容，它还是提供一种传统的，“不安全“的指针的编程模型。对指针上的操作可以绕过 Rust 诸多特性安全检查：<strong>生命周期</strong>、<strong>可变性</strong>、<strong>单一所有权</strong>等等。</p>

<p>对于 Rust 标准库的实现，他们就是在内部大量使用指针（做了一定的包装）来处理我们所面临的问题，但是他们不厚道的地方在于他们不愿意把他们标准库内部实现使用的方便工具全部开放出来，结果某种程度使得第三方不得不重新发明轮子。</p>

<p>前面我们把 key 和 val 两个字段都使用指针，就是为了能够创建非局部的引用，而 <code class="language-plaintext highlighter-rouge">mut_self</code> 通过把引用转换为指针再转换回引用，也是为了能把只读引用转换为可变引用 。</p>

<h4 id="插入">插入</h4>

<p>我们这里的插入实现，是 Rust 风格的，也就是糅合了 Push 和 Update ，需要根据插入的节点是否存在来选择 <code class="language-plaintext highlighter-rouge">splay</code> 的节点，这需要修改一下一般的插入方法。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">});</span>

    <span class="cm">/* modify a little bst_insert */</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">popped</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">splay_at</span> <span class="o">=</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">popped</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="nf">.replace_val</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
                <span class="n">splay_at</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splay_at</span><span class="p">);</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="删除">删除</h4>

<p>找到搜索节点后，（如果节点存在）<code class="language-plaintext highlighter-rouge">Split</code> 该节点，此时左子树的根节点应该就是要被删除的节点，删掉之后，把左子树的左孩子（<code class="language-plaintext highlighter-rouge">Split</code> 得到的左子树的右孩子为空）和右子树 <code class="language-plaintext highlighter-rouge">Join</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">s_left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="nd">disconn!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s_left</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.join</span><span class="p">((</span><span class="n">s_left</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(4) - 替罪羊树（SG）</title><link href="/algs/BST-4-SG-Tree.html" rel="alternate" type="text/html" title="BST(4) - 替罪羊树（SG）" /><published>2023-01-29T00:00:00+08:00</published><updated>2023-01-29T00:00:00+08:00</updated><id>/algs/BST%20-%204%20-%20SG%20Tree</id><content type="html" xml:base="/algs/BST-4-SG-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">替罪羊树</code>（<code class="language-plaintext highlighter-rouge">Scapegoat Tree</code>）初始是在 1989 年由 <a href="https://en.wikipedia.org/w/index.php?title=Arne_Andersson_(computer_scientist)&amp;action=edit&amp;redlink=1">Arne Andersson</a> 发明，而在 1993 年 <a href="https://en.wikipedia.org/w/index.php?title=Igal_Galperin&amp;action=edit&amp;redlink=1">Igal Galperin</a> and <a href="https://en.wikipedia.org/wiki/Ronald_L._Rivest">Ronald L. Rivest</a> 正式提出这个概念。</p>

<p>它是说不用每次修改树结构后都进行重平衡的操作，而是当检测到树的不平衡程度达到阈值时直接重构以某个节点为根的树。</p>

<p>搜/插/删的平均时间复杂度与其他自平衡二叉搜索树一样，都是 $O(\text{log}\ \text{n})$ ，但是由于重构的存在，插/删的最坏时间复杂度为 $O(\text{n})$ 。</p>

<p>它使用一个 $\alpha$ 因子衡量平衡性，$ 0.5 \lt \alpha \lt 1$ ，最终维护一个宽松的 $\alpha\text{-height}$ 平衡。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// Scapegoat Tree</span>
    <span class="n">SG</span>
    <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="cd">/// nodes count including marked</span>
        <span class="n">max_cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({});</span>

</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span>
    <span class="n">SG</span> <span class="k">-&gt;</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<p>由于不存在严格的平衡，就不进行平衡校验了。</p>

<h2 id="重平衡">重平衡</h2>

<h3 id="重构">重构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_flatten_cleanup!</span><span class="p">();</span>
<span class="nd">impl_build_cleanup!</span><span class="p">();</span>

<span class="cd">/// impl SG</span>

<span class="cd">/// Rebuild at p, return new root</span>
<span class="k">fn</span> <span class="nf">rebuild_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">bst_build!</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">bst_flatten!</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// ...</span>
</code></pre></div></div>

<h3 id="插入重平衡">插入重平衡</h3>

<p>插入的时候，从插入的节点开始向上检查，找到第一个不平衡的节点，在该节点上进行重构。</p>

\[\begin{array}{l}
\texttt{size}\text{(left)} &amp;\leqslant\ α*\texttt{size}\text{(node)}\\
\texttt{size}\text{(right)} &amp;\leqslant\ α*\texttt{size}\text{(node)}
\end{array}\]

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span> <span class="o">+</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// impl SG</span>

<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">size_self</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">pp</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">size_sib</span> <span class="o">=</span> <span class="n">sib</span><span class="nf">.size</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">size_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">size_self</span><span class="p">,</span> <span class="n">size_sib</span><span class="p">);</span>

        <span class="n">size_self</span> <span class="o">+=</span> <span class="n">size_sib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">size_max</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">/</span> <span class="n">size_self</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.alpha</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pp</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
				<span class="nd">conn_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_dir</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除重平衡">删除重平衡</h3>

<p>删除的时候，直接考虑最大节点数与现有节点数的关系。</p>

\[\text{NodeCount} \leqslant α*\text{MaxNodeCount}\]

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>重构后需要重置最大节点数为当前结点数。</p>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">SG</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">&amp;&amp;</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">"bad alpha {alpha}"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">max_cnt</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span><span class="p">,</span> <span class="k">self</span><span class="py">.max_cnt</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">bst_delete!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>原始替罪羊树本身理论最坏时间复杂度不好，实际性能测试也不好，呃应该是相当相当差。</p>

<p>它的优势是保持平均的理论时间复杂度 $O(\text{log}\ \text{n})$ 情况下，由于没有额外字段，在考虑到数据对齐的情况下，每个节点可以节省多至 $1/3$ 的内存。</p>

<p>但是实际运行实在是太太太太慢了！两块儿最慢，一个是树的重构，一个是插入时动态计算节点大小，这么一看，所谓没有额外字段根本没有意义，因为省略了 size 字段严重地拖累了运行时间 。</p>

<p>接下来会在本篇基础上加入 size 字段，和惰性删除的特性，介绍 LSG （惰性替罪羊树）。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(4.1) - 惰性替罪羊树（LSG）</title><link href="/algs/BST-4.1-LSG-Tree.html" rel="alternate" type="text/html" title="BST(4.1) - 惰性替罪羊树（LSG）" /><published>2023-01-29T00:00:00+08:00</published><updated>2023-01-29T00:00:00+08:00</updated><id>/algs/BST%20-%204.1%20-%20LSG%20Tree</id><content type="html" xml:base="/algs/BST-4.1-LSG-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">替罪羊树</code> 的基本概念前文已经介绍过，这里主要做两个变化，一个是增加 <code class="language-plaintext highlighter-rouge">size</code> 字段来省略动态计算 <code class="language-plaintext highlighter-rouge">size</code> 的时间，另一个是使用惰性删除。</p>

<p>由于重构的存在，替罪羊树本来就很适合使用惰性删除的方法。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_tree!</span><span class="p">(</span>
    <span class="cd">/// Lazy Scapegoat Tree</span>
    <span class="n">LSG</span>
    <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="cd">/// nodes count including marked</span>
        <span class="n">max_cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">LSG</span><span class="p">);</span>

<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="nb">bool</span> <span class="p">});</span>
<span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">LSG</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_balance</span><span class="p">(</span><span class="k">self</span><span class="py">.alpha</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">);</span>

</code></pre></div></div>

<h3 id="搜插删时的小变化">搜/插/删时的小变化</h3>

<h4 id="搜索">搜索</h4>

<p>惰性搜索，如果找出的节点已被删除标记，那么仍然返回 <code class="language-plaintext highlighter-rouge">None</code> 。</p>

<h4 id="插入">插入</h4>

<p>惰性插入，当节点已存在时，用插入的节点的值替换既有节点的值（实现上注意手动管理内存的问题），如果节点已被标记删除，还要取消标记，并且给当前数量节点数 +1 。</p>

<h4 id="删除">删除</h4>

<p>惰性删除，删除节点时返回值，标记删除，但仍然保留节点（实现上注意手动管理内存的问题）。</p>

<h2 id="重平衡">重平衡</h2>

<h3 id="重构">重构</h3>

<p>重构的时候清除被标记删除的节点</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl LSG</span>

<span class="k">fn</span> <span class="nf">rebuild_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">part_nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dead_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="nd">bst_flatten!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">deleted!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">part_nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">dead_nodes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">-=</span> <span class="n">dead_nodes</span><span class="p">;</span>

    <span class="nd">bst_build!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_nodes</span><span class="p">[</span><span class="o">..</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="插入重平衡">插入重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_flatten_cleanup!</span><span class="p">(</span>
    <span class="k">fn</span> <span class="nf">flatten_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">size!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_build_cleanup!</span><span class="p">(</span>
    <span class="k">fn</span> <span class="nf">build_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.update_size</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="c1">// impl Node</span>

<span class="k">fn</span> <span class="nf">update_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">size!</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span> <span class="o">+</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>


<span class="c1">// impl LSG</span>

<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">pp</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">pp</span><span class="nf">.update_size</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">size_max</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="n">sib</span><span class="nf">.size</span><span class="p">(),</span> <span class="n">p</span><span class="nf">.size</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">size_max</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">/</span> <span class="n">pp</span><span class="nf">.size</span><span class="p">()</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.alpha</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pp</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
				<span class="nd">conn_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_dir</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">LSG</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">&amp;&amp;</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">"bad alpha {alpha}"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">max_cnt</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_delete!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="n">popped</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>省去了插入时巨慢的动态计算 <code class="language-plaintext highlighter-rouge">size</code> 的过程，但还是很慢，而且这样也不省内存了，真的是没什么用呐，替罪羊树。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(1) - 左偏红黑树</title><link href="/algs/BST-2-RB-Tree-1-LLRB-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(1) - 左偏红黑树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%201%20-%20LLRB%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-1-LLRB-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>LLRB 是特化后的红黑树，基本来源是一个 2008年 <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> （原始红黑树的两位联合发明人之一）的教学 PPT ，和红黑树一样，基本也不太行（指得是实现复杂，不直观，而且不体面（指得是删除操作依靠节点内容的交换））</p>

<p>关于 LLRB 名气很大，但是基本上也找不到很多除了原作者以外的介绍资料，大家抄得都是同一份 Slide 。实际上它在代码上如果不使用递归版本，那几乎就是红黑树代码，与其说它是红黑树的变种，不如说它还是红黑树本身。</p>

<p>一般说它的节点颜色指得是节点的父链接的颜色，但这种定义只是为了方便与2-4树的实现做对比。从代码实现角度，仍然看作节点本身的颜色是一点儿问题都没有！</p>

<p>左偏指得是3-节点的红连接只能在左边，也就是在黑父节点的孩子是一黑一红的时候，红节点只能在左边。当出现在右边的时候要左旋到左边。</p>

<p><img src="/../assets/img/bst_llrb/llrb_3nodes_4nodes.png" alt="初始" /></p>

<p>实在是鸡肋，不太想花很长时间只是为了实现一个并不简单的递归版本的红黑树。</p>

<p>可以参考</p>

<ol>
  <li><a href="https://oi-wiki.org/ds/llrbt">OI-WIKI 上的中文介绍以及下面我的评论</a></li>
  <li>Sedgewick Analysis of Algorithms meeting at Maresias (Apr 2008) 版本的 Slide</li>
</ol>

<p>问题在对比 RB ，LLRB的变化仅在于能提出一个递归实现的 插/删 版本的也简单不到哪儿去的实现</p>

<p>对于展开版本的实现，根本就不如RB</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(2) - AA树</title><link href="/algs/BST-2-RB-Tree-2-AA-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(2) - AA树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%202%20-%20AA%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-2-AA-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">AA</code> 树（以下简称 AA）由 <a href="https://en.wikipedia.org/w/index.php?title=Arne_Andersson_(computer_science)&amp;action=edit&amp;redlink=1">Arne Andersson</a> 在 1993 年发明提出。</p>

<p>AA 从理解到实现和 LLRB 是<strong>高度相似</strong>的（但是从作者关系上我们还是选择先介绍 LLRB），而一般的介绍资料，不管是 LLRB 还是 AA 的，都没有提这种密切的联系。</p>

<p>在 LLRB 里面，通过颜色关系，让节点与 2-3/2-4 树的节点一一对应；而在 AA 里每个节点也对应2-3树的节点。我们说 LLRB 是左偏的红黑树，那么 AA 实质上更早出现的右偏红黑树（<code class="language-plaintext highlighter-rouge">RLRB</code>）。</p>

<h3 id="基本性质">基本性质</h3>

<p><code class="language-plaintext highlighter-rouge">AA</code> 节点有一个用于辅助树平衡的字段：$\texttt{level}$ ， 表明节点所在的层级，叶子节点（这里的叶子不同于一般红黑树概念里的 $\texttt{nil}$ 叶子，而是普通意义上的叶子）的 $\texttt{level}$ 为 $1$ ， $\texttt{nil}$ 节点的 $\texttt{level}$ 为 $0$</p>

<p>如下就是一棵 AA树：</p>

<p><img src="/../assets/img/bst_aa/lv_intro.png" alt="" /></p>

<h4 id="3-节点">3-节点</h4>

<p>在同一 $\texttt{level}$ 上相连的节点，对应的是 <code class="language-plaintext highlighter-rouge">2-3树</code> 里的<code class="language-plaintext highlighter-rouge">3-节点</code></p>

<p><img src="/../assets/img/bst_aa/3_node.png" alt="" /></p>

<h4 id="5特性">5特性</h4>

<p>更具体地，AA 有以下 $5$ 个性质：</p>

<ol>
  <li>叶子节点（左右孩子都为 $\texttt{nil}$ 的节点）的 $\texttt{level}$ 为 $1$；</li>
  <li>左孩子在下一层；</li>
  <li>右孩子在同一层或下一层；</li>
  <li>右孙子（右孩子的所有孩子）一定在下一层；</li>
  <li>如果节点的 $\texttt{level} \gt 1$ ，它一定有两个孩子</li>
</ol>

<p>解释一下这5个性质：</p>

<ol>
  <li>叶子节点 $\texttt{level} = 1$ ，是一个规定，设置 $\texttt{level}$ 的基准；</li>
  <li>左节点在下一层因为这是 “LRRB“ ，只有右孩子能够在同一层；</li>
  <li>“LRRB“ ，只有右孩子能够在同一层；</li>
  <li>如果连续两个孩子都在同一层，那就出现了4-节点，而我们对应的 2-3 树 ，最多只能有 3-节点；</li>
  <li>$\texttt{lv} \gt 1$ 的节点如果只有一个孩子，那么一定可以把它的孩子转到右边，并放在第一层</li>
</ol>

<h4 id="黑平衡">黑平衡</h4>

<p>显然对于 AA 来说，叶子节点到祖先节点的左链接数应该保持相等，这就是它的黑平衡</p>

<h4 id="性质校验">性质校验</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">AA</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_balance</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="c1">// impl AA</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">fn</span> <span class="nf">validate_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

    <span class="c1">// Invariants-1: if x is leaf then x.lv == 1</span>
    <span class="k">if</span> <span class="n">left</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nd">lv!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Invariant-2.: x.left.lv + 1 = x.lv.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">left</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="nf">.lv</span><span class="p">());</span>

    <span class="c1">// Invariant-3.: x.right.lv == x.lv || x.right.lv + 1 == x.lv.</span>
    <span class="nd">assert!</span><span class="p">(</span>
        <span class="n">right</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.lv</span><span class="p">()</span>
        <span class="p">||</span> <span class="n">right</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.lv</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Invariant-4.: x.right.child.lv &lt; x.lv</span>
    <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nd">lv!</span><span class="p">(</span><span class="k">self</span><span class="p">));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nd">lv!</span><span class="p">(</span><span class="k">self</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// Invariant-5.: if x.lv &gt; 1 then x.children.len == 2</span>
    <span class="k">if</span> <span class="k">self</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">left</span><span class="nf">.validate_balance</span><span class="p">();</span>
    <span class="n">right</span><span class="nf">.validate_balance</span><span class="p">();</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">lv</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">});</span>

<span class="nd">impl_tree!</span><span class="p">(</span><span class="n">AA</span> <span class="p">{});</span>
<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">AA</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">AA</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
	
    <span class="c1">// ...</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">fn</span> <span class="nf">lv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">lv!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="重平衡操作">重平衡操作</h2>

<p>为了维护 插/删 造成的树的性质的破坏（不平衡），发明了两种基本操作：（确保）（向右）倾斜（<code class="language-plaintext highlighter-rouge">skew</code>）、分离（<code class="language-plaintext highlighter-rouge">4-节点</code>）（<code class="language-plaintext highlighter-rouge">split</code>）</p>

<h3 id="skew">Skew</h3>

<p><img src="/../assets/img/bst_aa/skew_1.png" alt="" /> <img src="/../assets/img/rarrow.png" alt="" /> <img src="/../assets/img/bst_aa/skew_2.png" alt="" /></p>

<p>实际上就是右旋，只不过有一个额外的警戒哨的功能，确保把箭头倾倒在右边</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl </span>

<span class="k">fn</span> <span class="nf">skew</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">t</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">t</span><span class="nf">.is_some</span><span class="p">());</span>

    <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="n">t</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">t</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="split">Split</h3>

<p>实际是带警戒哨的左旋，确保把 <code class="language-plaintext highlighter-rouge">4-节点</code> 分割出来，另外不要忘了让新的根节点的 $\texttt{level} + 1$</p>

<p><img src="/../assets/img/bst_aa/split_1.png" alt="" /> <img src="/../assets/img/rarrow.png" alt="" /> <img src="/../assets/img/bst_aa/split_2.png" alt="" /></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl AA</span>


<span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">t</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">t</span><span class="nf">.is_some</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>

        <span class="nd">lv!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nd">lv!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// t == right</span>
    <span class="p">}</span>

    <span class="n">t</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>就像 <code class="language-plaintext highlighter-rouge">LLRB</code> 一样，插入删除的实现实际上是为了重平衡操作的实现</p>

<h3 id="插入">插入</h3>

<p>严重依赖于子过程 <code class="language-plaintext highlighter-rouge">insert_at</code> 的递归操作，<code class="language-plaintext highlighter-rouge">insert_at</code> 返回旧的节点（如果存在）的值和新的根节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl AA</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">popped</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.insert_at</span><span class="p">(</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">v</span>
    <span class="p">);</span>

    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">insert_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">t</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">t</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="nd">node!</span><span class="p">(</span><span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lv</span><span class="p">:</span> <span class="mi">1</span> <span class="p">}),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">popped</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">k</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>  <span class="c1">// replace node</span>
            <span class="k">let</span> <span class="n">old_valptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">unboxptr!</span><span class="p">(</span><span class="n">old_valptr</span><span class="p">)));</span>
        <span class="p">}</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">popped_</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.insert_at</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
            <span class="n">popped</span> <span class="o">=</span> <span class="n">popped_</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">popped_</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.insert_at</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
            <span class="n">popped</span> <span class="o">=</span> <span class="n">popped_</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">t</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.skew</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">t</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">popped</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>严重依赖于子过程 <code class="language-plaintext highlighter-rouge">remove_at</code> 的递归操作，<code class="language-plaintext highlighter-rouge">remove_at</code> 返回符合删除条件的节点（用指针表示）的值和新的根节点。</p>

<p>如果被删除的节点不是叶子节点，就在它不为空的孩子上寻找后继或前驱，然后在那个孩子上使用原递归调用删除，最后用假替换把删除后的前驱或后继节点的 <code class="language-plaintext highlighter-rouge">key-val</code> 与当前节点交换，并进行对该节点的重平衡操作。</p>

<p>每次递归调用过程的重平衡操作可以总结为 $3$ 次分别在 <code class="language-plaintext highlighter-rouge">t</code>、<code class="language-plaintext highlighter-rouge">t.right</code>、<code class="language-plaintext highlighter-rouge">t.right.right</code> 上 <code class="language-plaintext highlighter-rouge">skew</code> 和 $2$ 次 在 <code class="language-plaintext highlighter-rouge">t</code> 和 <code class="language-plaintext highlighter-rouge">t.right</code> 上 <code class="language-plaintext highlighter-rouge">split</code> 。注意得是每次 <code class="language-plaintext highlighter-rouge">skew</code> 或 <code class="language-plaintext highlighter-rouge">split</code>，不仅根节点变动，右孩子的节点也会变动，需要动态计算。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl AA</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">popped</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.remove_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="n">popped</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">k_ptr</span><span class="p">,</span> <span class="n">v_ptr</span><span class="p">)|</span> <span class="p">{</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">k_ptr</span><span class="p">);</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">v_ptr</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>    


<span class="k">fn</span> <span class="n">remove_at</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">t</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span>
<span class="k">-&gt;</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="n">K</span><span class="p">,</span> <span class="o">*</span><span class="k">mut</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">t</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span>

    <span class="k">match</span> <span class="n">k</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">popped_</span><span class="p">)</span>
            <span class="o">=</span> <span class="k">self</span><span class="nf">.remove_at</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">k</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
            <span class="n">popped_</span>
        <span class="p">}</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">popped_</span><span class="p">)</span>
            <span class="o">=</span> <span class="k">self</span><span class="nf">.remove_at</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">k</span><span class="p">);</span>
            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
            <span class="n">popped_</span>
        <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">old_keyptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">old_valptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

                    <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="nf">null_mut</span><span class="p">());</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nf">null_mut</span><span class="p">());</span>

                    <span class="k">return</span> <span class="p">(</span>
                        <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
                        <span class="nf">Some</span><span class="p">((</span>
                            <span class="n">old_keyptr</span><span class="p">,</span>
                            <span class="n">old_valptr</span>
                        <span class="p">))</span>
                    <span class="p">);</span>
                <span class="p">}</span>

                <span class="k">let</span> <span class="n">nil_dir</span> <span class="o">=</span> <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span> <span class="nb">Left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">Right</span> <span class="p">};</span>
                <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">if</span> <span class="n">nil_dir</span><span class="nf">.is_left</span><span class="p">()</span>
                    <span class="p">{</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nd">bst_predecessor!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">};</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">l_entry</span><span class="p">)</span>
                    <span class="o">=</span> <span class="k">self</span><span class="nf">.remove_at</span><span class="p">(</span><span class="nd">child!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">nil_dir</span><span class="nf">.rev</span><span class="p">()),</span> <span class="nd">key!</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">());</span>

                <span class="nd">conn_child!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">nil_dir</span><span class="nf">.rev</span><span class="p">());</span>

                <span class="k">let</span> <span class="n">old_keyptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">old_valptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">l_entry</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="nf">Some</span><span class="p">((</span><span class="n">old_keyptr</span><span class="p">,</span> <span class="n">old_valptr</span><span class="p">))</span>
            <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">t</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">||</span> <span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.lv</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">t</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* Decrease lv */</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">lv</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">min</span><span class="p">(</span><span class="n">left</span><span class="nf">.lv</span><span class="p">(),</span> <span class="n">right</span><span class="nf">.lv</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">t</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">lv!</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">right</span><span class="nf">.lv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">lv!</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* Tripple skew */</span>

        <span class="n">t</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.skew</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

        <span class="c1">// Warnning: right(t) changes after this</span>
        <span class="k">self</span><span class="nf">.skew</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>

        <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.skew</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">)));</span>
        <span class="p">}</span>

        <span class="cm">/* Double split */</span>

        <span class="n">t</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">popped</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>AA 是更扁平化的红黑树变种也因此需要付出更多的旋转来维护平衡，实际测试感觉和 AVL 差不多，总体结果就是没什么用，一方面不如 AVL 更容易实现，一方面也丢掉了红黑树维护旋转少的特点，和 LLRB 一样鸡肋。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry></feed>