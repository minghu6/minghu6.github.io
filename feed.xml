<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-03-16T22:11:58+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">BT(2) - B+树（TreeMap）</title><link href="/algs/BT-2-BPT2.html" rel="alternate" type="text/html" title="BT(2) - B+树（TreeMap）" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-2-BPT2</id><content type="html" xml:base="/algs/BT-2-BPT2.html"><![CDATA[<p>对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。</p>

<p>没错，现在我们就是要用前文实现的 B+ 树作为我们新 B+ 树的节点基础。当然这是一个递归的概念，我们也可以继续下去把这个新的 B+ 树的实现作为节点基础实现 B+ 树，如此 $3$ 层、$4$ 层的嵌套。但从 $m$ 常数的角度，两层就够了，再多也没有意义，通常 $m$ 也就是一百左右，次级的 B+ 树的 $m$ 最多也就是就是十几，已经什么空间了，何况因此获得的性能增长也呈指数级下降。</p>

<p>但是实现用前面实现的 B+ 树作为节点的基础，还需要实现额外的一些 public method ，包括增加字段，比如统计键值总数的 cnt 字段等等。但是如何扩写 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树一时难以论说，事实上扩写&amp;重构改动的代码比原代码还长，所以就把它放到下一篇介绍，那时将得到一个相对完整的 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树。</p>

<p>这里会列出一个作为节点实现 B+ 树的 <a href="#方法统计">TreeMap 需要实现的方法</a>，既作为下一篇的索引，也作为用其他 TreeMap 代替实现时的参考。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>这里增加了 <code class="language-plaintext highlighter-rouge">cnt</code> 统计字段和 <code class="language-plaintext highlighter-rouge">min_node</code> 用于快速范查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees powered by B+ tree</span>
    <span class="cd">///</span>
    <span class="n">BPT2</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>TreeMap 实现的 B+ 树和数组实现的 B+ 树在内部节点的设计上有质的不同。</p>

<p>数组版本的，键值和孩子是按照索引来排的，而 TreeMap 则是按照唯一的键值来排列的。这既省了事儿又另一方面多了事儿，整个节点状态维护的逻辑都发生了变化。</p>

<p>首先从节点布局上，内部节点的 <code class="language-plaintext highlighter-rouge">keys</code> 字段没有存在的意义，直接使用 <code class="language-plaintext highlighter-rouge">children</code> map，但是这样对 map 的键的维护就成了一个关键。如何选取一个合适的键来代表孩子呢？</p>

<p>有两种明显的思路：</p>

<ol>
  <li>就用节点的最小值作为键，这样查询起来非常快，可以快速失败，但是当节点的最小键发生变化时，必须向上更新 map 来维护这一性质；</li>
  <li>那么用任意孩子节点的任一一个键就不需要始终维护了，但这样的话查询的时候就不知道到底要落到哪一个键上，就查询左右两个键的孩子的所有键值也解决不了问题，因为它们也不一定都是最小键</li>
</ol>

<p>于是显然，我们采用把最小键最为子节点在父节点上的键的设计。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SUB_M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础方法">基础方法</h2>

<h3 id="搜索到叶子">搜索到叶子</h3>

<p>这里会用到 TreeMap 里面的一个配合方法，<code class="language-plaintext highlighter-rouge">low_bound_search</code> ，是搜索 $\geqslant k$ 的第一个节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf_r</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.low_bound_search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点访问">节点访问</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">min_key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.min_key</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">k</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"No min-key {:?}"</span><span class="p">,</span> <span class="nv">$x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点">创建节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">BPT</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">entries</span><span class="nf">.insert</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">);</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="一般公开方法">一般公开方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min_node</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="范围查询">范围查询</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
                <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span> <span class="o">=</span> <span class="n">entries</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">fst</span><span class="p">;</span>

                    <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="n">ent</span>
                    <span class="p">}</span>

                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="插入">插入</h2>

<h3 id="主流程">主流程</h3>

<p>插入的时候，检查是否需要更新 map 的索引。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* new min none */</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* insert into leaf */</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<p>索引更新需要一路向上检查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">old_k</span> <span class="o">!=</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* update x key */</span>

            <span class="k">let</span> <span class="n">old_p_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_p_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升">节点提升</h3>

<p>到目前位置 TreeMap 的节点实现给我们增加了很多麻烦，但当分裂节点的时候，就很简单了<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，这里的 <code class="language-plaintext highlighter-rouge">split_off</code> 的表现和 <code class="language-plaintext highlighter-rouge">Vec</code> 的一致。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span>
                <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">((</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x2_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">bpt!</span> <span class="p">{</span>
                <span class="n">x_k</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">x2_k</span> <span class="k">=&gt;</span> <span class="n">x2</span>
            <span class="p">};</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="c1">// insert new or update</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x2_k</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="删除">删除</h2>

<h3 id="主流程-1">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">remove_on_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<p><strong>在本方法和后面的重平衡方法里更新索引时很容易出错，需要仔细考虑，比如同时更新两个索引时可能会出现键值覆盖的问题。</strong></p>

<p><code class="language-plaintext highlighter-rouge">rank</code>：查询键排名，从 $0$ 开始</p>

<p><code class="language-plaintext highlighter-rouge">nth</code>：根据排名，返回键值，从 $0$ 开始</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.rank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">old_k</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// merge with left_sib (no need to update index)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sib_lf</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for right_sib (merge into left)</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="c1">// 由于没有prev，只能总是合并到左节点，好在此时叶子节点只有一个元素</span>
            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">));</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// remove x from p</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

                <span class="c1">// 不需要更新索引，因为 sib_rh 值更大</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_key_sib_rh</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_key_sib_rh</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.1</span><span class="p">;</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_key</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// try to redistribute with left</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// try to redistribute with right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// WARNING： it wll replace sib_rh with x</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">),</span> <span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">sib_rh_old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// 不需要像叶子节点那样两段儿更新是因为在叶子更新的时候，已经对 x 向上更新过了</span>
                <span class="c1">// Self::update_index(old_k, x);</span>
                <span class="c1">// children_mut!(p).insert(min_key!(sib_rh), sib_rh);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">sib_rh_old_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="测试">测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT2"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Internal</span> <span class="p">{</span> <span class="n">children</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">f</span>
                <span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Internal"</span><span class="p">)</span>
                <span class="nf">.field</span><span class="p">(</span><span class="s">"children"</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
                <span class="nf">.finish</span><span class="p">(),</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Leaf"</span><span class="p">)</span><span class="nf">.field</span><span class="p">(</span><span class="s">"entries"</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span><span class="nf">.finish</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{self:?}"</span><span class="p">);</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {lv} #############"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">println!</span><span class="p">();</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="校验方法">校验方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">);</span>

                        <span class="c1">// children!(child).validate();</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="c1">// entries!(child).validate();</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="方法统计">方法统计</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">BPT</th>
      <th style="text-align: center">Tree Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">select/select_mut</td>
      <td style="text-align: center">select_mut</td>
    </tr>
    <tr>
      <td style="text-align: center">remove etc.</td>
      <td style="text-align: center">remove</td>
    </tr>
    <tr>
      <td style="text-align: center">insert etc.</td>
      <td style="text-align: center">insert</td>
    </tr>
    <tr>
      <td style="text-align: center">search_to_leaf_r</td>
      <td style="text-align: center">low_bound_search</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">len</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min</td>
    </tr>
    <tr>
      <td style="text-align: center">promote</td>
      <td style="text-align: center">split_off</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">nth</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">rank</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">push_back</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">pop_first/pop_last</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min_key</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="总结">总结</h2>

<p>运行一个简单的基准测试，结果符合预期：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">环境</th>
      <th style="text-align: left">值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CPU</td>
      <td style="text-align: left">Intel Haswell Core i5-4590</td>
    </tr>
    <tr>
      <td style="text-align: left">Memory</td>
      <td style="text-align: left">16 GB</td>
    </tr>
    <tr>
      <td style="text-align: left">Key Size</td>
      <td style="text-align: left">8 Bytes</td>
    </tr>
  </tbody>
</table>

<p>最优配置：</p>

<p>$\text{SUB_M} = 20$</p>

<p>$10 \leqslant M \leqslant 20$</p>

<ol>
  <li>查询性能非常好，<strong>比 Rust 标准库里 HashMap 的查询速度还要快25%！</strong>但是这种加速不是 B+ 树结构本身所导致的，而是 Map 的使用使得节点的内存布局在缓存上更有利，也就是单一数组的 TreeMap 比起分离的两个数组更有利，换言之，<strong>直接使用单一数组实现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的 Map 性能会更好！</strong></li>
  <li>插、删的性能介于传统 BST 和 B 树、B+ 树之间</li>
</ol>

<p>这个结果符合了理论和经验上的预期，最后再补充一个对比测试：</p>

<p>B+ Tree <code class="language-plaintext highlighter-rouge">push_back</code>-<code class="language-plaintext highlighter-rouge">pop_first</code> vs Vec <code class="language-plaintext highlighter-rouge">push</code>-<code class="language-plaintext highlighter-rouge">remove(0)</code> on <code class="language-plaintext highlighter-rouge">u64</code></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M</th>
      <th>batch CroSS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">105</td>
      <td>1150</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td>2500</td>
    </tr>
  </tbody>
</table>

<p>也就是说当数据量要足够大才能发挥出算法上的性能才能抵消缓存的优势，而在最佳 M 范围下，数组实现具有明显优势。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>只不过看起来 <code class="language-plaintext highlighter-rouge">split_off</code> 大概也是得自己实现 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">比如 Vec&lt;KVEntry&lt;K, V&gt;&gt;</code> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。]]></summary></entry><entry><title type="html">BT(3) - B+树完整版以及B*性质</title><link href="/algs/BT-3-BPT_complete_with_star.html" rel="alternate" type="text/html" title="BT(3) - B+树完整版以及B*性质" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-3-BPT_complete_with_star</id><content type="html" xml:base="/algs/BT-3-BPT_complete_with_star.html"><![CDATA[<p>继承前两篇 <a href="/algs/BT-1-BPT.html">B+树(Vec)</a> 和 <a href="/algs/BT-2-BPT2.html">B+树(TreeMap)</a> 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在<a href="https://github.com/minghu6/rust-minghu6/tree/snapshot-2">这里</a></p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>为了 <code class="language-plaintext highlighter-rouge">pop_first</code> / <code class="language-plaintext highlighter-rouge">pop_last</code> 增加了最小、最大节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">max_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="新增简单方法">新增简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">entries</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.nodes</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">values</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">drop</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// collect all item without drop itself used for BPT2::remove</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">drain_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.min_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.max_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.max_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="修改的既有方法">修改的既有方法</h2>

<h3 id="插入">插入</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">x2</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* merge node */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_internal</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"min_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"max_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="新增方法">新增方法</h2>

<h3 id="push_back">push_back</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into max</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push_front">push_front</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into min</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="c1">// self.insert_into_leaf(x, k, v);</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_first">pop_first</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* min-key has no internal index */</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_last">pop_last</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_last</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">internal_and_idx</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rank">rank</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Start from 0 O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">rank</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>
                <span class="n">is_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">rem</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">rem</span> <span class="o">+=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">rk</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">is_err</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nth">nth</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return Nth child (start from 0), O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="split_off">split_off</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return [at, ...)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">split_off</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">oth</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">at</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">oth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">oth</span><span class="nf">.bulk_push_front</span><span class="p">(</span><span class="k">self</span><span class="nf">.bulk_pop</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">at</span><span class="p">));</span>

        <span class="n">oth</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="b-性质">B* 性质</h2>

<p>B* 就是在键值插入的时候如果发生节点溢出时，不急着先分裂节点，而是和删除时一样，首先尝试从邻居节点进行平衡操作。</p>

<h3 id="try_balacing">try_balacing</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution_eager</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vec_even_up</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">left_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">right_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left_old_len</span> <span class="o">&lt;</span> <span class="n">right_old_len</span>  <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_old_len</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span><span class="o">-</span><span class="n">right_old_len</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vec_even_up">vec_even_up</h3>

<p>保持左右的顺序前提下，平分左右两个数组。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Even up two vector using clone</span>
<span class="cd">///</span>
<span class="cd">/// (This implementation is inspired by Vec::remove)</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">/// use m6_common::vec_even_up;</span>
<span class="cd">///</span>
<span class="cd">/// /* case-0 left max for pop is easy (odd) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..7).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-1 the left is samller (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..8).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-2 the left is larger (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..4).collect();</span>
<span class="cd">/// let mut v1 = (4..6).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2]);</span>
<span class="cd">/// assert_eq!(v1, vec![3, 4, 5]);</span>
<span class="cd">///</span>
<span class="cd">///</span>
<span class="cd">/// /* case-3-0 the left is larger (given more than old_len) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..7).collect();</span>
<span class="cd">/// let mut v1 = (7..9).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2, 3, 4,]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7, 8]);</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">vec_even_up</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v0</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v0_old_len</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">v1_old_len</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">tnt</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">+</span> <span class="n">v1_old_len</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">cnt_lf</span> <span class="o">=</span> <span class="n">tnt</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">cnt_rh</span> <span class="o">=</span> <span class="n">tnt</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

    <span class="cm">/* Check if it's balanced? */</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">==</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">v1</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cnt_rh</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">v0_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">v1_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::{</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy_nonoverlapping</span><span class="p">,</span> <span class="n">read</span> <span class="p">};</span>

    <span class="c1">// V0 is smaller</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">&lt;</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="c1">// let v0_get = cnt_lf - v0_old_len;</span>
        <span class="k">let</span> <span class="n">v1_given</span> <span class="o">=</span> <span class="n">v1_old_len</span> <span class="o">-</span> <span class="n">cnt_rh</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">v0</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">v</span>
        <span class="p">});</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v1_given</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">cnt_rh</span>
            <span class="p">);</span>

            <span class="n">v1</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// V0 is larger</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0_given</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v0_ptr</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="n">v1</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Fill with dirty data</span>
            <span class="c1">// read(v0_ptr)</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">zeroed</span><span class="p">()</span>
        <span class="p">});</span>

        <span class="c1">// get ptr after resize to avoid realloc issue</span>
        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v0_given</span><span class="p">),</span>
                <span class="n">v1_old_len</span>
            <span class="p">);</span>

            <span class="nf">copy_nonoverlapping</span><span class="p">(</span>
                <span class="n">v0_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v0_given</span>
            <span class="p">);</span>

            <span class="n">v0</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>B* 没什么用，对插入的性能改进没有什么帮助</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[继承前两篇 B+树(Vec) 和 B+树(TreeMap) 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在这里]]></summary></entry><entry><title type="html">BT(1) - B+树（Vec）</title><link href="/algs/BT-1-BPT.html" rel="alternate" type="text/html" title="BT(1) - B+树（Vec）" /><published>2023-03-13T00:00:00+08:00</published><updated>2023-03-13T00:00:00+08:00</updated><id>/algs/BT-1-BPT</id><content type="html" xml:base="/algs/BT-1-BPT.html"><![CDATA[<p>在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。</p>

<p>如果说之前好不容易把观念从二叉搜索树转换到了 B 树，那么从现在开始，从 B 树到 B+ 树又需要有一个很大的观念转变。不过请放心，本文讲得是依靠 <code class="language-plaintext highlighter-rouge">Vec</code> 实现的 B+ 树，后面还会介绍用 <code class="language-plaintext highlighter-rouge">TreeMap</code> 实现的 B+ 树，那时又需要一个很大的观念转变。</p>

<p>整个 B 树系列计划了四篇文章，即使层层铺叠，每篇间的学习曲线都很陡峭，可谓是一山四绝弯！</p>

<h2 id="概念基础">概念基础</h2>

<p>B+ 树区别于普通 B 树的主要特点是中间节点有键无值<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ，而在最底层的叶子上存储数据。另外叶子节点存储有 next 指针，指向它的后继节点，为得是高效的范围查询。</p>

<p>由于更好的缓存适应性，B+ 树的基础操作 查/增/删 都明显快于普通 B 树，完全可以当做普通 B 树的上位替代。</p>

<h3 id="观念挑战">观念挑战</h3>

<p>虽然看起来只是一个小小的改变，但又一次颠覆了习惯的概念。</p>

<ol>
  <li>从二叉搜索树到 B 树，我们一直习惯的是键就是键值的代名词，但正如前面节点不再是键的代名词，这里键与值的关系也分开了；</li>
  <li>进一步考虑，这就出现了叶子上必然存在一个键，而中间节点里可能还存在一个重复的键；</li>
  <li>也就是说父节点的键与子节点键的大小关系也不同了，不仅是大于或者小于，还有可能是相等的关系</li>
</ol>

<p>因此这里还要明确一下：B+ 树父节点的键可能与子节点的最小键相等，这符合左闭右开的惯例。</p>

<h3 id="索引的重要性质">索引的重要性质</h3>

<p>不是叶子节点上的每一个键值都在内部节点上有一个键，在内部节点的键有两种情况：</p>

<p><img src="/../assets/img/bt_bpt_vec/dupidx.png" alt="" /></p>

<ol>
  <li>每个根的叶子节点，除了第一个以外，每个叶子的最小键，都在这个这个根上有对应的键，就是左键<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>；</li>
  <li>第一个叶子节点除了最小的根以外，在根或者根的祖先上也有对应的键</li>
</ol>

<p>也就是说，<strong>所有中间节点的键由且仅由除了第一个节点以外的每个叶子节点的最小键组成</strong></p>

<p>在我做调查的过程中发现这个索引的性质在有的实现里并没有被尊重，这不会直接影响功能的实现，却破坏了 B+ 树的性质，引入了潜在的 Bug ：删除会导致中间节点存在废弃的键。</p>

<h3 id="重平衡">重平衡</h3>

<p>过程与 B 树一致，只是分裂节点时由弹出中间的键改为克隆中间的键，合并节点的时候只删除父节点对应键而不是并入节点，因此这里就不再赘述。</p>

<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">在线的 B+ 树的模拟页面</a></p>

<h2 id="实现-数据结构">实现-&gt;数据结构</h2>

<h3 id="树">树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>B+ 树叶子节点和内部节点的字段区别还是很大的，是否沿用之前的同构的设计是个值得思考的问题。</p>

<p>我们比较这两种设计的 drawback：</p>

<p>如果采用同构：</p>

<ol>
  <li>会有冗余字段，每个字段都占了至少是指针宽度的空间；</li>
  <li>节点看起来有些杂乱，严重降低代码可读性</li>
</ol>

<p>如果采用异构：</p>

<ol>
  <li>由于使用了枚举，导致之前积累的宏没法儿使用，需要重写一套，另外还要编写配套的内部节点的属性访问代码</li>
</ol>

<p>看起来没有哪一个是写起来又好又快的，但是我们再仔细考虑发现：</p>

<ol>
  <li>同构的设计还是需要一个单独字段来内省地判断自己是叶子节点还是中间节点，它和异构的枚举实现的区别本质上只是一个是手搓的、特化的，一个是系统的、泛化的；</li>
  <li>编程也有一个不可能三角：</li>
</ol>

<p><img src="/../assets/img/bt_basic/prog_triangle.png" alt="" /></p>

<p>一般地，条件允许下，是牺牲部分代码简洁性，来保障另外的两个目标。</p>

<p>因此这里我还是采用了异构的设计：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">keys</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<p>内部节点的属性访问方法：</p>

<p>使用宏来统一描述这个方法，来避免无谓的代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Node_ heap data field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__heap_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Node_ WeakNode field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__wn_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是属性访问就可以写成：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这就可以写 B+ 树 专属的生成宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro_bpt</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="nv">$$val</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用它来生成节点包装 <code class="language-plaintext highlighter-rouge">Node</code> 的属性访问的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="实现-基础方法">实现-&gt;基础方法</h2>

<h3 id="搜索到叶子节点">搜索到叶子节点</h3>

<p>和 B 树的节点上的递归搜索方法一样，只是当在中间节点遇到相等的键时不是直接退出而是在它的右孩子上继续搜索。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询节点属性">查询节点属性</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小最大节点">最小/最大节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">min_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">max_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点包装">创建节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$keys:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">keys</span><span class="p">:</span> <span class="nv">$keys</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-简单方法">实现-&gt;简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-范围查询">实现-&gt;范围查询</h2>

<p>使用前面二叉搜索树里的 <code class="language-plaintext highlighter-rouge">mut_self</code> 宏来少些一点儿代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                <span class="c1">// Nil</span>
                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c1">// Leaf</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                        <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                    <span class="p">};</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_node</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">==</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="o">..</span><span class="p">];</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">range</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ent</span><span class="na">.1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="o">..</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-插入">实现-&gt;插入</h2>

<h3 id="插入主流程">插入主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升方法">节点提升方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-删除">实现-&gt;删除</h2>

<p>这里特别需要注意的是，</p>

<h3 id="删除主流程">删除主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>    

	<span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_internal_key</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">internal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">i_idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">new_key</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="cm">/* check remain node */</span>

            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="c1">// right sib</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="cm">/* use default (left first)*/</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">internal</span><span class="p">)[</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Exclude leaf node and nil node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="c1">// Left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">);</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="合并节点">合并节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="c1">// update pred</span>
            <span class="k">if</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">pred!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-测试">实现-&gt;测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
	<span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">writeln!</span><span class="p">(</span>
                            <span class="n">f</span><span class="p">,</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性质校验">性质校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
    <span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert_eq!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                            <span class="s">"{child:?}"</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                            <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nd">assert_eq!</span><span class="p">(</span>
                                    <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span>
                                <span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="cm">/* search obsoleted key */</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nd">search_to_leaf!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">leaf</span><span class="nf">.is_none</span><span class="p">()</span>
                                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span>
                                    <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span>
                                <span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span>
                            <span class="p">{</span>
                                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Found obsoleted key: {k:?}"</span><span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                            <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="nd">last_key!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">last_key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这是等价转换后的说法，原始说法是所有的节点都只保留键，而在底部额外加一层数据节点 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>反证法，如果那个左键与叶子节点上的不相等，那么那个左键就找不到对应的键值了 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。]]></summary></entry><entry><title type="html">单词与短语</title><link href="/oth/WordAndPhase.html" rel="alternate" type="text/html" title="单词与短语" /><published>2023-02-27T00:00:00+08:00</published><updated>2023-02-27T00:00:00+08:00</updated><id>/oth/WordAndPhase</id><content type="html" xml:base="/oth/WordAndPhase.html"><![CDATA[<h2 id="a">A</h2>

<h3 id="a-grinding-halt">a grinding halt</h3>

<p>陷入停顿</p>

<ol>
  <li>Memory-hogging programs can deplete the system’s memory, bringing the whole system to <strong>a grinding halt</strong>.</li>
</ol>

<h2 id="b">B</h2>

<h2 id="c">C</h2>

<h3 id="contemporary">Contemporary</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈtempəˌrerē/</code></p>

<p>当代的</p>

<ol>
  <li>Such devices are hard to find on <strong>contemporary</strong> computers.</li>
</ol>

<h3 id="consensus">Consensus</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈsensəs/</code></p>

<p>noun</p>

<p>共识</p>

<ol>
  <li>However, it may take some time to come to a <strong>consensus</strong> on a final control solution.</li>
</ol>

<h2 id="d">D</h2>

<h3 id="deplete">Deplete</h3>

<p><code class="language-plaintext highlighter-rouge">/dəˈplēt/</code></p>

<p>verb</p>

<p>耗尽</p>

<ol>
  <li>Memory-hogging programs can <strong>deplete</strong> the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h3 id="dedicate">Dedicate</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkāt/</code></p>

<p>verb</p>

<p>奉献</p>

<h3 id="dedicated">Dedicated</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkādəd/</code></p>

<p>adj</p>

<p>专用的</p>

<p>This enables batch managers monitoring jobs running in <strong>dedicated</strong> cpusets to efficiently detect what level of memory pressure that job is causing。</p>

<h2 id="e">E</h2>

<h2 id="f">F</h2>

<h2 id="g">G</h2>

<h2 id="h">H</h2>

<h3 id="hog">Hog</h3>

<p><code class="language-plaintext highlighter-rouge">/hôɡ,häɡ/</code></p>

<p>verb</p>

<p>抢占</p>

<ol>
  <li><strong>Memory-hogging</strong> programs can deplete the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h2 id="i">I</h2>

<h3 id="imminent">Imminent</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈimənənt/</code></p>

<p>adj</p>

<p>迫在眉睫的</p>

<ol>
  <li>This can include the cgroup oom notifier behavior when a collection of tasks is completely out of memory, but can also warn when such a condition may be <strong>imminent</strong>.</li>
</ol>

<h3 id="initiative">Initiative</h3>

<p><code class="language-plaintext highlighter-rouge">/iˈniSHədiv/</code></p>

<p>noun</p>

<p>积极性、倡议</p>

<ol>
  <li>these new <strong>initiatives</strong> of offering better control to the user in selecting the process to be the sacrificial lamb are steps to a robust design to give more control to the user.</li>
</ol>

<h2 id="j">J</h2>

<h2 id="k">K</h2>

<h3 id="keep-account-of">keep account of</h3>

<p>记录</p>

<ol>
  <li>This chapter describes the structures used to <strong>keep account of</strong> memory banks, pages and the flags that affect VM behaviour.</li>
</ol>

<h2 id="l">L</h2>

<h2 id="m">M</h2>

<h3 id="metric">Metric</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈmetrik/</code></p>

<p>adj</p>

<p>noun</p>

<p>（系统、标准）衡量</p>

<ol>
  <li>The memory_pressure of a cpuset provides a simple per-cpuset <strong>metric</strong> of the rate that the tasks in a cpuset are attempting to free up in use memory on the nodes of the cpuset to satisfy additional memory requests.</li>
</ol>

<h2 id="n">N</h2>

<h2 id="o">O</h2>

<h3 id="out-of-curiosity">out of curiosity</h3>

<p>出于好奇</p>

<ol>
  <li><strong>Out of curiosity</strong> I compiled both versions and ran objdump on the binaries, to see how many bytes were saved.</li>
</ol>

<h3 id="overlook">Overlook</h3>

<p>verb</p>

<p>忽视</p>

<ol>
  <li>The primary reason is that they have been run passively, “fire and forget” style, with no additional analysis, and all problems were <strong>overlooked</strong>.</li>
</ol>

<p>从上面看</p>

<h2 id="p">P</h2>

<h3 id="put-simply">put simply</h3>

<p>简单说</p>

<ol>
  <li><strong>Put simply</strong>, it costs less to balance between two smaller sched domains than one big one, but doing so means that overloads in one of the two domains won’t be load balanced to the other one.</li>
</ol>

<h3 id="proper">Proper</h3>

<p>adj</p>

<p>正确的</p>

<p>合适的</p>

<ol>
  <li>Active benchmarking helps you accurately test the true target of the benchmark, and <strong>properly</strong> understand its results</li>
</ol>

<p>adv</p>

<ol>
  <li>令人满意地、正确地</li>
</ol>

<h3 id="properly">Properly</h3>

<p>adv</p>

<p>正确地</p>

<p>properly understand vs understand proper</p>

<h2 id="q">Q</h2>

<h2 id="r">R</h2>

<h3 id="rule-out">rule out</h3>

<p>排除</p>

<ol>
  <li>This approach can specify only one name at a time, <strong>ruling out</strong> the possibility of a hierarchy</li>
</ol>

<h2 id="s">S</h2>

<h3 id="substantial">Substantial</h3>

<p><code class="language-plaintext highlighter-rouge">/ˌsəbˈstan(t)SHəl/</code></p>

<p>adj</p>

<ol>
  <li>
    <p>相当数量的</p>
  </li>
  <li>
    <p>实质性的</p>
  </li>
  <li>
    <p>This policy can provide <strong>substantial</strong> improvements for jobs that need to place thread local data on the corresponding node</p>
  </li>
</ol>

<h3 id="stall">Stall</h3>

<p><code class="language-plaintext highlighter-rouge">/stôl/</code></p>

<p>n.</p>

<p>（市场）摊位、隔间</p>

<p>（马厩、谷仓中动物的）隔间</p>

<p>verb</p>

<p>（引擎）停止运行</p>

<ol>
  <li>It’s intended to be simple, minimizing variation caused by cache misses, <strong>stall cycles</strong>, and branch misprediction.</li>
</ol>

<p>停滞（取得进展）</p>

<h2 id="t">T</h2>

<h3 id="tame">Tame</h3>

<p><code class="language-plaintext highlighter-rouge">/tām/</code></p>

<p>adj 温顺的</p>

<p>verb 驯服</p>

<ol>
  <li>This calls for a different design to <strong>tame</strong> the OOM killer.</li>
</ol>

<h2 id="u">U</h2>

<h3 id="utilize">Utilize</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈyo͞odlˌīz/</code></p>

<p>verb</p>

<p>利用</p>

<p>underutilize 未利用</p>

<ol>
  <li>If one CPU is <strong>underutilized</strong>, kernel code running on that CPU will look for tasks on other more overloaded CPUs and move those tasks to itself,</li>
</ol>

<h2 id="v">V</h2>

<h2 id="w">W</h2>

<h2 id="x">X</h2>

<h2 id="y">Y</h2>

<h2 id="z">Z</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[A]]></summary></entry><entry><title type="html">BT(0) - B树</title><link href="/algs/BT-0-BT.html" rel="alternate" type="text/html" title="BT(0) - B树" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/algs/BT-0-BT</id><content type="html" xml:base="/algs/BT-0-BT.html"><![CDATA[<p>B 树是波音实验室的 <a href="https://en.wikipedia.org/wiki/Rudolf_Bayer">Rudolf Bayer</a> and <a href="https://en.wikipedia.org/wiki/Edward_M._McCreight">Edward M. McCreight</a> 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。</p>

<p>本系列将介绍 B 树以及 B+ 树、B+ 树的 TreeMap 实现、 B+* 树等一些列算是 B 树的变种。</p>

<h2 id="概念基础">概念基础</h2>

<p>B 树是<strong>完全平衡</strong>的<strong>多路搜索树</strong>，基本上已经是传统红黑树的上位替代。</p>

<ol>
  <li>节点数的减少，极大地节省了内存；</li>
  <li>在 Intel 这样的大缓存 CPU 架构下，性能明显高于传统二叉搜索树</li>
</ol>

<p><strong>完全平衡</strong>指得是每个叶子节点到根节点的深度相等。</p>

<p>B 树节点一般可以分为最后一层的叶子节点（leaf）和中间的节点（internal），当B 树只有一层的时候，那就只有叶子节点。</p>

<p>对于 $m$ 阶 B 树（最多有 $m$ 个孩子）有这样的性质：</p>

<ol>
  <li>中间节点的键数 $N_{\large\text{key}} \in [\lceil {\large\frac{m}{2}}\rceil-1,m)$</li>
  <li>叶子节点的键数 $N_{\large\text{key}} \in [1,m)$</li>
</ol>

<p>其中根节点比较特殊，对于高度大于 $1$ 的 B 树，根节点显然属于是中间节点，但它可以像叶子节点一样最少只有单键<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。因此一些介绍里把 internal 节点的概念定义为不包括根节点，而另外的介绍里则保留这种矛盾，这是让初学者很困惑的一个地方。</p>

<p>而中间节点的最小键数 $\lceil {\large\frac{m}{2}}\rceil-1$  ，是由一个溢出节点的分裂过程推导出的：</p>

<p>假设一个节点溢出了，则此时它有 $m$ 个键，此时应该取出中间的一个键，推到父节点上，然后把左右两边的键平分为两个节点。这种情况下 $\lceil{\large\frac{m}{2}}\rceil + \lceil{\large\frac{m}{2}}\rceil - 2 = m + 1 - 2 = m - 1$ 。</p>

<p>并且显然，应该有 $m \geqslant 3$ ，二叉树一个节点里只有一个键，没有节点分裂与合并的空间。</p>

<h2 id="重平衡">重平衡</h2>

<p>我们把对插入时节点键值溢出和删除时节点键值不足的情况的处理操作，按照前文二叉搜索树的惯例，也一样地称之为重平衡。</p>

<p>文字说明未必直观，可以通过<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">在线的 B 树的模拟页面</a>直观地体验算法过程</p>

<h3 id="插入">插入</h3>

<p>当插入某个键后发现节点溢出了，就要分裂节点：</p>

<ol>
  <li>把中间的一个键提升到父节点，其余的键分到左右两个新节点<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> ；</li>
  <li>递归地在父节点上调用，直到根节点；</li>
  <li>当根节点溢出时，中间的键单独构成一个新节点，作为新的根节点<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，算法终止</li>
</ol>

<h3 id="删除">删除</h3>

<p>当删除某个键后发现节点不足，就要<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">4</a></sup>：</p>

<ol>
  <li>尝试<strong>节点重平衡</strong>；</li>
  <li>如果平衡失败，递归地<strong>合并节点</strong></li>
</ol>

<p>尝试<strong>节点重平衡</strong>（try rebalancing）：</p>

<ol>
  <li>如果有左邻居，检查左邻居节点是否有多余的键：
    <ol>
      <li>如果有，弹出最大的键替换父节点的键，而把原父节点的键插入到目标节点，分配成功；</li>
      <li>否则，继续检查</li>
    </ol>
  </li>
  <li>如果有右邻居，检查右邻居节点是否有多余的键：
    <ol>
      <li>如果有，弹出最小的键替换父节点的键，而把原父节点的键插入到目标节点，分配成功；</li>
      <li>否则，重平衡失败</li>
    </ol>
  </li>
</ol>

<p>下图假设了一个 $m=3$ 的 B 树删除情况，空白节点是被删除的 $4$ ：</p>

<p><img src="/../assets/img/bt_basic/rebalancing_1.png" alt="" /></p>

<p>之后情况变为如下所示：</p>

<p><img src="/../assets/img/bt_basic/rebalancing_2.png" alt="" /></p>

<p>递归地<strong>合并节点</strong>：</p>

<ol>
  <li>把左邻居节点、对应父节点的键和目标节点合并<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup>；</li>
  <li>递归地在父节点上调用，直到根节点；</li>
  <li>当根节点的键不足时，弹出它的孩子<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>作为新的根节点<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup></li>
</ol>

<h2 id="实现-数据结构">实现-&gt;数据结构</h2>

<h3 id="辅助宏">辅助宏</h3>

<p>就像前文二叉搜索树那样，我们首先通过一个宏，来描述这个系列的 B 树的代码结构，来避免无谓的重复<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>：</p>

<p>其中 M 表示阶数，这也暗示我们的节点将不再像二叉搜索树那样在字段名上分出键和孩子的顺序，而是采用更一般化地安排。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_tree</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span>
        <span class="nv">$treename:ident</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr:meta]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="k">=&gt;</span>
    <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
        <span class="k">pub</span> <span class="k">struct</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_low_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_high_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>节点包装 <code class="language-plaintext highlighter-rouge">Node&lt;K, V&gt;</code> 沿用<a href="/algs/BST-0-Basic.html#完整包装">二叉搜索树里的实现</a>。</p>

<p>而我对属性访问相关的宏 <code class="language-plaintext highlighter-rouge">attr</code> 和 <code class="language-plaintext highlighter-rouge">def_attr_macro</code> ，为了更加丰富的功能和完整一致的语义而进行了重构：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Evil hack for Rc&lt;RefCell&lt;T&gt;&gt;</span>
<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bor</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="n">bor</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span> <span class="o">=</span> <span class="nv">$val</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$</span><span class="p">((</span><span class="nv">$name:ident</span><span class="p">,</span><span class="nv">$ty:ty</span><span class="p">)),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">];</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="b-树结构">B-树结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B-Trees</span>
    <span class="cd">///</span>
    <span class="cd">/// Panic: M &gt; 2</span>
    <span class="cd">///</span>
    <span class="cd">/// Recommend: maybe 60, 90, 250</span>
    <span class="cd">/// (Rust use M=12 (B=6, M=2B-1+1) maybe increase it in the futer)</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="n">BT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="b-树节点">B-树节点</h3>

<p>前面都是公共的代码，而对于真正节点的定义 <code class="language-plaintext highlighter-rouge">Node_</code> 的定义是真正独特设计的体现，这里有两点需要注意的：</p>

<ol>
  <li>普通的 B 树就像二叉搜索树一样直接把键值存在一起，这里用 <code class="language-plaintext highlighter-rouge">KVEntry</code> 把它们直接放到一起便于集中管理，<code class="language-plaintext highlighter-rouge">KVEntry</code> 是一个以第一个元素为排序键的二元组。</li>
  <li>对节点内键的存储使用了连续地址的向量结构，这是我在实现时的第一选择，在经典的 CPU 架构下，这样不超过 $100$ 个 指针宽度的数组的读写是最优的<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">9</a></sup></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">clone</span><span class="p">|</span>
    <span class="n">paren</span>
<span class="p">);</span>
<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="k">ref</span><span class="p">|</span>
    <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="cd">/// 即使是叶子节点，也要保持孩子数量 = k-v 数量 + 1</span>
    <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="kventry">KVEntry</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="n">K</span><span class="p">,</span> <span class="k">pub</span> <span class="n">V</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">drain</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialEq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">==</span> <span class="n">other</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialOrd</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-基础方法">实现-&gt;基础方法</h2>

<p>如果是从二叉搜索树第一次接触到 B 树这样的 $m$ 路搜索树（$m \geqslant 3$），会感到很多观念上的不适应，一些基础操作到底怎么实现，难以想得很清楚<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">10</a></sup>。</p>

<p>一个关键的区别在于二叉搜索树一个节点只有一个键，在这种情况下，键就是节点，节点就是键，找到了节点就找到了键，反之亦然。</p>

<p>而 B 树这样的多路搜索树不止有一个键，找到了节点后还要在节点里寻找键，不仅考虑得是节点间的关系，还要考虑节点内键之间的关系，以及某个键的对应的左右孩子的索引位置。</p>

<p>因此这里我们首先要点出键和孩子在节点内的布局。</p>

<h3 id="节点布局">节点布局</h3>

<ol>
  <li>对于键，按向量的地址增长顺序从小到大排列；</li>
  <li>对于孩子，也按照同样地顺序排列</li>
</ol>

<p>这样有 $\text{len(keys) + 1 = len(children)}$ ，并且节点内索引为 $i$ 的键对应的左右孩子分别为 $\text{children}[i]$ 和 $\text{children}[i+1]$ 。</p>

<p>也就是说，与孩子同编号的是右邻居键，每个键与它的左孩子同编号：</p>

<p><img src="/../assets/img/bt_basic/key_children_idx.png" alt="" /></p>

<h3 id="创建节点">创建节点</h3>

<p>我们同样可以使用二叉搜索树那里用过的 <code class="language-plaintext highlighter-rouge">node</code> 宏来简化节点的创建。</p>

<p>创建新节点的情景有两种：</p>

<ol>
  <li>树为空的时候，从新开始创建一个叶子节点，这时只需要指明键值对儿即可；</li>
  <li>节点分裂以及 <code class="language-plaintext highlighter-rouge">push_new_level</code> 的时候，这时需要指明节点的各个属性</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">coll</span><span class="p">::{</span> <span class="o">*</span><span class="p">,</span> <span class="n">node</span> <span class="k">as</span> <span class="n">aux_node</span> <span class="p">};</span>

<span class="c1">// ...</span>

<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">;</span> <span class="mi">2</span><span class="p">];</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="求取子节点索引">求取子节点索引</h3>

<p>在二叉搜索树的系列里常用到一个给出子节点，求它是父节点的左孩子还是右孩子的操作，使用这个 <code class="language-plaintext highlighter-rouge">index_of_child</code> 宏。</p>

<p>在 B 树上更有这样需求，不管是获取键还是孩子。</p>

<p><strong>最普遍性的方法是遍历父节点的孩子索引</strong>：</p>

<p>显然它的时间复杂度是线性的，是 $O(m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(M)</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child_by_rc</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">idx</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"There are no matched child"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>虽然 $m$ 也不会很大，但是线性时间复杂度显然有改进的余地。</p>

<p>我们可以直接通过利用孩子节点里任一一个<strong>键在父节点上执行二分查找</strong>：</p>

<p>时间复杂度就变成对数级的，是 $O(\text{log}\ m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(logM) search by key</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Dup key on {oldidx}"</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">inseridx</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[track_caller]</span>
    <span class="k">fn</span> <span class="nf">last_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">ent</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"EMPTY entries"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这个方法存在限制，无法适用于空节点的情况，在删除键的一些情境下只能回归到普遍性的算法上。</p>

<h3 id="搜索到叶子节点">搜索到叶子节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// 漂亮的尾递归</span>
    <span class="k">fn</span> <span class="n">search</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-一般公开方法">实现-&gt;一般公开方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-插入方法">实现-&gt;插入方法</h2>

<h3 id="搜索插入">搜索、插入</h3>

<p>这个插入的主流程和二叉搜索树的插入结构上是类似的。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span>
                <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">y</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升">节点提升</h3>

<p>Rust 标准库里的 <code class="language-plaintext highlighter-rouge">Vec</code> 为我们提供了一切的便利方法，从二分查找到向量分割（<code class="language-plaintext highlighter-rouge">split_off</code>）。不过与其说是 Rust 为我们提供了便利，不如说是它的 API 设计指导了我们的代码风格。</p>

<p>回顾之前的<a href="#插入">节点提升的算法</a>，对比下这里的代码实现：</p>

<h4 id="分离节点">分离节点</h4>

<ol>
  <li>目标节点的键值按照 $\lceil {\large\frac{m}{2}}\rceil$ 分出右半部分，左半部分弹出尾部的键值作为提升；</li>
  <li>目标节点的孩子按照 $\lceil {\large\frac{m}{2}}\rceil$ 分出右半部分，把分出的这些键值和孩子组合成新的右邻居节点；</li>
  <li>不要忘记更新新节点的孩子的反向引用指向自己</li>
</ol>

<h4 id="检查是否停止">检查是否停止</h4>

<ol>
  <li>如果到达根节点，把提升的键值，和分裂出的两个孩子组合成新的根节点；</li>
  <li>否则把提升的键值和右邻节点插入到对应的父节点中，检查父节点是否溢出，递归地进行提升</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// 漂亮的尾递归</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">split_pos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entries_x</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entry_head</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
        <span class="nd">children_revref!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* push new level */</span>

            <span class="k">let</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">entry_head</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into paren node */</span>

            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">entry_head</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.downgrade</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>   
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">children_revref</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$x</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-删除方法">实现-&gt;删除方法</h2>

<h3 id="搜索删除">搜索、删除</h3>

<p>删除的主流程，同样类似于二叉搜索树的算法，找到目标键，和后继键交换，确保最终要删除的键位于叶子节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="k">mut</span> <span class="n">x</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>

            <span class="cm">/* Swap with its successor leaf node */</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">succ</span><span class="p">,</span> <span class="n">succ_idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="nf">.minimum</span><span class="p">();</span>

                <span class="nf">swap</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">succ</span><span class="p">)[</span><span class="n">succ_idx</span><span class="p">],</span>
                <span class="p">);</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">succ</span><span class="p">;</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">succ_idx</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="n">popped</span><span class="na">.1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Left most</span>
    <span class="k">fn</span> <span class="nf">minimum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下沉">节点下沉</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Exclude leaf node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* merge with sib node (rebalance failed means that each node are small) */</span>

            <span class="c1">// merge left child</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// merge right child</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">());</span>
                    <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<p>这里使用了二叉搜索树里定义的 <code class="language-plaintext highlighter-rouge">Dir</code> 枚举结构，提供方向标识。</p>

<p>对节点的重平衡当初是用宏来描述的，但完全可以替换成一般的方法。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">bst</span><span class="p">::{</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">};</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// (parent, left-idx, sib_dir)</span>
<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
	<span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="合并节点">合并节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// (parent, left-idx)</span>
<span class="nd">macro_rules!</span> <span class="n">merge_node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// merge right's children to the left</span>

        <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// merge entries</span>
        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="实现-测试方法">实现-&gt;测试方法</h2>

<p>这里介绍了测试与调试相关的代码</p>

<h3 id="打印节点">打印节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="nv">$x</span><span class="p">)[</span><span class="nv">$idx</span><span class="p">]</span><span class="na">.0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">kn</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}, "</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="打印树">打印树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    	<span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}</span>

                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: {p:?})"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性质校验">性质校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="nd">assert_eq!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                        <span class="s">"{child:?}"</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                        <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="p">);</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                        <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这是为了让插入提升能够在根节点处终止 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>当然实际上其中一个节点可以是旧节点的重新利用 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>这个过程在很多实现里被惯例地称为 <code class="language-plaintext highlighter-rouge">push_new_level</code> 之类的名字 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>也可以采用惰性删除的方法，但这里就不介绍了 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>当然也可以合并目标节点、父节点键和右邻居节点 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>根节点键不足的时候也就是只有空节点和一个孩子的情况 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>这个降低树高的过程可以称为 <code class="language-plaintext highlighter-rouge">pop_level</code> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>如果可以，我不愿意多打哪怕一个重复的字符 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>后面的以一种实现的性能测试实际完全验证了我的这种认识 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>对于我来讲，想不清楚的就躺床上慢慢想，这也是笛卡尔思考问题的办法，当初解析几何的想法就是在床上想出来的 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[B 树是波音实验室的 Rudolf Bayer and Edward M. McCreight 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。]]></summary></entry><entry><title type="html">疑难杂症备忘录</title><link href="/oth/BackNotes.html" rel="alternate" type="text/html" title="疑难杂症备忘录" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/oth/BackNotes</id><content type="html" xml:base="/oth/BackNotes.html"><![CDATA[<h4 id="q1">Q1:</h4>

<p>Ubuntu 22.04 叠加几次需要重启的更新后重启发现WiFi模块找不到了</p>

<p>A: 再次重启或关机重启都没有用，最后是重新关闭和启用了WiFi驱动（在软件更新里）解决的问题</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[Q1:]]></summary></entry><entry><title type="html">存储介质（0）- 基础</title><link href="/oth/StorageMedium-0-Basic.html" rel="alternate" type="text/html" title="存储介质（0）- 基础" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%200%20-%20Basic</id><content type="html" xml:base="/oth/StorageMedium-0-Basic.html"><![CDATA[<h2 id="分类">分类</h2>

<p>按照记录数据的载体，可以分为<strong>磁性存储（magnetic）</strong>、<strong>光学存储（optical）</strong>和<strong>集成电路存储</strong></p>

<h2 id="磁性存储">磁性存储</h2>

<ol>
  <li>机械硬盘</li>
  <li>软盘（floppy disk）</li>
  <li>磁带鼓</li>
</ol>

<p>一个比一个老，磁带鼓更是老资格</p>

<h2 id="光学存储">光学存储</h2>

<ol>
  <li>光盘</li>
</ol>

<h2 id="集成电路存储">集成电路存储</h2>

<p>集成电路（Integrated Circuit， IC），不管有没有晶体管，都是有有半导体材料，也直接叫做半导体存储。</p>

<p>在这样电路实现分为：<strong>RAM</strong> 和 <strong>ROM</strong></p>

<h2 id="ram">RAM</h2>

<p>RAM（Random-access memory） 分为：<strong>SRAM</strong> 和 <strong>DRAM</strong></p>

<h3 id="sram">SRAM</h3>

<p>传统上使用 $6$ 个晶体管，是“真”半导体存储。</p>

<p>更低的封装密度，更快的访问速度，更少的耗电。</p>

<h4 id="应用实例">应用实例</h4>

<p>CPU 缓存、CPU 寄存器</p>

<h3 id="dram">DRAM</h3>

<p>需要脉冲刷新，很少的晶体管，大部分是电容（各种各样绝缘材料制作）</p>

<h4 id="应用实例-1">应用实例</h4>

<p>电脑的内存条</p>

<h2 id="rom">ROM</h2>

<p>ROM（Read-only memory）</p>

<p>ROM分为：<strong>EPROM</strong>、<strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>可擦除、电可擦除、另一个电可擦除的改版</p>

<p>实际上只有 <strong>E2PROM</strong>、<strong>Flash</strong></p>

<p>重编程 ROM 重写入的次数是有限制的</p>

<p>从概念上讲，Flash 属于 E2PROM 的范畴，但是一般而讲，Flash Memory 高速高密度，有更大的擦除块和更有限的写入次数。现在一般 E2PROM 都被 Flash 替代了。</p>

<h3 id="flash">Flash</h3>

<p>分为 <strong>NOR</strong> 型 和后面发展的 <strong>NAND</strong> 型</p>

<h4 id="nor">NOR</h4>

<p>贴近原始的E2PROM，支持随机存取</p>

<h4 id="nand">NAND</h4>

<p>只支持按页存取，目标是代替固态硬盘（U盘，固态硬盘，内存卡）</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[分类]]></summary></entry><entry><title type="html">Disk上的存储结构</title><link href="/oth/StorageMedium-1-Disk.html" rel="alternate" type="text/html" title="Disk上的存储结构" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%201%20-%20Disk</id><content type="html" xml:base="/oth/StorageMedium-1-Disk.html"><![CDATA[<p>介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。</p>

<h2 id="盘片划分">盘片划分</h2>

<p>一个盘片的基本两级结构是： 轨道（Track）- 扇区（Sector）。</p>

<p>轨道是盘片上的同心圆（考虑到轨道的宽度，实际上是很窄的同心圆环）</p>

<p>而扇区则是一条轨道上按照一定角度划分的弧，是最基本的存储单元。</p>

<p>注意这个概念显然有别于几何学上的扇区，这里的扇区实际是几何意义上的扇区在某一轨道上的交集。</p>

<h2 id="轨道">轨道</h2>

<h3 id="编号习惯">编号习惯</h3>

<p>轨道的编号传统上从小到大按照从外到内的顺序。</p>

<h3 id="pmr-vs-smr">PMR vs SMR</h3>

<p>现在业界现在有两种主流的与轨道排布相关的磁记录方式：<strong>垂直式磁记录（Perpendicular magnetic recording，PMR）</strong>、<strong>叠瓦式磁记录（Shingled magnetic recording，SMR）</strong></p>

<p><strong>PMR</strong> 也可以称为<strong>传统式磁记录（Conventional magnetic recording，CMR）</strong>有着数十年的悠久历史。</p>

<p><strong>SMR</strong> 是为了增加 PMR 的存储密度上限而发明的，使用了更窄的轨道排布布局，代价是安全性和访问效率都有所下降。</p>

<h2 id="扇区">扇区</h2>

<p>传统 HDD 的扇区是 512 bytes，CD-ROM 和 DVD-ROM 是 2048 bytes，现代 HDD 的扇区是 4096 bytes。</p>

<h3 id="物理扇区和逻辑扇区">物理扇区和逻辑扇区</h3>

<p>为了向后兼容，扇区还分了<strong>逻辑扇区</strong>和<strong>物理扇区</strong>两个概念。</p>

<p><strong>物理扇区</strong>是实际上的扇区划分比如 4096 bytes。</p>

<p><strong>逻辑扇区</strong>实际上是划分了物理扇区，比如 512 bytes，以提供更小的扇区的访问的后向兼容性，但这种访问显然是低效的，因为每次都要取出整个物理扇区修改后再重新写回去。因此除非必要，默认都采取逻辑扇区和物理扇区一样大小。</p>

<h3 id="扇区结构">扇区结构</h3>

<p>header area（so-called ID） + data area</p>

<h4 id="header">header</h4>

<p>同步字节+地址标志符+缺陷标志（flaw flag）+错误检查和纠正信息，如果数据区不可靠，还可一包含备用地址</p>

<h4 id="data">data</h4>

<p>同步字节+存储的数据+错误纠正码（ECC）</p>

<h3 id="区位记录">区位记录</h3>

<p>Zero bit recording，ZBR。</p>

<p>按照传统磁盘扇区的划分方式，显然越靠外面的弧越长，磁密度越小，相对最里面的弧，显然存在严重的数据容量上的浪费。</p>

<p>如果按照半径范围，把盘上所有的轨道归为几个不同的分区（Zone），把不同的分区上的轨道的弧划分成从1到n不等数量的扇区，越靠外的弧划分出的轨道越多。</p>

<p>下图来自 <a href="https://en.wikipedia.org/wiki/Zone_bit_recording">wiki</a> ，其中红绿灰三色就是三个分区，不同分区的弧分别可以有 $1$、$2$、$4$ 个扇区。</p>

<p><img src="/../assets/img/disk/zone.svg" alt="" /></p>

<p>ZBR实际上是把原来的固定角速度转变为固定线速度，带来了数据容量的提高和外部扇区访问速度的提升。</p>

<p>不过由于系统编号管理是从到内，这就带来一个系统初创测试时期和后续使用过程中较大的性能差异的问题，有的drive会故意减慢读外周时的转速来避免这种差异。</p>

<p>现代的HDD普遍使用了 ZBR 的设计</p>

<h2 id="文件系统映射">文件系统映射</h2>

<p>block 或 allocation unit 或 cluster ，指得是文件系统存储的基本单位，对应一般从 $1$ 个扇区 ($512$ bytes) 到 $128$ 个扇区 ($64$ Kbytes )。</p>

<p>这样的 cluster 包含的扇区不一定要在物理上是连续的。<em>注意：它们不是碎片，因为在逻辑上它们是连续的</em></p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。]]></summary></entry><entry><title type="html">BST(5) - 树堆（Treep）</title><link href="/algs/BST-5-Treep.html" rel="alternate" type="text/html" title="BST(5) - 树堆（Treep）" /><published>2023-02-02T00:00:00+08:00</published><updated>2023-02-02T00:00:00+08:00</updated><id>/algs/BST-5-Treep</id><content type="html" xml:base="/algs/BST-5-Treep.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>树堆的概念首次是由 <a href="https://en.wikipedia.org/wiki/Raimund_Seidel">Raimund Seidel</a> and <a href="https://en.wikipedia.org/wiki/Cecilia_R._Aragon">Cecilia R. Aragon</a> 在 1989 年提出，它意思是节点用两个属性分别维护了二叉搜索树的性质和堆的性质。从二叉搜索树的角度看，可以类比前面的 <code class="language-plaintext highlighter-rouge">Splay树</code>，<code class="language-plaintext highlighter-rouge">Splay</code> 平衡性好要依赖于输入的数据具有随机性，而树堆干脆利用随机生成的权重来手动制造这种随机性。实质上都是通过随机化的输入来达到树结构的平衡。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Treap</span> <span class="p">{</span> <span class="n">improve_search</span><span class="p">:</span> <span class="nb">bool</span> <span class="p">});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="堆校验">堆校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Validate MaxHeap</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">));</span>
            <span class="n">left</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="n">right</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基本操作">基本操作</h2>

<p>树堆基本操作有两种方式，就像讲到一般二叉搜索树的基础方法时，一种是展开型，一种是递归型 。在常见的树堆的文章里介绍得是递归型的方法，依靠 <code class="language-plaintext highlighter-rouge">Split</code> 和 <code class="language-plaintext highlighter-rouge">Join</code> 这两个基础型方法（这两个方法本身也是递归实现的）。</p>

<p>我们这里介绍展开型的实现方法，而这种方法就像一般堆的实现一样，依赖 <code class="language-plaintext highlighter-rouge">Sift-up</code> 和 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作来维护堆修改后的性质 ，而这两个操作背后又通过树的旋转实现。树的旋转不仅保持了二叉搜索树的性质，也保留了既有的堆的权重大小关系 。</p>

<h3 id="sift-up">Sift-up</h3>

<p>把一个权重较大的节点试着向上提升，直到符合堆的性质。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">fn</span> <span class="nf">siftup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="sift-down">Sift-down</h3>

<p>把权重较小的节点向下沉，直到符合堆的性质。选择左右孩子中权重最大的那一个，把它旋转到根，如此反复直到堆的性质得到维护。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="cd">/// rotate down if MaxHeap violation</span>
<span class="k">fn</span> <span class="nf">siftdown</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_child</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_dir</span><span class="p">)</span> <span class="o">=</span> <span class="n">max_child</span> <span class="p">{</span>
            <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">child_dir</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="搜索">搜索</h3>

<p>和一般的二叉搜索树的搜索方法没什么不同。唯一特别的是两位原作者建议可以在搜索的时候给经常访问的节点更高的权重，来加快搜索效率。这样就结合了伸缩树的特点，但是没有那么直接，没有访问一次就直接提到根。我们实现这个做法是采用了 wiki 上建议，每次访问给一个随机数，当超过当前节点的权重时，就赋予这个权重然后 <code class="language-plaintext highlighter-rouge">Sift-up</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// https://en.wikipedia.org/wiki/Treap</span>
<span class="k">fn</span> <span class="nf">aragon_seidel_search_suggestion</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">neww</span> <span class="o">=</span> <span class="nf">random</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">neww</span> <span class="o">&gt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">neww</span><span class="p">);</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="插入">插入</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">Sift-up</code> 修复新节点插入时可能造成的对堆的性质的破坏</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nf">random</span><span class="p">()</span> <span class="p">});</span>

    <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>和标准的二叉搜索树的删除方法一致。有一点需要额外调整，就是当被删除的节点左右孩子都不为空的时候。这时候 <code class="language-plaintext highlighter-rouge">y</code> 与 <code class="language-plaintext highlighter-rouge">y.left</code> , <code class="language-plaintext highlighter-rouge">y.right</code></p>

<p>的权重大小关系就不确定了，需要对 <code class="language-plaintext highlighter-rouge">y</code> 进行 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-1       case-2

                    z            z
                    \            \
                    y            z.right
                                /
                                / (left-most)
                                y
                                \
                                y.right
                */</span>

            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>

            <span class="cm">/* Only y and y.left and maybe y.right violate weight */</span>
            <span class="k">self</span><span class="nf">.siftdown</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="创建">创建</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="n">improve_search</span><span class="p">:</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">improve_search</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.improve_search</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">self</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>树堆是一个相对来讲容易理解，实现简单（相对红黑树家族），性能表现令人满意的二叉搜索树的数据结构。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(3) - 伸展树（Splay Tree）</title><link href="/algs/BST-3-Splay-Tree.html" rel="alternate" type="text/html" title="BST(3) - 伸展树（Splay Tree）" /><published>2023-01-30T00:00:00+08:00</published><updated>2023-01-30T00:00:00+08:00</updated><id>/algs/BST-3-Splay-Tree</id><content type="html" xml:base="/algs/BST-3-Splay-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">伸缩树</code>（<code class="language-plaintext highlighter-rouge">Splay Tree</code>）是 <a href="https://en.wikipedia.org/wiki/Daniel_Sleator">Daniel Sleator</a> and <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a> 在 1985 年提出，它的想法就是一个，把最近访问的节点 roll 到根节点。</p>

<p>它的性质与 CPU 缓存机制非常契合，又不需要存储额外字段，常用于缓存和垃圾回收器的实现。</p>

<p>但是这样的性质也导致</p>

<ol>
  <li>查询的时候也会修改自身的结构，这在多线程环境和纯函数编程语言里会造成很大的麻烦；</li>
  <li>这不是很“体面“的平衡方法，依赖于数据访问的有一定的随机性，顺序访问会造成数据结构蜕化为链表（前一个根节点总是成为当前根节点的右子树）</li>
</ol>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Splay</span> <span class="p">{});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Splay</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="基础操作">基础操作</h2>

<h3 id="splay">Splay</h3>

<p><code class="language-plaintext highlighter-rouge">Splay树</code> 最基础的操作当然就是 <code class="language-plaintext highlighter-rouge">Splay</code> 操作，就是把树中的一个节点旋转到根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">splay</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="split">Split</h3>

<p>给定树中一个节点 <code class="language-plaintext highlighter-rouge">x</code> ，把树分为比 <code class="language-plaintext highlighter-rouge">x</code> 小（包含 <code class="language-plaintext highlighter-rouge">x</code> ）和比 <code class="language-plaintext highlighter-rouge">x</code> 大的两部分。方法是把 <code class="language-plaintext highlighter-rouge">x</code> 旋转到根，然后分出 <code class="language-plaintext highlighter-rouge">x</code> 的右子树和 <code class="language-plaintext highlighter-rouge">x</code> 的其余部分。</p>

<p>需要注意的是分割的时候需要断开连接。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">x_right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">disconn!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_right</span><span class="p">);</span>

    <span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="n">x_right</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="join">Join</h3>

<p>给两个节点，把节点代表的子树合并为一棵完整的树。能够合并前提是这两棵子树其中一棵的最大值小于另一棵的最小值，方法是把较小子树的最大值 <code class="language-plaintext highlighter-rouge">splay</code> （最大值节点的右子树为空），然后把另一棵较大的子树放到根节点的右子树位置。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">join</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">trees</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">s</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s_max</span> <span class="o">=</span> <span class="nd">bst_maximum!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_max</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">s_max</span><span class="nf">.clone</span><span class="p">();</span> <span class="c1">//  s maybe not root node</span>
        <span class="nd">conn_right!</span><span class="p">(</span><span class="n">s_max</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>注意，对<strong>子树</strong> <code class="language-plaintext highlighter-rouge">Splay</code> 的时候不会更新所属母树的根节点（左子树的根不一定是母树的根），需要手动保证树的根节点为左子树的根节点。</p>

<h2 id="总装">总装</h2>

<h4 id="搜索">搜索</h4>

<p>找到节点后额外执行 <code class="language-plaintext highlighter-rouge">Splay</code> 操作。在 Rust 实现里，如 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏所示，我们使用一个 tricky 的方法绕过可变性检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="cd">/// Hack method convert self to self_mut</span>
<span class="nd">macro_rules!</span> <span class="n">mut_self</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self</span><span class="p">:</span> <span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="nv">$self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="k">Self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>这里对 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏稍微展开讲一下：</p>

<p>作为一门现代性的语言（发明于21世纪的第二个十年，比传统主流编程语言年轻20岁），Rust 有很多编程模型上的新的探索（或者说从先锋性语言身上吸收了很多成熟的特性），前面的博文比如 Fib 堆的Rust实作、BST基础等等都谈过这里不赘述 。</p>

<p>这些特性在内存安全方面，在多线程环境下，有巨大的好处，但当编程对象是传统的树、图上的算法时，就显得非常不兼容，按照编程模型，这些传统算法都要重新设计！而另一方面， Rust 作为一门系统级编程语言，不管是出于对运行效率的极致追求还是对 C 库的向下兼容，它还是提供一种传统的，“不安全“的指针的编程模型。对指针上的操作可以绕过 Rust 诸多特性安全检查：<strong>生命周期</strong>、<strong>可变性</strong>、<strong>单一所有权</strong>等等。</p>

<p>对于 Rust 标准库的实现，他们就是在内部大量使用指针（做了一定的包装）来处理我们所面临的问题，但是他们不厚道的地方在于他们不愿意把他们标准库内部实现使用的方便工具全部开放出来，结果某种程度使得第三方不得不重新发明轮子。</p>

<p>前面我们把 key 和 val 两个字段都使用指针，就是为了能够创建非局部的引用，而 <code class="language-plaintext highlighter-rouge">mut_self</code> 通过把引用转换为指针再转换回引用，也是为了能把只读引用转换为可变引用 。</p>

<h4 id="插入">插入</h4>

<p>我们这里的插入实现，是 Rust 风格的，也就是糅合了 Push 和 Update ，需要根据插入的节点是否存在来选择 <code class="language-plaintext highlighter-rouge">splay</code> 的节点，这需要修改一下一般的插入方法。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">});</span>

    <span class="cm">/* modify a little bst_insert */</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">popped</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">splay_at</span> <span class="o">=</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">popped</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="nf">.replace_val</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
                <span class="n">splay_at</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splay_at</span><span class="p">);</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="删除">删除</h4>

<p>找到搜索节点后，（如果节点存在）<code class="language-plaintext highlighter-rouge">Split</code> 该节点，此时左子树的根节点应该就是要被删除的节点，删掉之后，把左子树的左孩子（<code class="language-plaintext highlighter-rouge">Split</code> 得到的左子树的右孩子为空）和右子树 <code class="language-plaintext highlighter-rouge">Join</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">s_left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="nd">disconn!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s_left</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.join</span><span class="p">((</span><span class="n">s_left</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry></feed>