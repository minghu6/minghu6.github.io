<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-03-27T16:26:23+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6â€™s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">åŠ é€Ÿ Rust æ„å»º</title><link href="/lang/SpeedupRustBuilding.html" rel="alternate" type="text/html" title="åŠ é€Ÿ Rust æ„å»º" /><published>2023-03-22T00:00:00+08:00</published><updated>2023-03-22T00:00:00+08:00</updated><id>/lang/SpeedupRustBuilding</id><content type="html" xml:base="/lang/SpeedupRustBuilding.html"><![CDATA[<p>é˜…è¯»äº† https://fasterthanli.me/articles/why-is-my-rust-build-so-slow</p>

<p>æ€»ç»“äº†åŠ é€Ÿçš„æ³¨æ„äº‹é¡¹ï¼š</p>

<ol>
  <li>æ‹†åˆ†è¿‡å¤§çš„ crate ï¼Œä¸€ä¸ªåŸºæœ¬ç¼–è¯‘å•å…ƒè‡³å°‘æ˜¯ä¸€ä¸ª crateï¼Œæ‹†åˆ† crate å¯ä»¥åˆ©ç”¨å¤šæ ¸ä¼˜åŠ¿</li>
  <li>æ£€æŸ¥ä¸å¿…è¦çš„ä¾èµ–ï¼ŒæŸäº›ä¾èµ–å¯èƒ½ä¼šå¤§å¹…æ‹–æ…¢ç¼–è¯‘æ—¶é—´</li>
  <li>é¿å…ä¸å¿…è¦çš„å¤šæ€ï¼Œç¼©å‡ç¼–è¯‘æ—¶é—´</li>
  <li>ä¸º release ä¹Ÿå¼€å¯å¢é‡ç¼–è¯‘ <code class="language-plaintext highlighter-rouge">incremental = true</code> ï¼Œè¿™ä¼šè®©cold build æ…¢ä¸€ç‚¹ï¼Œä½†æ˜¯å¤§å¹…åŠ é€Ÿ hot buildï¼Œ</li>
  <li>æ˜¯å¯¹äºè¢«å·¥å…·å‹ç¼©çš„ crateï¼Œdebug ç­–ç•¥ä¼šéå¸¸æ…¢ï¼Œéœ€è¦å¯¹è¿™äº›åŒ…<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides">å•ç‹¬è®¾ç½® debug ç­–ç•¥</a></li>
</ol>

<p>â€‹</p>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[é˜…è¯»äº† https://fasterthanli.me/articles/why-is-my-rust-build-so-slow]]></summary></entry><entry><title type="html">åŸºäºå‰ç¼€æ ‘çš„æŒä¹…åŒ–å‘é‡ï¼ˆTrieVecï¼‰</title><link href="/algs/TrieVec.html" rel="alternate" type="text/html" title="åŸºäºå‰ç¼€æ ‘çš„æŒä¹…åŒ–å‘é‡ï¼ˆTrieVecï¼‰" /><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><id>/algs/TrieVec</id><content type="html" xml:base="/algs/TrieVec.html"><![CDATA[<p>åœ¨å‰é¢ä»‹ç»äº†ä» Fibonacci å †ã€Dary å †ï¼Œåˆ°å›¾ä¸Šçš„è¯¸å¤šç®—æ³•ï¼Œä» BST åˆ° BT çš„ä¸€ç³»åˆ—æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œå¹¶æä¾›äº†å®ƒä»¬çš„ Rust å®ç°ï¼Œå¦‚æœæŠŠè¿™äº›ä»£ç éƒ½é›†æˆèµ·æ¥ï¼Œå¯èƒ½å°±ä¼šå‘ç°è¿™ä¸ªç¼–è¯‘çš„è¿‡ç¨‹æ€ä¹ˆè¿™ä¹ˆç†¬äººï¼Œä¼¼ä¹è¶Šæ¥è¶Šè®©äººéš¾ä»¥å¿å—ï¼Œè¿™æ—¶å¯ä»¥å‚è€ƒä¸€ä¸‹<a href="./SpeedupRustBuilding">å¦ç¯‡å…³äºé™ä½æ„å»ºæ—¶é—´çš„ç¬”è®°</a>ã€‚</p>

<h2 id="å‰è¨€">å‰è¨€</h2>

<p>æœ¬ç¯‡ä½œä¸ºä¸€ä¸ªé˜¶æ®µæ€§çš„æ€»ç»“ç¯‡ï¼Œä»‹ç»ä¸€ä¸ªåŸºäºå‰ç¼€æ ‘ï¼ˆTrieï¼‰çš„æŒä¹…åŒ–å‘é‡ï¼ˆVectorï¼‰çš„å®ç°<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ï¼Œä»¥ä¸‹ç”¨ TrieVec ç®€ç§°ã€‚</p>

<p>ä¸€æ–¹é¢ï¼ŒVector ä½œä¸ºå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€é‡Œçš„å…è®¸éšæœºè¯»å†™çš„æ•°æ®ç»“æ„ï¼Œæœ¬èº«æœ‰å¾ˆé‡è¦çš„æ„ä¹‰ï¼Œæ²¡æœ‰å®ƒï¼Œä¼ ç»Ÿçš„ç”¨ç±» C æè¿°çš„ç®—æ³•å°±æ— æ³•è½åœ°ï¼›</p>

<p>å¦ä¸€æ–¹é¢ï¼Œè®²åˆ°æŒä¹…åŒ–æ•°æ®ç»“æ„ï¼Œå…¶å®å¤§éƒ¨åˆ†éƒ½å·²æ¶‰åŠï¼Œåªæœ‰æŒä¹…åŒ–å‘é‡æ¯”è¾ƒé™Œç”Ÿå¹¶ä¸”æ¯”è¾ƒå¤æ‚ï¼Œæœ‰å¿…è¦ä¸“é—¨çœ‹ä¸€ä¸‹ï¼›</p>

<p>æœ€åï¼Œåœ¨çœ‹è¿™ä¸ªå®ç°çš„è¿‡ç¨‹ä¸­ï¼Œä¼šå‘ç°è¿™æ˜¯ä¸€ä¸ªæ€»ä½“æ¦‚å¿µé™Œç”Ÿä½†å±€éƒ¨ç»†èŠ‚ç†Ÿæ‚‰çš„æ•°æ®ç»“æ„ï¼Œå®ƒå¯ä»¥ä¸²èµ·ä¹‹å‰ä»‹ç»è¿‡çš„è¯¸å¤šæ•°æ®ç»“æ„ï¼Œä¸ç®¡æ˜¯ç»“æ„ç‰¹ç‚¹ã€è®¾è®¡æ–¹æ¡ˆè¿˜æ˜¯å®ç°æ–¹æ³•ï¼Œæ˜¯ä¸€ä¸ªåˆé€‚çš„é˜¶æ®µå°¾å£°ã€‚</p>

<h2 id="æ¦‚å¿µåŸºç¡€">æ¦‚å¿µåŸºç¡€</h2>

<p>TrieVec æœ¬è´¨ä¸Šå°±åƒæˆ‘ä»¬åœ¨<a href="/algs/DaryHeap.html">å¤šå‰å †</a>ä¸Šé‚£æ ·çš„åšæ³•ï¼Œåªä¸è¿‡å¤šå‰å †å»ºç«‹åœ¨æ•°ç»„ä¸Šï¼Œè€Œ TrieVec åˆ™ä»¥æ ‘çš„çš„å½¢å¼ç»„ç»‡ã€‚</p>

<p>æ¯”å¦‚å¯¹äºä¸€æ£µèŠ‚ç‚¹æ•°å®½åº¦ä¸º $2$ ï¼Œä¹Ÿå°±æ˜¯ $2^2 = 4$ é˜¶çš„æ ‘ï¼Œè®¿é—® idx = 54</p>

\[\begin{array}{l}
54 &amp;=\underbrace{11}\ \underbrace{01}\ \underbrace{10}\\
&amp;=\ \ \ 3\quad\ \ \ 1\quad\quad 2
\end{array}\]

<p>æƒ…å†µå¦‚ä¸‹å›¾ï¼š</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_exp.svg" width="65%" /></div>

<p>è¿™è¦æ±‚æ ‘çš„å®Œå…¨å¹³è¡¡ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªå¶å­åˆ°æ ¹çš„é«˜åº¦éƒ½ä¸€æ ·ï¼Œç„¶åæŠŠæ•°æ®å­˜å‚¨åœ¨æ¯ä¸ªå¶å­ä¸Šï¼Œè¿™ä¸€ç‚¹åˆå’Œæˆ‘ä»¬åœ¨<a href="/algs/BT-1-BPT.html">B+ æ ‘</a>ä¸Šçš„æƒ…å†µç›¸ä¼¼ã€‚</p>

<p>è€Œå¯¹æ ‘å±‚çº§çš„å®šä¹‰åˆå’Œ <a href="./BST-2-RB-Tree-2-AA">AA æ ‘</a> æ˜¯ä¸€æ ·ï¼Œç”¨ level çš„æ¦‚å¿µæ¥æè¿°æ˜¯éå¸¸æ°å½“çš„ï¼Œå¶å­å±‚çš„ level æ˜¯ $1$ ï¼Œç©ºæ ‘çš„ level æ˜¯ $0$ ã€‚</p>

<p>å¯¹äºæŒä¹…åŒ–çš„è¦æ±‚æ¥è®²ï¼Œæ¯æ¬¡æ“ä½œï¼ŒPush/Pop/Update etc. åªéœ€è¦å¤åˆ¶ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­ä¸€æ¡è·¯å¾„çš„èŠ‚ç‚¹ï¼Œå¯¹æ•°çº§åˆ«çš„å¼€é”€æ˜¯ä¸€ä¸ªå¯ä»¥æ¥å—çš„ä»£ä»·ã€‚</p>

<p>å¦å¤–ï¼Œå¯¹äºæŸäº›æ—¶é—´æ•æ„Ÿçš„ä»»åŠ¡ï¼ŒClojure è¿˜å…è®¸æŠŠæŒä¹…åŒ–çš„ç»“æ„è½¬å˜ä¸ºæ˜“å˜çš„ç»“æ„ï¼ˆTransientï¼‰æ¥åšå°±åœ°ä¿®æ”¹ï¼Œç„¶åå†è½¬å›æŒä¹…æ€§ç»“æ„ï¼Œä»¥é¿å…å¤åˆ¶å¼€é”€ã€‚è¿™æ ·çš„è¯éœ€è¦åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šåšå‡ºæ ‡è¯†æ¥è¿½è¸ªèŠ‚ç‚¹çš„åˆ›å»ºè€…ï¼Œåœ¨ä¸‹ä¸€éƒ¨åˆ†çš„<a href="#æ ‡è®°">æ ‡è®°</a>ä¸€èŠ‚å…·ä½“è®¨è®ºã€‚</p>

<p>ä¸æ˜“å˜å‘é‡çš„èŠ‚ç‚¹ï¼Œä»¥åŠåŒºåˆ†å†å²ä¸Šç”±ä¸åŒçº¿ç¨‹åˆ›å»ºçš„èŠ‚ç‚¹ã€‚</p>

<h2 id="æ•°æ®ç»“æ„">æ•°æ®ç»“æ„</h2>

<h3 id="æ ‘">æ ‘</h3>

<p>è¿™é‡Œæœ‰ä¸€ä¸ªä¼˜åŒ–çš„å°æ”¹åŠ¨<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup>ï¼Œå°±æ˜¯æŠŠ TrieVec æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆBucketï¼‰ä» Trie ä¸­å•ç‹¬æ‹¿å‡ºæ¥ï¼Œä½œä¸ºå°¾èŠ‚ç‚¹ï¼Œè¿™ä¼šä½¿å¾— Clojure é‡Œåƒ <code class="language-plaintext highlighter-rouge">conj</code> è¿™æ ·ç­‰ä»·äº push çš„æ“ä½œåœ¨å¸¸é‡æ—¶é—´é‡Œå®Œæˆã€‚æˆ‘ä»¬è®¡ç®— TrieVec çš„ç»“æ„æ—¶å€™éœ€è¦æŠŠå°¾éƒ¨èŠ‚ç‚¹çš„é•¿åº¦æ‰£é™¤ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="å¸¸é‡å®šä¹‰">å¸¸é‡å®šä¹‰</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">BIT_WIDTH</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="n">NODE_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MASK</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">NODE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="ä»-trie-size-åæ¨-trie-height">ä» Trie size åæ¨ Trie height</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">h</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">trie_height</span><span class="p">(</span><span class="nd">tailoff!</span><span class="p">(</span><span class="nv">$self</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">fn</span> <span class="nf">trie_height</span><span class="p">(</span><span class="n">trie_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">trie_size</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">x</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.ilog2</span><span class="p">()</span> <span class="o">/</span> <span class="n">BIT_WIDTH</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">h</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">h</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="æ ¹æ®æ€»ç´¢å¼•å’Œå½“å‰å±‚å¾—åˆ°ç´¢å¼•ä½ç½®">æ ¹æ®æ€»ç´¢å¼•å’Œå½“å‰å±‚å¾—åˆ°ç´¢å¼•ä½ç½®</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">idx</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$lv:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Precedence: '*' &gt; '&gt;&gt;' &gt; '&amp;'</span>
        <span class="nv">$idx</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nv">$lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BIT_WIDTH</span> <span class="o">&amp;</span> <span class="n">MASK</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="å°¾éƒ¨åç§»é‡">å°¾éƒ¨åç§»é‡</h4>

<p>ä¹Ÿå°±æ˜¯å°¾èŠ‚ç‚¹ä¹‹å‰çš„å…ƒç´ æ•°ï¼Œä¹Ÿå°±æ˜¯å®é™… Trie çš„å¤§å°</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">tailoff</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">((</span><span class="nv">$self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">BIT_WIDTH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ ‡å¿—">æ ‡å¿—</h3>

<p>ç”±äºå­˜åœ¨æŒä¹…ä¸æ˜“å˜ç‰ˆæœ¬é—´çš„è½¬æ¢ï¼Œä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½æ˜¯æŒä¹…ç‰ˆæœ¬çš„èŠ‚ç‚¹ï¼Œä¹Ÿå¯èƒ½æ˜¯å†å²ä¸Šä¸åŒçº¿ç¨‹åˆ›å»ºçš„æ˜“å˜èŠ‚ç‚¹ã€‚</p>

<p>è¿™é‡Œä½¿ç”¨ <code class="language-plaintext highlighter-rouge">u64</code> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>è¡¨ç¤ºçš„ Thread id ä½œä¸ºæ ‡å¿—ï¼Œè¡¨ç¤ºå†å²ä¸Šåˆ›å»ºæ˜“å˜èŠ‚ç‚¹çš„çº¿ç¨‹ï¼ŒThread id éƒ½å¤§äº 0 ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨ 0 æ¥è¡¨ç¤ºæŒä¹…ç‰ˆæœ¬çš„èŠ‚ç‚¹ã€‚</p>

<p>è¿™æ ·å¯¹äºå¯ç¼–è¾‘èŠ‚ç‚¹éœ€è¦æ»¡è¶³ï¼š</p>

<ol>
  <li>ä¸æ˜¯æŒä¹…åŒ–èŠ‚ç‚¹</li>
  <li>ä¸æ˜¯å†å²ä¸Šå…¶ä»–çº¿ç¨‹åˆ›å»ºçš„èŠ‚ç‚¹</li>
</ol>

<p>ä¸æ»¡è¶³æ¡ä»¶å°±éœ€è¦å¤åˆ¶èŠ‚ç‚¹ï¼Œåˆ›é€ å±äºå½“å‰çº¿ç¨‹çš„èŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.id</span><span class="p">()</span><span class="nf">.as_u64</span><span class="p">()</span><span class="nf">.get</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">no_edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">ID</span> <span class="o">=</span> <span class="nb">u64</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å†…éƒ¨èŠ‚ç‚¹">å†…éƒ¨èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ID</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array</code> ä½¿ç”¨çš„æ˜¯å‰é¢ <code class="language-plaintext highlighter-rouge">DaryHeap</code> ä½¿ç”¨è¿‡çš„åˆ†é…åœ¨å †ä¸Šçš„é™æ€æ•°ç»„ï¼›</li>
  <li><code class="language-plaintext highlighter-rouge">def_node__heap_access</code> å®ä½¿ç”¨çš„ä¹‹å‰ B+ æ ‘é‡Œé¢ä½¿ç”¨è¿‡çš„å®</li>
</ol>

<h3 id="èŠ‚ç‚¹åŒ…è£…">èŠ‚ç‚¹åŒ…è£…</h3>

<p>è€ƒè™‘åˆ°æŒä¹…åŒ–æ•°æ®ç»“æ„çš„è·¨çº¿ç¨‹ä½¿ç”¨çš„æƒ…å†µï¼ŒèŠ‚ç‚¹åŒ…è£…é‡Œé¢çš„å¼•ç”¨è®¡æ•°å™¨å°†ä¸å†é‡‡ç”¨ä¹‹å‰çš„ <code class="language-plaintext highlighter-rouge">std::rc::Rc</code> ï¼Œè€Œæ”¹ç”¨åŒæ­¥ç‰ˆæœ¬çš„ <code class="language-plaintext highlighter-rouge">std::sync::Arc</code> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup> ã€‚</p>

<p>ä½†å³ä½¿å¦‚æ­¤ï¼Œç”±äº Rust çš„ä¸¥æ ¼é™åˆ¶ï¼Œæˆ‘ä»¬ä»ç„¶ä¸èƒ½æŠŠ <code class="language-plaintext highlighter-rouge">Node</code> è·¨çº¿ç¨‹ä½¿ç”¨ï¼Œå³ä½¿æˆ‘ä»¬ç¡®ä¿¡ä½œä¸ºæŒä¹…åŒ–çš„ç»“æ„æ—¶ï¼Œæ˜¯å¯ä»¥è¿™æ ·å®‰å…¨ä½¿ç”¨çš„ã€‚åœ¨ <code class="language-plaintext highlighter-rouge">std::sync</code> çš„åŒ…é‡Œæœ‰å„ç§å„æ ·çš„åŒæ­¥æ‰‹æ®µï¼š</p>

<ol>
  <li>ä¸´ç•ŒåŒºï¼ˆExclusiveï¼‰</li>
  <li>æƒ°æ€§é”ï¼ˆLazyLockï¼‰</li>
  <li>å•å†™é”ï¼ˆOnceLockï¼‰</li>
  <li>æ …æ ï¼ˆBarrierï¼‰</li>
  <li>æ¡ä»¶å˜é‡ï¼ˆCondVarï¼‰</li>
  <li>é”ï¼ˆMutexï¼‰</li>
  <li>å•æ¬¡é” ï¼ˆOnceï¼‰</li>
  <li>è¯»å†™é” ï¼ˆRwLockï¼‰</li>
</ol>

<p>çœ‹äº†è®©äººç›´å‘¼å¥½å®¶ä¼™ï¼Œä¸Šä¸–çºªçš„é‚£ç‚¹å„¿å¤è‘£ç©æ„å„¿éƒ½è®©å®ƒç»™å¤æ´»äº†ğŸ˜…ï¼Œä½†æ˜¯è¿™é‡Œé¢æ²¡æœ‰æˆ‘ä»¬éœ€è¦çš„ï¼Œæˆ‘ä»¬çš„æŒä¹…åŒ–ç»“æ„å®é™…é¿å…äº†åŒæ­¥çš„éœ€æ±‚ï¼Œä½†æ˜¯éœ€è¦æœ‰ä¸€ç§æœºåˆ¶è®©ç¼–è¯‘å™¨çŸ¥é“è¿™ä¸ªæƒ…å†µä»¥ä¾¿èƒ½é€šè¿‡ Trait æ£€æŸ¥ï¼Œè€Œæ˜¾ç„¶æ ‡å‡†åº“é‡Œæ²¡æœ‰æä¾›è¿™ç§æ‰‹æ®µã€‚</p>

<p>ä¸è¿‡æˆ‘ä»¬è‡ªå·±å¯ä»¥é€šè¿‡å®šä¹‰ä¸€ä¸ªæ–°çš„åŒ…è£…ç»“æ„ï¼Œä¸ºå®ƒå®ç° <code class="language-plaintext highlighter-rouge">Sync</code> å’Œ <code class="language-plaintext highlighter-rouge">Send</code> ä¸¤ä¸ª Trait æ¥å®ç°æŒä¹…åŒ–ç»“æ„éœ€è¦çš„ Trait è¯­ä¹‰ï¼Œ<a href="https://github.com/bamidev/unsafe-send-sync">å·²ç»æœ‰äººå¹²å¾—å¾ˆå¥½äº†</a>ï¼Œæˆ‘ä»¬åœ¨å®ƒçš„åŸºç¡€ä¸ŠæŒ‰ç…§æˆ‘ä»¬çš„éœ€æ±‚æ”¹è¿›ï¼Œå¾—åˆ°ä¸€ä¸ªå‘ŠçŸ¥ç¼–è¯‘å™¨é€šè¿‡åŒæ­¥æ£€æŸ¥çš„åŒ…è£…ç»“æ„ï¼Œ<code class="language-plaintext highlighter-rouge">UnsafeSendSync</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="cd">/// ä¸€ä¸ªè‡ªåŠ¨å®ç°Traitçš„å®ï¼Œç»†èŠ‚ä¸å±•å¼€äº†</span>
<span class="nd">impl_unpack!</span><span class="p">(</span><span class="n">UnsafeSendSync</span> <span class="p">|</span> <span class="nb">AsRef</span><span class="p">,</span> <span class="nb">AsMut</span><span class="p">,</span> <span class="n">Deref</span><span class="p">,</span> <span class="n">DerefMut</span><span class="p">,</span> <span class="nb">From</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_ref_mut_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">_</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>äºæ˜¯æˆ‘ä»¬é‡æ–°ä¿®æ”¹äº†å‰é¢å®šä¹‰èŠ‚ç‚¹åŒ…è£…å™¨çš„ <code class="language-plaintext highlighter-rouge">impl_node</code> çš„å®ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_node</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span><span class="p">(</span><span class="k">self</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="nv">$vis</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">rc</span><span class="nf">.as_ptr</span><span class="p">(),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
                    <span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="nf">.into_inner</span><span class="p">()</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="nv">$rc:ty</span><span class="p">,</span> <span class="nv">$wk:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$vis</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="cd">/// Used for reverse reference to avoid circular-reference</span>
        <span class="cd">///</span>
        <span class="cd">/// So we can easy auto drop</span>
        <span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$wk</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">WeakNode</span><span class="p">(</span>
                    <span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                            <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="kc">false</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="o">=</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">strong</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"weak node upgrade failed"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}))</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">oth</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">oth</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>å¹¶æ›´æ–°èŠ‚ç‚¹åŒ…è£…çš„è®¿é—®å®ï¼Œå¢åŠ æ–°çš„ç”¨ä¾‹ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span><span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ref_mut_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>äºæ˜¯å¾—åˆ°æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„èŠ‚ç‚¹çš„è®¿é—®å®ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div></div>

<p>å¹¶ç”¨å®ƒä»¬å®šä¹‰ä¸€äº›èŠ‚ç‚¹åŒ…è£…ä¸Šçš„æ–¹æ³•ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">values!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ç®€å•æ–¹æ³•">ç®€å•æ–¹æ³•</h2>

<p>é¦–å…ˆå®šä¹‰ä¸‹å‘é‡çš„æŒä¹…åŒ–ç‰ˆæœ¬å’Œæ˜“å˜ç‰ˆæœ¬å…±é€šçš„ä¸€äº›æ–¹æ³•ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_trie_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
                <span class="n">tail</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="p">}</span>

        <span class="c1">// Alias as search to leaf, array_for, etc</span>
        <span class="k">fn</span> <span class="nf">down_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">)];</span>
                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>ä¸åŒäº Clojure é‡Œé¢çš„å®ç°ï¼Œæˆ‘ä»¬æ£€æŸ¥å°¾èŠ‚ç‚¹çš„ <code class="language-plaintext highlighter-rouge">id</code> è€Œä¸æ˜¯æ ¹èŠ‚ç‚¹çš„ï¼Œå› ä¸ºå°¾èŠ‚ç‚¹æ‰æ˜¯é¦–å…ˆè¢«æ’å…¥çš„èŠ‚ç‚¹</li>
</ol>

<h2 id="åˆ›å»ºèŠ‚ç‚¹">åˆ›å»ºèŠ‚ç‚¹</h2>

<p>å®šä¹‰ä¸€ä¸ªåˆ›å»ºèŠ‚ç‚¹çš„å®å¯ä»¥æå¤§åœ°æ–¹ä¾¿æˆ‘ä»¬åç»­æŒä¹…æ€§ä»¥åŠæ˜“å˜æ€§æ•°æ®ç»“æ„æ¨å…¥æˆ–å¼¹å‡ºèŠ‚ç‚¹çš„è¿‡ç¨‹ã€‚</p>

<h3 id="åŸºç¡€åˆ›å»º">åŸºç¡€åˆ›å»º</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">single</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">);</span>
        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>
        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new_with_clone</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å¸¦æœ‰å®¹ç§¯å‚æ•°çš„å¤åˆ¶">å¸¦æœ‰å®¹ç§¯å‚æ•°çš„å¤åˆ¶</h3>

<p>åˆ›å»ºä¸€ä¸ªæŒ‡å®šå¤§å°çš„æ•°ç»„ï¼Œå¹¶åœ¨å…è®¸èŒƒå›´å†…å¤åˆ¶ä¸€ä¸ªæ—¢æœ‰èŠ‚ç‚¹ã€‚è¿™æ—¢å¯ä»¥ç”¨åœ¨ <code class="language-plaintext highlighter-rouge">push</code> æ—¶åˆ›å»ºä¸€ä¸ªæ‰©å®¹çš„æ–°èŠ‚ç‚¹ï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨ <code class="language-plaintext highlighter-rouge">pop</code> æ—¶åˆ›å»ºä¸€ä¸ªç¼©å®¹çš„æ–°èŠ‚ç‚¹ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åŸå°ä¸åŠ¨åœ°å¤åˆ¶èŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...    </span>
   <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">nod</span>
    <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>       
</code></pre></div></div>

<h3 id="å¤åˆ¶æ—¶å®¹é‡-1-1">å¤åˆ¶æ—¶å®¹é‡ +1/-1</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...        </span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
		
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">dec</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>

<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¯¹ +1 å¤åˆ¶ä¸ -1 å¤åˆ¶çš„å®ç°è¡Œä¸ºæœ‰äº›ä¸åŒï¼Œ+1 å¤åˆ¶è¦å•ç‹¬åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œè¿™æ˜¯å› ä¸ºå®ƒæœ‰ä¸€ä¸ªé¢å¤–çš„å‚æ•° <code class="language-plaintext highlighter-rouge">$v</code> ï¼Œä¹Ÿå°±æ˜¯éœ€è¦æ’å…¥èŠ‚ç‚¹çš„å€¼ï¼Œè€Œå€¼çš„ç±»å‹æ˜¯å¼‚æ„çš„ï¼Œä¸èƒ½åŠ¨æ€åœ°åˆ†å‘ï¼Œåªèƒ½æ‰‹åŠ¨é™æ€åœ°åˆ†å‘ã€‚</p>

<h2 id="push">Push</h2>

<h3 id="ä¸»æµç¨‹">ä¸»æµç¨‹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="åˆ›å»ºæ–°è·¯å¾„">åˆ›å»ºæ–°è·¯å¾„</h3>

<p>åˆ›å»ºä¸€æ¡ä»æŸ $\text{lv}$ å¼€å§‹ç›´åˆ°å¶å­( $\text{lv}=1$ )çš„æ–°è·¯å¾„ï¼š</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_new_path.svg" width="40%" /></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Top-down clone new path from lv (1..h)</span>
<span class="k">fn</span> <span class="n">new_path</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">lv</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="n">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>è¿™é‡Œä½¿ç”¨äº†é€’å½’çš„å®ç°ï¼Œåœ¨åŸç‰ˆçš„ä½œä¸º Clojure æ ‡å‡†åº“çš„ Java å®ç°é‡Œæ‰€æœ‰ Trie ä¸Šçš„æ“ä½œéƒ½é‡‡ç”¨äº†ç±»ä¼¼ç»“æ„çš„é€’å½’çš„å®ç°ï¼Œè¿™æˆ–è®¸èƒ½ç®€åŒ–ä¸€äº›ä»£ç ï¼Œä½†æ˜¯ä¸¥é‡ç‰ºç‰²äº†ä»£ç çš„å¯è¯»æ€§ï¼šä¸€æ–¹é¢æ¥å£ä¸‘é™‹ï¼Œä½œä¸ºé€’å½’å‡½æ•°çš„ä»£ä»·ï¼ŒåŒ…å«äº†è¿‡å¤šä¸åº”è¯¥å±äºæ¥å£è€Œæ˜¯æ ˆä¸Šä¸´æ—¶çš„å‚æ•°ï¼›å¦ä¸€æ–¹é¢é€’å½’æœ¬èº«åˆéšè—äº†ç»†èŠ‚ï¼Œè®©äººéš¾ä»¥çœ‹æ¸…æ¥šåˆ°åº•è¿™ä¸ªè¿‡ç¨‹åšäº†ä»€ä¹ˆäº‹æƒ…ã€‚å› æ­¤åé¢æˆ‘ä»¬å°†ä½¿ç”¨æˆ‘ä»¬è‡ªå·±çš„å±•å¼€ç‰ˆæœ¬çš„å®ç°ä½œä¸ºæ›¿ä»£ã€‚</p>

<h3 id="æ¨å…¥å°¾èŠ‚ç‚¹">æ¨å…¥å°¾èŠ‚ç‚¹</h3>

<p>å½“ <code class="language-plaintext highlighter-rouge">push</code> æ—¶å‘ç°å°¾èŠ‚ç‚¹å·²æ»¡æ—¶ï¼Œéœ€è¦æŠŠæ—§çš„å°¾èŠ‚ç‚¹æ¨å…¥ Trie é‡Œé¢ï¼ŒæŒ‰ç…§ Trie æ ‘é«˜å¯ä»¥åˆ†ä¸ºä¸‰ç§æƒ…å†µï¼š</p>

<ol>
  <li>$\text{lv}=0$ ï¼Œä¹Ÿå°±æ˜¯ Trie ä¸ºç©ºçš„æƒ…å†µï¼ŒæŠŠæ—§å°¾èŠ‚ç‚¹ä½œä¸º Trie çš„æ ¹ï¼›</li>
  <li>$\text{lv}=1$ ï¼Œæ­¤æ—¶å‘ç°æ ¹æº¢å‡ºï¼Œäºæ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹åŒ…å«åŸæ¥çš„æ—§æ ¹å’Œæ¨å…¥çš„å°¾èŠ‚ç‚¹ã€‚ä½†æ˜¯æ›´è¿›ä¸€æ­¥åœ°ï¼Œå¯ä»¥æ¨å¹¿åˆ°åŒ…å« $\text{lv}=1$ åœ¨å†…çš„å…¨éƒ¨æ ¹æº¢å‡ºçš„æƒ…å†µï¼Œæ­¤æ—¶æ–°æ ¹æ’å…¥çš„ä¸æ˜¯åŸæ¥çš„å°¾èŠ‚ç‚¹ï¼Œè€Œæ˜¯ <code class="language-plaintext highlighter-rouge">new_path</code> åˆ›å»ºçš„åŒ…å«å°¾èŠ‚ç‚¹çš„ä¸€æ•´æ¡è·¯å¾„ï¼›</li>
  <li>$\text{lv} \ge 2$ ï¼Œä»æ ¹èŠ‚ç‚¹å¼€å§‹å¤åˆ¶ï¼Œæ³¨æ„é€‰æ‹©åˆé€‚çš„æ•°ç»„å®¹é‡ï¼Œå½“ä¸­é—´èŠ‚ç‚¹è¶…è¿‡ä¸€å±‚æ—¶ï¼Œè‡ªé¡¶å‘ä¸‹åœ°å¤åˆ¶æ¯ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œå¹¶æŠŠä¸Šä¸€å±‚ä¸­é—´èŠ‚ç‚¹é‡Œå¯¹æœ¬å±‚èŠ‚ç‚¹çš„å¼•ç”¨æ›´æ–°ä¸ºæ–°åˆ›å»ºçš„èŠ‚ç‚¹ï¼Œå½“å‘ç°æ–°çš„èŠ‚ç‚¹åœ¨ä¸€ä¸ªè¿˜æœªåˆ›å»ºçš„è·¯å¾„æ—¶ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">new_path</code> åˆ›å»ºåˆ°å¶å­çš„æ–°è·¯å¾„ï¼Œç„¶åæ’å…¥åˆ°ä¸Šä¸€å±‚èŠ‚ç‚¹ã€‚</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Complete trie including case lv == 1</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">p_i</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span>
                <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// Go down through the branch</span>
        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">cur</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">old_cur</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">cur_i</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                        <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                        <span class="n">old_cur</span><span class="p">,</span>
                        <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="assoc">Assoc</h2>

<p>æŒ‰ç…§ç´¢å¼•æ›´æ–°å‘é‡ï¼Œå¦‚æœç´¢å¼•å’Œé•¿åº¦ç›¸ç­‰ï¼Œå°±é¡ºåŠ¿æ’å…¥ã€‚</p>

<p>å’Œå‰é¢ <code class="language-plaintext highlighter-rouge">push_tail_into_trie</code> åŒæ ·è‡ªé¡¶å‘ä¸‹åœ°å¤åˆ¶ä¸€æ¡åªåˆ°å¶å­çš„è·¯å¾„ï¼Œåªä¸è¿‡å‰è€…ç›¸å½“äºè®¿é—®çš„ç´¢å¼•æ˜¯ <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> ï¼Œè€Œè¿™é‡Œä½¿ç”¨çš„æ˜¯ä¼ å…¥çš„ç´¢å¼•ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// idx in `[0, self.len()]` (update or push)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>

                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="pop">Pop</h2>

<h3 id="ä¸»æµç¨‹-1">ä¸»æµç¨‹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// Get empty vec</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// Get non-empty tail</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">dec</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// the last two idx</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å¼¹å‡ºå°¾èŠ‚ç‚¹">å¼¹å‡ºå°¾èŠ‚ç‚¹</h3>

<p>ä¸ <code class="language-plaintext highlighter-rouge">push</code> çš„æ“ä½œç›¸å¯¹çš„ï¼Œå½“å¼¹å‡ºå°¾éƒ¨å…ƒç´ åå‘ç°å°¾èŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œéœ€è¦æŠŠ Trie æœ€åä¸€ä¸ªèŠ‚ç‚¹å¼¹å‡ºæ¥ä½œä¸ºå°¾èŠ‚ç‚¹ã€‚</p>

<p>æœ‰ä¸¤ç‚¹å€¼å¾—ä¸€è®²ï¼š</p>

<ol>
  <li>
    <p>ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">self.cnt - 2</code> ä½œä¸ºå¯¹ Trie ä¸Šæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„è®¿é—®ç´¢å¼•ï¼Œå› ä¸ºæ­¤æ—¶åŸå°¾èŠ‚ç‚¹ä¸Šåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œå› æ­¤ Trie ä¸Šæœ‰ <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> ä¸ªå…ƒç´ ï¼›</p>
  </li>
  <li>
    <p>å¼¹å‡ºå°¾èŠ‚ç‚¹å¯èƒ½ä¼šäº§ç”Ÿç©ºè·¯å¾„ï¼Œä¹Ÿå°±æ˜¯å”¯ä¸€çš„å­èŠ‚ç‚¹ä¸ºç©ºçš„èŠ‚ç‚¹ï¼Œç©ºè·¯å¾„å¯èƒ½ä¼šä¸€è·¯å‘ä¸Šå»¶ä¼¸ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>ã€‚å¯¹åº”æ¨å…¥å°¾èŠ‚ç‚¹æ—¶æœ‰æ ¹æº¢å‡ºçš„æƒ…å†µï¼Œè¿™æ—¶åº”è¯¥å«åšæ ¹ä¸è¶³å§ğŸ˜€ã€‚</p>

    <p>ä»ç»“æ„ä¸Šè¿›è¡Œåˆ¤æ–­çš„è¯ï¼Œéœ€è¦ä»å°¾éƒ¨å†å›æº¯åˆ°æ ¹ï¼Œç”±äº Trie èŠ‚ç‚¹æ²¡æœ‰å¯¹çˆ¶èŠ‚ç‚¹çš„åå‘å¼•ç”¨ï¼Œæ‰€ä»¥åœ¨è‡ªé¡¶å‘ä¸‹è¿‡ç¨‹ä¸­è¿˜è¦ä¿å­˜ä¸€ä¸‹æ•´æ¡èŠ‚ç‚¹è·¯å¾„ï¼Œç„¶åè¿›è¡Œæ£€æŸ¥ã€‚</p>

    <p>ä¸è¿‡æœ‰æ›´ç®€å•çš„ï¼Œå°±æ˜¯ç›´æ¥æ£€æŸ¥ Trie çš„å¤§å°ï¼Œæ˜¯å¦å¼¹å‡ºå°¾èŠ‚ç‚¹ååé«˜åº¦ä¼šä¸‹é™</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// Get empty tail</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// tail size 1</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* pop root */</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ˜“å˜ç‰ˆæœ¬å®ç°">æ˜“å˜ç‰ˆæœ¬å®ç°</h2>

<h3 id="æ•°æ®ç»“æ„-1">æ•°æ®ç»“æ„</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Send</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>ç”±äº <code class="language-plaintext highlighter-rouge">Sync</code> å’Œ <code class="language-plaintext highlighter-rouge">Send</code> æ˜¯è‡ªåŠ¨ Traitï¼Œç”±äº Node å› ä¸ºæˆ‘ä»¬å®šä¹‰çš„ <code class="language-plaintext highlighter-rouge">UnsafeSendSync</code> è‡ªåŠ¨å®ç°äº†è¿™ä¸¤ä¸ª Trait ï¼Œå› æ­¤ <code class="language-plaintext highlighter-rouge">PTrieVec</code> å’Œ <code class="language-plaintext highlighter-rouge">TTrieVec</code> ä¹Ÿéƒ½è‡ªåŠ¨å®ç°äº†è¿™ä¸¤ä¸ª Trait ï¼Œä½†æˆ‘ä»¬ä¸å–œæ¬¢è®© <code class="language-plaintext highlighter-rouge">TTrieVec</code> èƒ½åè¢«è·¨çº¿ç¨‹çš„åˆ†å‘ä¸è®¿é—®ï¼Œäºæ˜¯é€šè¿‡â€œè´Ÿå®ç°â€å–æ¶ˆè¿™ä¸¤ä¸ª Trait çš„è‡ªåŠ¨å®ç°ã€‚</p>

<h3 id="transient">transient</h3>

<p>æŠŠæŒä¹…å‘é‡å˜ä¸ºå±äºå½“å‰çº¿ç¨‹çš„å¯å˜å‘é‡ã€‚</p>

<p>ä¸ä¼šé©¬ä¸Šå¤åˆ¶æ•´æ£µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œè€Œåªæ˜¯ TrieVec çš„æ ¹èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹ã€‚</p>

<p>ä½¿ç”¨å® <code class="language-plaintext highlighter-rouge">ensure_editable</code> ä½œä¸ºè­¦æˆ’å“¨ï¼Œç¡®ä¿æœ€åå¾—åˆ°ä¸€ä¸ªå±äºå½“å‰çº¿ç¨‹çš„å¯å˜çš„èŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">ensure_editable</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nv">$id</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">id</span> <span class="o">==</span> <span class="n">x</span><span class="nf">.id</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">ensure_editable!</span><span class="p">(</span><span class="nd">edit!</span><span class="p">(),</span> <span class="nv">$x</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">transient</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">TTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push-1">push</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">}</span>

	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="nd">edit!</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="c1">// WARNING: neq `tail.len` for it's array capcity</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">leaf_i</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span>
                    <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="n">leaf_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>


        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
   	<span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>åŸºæœ¬è¿‡ç¨‹å’ŒæŒä¹…åŒ–ç‰ˆæœ¬é«˜åº¦ä¸€è‡´ï¼Œæœ‰ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼š</p>

<ol>
  <li>æŒä¹…åŒ–ç‰ˆæœ¬æ‰©å®¹æ—¶å®¹é‡æœ€å¤šå¢åŠ  $1$ ï¼Œè€Œæ˜“å˜ç‰ˆæœ¬ç›´æ¥åˆ†é…æ»¡é¢çš„èŠ‚ç‚¹ï¼›</li>
  <li>ç›´æ¥ä¿®æ”¹ TrieVec å¤´ï¼Œ<code class="language-plaintext highlighter-rouge">self.root</code>, <code class="language-plaintext highlighter-rouge">self.tail</code></li>
</ol>

<h3 id="assoc-1">assoc</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>      
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>


        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.id</span><span class="p">());</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-1">pop</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="persistent">persistent</h3>

<p>æŠŠæ˜“å˜ç‰ˆæœ¬è½¬æ¢å›æŒä¹…åŒ–ç‰ˆæœ¬ã€‚æ”¹ä¸€ä¸‹å¤´å°¾èŠ‚ç‚¹çš„æ ‡è®°å°±å¯ä»¥ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">persistent</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="nd">id_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span> <span class="o">=</span> <span class="nd">no_edit!</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="n">PTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ç”±äº Rust çš„ç¼–ç¨‹æ¨¡å‹ï¼Œæ˜“å˜ç‰ˆæœ¬æŒä¹…åŒ–ååŸæ¥çš„æ˜“å˜ç‰ˆæœ¬ä¿è¯æ— æ³•è®¿é—®ï¼Œç›¸æ¯” Clojure çš„ Java å®ç°ä¼šç®€åŒ–å¾ˆå¤šè¿‡ç¨‹ã€‚</p>

<h2 id="è°ƒè¯•æ–¹æ³•">è°ƒè¯•æ–¹æ³•</h2>

<h3 id="æ‰“å°æ–¹æ³•">æ‰“å°æ–¹æ³•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[cfg(test)]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_trie_test_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[allow(unused)]</span>
        <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
        <span class="k">where</span>
            <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="p">{</span>
            <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">fn</span> <span class="n">debug_print</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">tail</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"MAIN TRIE:"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">root</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {} #############</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{i:02}. {child:?}"</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">child_group</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">())</span>
                        <span class="nf">.collect</span><span class="p">();</span>
                    <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_group</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">println!</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// print tail</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"###################################</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"TAIL: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å°¾å£°">å°¾å£°</h2>

<p><a href="">ä»£ç å‚è€ƒ</a></p>

<h2 id="æ³¨è§£">æ³¨è§£</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>å‚è€ƒè‡ª <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">hyPiRion ä»‹ç»çš„ç³»åˆ—åšæ–‡</a> å’Œ <a href="https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha2/src/jvm/clojure/lang/PersistentVector.java">Clojure æºä»£ç </a>Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>https://hypirion.com/musings/understanding-persistent-vector-pt-3#the-rationale-for-tailsÂ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>åœ¨åŸç‰ˆ Clojure çš„ Java é‡Œï¼Œæ ‡å¿—ä½¿ç”¨äº†åŸå­ç±»å‹ï¼Œè¿™ä¸»è¦æ˜¯æ‹…å¿ƒæ˜“å˜ç±»å‹åœ¨è·¨çº¿ç¨‹ä½¿ç”¨æ—¶é‡æ–°å˜ä¸ºæŒä¹…ç±»å‹æ—¶çš„ç«äº‰é—®é¢˜ï¼Œä½†æ˜¯ç”±äº Rust çš„ç¼–ç¨‹æ¨¡å‹é™åˆ¶äº†æ˜“å˜ç±»å‹ä¸å…è®¸è·¨çº¿ç¨‹ä½¿ç”¨ï¼Œå› æ­¤å°±ä¸éœ€è¦å˜ä¸ºåŸå­ç±»å‹Â <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Atomic RcÂ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>å¯¹äºæ ‘é«˜è‡³å°‘ä¸º $2$ ä½œä¸ºçš„ Trie æ¥è®²ï¼Œç©ºè·¯å¾„åº”è¯¥æ˜¯æ ¹èŠ‚ç‚¹çš„ç¬¬äºŒä¸ªå­©å­ï¼ŒÂ <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[åœ¨å‰é¢ä»‹ç»äº†ä» Fibonacci å †ã€Dary å †ï¼Œåˆ°å›¾ä¸Šçš„è¯¸å¤šç®—æ³•ï¼Œä» BST åˆ° BT çš„ä¸€ç³»åˆ—æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œå¹¶æä¾›äº†å®ƒä»¬çš„ Rust å®ç°ï¼Œå¦‚æœæŠŠè¿™äº›ä»£ç éƒ½é›†æˆèµ·æ¥ï¼Œå¯èƒ½å°±ä¼šå‘ç°è¿™ä¸ªç¼–è¯‘çš„è¿‡ç¨‹æ€ä¹ˆè¿™ä¹ˆç†¬äººï¼Œä¼¼ä¹è¶Šæ¥è¶Šè®©äººéš¾ä»¥å¿å—ï¼Œè¿™æ—¶å¯ä»¥å‚è€ƒä¸€ä¸‹å¦ç¯‡å…³äºé™ä½æ„å»ºæ—¶é—´çš„ç¬”è®°ã€‚]]></summary></entry><entry><title type="html">BT(2) - B+æ ‘ï¼ˆTreeMapï¼‰</title><link href="/algs/BT-2-BPT2.html" rel="alternate" type="text/html" title="BT(2) - B+æ ‘ï¼ˆTreeMapï¼‰" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-2-BPT2</id><content type="html" xml:base="/algs/BT-2-BPT2.html"><![CDATA[<p>å¯¹äº B æ ‘æ¥è¯´ï¼Œä¼ ç»Ÿä¸Šæœ‰ä¸€ç§å¯¹èŠ‚ç‚¹åˆ†è£‚ã€åˆå¹¶æ—¶æ€§èƒ½çš„æ”¹è¿›æ–¹æ³•ï¼Œå°±æ˜¯æŠŠå­˜å‚¨ç»“æ„ç”±æ•°ç»„æ”¹ä¸º TreeMap ã€‚TreeMap æˆ–è€…æœ‰åºå­—å…¸ï¼Œæ¯”å¦‚æˆ‘ä»¬å‰é¢ä»‹ç»çš„æ‰€æœ‰çš„ BSTï¼Œæ¯”å¦‚çº¢é»‘æ ‘ï¼Œä»¥åŠï¼Œæˆ‘ä»¬ B æ ‘ã€‚</p>

<p>æ²¡é”™ï¼Œç°åœ¨æˆ‘ä»¬å°±æ˜¯è¦ç”¨å‰æ–‡å®ç°çš„ B+ æ ‘ä½œä¸ºæˆ‘ä»¬æ–° B+ æ ‘çš„èŠ‚ç‚¹åŸºç¡€ã€‚å½“ç„¶è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„æ¦‚å¿µï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»§ç»­ä¸‹å»æŠŠè¿™ä¸ªæ–°çš„ B+ æ ‘çš„å®ç°ä½œä¸ºèŠ‚ç‚¹åŸºç¡€å®ç° B+ æ ‘ï¼Œå¦‚æ­¤ $3$ å±‚ã€$4$ å±‚çš„åµŒå¥—ã€‚ä½†ä» $m$ å¸¸æ•°çš„è§’åº¦ï¼Œä¸¤å±‚å°±å¤Ÿäº†ï¼Œå†å¤šä¹Ÿæ²¡æœ‰æ„ä¹‰ï¼Œé€šå¸¸ $m$ ä¹Ÿå°±æ˜¯ä¸€ç™¾å·¦å³ï¼Œæ¬¡çº§çš„ B+ æ ‘çš„ $m$ æœ€å¤šä¹Ÿå°±æ˜¯å°±æ˜¯åå‡ ï¼Œå·²ç»ä»€ä¹ˆç©ºé—´äº†ï¼Œä½•å†µå› æ­¤è·å¾—çš„æ€§èƒ½å¢é•¿ä¹Ÿå‘ˆæŒ‡æ•°çº§ä¸‹é™ã€‚</p>

<p>ä½†æ˜¯å®ç°ç”¨å‰é¢å®ç°çš„ B+ æ ‘ä½œä¸ºèŠ‚ç‚¹çš„åŸºç¡€ï¼Œè¿˜éœ€è¦å®ç°é¢å¤–çš„ä¸€äº› public method ï¼ŒåŒ…æ‹¬å¢åŠ å­—æ®µï¼Œæ¯”å¦‚ç»Ÿè®¡é”®å€¼æ€»æ•°çš„ cnt å­—æ®µç­‰ç­‰ã€‚ä½†æ˜¯å¦‚ä½•æ‰©å†™ <code class="language-plaintext highlighter-rouge">Vec</code> ç‰ˆæœ¬çš„ B+ æ ‘ä¸€æ—¶éš¾ä»¥è®ºè¯´ï¼Œäº‹å®ä¸Šæ‰©å†™&amp;é‡æ„æ”¹åŠ¨çš„ä»£ç æ¯”åŸä»£ç è¿˜é•¿ï¼Œæ‰€ä»¥å°±æŠŠå®ƒæ”¾åˆ°ä¸‹ä¸€ç¯‡ä»‹ç»ï¼Œé‚£æ—¶å°†å¾—åˆ°ä¸€ä¸ªç›¸å¯¹å®Œæ•´çš„ <code class="language-plaintext highlighter-rouge">Vec</code> ç‰ˆæœ¬çš„ B+ æ ‘ã€‚</p>

<p>è¿™é‡Œä¼šåˆ—å‡ºä¸€ä¸ªä½œä¸ºèŠ‚ç‚¹å®ç° B+ æ ‘çš„ <a href="#æ–¹æ³•ç»Ÿè®¡">TreeMap éœ€è¦å®ç°çš„æ–¹æ³•</a>ï¼Œæ—¢ä½œä¸ºä¸‹ä¸€ç¯‡çš„ç´¢å¼•ï¼Œä¹Ÿä½œä¸ºç”¨å…¶ä»– TreeMap ä»£æ›¿å®ç°æ—¶çš„å‚è€ƒã€‚</p>

<h2 id="æ•°æ®ç»“æ„">æ•°æ®ç»“æ„</h2>

<h3 id="æ ‘">æ ‘</h3>

<p>è¿™é‡Œå¢åŠ äº† <code class="language-plaintext highlighter-rouge">cnt</code> ç»Ÿè®¡å­—æ®µå’Œ <code class="language-plaintext highlighter-rouge">min_node</code> ç”¨äºå¿«é€ŸèŒƒæŸ¥</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees powered by B+ tree</span>
    <span class="cd">///</span>
    <span class="n">BPT2</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹åŒ…è£…">èŠ‚ç‚¹åŒ…è£…</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="å†…éƒ¨èŠ‚ç‚¹">å†…éƒ¨èŠ‚ç‚¹</h3>

<p>TreeMap å®ç°çš„ B+ æ ‘å’Œæ•°ç»„å®ç°çš„ B+ æ ‘åœ¨å†…éƒ¨èŠ‚ç‚¹çš„è®¾è®¡ä¸Šæœ‰è´¨çš„ä¸åŒã€‚</p>

<p>æ•°ç»„ç‰ˆæœ¬çš„ï¼Œé”®å€¼å’Œå­©å­æ˜¯æŒ‰ç…§ç´¢å¼•æ¥æ’çš„ï¼Œè€Œ TreeMap åˆ™æ˜¯æŒ‰ç…§å”¯ä¸€çš„é”®å€¼æ¥æ’åˆ—çš„ã€‚è¿™æ—¢çœäº†äº‹å„¿åˆå¦ä¸€æ–¹é¢å¤šäº†äº‹å„¿ï¼Œæ•´ä¸ªèŠ‚ç‚¹çŠ¶æ€ç»´æŠ¤çš„é€»è¾‘éƒ½å‘ç”Ÿäº†å˜åŒ–ã€‚</p>

<p>é¦–å…ˆä»èŠ‚ç‚¹å¸ƒå±€ä¸Šï¼Œå†…éƒ¨èŠ‚ç‚¹çš„ <code class="language-plaintext highlighter-rouge">keys</code> å­—æ®µæ²¡æœ‰å­˜åœ¨çš„æ„ä¹‰ï¼Œç›´æ¥ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">children</code> mapï¼Œä½†æ˜¯è¿™æ ·å¯¹ map çš„é”®çš„ç»´æŠ¤å°±æˆäº†ä¸€ä¸ªå…³é”®ã€‚å¦‚ä½•é€‰å–ä¸€ä¸ªåˆé€‚çš„é”®æ¥ä»£è¡¨å­©å­å‘¢ï¼Ÿ</p>

<p>æœ‰ä¸¤ç§æ˜æ˜¾çš„æ€è·¯ï¼š</p>

<ol>
  <li>å°±ç”¨èŠ‚ç‚¹çš„æœ€å°å€¼ä½œä¸ºé”®ï¼Œè¿™æ ·æŸ¥è¯¢èµ·æ¥éå¸¸å¿«ï¼Œå¯ä»¥å¿«é€Ÿå¤±è´¥ï¼Œä½†æ˜¯å½“èŠ‚ç‚¹çš„æœ€å°é”®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¿…é¡»å‘ä¸Šæ›´æ–° map æ¥ç»´æŠ¤è¿™ä¸€æ€§è´¨ï¼›</li>
  <li>é‚£ä¹ˆç”¨ä»»æ„å­©å­èŠ‚ç‚¹çš„ä»»ä¸€ä¸€ä¸ªé”®å°±ä¸éœ€è¦å§‹ç»ˆç»´æŠ¤äº†ï¼Œä½†è¿™æ ·çš„è¯æŸ¥è¯¢çš„æ—¶å€™å°±ä¸çŸ¥é“åˆ°åº•è¦è½åˆ°å“ªä¸€ä¸ªé”®ä¸Šï¼Œå°±æŸ¥è¯¢å·¦å³ä¸¤ä¸ªé”®çš„å­©å­çš„æ‰€æœ‰é”®å€¼ä¹Ÿè§£å†³ä¸äº†é—®é¢˜ï¼Œå› ä¸ºå®ƒä»¬ä¹Ÿä¸ä¸€å®šéƒ½æ˜¯æœ€å°é”®</li>
</ol>

<p>äºæ˜¯æ˜¾ç„¶ï¼Œæˆ‘ä»¬é‡‡ç”¨æŠŠæœ€å°é”®æœ€ä¸ºå­èŠ‚ç‚¹åœ¨çˆ¶èŠ‚ç‚¹ä¸Šçš„é”®çš„è®¾è®¡ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SUB_M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="åŸºç¡€æ–¹æ³•">åŸºç¡€æ–¹æ³•</h2>

<h3 id="æœç´¢åˆ°å¶å­">æœç´¢åˆ°å¶å­</h3>

<p>è¿™é‡Œä¼šç”¨åˆ° TreeMap é‡Œé¢çš„ä¸€ä¸ªé…åˆæ–¹æ³•ï¼Œ<code class="language-plaintext highlighter-rouge">low_bound_search</code> ï¼Œæ˜¯æœç´¢ $\geqslant k$ çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf_r</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.low_bound_search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹è®¿é—®">èŠ‚ç‚¹è®¿é—®</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">min_key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.min_key</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">k</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"No min-key {:?}"</span><span class="p">,</span> <span class="nv">$x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="åˆ›å»ºèŠ‚ç‚¹">åˆ›å»ºèŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">BPT</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">entries</span><span class="nf">.insert</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">);</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ä¸€èˆ¬å…¬å¼€æ–¹æ³•">ä¸€èˆ¬å…¬å¼€æ–¹æ³•</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min_node</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="èŒƒå›´æŸ¥è¯¢">èŒƒå›´æŸ¥è¯¢</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
                <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span> <span class="o">=</span> <span class="n">entries</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">fst</span><span class="p">;</span>

                    <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="n">ent</span>
                    <span class="p">}</span>

                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ’å…¥">æ’å…¥</h2>

<h3 id="ä¸»æµç¨‹">ä¸»æµç¨‹</h3>

<p>æ’å…¥çš„æ—¶å€™ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–° map çš„ç´¢å¼•ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* new min none */</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* insert into leaf */</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ›´æ–°ç´¢å¼•">æ›´æ–°ç´¢å¼•</h3>

<p>ç´¢å¼•æ›´æ–°éœ€è¦ä¸€è·¯å‘ä¸Šæ£€æŸ¥</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">old_k</span> <span class="o">!=</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* update x key */</span>

            <span class="k">let</span> <span class="n">old_p_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_p_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹æå‡">èŠ‚ç‚¹æå‡</h3>

<p>åˆ°ç›®å‰ä½ç½® TreeMap çš„èŠ‚ç‚¹å®ç°ç»™æˆ‘ä»¬å¢åŠ äº†å¾ˆå¤šéº»çƒ¦ï¼Œä½†å½“åˆ†è£‚èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå°±å¾ˆç®€å•äº†<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>ï¼Œè¿™é‡Œçš„ <code class="language-plaintext highlighter-rouge">split_off</code> çš„è¡¨ç°å’Œ <code class="language-plaintext highlighter-rouge">Vec</code> çš„ä¸€è‡´ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span>
                <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">((</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x2_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">bpt!</span> <span class="p">{</span>
                <span class="n">x_k</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">x2_k</span> <span class="k">=&gt;</span> <span class="n">x2</span>
            <span class="p">};</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="c1">// insert new or update</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x2_k</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="åˆ é™¤">åˆ é™¤</h2>

<h3 id="ä¸»æµç¨‹-1">ä¸»æµç¨‹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">remove_on_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹ä¸‹é™">èŠ‚ç‚¹ä¸‹é™</h3>

<p><strong>åœ¨æœ¬æ–¹æ³•å’Œåé¢çš„é‡å¹³è¡¡æ–¹æ³•é‡Œæ›´æ–°ç´¢å¼•æ—¶å¾ˆå®¹æ˜“å‡ºé”™ï¼Œéœ€è¦ä»”ç»†è€ƒè™‘ï¼Œæ¯”å¦‚åŒæ—¶æ›´æ–°ä¸¤ä¸ªç´¢å¼•æ—¶å¯èƒ½ä¼šå‡ºç°é”®å€¼è¦†ç›–çš„é—®é¢˜ã€‚</strong></p>

<p><code class="language-plaintext highlighter-rouge">rank</code>ï¼šæŸ¥è¯¢é”®æ’åï¼Œä» $0$ å¼€å§‹</p>

<p><code class="language-plaintext highlighter-rouge">nth</code>ï¼šæ ¹æ®æ’åï¼Œè¿”å›é”®å€¼ï¼Œä» $0$ å¼€å§‹</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.rank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">old_k</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// merge with left_sib (no need to update index)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sib_lf</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for right_sib (merge into left)</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="c1">// ç”±äºæ²¡æœ‰prevï¼Œåªèƒ½æ€»æ˜¯åˆå¹¶åˆ°å·¦èŠ‚ç‚¹ï¼Œå¥½åœ¨æ­¤æ—¶å¶å­èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå…ƒç´ </span>
            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">));</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// remove x from p</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

                <span class="c1">// ä¸éœ€è¦æ›´æ–°ç´¢å¼•ï¼Œå› ä¸º sib_rh å€¼æ›´å¤§</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_key_sib_rh</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_key_sib_rh</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.1</span><span class="p">;</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_key</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å°è¯•é‡å¹³è¡¡">å°è¯•é‡å¹³è¡¡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// try to redistribute with left</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// try to redistribute with right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// WARNINGï¼š it wll replace sib_rh with x</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">),</span> <span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">sib_rh_old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// ä¸éœ€è¦åƒå¶å­èŠ‚ç‚¹é‚£æ ·ä¸¤æ®µå„¿æ›´æ–°æ˜¯å› ä¸ºåœ¨å¶å­æ›´æ–°çš„æ—¶å€™ï¼Œå·²ç»å¯¹ x å‘ä¸Šæ›´æ–°è¿‡äº†</span>
                <span class="c1">// Self::update_index(old_k, x);</span>
                <span class="c1">// children_mut!(p).insert(min_key!(sib_rh), sib_rh);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">sib_rh_old_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æµ‹è¯•">æµ‹è¯•</h2>

<h3 id="æ‰“å°æ–¹æ³•">æ‰“å°æ–¹æ³•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT2"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Internal</span> <span class="p">{</span> <span class="n">children</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">f</span>
                <span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Internal"</span><span class="p">)</span>
                <span class="nf">.field</span><span class="p">(</span><span class="s">"children"</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
                <span class="nf">.finish</span><span class="p">(),</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Leaf"</span><span class="p">)</span><span class="nf">.field</span><span class="p">(</span><span class="s">"entries"</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span><span class="nf">.finish</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{self:?}"</span><span class="p">);</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {lv} #############"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">println!</span><span class="p">();</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ ¡éªŒæ–¹æ³•">æ ¡éªŒæ–¹æ³•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">);</span>

                        <span class="c1">// children!(child).validate();</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="c1">// entries!(child).validate();</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ–¹æ³•ç»Ÿè®¡">æ–¹æ³•ç»Ÿè®¡</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">BPT</th>
      <th style="text-align: center">Tree Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">select/select_mut</td>
      <td style="text-align: center">select_mut</td>
    </tr>
    <tr>
      <td style="text-align: center">remove etc.</td>
      <td style="text-align: center">remove</td>
    </tr>
    <tr>
      <td style="text-align: center">insert etc.</td>
      <td style="text-align: center">insert</td>
    </tr>
    <tr>
      <td style="text-align: center">search_to_leaf_r</td>
      <td style="text-align: center">low_bound_search</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">len</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min</td>
    </tr>
    <tr>
      <td style="text-align: center">promote</td>
      <td style="text-align: center">split_off</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">nth</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">rank</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">push_back</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">pop_first/pop_last</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min_key</td>
    </tr>
    <tr>
      <td style="text-align: center">Â </td>
      <td style="text-align: center">Â </td>
    </tr>
  </tbody>
</table>

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<p>è¿è¡Œä¸€ä¸ªç®€å•çš„åŸºå‡†æµ‹è¯•ï¼Œç»“æœç¬¦åˆé¢„æœŸï¼š</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">ç¯å¢ƒ</th>
      <th style="text-align: left">å€¼</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CPU</td>
      <td style="text-align: left">Intel Haswell Core i5-4590</td>
    </tr>
    <tr>
      <td style="text-align: left">Memory</td>
      <td style="text-align: left">16 GB</td>
    </tr>
    <tr>
      <td style="text-align: left">Key Size</td>
      <td style="text-align: left">8 Bytes</td>
    </tr>
  </tbody>
</table>

<p>æœ€ä¼˜é…ç½®ï¼š</p>

<p>$\text{SUB_M} = 20$</p>

<p>$10 \leqslant M \leqslant 20$</p>

<ol>
  <li>æŸ¥è¯¢æ€§èƒ½éå¸¸å¥½ï¼Œ<strong>æ¯” Rust æ ‡å‡†åº“é‡Œ HashMap çš„æŸ¥è¯¢é€Ÿåº¦è¿˜è¦å¿«25%ï¼</strong>ä½†æ˜¯è¿™ç§åŠ é€Ÿä¸æ˜¯ B+ æ ‘ç»“æ„æœ¬èº«æ‰€å¯¼è‡´çš„ï¼Œè€Œæ˜¯ Map çš„ä½¿ç”¨ä½¿å¾—èŠ‚ç‚¹çš„å†…å­˜å¸ƒå±€åœ¨ç¼“å­˜ä¸Šæ›´æœ‰åˆ©ï¼Œä¹Ÿå°±æ˜¯å•ä¸€æ•°ç»„çš„ TreeMap æ¯”èµ·åˆ†ç¦»çš„ä¸¤ä¸ªæ•°ç»„æ›´æœ‰åˆ©ï¼Œæ¢è¨€ä¹‹ï¼Œ<strong>ç›´æ¥ä½¿ç”¨å•ä¸€æ•°ç»„å®ç°<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>çš„ Map æ€§èƒ½ä¼šæ›´å¥½ï¼</strong></li>
  <li>æ’ã€åˆ çš„æ€§èƒ½ä»‹äºä¼ ç»Ÿ BST å’Œ B æ ‘ã€B+ æ ‘ä¹‹é—´</li>
</ol>

<p>è¿™ä¸ªç»“æœç¬¦åˆäº†ç†è®ºå’Œç»éªŒä¸Šçš„é¢„æœŸï¼Œæœ€åå†è¡¥å……ä¸€ä¸ªå¯¹æ¯”æµ‹è¯•ï¼š</p>

<p>B+ Tree <code class="language-plaintext highlighter-rouge">push_back</code>-<code class="language-plaintext highlighter-rouge">pop_first</code> vs Vec <code class="language-plaintext highlighter-rouge">push</code>-<code class="language-plaintext highlighter-rouge">remove(0)</code> on <code class="language-plaintext highlighter-rouge">u64</code></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M</th>
      <th>batch CroSS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">105</td>
      <td>1150</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td>2500</td>
    </tr>
  </tbody>
</table>

<p>ä¹Ÿå°±æ˜¯è¯´å½“æ•°æ®é‡è¦è¶³å¤Ÿå¤§æ‰èƒ½å‘æŒ¥å‡ºç®—æ³•ä¸Šçš„æ€§èƒ½æ‰èƒ½æŠµæ¶ˆç¼“å­˜çš„ä¼˜åŠ¿ï¼Œè€Œåœ¨æœ€ä½³ M èŒƒå›´ä¸‹ï¼Œæ•°ç»„å®ç°å…·æœ‰æ˜æ˜¾ä¼˜åŠ¿ã€‚</p>

<h2 id="æ³¨è§£">æ³¨è§£</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>åªä¸è¿‡çœ‹èµ·æ¥ <code class="language-plaintext highlighter-rouge">split_off</code> å¤§æ¦‚ä¹Ÿæ˜¯å¾—è‡ªå·±å®ç°Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">æ¯”å¦‚ Vec&lt;KVEntry&lt;K, V&gt;&gt;</code>Â <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[å¯¹äº B æ ‘æ¥è¯´ï¼Œä¼ ç»Ÿä¸Šæœ‰ä¸€ç§å¯¹èŠ‚ç‚¹åˆ†è£‚ã€åˆå¹¶æ—¶æ€§èƒ½çš„æ”¹è¿›æ–¹æ³•ï¼Œå°±æ˜¯æŠŠå­˜å‚¨ç»“æ„ç”±æ•°ç»„æ”¹ä¸º TreeMap ã€‚TreeMap æˆ–è€…æœ‰åºå­—å…¸ï¼Œæ¯”å¦‚æˆ‘ä»¬å‰é¢ä»‹ç»çš„æ‰€æœ‰çš„ BSTï¼Œæ¯”å¦‚çº¢é»‘æ ‘ï¼Œä»¥åŠï¼Œæˆ‘ä»¬ B æ ‘ã€‚]]></summary></entry><entry><title type="html">BT(3) - B+æ ‘å®Œæ•´ç‰ˆä»¥åŠB*æ€§è´¨</title><link href="/algs/BT-3-BPT_complete_with_star.html" rel="alternate" type="text/html" title="BT(3) - B+æ ‘å®Œæ•´ç‰ˆä»¥åŠB*æ€§è´¨" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-3-BPT_complete_with_star</id><content type="html" xml:base="/algs/BT-3-BPT_complete_with_star.html"><![CDATA[<p>ç»§æ‰¿å‰ä¸¤ç¯‡ <a href="/algs/BT-1-BPT.html">B+æ ‘(Vec)</a> å’Œ <a href="/algs/BT-2-BPT2.html">B+æ ‘(TreeMap)</a> çš„å®Œæ•´ç‰ˆ B+ æ ‘ (Vec) å®ç°ã€‚ç³»åˆ—æ‰€æœ‰ä»£ç å¯ä»¥åœ¨<a href="https://github.com/minghu6/rust-minghu6/tree/snapshot-2">è¿™é‡Œ</a></p>

<h2 id="æ•°æ®ç»“æ„">æ•°æ®ç»“æ„</h2>

<h3 id="æ ‘">æ ‘</h3>

<p>ä¸ºäº† <code class="language-plaintext highlighter-rouge">pop_first</code> / <code class="language-plaintext highlighter-rouge">pop_last</code> å¢åŠ äº†æœ€å°ã€æœ€å¤§èŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">max_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="æ–°å¢ç®€å•æ–¹æ³•">æ–°å¢ç®€å•æ–¹æ³•</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">entries</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.nodes</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">values</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">drop</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// collect all item without drop itself used for BPT2::remove</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">drain_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.min_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.max_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.max_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="ä¿®æ”¹çš„æ—¢æœ‰æ–¹æ³•">ä¿®æ”¹çš„æ—¢æœ‰æ–¹æ³•</h2>

<h3 id="æ’å…¥">æ’å…¥</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">x2</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="åˆ é™¤">åˆ é™¤</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* merge node */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_internal</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æµ‹è¯•">æµ‹è¯•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"min_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"max_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ–°å¢æ–¹æ³•">æ–°å¢æ–¹æ³•</h2>

<h3 id="push_back">push_back</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into max</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push_front">push_front</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into min</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="c1">// self.insert_into_leaf(x, k, v);</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_first">pop_first</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* min-key has no internal index */</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_last">pop_last</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_last</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">internal_and_idx</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rank">rank</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Start from 0 O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">rank</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>
                <span class="n">is_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">rem</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">rem</span> <span class="o">+=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">rk</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">is_err</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nth">nth</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return Nth child (start from 0), O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="split_off">split_off</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return [at, ...)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">split_off</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">oth</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">at</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">oth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">oth</span><span class="nf">.bulk_push_front</span><span class="p">(</span><span class="k">self</span><span class="nf">.bulk_pop</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">at</span><span class="p">));</span>

        <span class="n">oth</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="b-æ€§è´¨">B* æ€§è´¨</h2>

<p>B* å°±æ˜¯åœ¨é”®å€¼æ’å…¥çš„æ—¶å€™å¦‚æœå‘ç”ŸèŠ‚ç‚¹æº¢å‡ºæ—¶ï¼Œä¸æ€¥ç€å…ˆåˆ†è£‚èŠ‚ç‚¹ï¼Œè€Œæ˜¯å’Œåˆ é™¤æ—¶ä¸€æ ·ï¼Œé¦–å…ˆå°è¯•ä»é‚»å±…èŠ‚ç‚¹è¿›è¡Œå¹³è¡¡æ“ä½œã€‚</p>

<h3 id="try_balacing">try_balacing</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution_eager</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vec_even_up</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">left_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">right_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left_old_len</span> <span class="o">&lt;</span> <span class="n">right_old_len</span>  <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_old_len</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span><span class="o">-</span><span class="n">right_old_len</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vec_even_up">vec_even_up</h3>

<p>ä¿æŒå·¦å³çš„é¡ºåºå‰æä¸‹ï¼Œå¹³åˆ†å·¦å³ä¸¤ä¸ªæ•°ç»„ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Even up two vector using clone</span>
<span class="cd">///</span>
<span class="cd">/// (This implementation is inspired by Vec::remove)</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">/// use m6_common::vec_even_up;</span>
<span class="cd">///</span>
<span class="cd">/// /* case-0 left max for pop is easy (odd) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..7).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-1 the left is samller (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..8).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-2 the left is larger (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..4).collect();</span>
<span class="cd">/// let mut v1 = (4..6).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2]);</span>
<span class="cd">/// assert_eq!(v1, vec![3, 4, 5]);</span>
<span class="cd">///</span>
<span class="cd">///</span>
<span class="cd">/// /* case-3-0 the left is larger (given more than old_len) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..7).collect();</span>
<span class="cd">/// let mut v1 = (7..9).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2, 3, 4,]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7, 8]);</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">vec_even_up</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v0</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v0_old_len</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">v1_old_len</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">tnt</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">+</span> <span class="n">v1_old_len</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">cnt_lf</span> <span class="o">=</span> <span class="n">tnt</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">cnt_rh</span> <span class="o">=</span> <span class="n">tnt</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

    <span class="cm">/* Check if it's balanced? */</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">==</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">v1</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cnt_rh</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">v0_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">v1_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::{</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy_nonoverlapping</span><span class="p">,</span> <span class="n">read</span> <span class="p">};</span>

    <span class="c1">// V0 is smaller</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">&lt;</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="c1">// let v0_get = cnt_lf - v0_old_len;</span>
        <span class="k">let</span> <span class="n">v1_given</span> <span class="o">=</span> <span class="n">v1_old_len</span> <span class="o">-</span> <span class="n">cnt_rh</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">v0</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">v</span>
        <span class="p">});</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v1_given</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">cnt_rh</span>
            <span class="p">);</span>

            <span class="n">v1</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// V0 is larger</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0_given</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v0_ptr</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="n">v1</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Fill with dirty data</span>
            <span class="c1">// read(v0_ptr)</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">zeroed</span><span class="p">()</span>
        <span class="p">});</span>

        <span class="c1">// get ptr after resize to avoid realloc issue</span>
        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v0_given</span><span class="p">),</span>
                <span class="n">v1_old_len</span>
            <span class="p">);</span>

            <span class="nf">copy_nonoverlapping</span><span class="p">(</span>
                <span class="n">v0_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v0_given</span>
            <span class="p">);</span>

            <span class="n">v0</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ€»ç»“">æ€»ç»“</h3>

<p>B* æ²¡ä»€ä¹ˆç”¨ï¼Œå¯¹æ’å…¥çš„æ€§èƒ½æ”¹è¿›æ²¡æœ‰ä»€ä¹ˆå¸®åŠ©</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[ç»§æ‰¿å‰ä¸¤ç¯‡ B+æ ‘(Vec) å’Œ B+æ ‘(TreeMap) çš„å®Œæ•´ç‰ˆ B+ æ ‘ (Vec) å®ç°ã€‚ç³»åˆ—æ‰€æœ‰ä»£ç å¯ä»¥åœ¨è¿™é‡Œ]]></summary></entry><entry><title type="html">BT(1) - B+æ ‘ï¼ˆVecï¼‰</title><link href="/algs/BT-1-BPT.html" rel="alternate" type="text/html" title="BT(1) - B+æ ‘ï¼ˆVecï¼‰" /><published>2023-03-13T00:00:00+08:00</published><updated>2023-03-13T00:00:00+08:00</updated><id>/algs/BT-1-BPT</id><content type="html" xml:base="/algs/BT-1-BPT.html"><![CDATA[<p>åœ¨å‰ä¸€ç¯‡çš„æ–‡ç« é‡Œä»‹ç»äº† B æ ‘ï¼Œè¿™é‡Œä»‹ç»å®ƒçš„å˜ç§ B+ æ ‘çš„åŸºæœ¬å®ç°ã€‚</p>

<p>å¦‚æœè¯´ä¹‹å‰å¥½ä¸å®¹æ˜“æŠŠè§‚å¿µä»äºŒå‰æœç´¢æ ‘è½¬æ¢åˆ°äº† B æ ‘ï¼Œé‚£ä¹ˆä»ç°åœ¨å¼€å§‹ï¼Œä» B æ ‘åˆ° B+ æ ‘åˆéœ€è¦æœ‰ä¸€ä¸ªå¾ˆå¤§çš„è§‚å¿µè½¬å˜ã€‚ä¸è¿‡è¯·æ”¾å¿ƒï¼Œæœ¬æ–‡è®²å¾—æ˜¯ä¾é  <code class="language-plaintext highlighter-rouge">Vec</code> å®ç°çš„ B+ æ ‘ï¼Œåé¢è¿˜ä¼šä»‹ç»ç”¨ <code class="language-plaintext highlighter-rouge">TreeMap</code> å®ç°çš„ B+ æ ‘ï¼Œé‚£æ—¶åˆéœ€è¦ä¸€ä¸ªå¾ˆå¤§çš„è§‚å¿µè½¬å˜ã€‚</p>

<p>æ•´ä¸ª B æ ‘ç³»åˆ—è®¡åˆ’äº†å››ç¯‡æ–‡ç« ï¼Œå³ä½¿å±‚å±‚é“ºå ï¼Œæ¯ç¯‡é—´çš„å­¦ä¹ æ›²çº¿éƒ½å¾ˆé™¡å³­ï¼Œå¯è°“æ˜¯ä¸€å±±å››ç»å¼¯ï¼</p>

<h2 id="æ¦‚å¿µåŸºç¡€">æ¦‚å¿µåŸºç¡€</h2>

<p>B+ æ ‘åŒºåˆ«äºæ™®é€š B æ ‘çš„ä¸»è¦ç‰¹ç‚¹æ˜¯ä¸­é—´èŠ‚ç‚¹æœ‰é”®æ— å€¼<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ï¼Œè€Œåœ¨æœ€åº•å±‚çš„å¶å­ä¸Šå­˜å‚¨æ•°æ®ã€‚å¦å¤–å¶å­èŠ‚ç‚¹å­˜å‚¨æœ‰ next æŒ‡é’ˆï¼ŒæŒ‡å‘å®ƒçš„åç»§èŠ‚ç‚¹ï¼Œä¸ºå¾—æ˜¯é«˜æ•ˆçš„èŒƒå›´æŸ¥è¯¢ã€‚</p>

<p>ç”±äºæ›´å¥½çš„ç¼“å­˜é€‚åº”æ€§ï¼ŒB+ æ ‘çš„åŸºç¡€æ“ä½œ æŸ¥/å¢/åˆ  éƒ½æ˜æ˜¾å¿«äºæ™®é€š B æ ‘ï¼Œå®Œå…¨å¯ä»¥å½“åšæ™®é€š B æ ‘çš„ä¸Šä½æ›¿ä»£ã€‚</p>

<h3 id="è§‚å¿µæŒ‘æˆ˜">è§‚å¿µæŒ‘æˆ˜</h3>

<p>è™½ç„¶çœ‹èµ·æ¥åªæ˜¯ä¸€ä¸ªå°å°çš„æ”¹å˜ï¼Œä½†åˆä¸€æ¬¡é¢ è¦†äº†ä¹ æƒ¯çš„æ¦‚å¿µã€‚</p>

<ol>
  <li>ä»äºŒå‰æœç´¢æ ‘åˆ° B æ ‘ï¼Œæˆ‘ä»¬ä¸€ç›´ä¹ æƒ¯çš„æ˜¯é”®å°±æ˜¯é”®å€¼çš„ä»£åè¯ï¼Œä½†æ­£å¦‚å‰é¢èŠ‚ç‚¹ä¸å†æ˜¯é”®çš„ä»£åè¯ï¼Œè¿™é‡Œé”®ä¸å€¼çš„å…³ç³»ä¹Ÿåˆ†å¼€äº†ï¼›</li>
  <li>è¿›ä¸€æ­¥è€ƒè™‘ï¼Œè¿™å°±å‡ºç°äº†å¶å­ä¸Šå¿…ç„¶å­˜åœ¨ä¸€ä¸ªé”®ï¼Œè€Œä¸­é—´èŠ‚ç‚¹é‡Œå¯èƒ½è¿˜å­˜åœ¨ä¸€ä¸ªé‡å¤çš„é”®ï¼›</li>
  <li>ä¹Ÿå°±æ˜¯è¯´çˆ¶èŠ‚ç‚¹çš„é”®ä¸å­èŠ‚ç‚¹é”®çš„å¤§å°å…³ç³»ä¹Ÿä¸åŒäº†ï¼Œä¸ä»…æ˜¯å¤§äºæˆ–è€…å°äºï¼Œè¿˜æœ‰å¯èƒ½æ˜¯ç›¸ç­‰çš„å…³ç³»</li>
</ol>

<p>å› æ­¤è¿™é‡Œè¿˜è¦æ˜ç¡®ä¸€ä¸‹ï¼šB+ æ ‘çˆ¶èŠ‚ç‚¹çš„é”®å¯èƒ½ä¸å­èŠ‚ç‚¹çš„æœ€å°é”®ç›¸ç­‰ï¼Œè¿™ç¬¦åˆå·¦é—­å³å¼€çš„æƒ¯ä¾‹ã€‚</p>

<h3 id="ç´¢å¼•çš„é‡è¦æ€§è´¨">ç´¢å¼•çš„é‡è¦æ€§è´¨</h3>

<p>ä¸æ˜¯å¶å­èŠ‚ç‚¹ä¸Šçš„æ¯ä¸€ä¸ªé”®å€¼éƒ½åœ¨å†…éƒ¨èŠ‚ç‚¹ä¸Šæœ‰ä¸€ä¸ªé”®ï¼Œåœ¨å†…éƒ¨èŠ‚ç‚¹çš„é”®æœ‰ä¸¤ç§æƒ…å†µï¼š</p>

<p><img src="/assets/img/bt_bpt_vec/dupidx.png" alt="" /></p>

<ol>
  <li>æ¯ä¸ªæ ¹çš„å¶å­èŠ‚ç‚¹ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªä»¥å¤–ï¼Œæ¯ä¸ªå¶å­çš„æœ€å°é”®ï¼Œéƒ½åœ¨è¿™ä¸ªè¿™ä¸ªæ ¹ä¸Šæœ‰å¯¹åº”çš„é”®ï¼Œå°±æ˜¯å·¦é”®<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>ï¼›</li>
  <li>ç¬¬ä¸€ä¸ªå¶å­èŠ‚ç‚¹é™¤äº†æœ€å°çš„æ ¹ä»¥å¤–ï¼Œåœ¨æ ¹æˆ–è€…æ ¹çš„ç¥–å…ˆä¸Šä¹Ÿæœ‰å¯¹åº”çš„é”®</li>
</ol>

<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œ<strong>æ‰€æœ‰ä¸­é—´èŠ‚ç‚¹çš„é”®ç”±ä¸”ä»…ç”±é™¤äº†ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä»¥å¤–çš„æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„æœ€å°é”®ç»„æˆ</strong></p>

<p>åœ¨æˆ‘åšè°ƒæŸ¥çš„è¿‡ç¨‹ä¸­å‘ç°è¿™ä¸ªç´¢å¼•çš„æ€§è´¨åœ¨æœ‰çš„å®ç°é‡Œå¹¶æ²¡æœ‰è¢«å°Šé‡ï¼Œè¿™ä¸ä¼šç›´æ¥å½±å“åŠŸèƒ½çš„å®ç°ï¼Œå´ç ´åäº† B+ æ ‘çš„æ€§è´¨ï¼Œå¼•å…¥äº†æ½œåœ¨çš„ Bug ï¼šåˆ é™¤ä¼šå¯¼è‡´ä¸­é—´èŠ‚ç‚¹å­˜åœ¨åºŸå¼ƒçš„é”®ã€‚</p>

<h3 id="é‡å¹³è¡¡">é‡å¹³è¡¡</h3>

<p>è¿‡ç¨‹ä¸ B æ ‘ä¸€è‡´ï¼Œåªæ˜¯åˆ†è£‚èŠ‚ç‚¹æ—¶ç”±å¼¹å‡ºä¸­é—´çš„é”®æ”¹ä¸ºå…‹éš†ä¸­é—´çš„é”®ï¼Œåˆå¹¶èŠ‚ç‚¹çš„æ—¶å€™åªåˆ é™¤çˆ¶èŠ‚ç‚¹å¯¹åº”é”®è€Œä¸æ˜¯å¹¶å…¥èŠ‚ç‚¹ï¼Œå› æ­¤è¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚</p>

<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">åœ¨çº¿çš„ B+ æ ‘çš„æ¨¡æ‹Ÿé¡µé¢</a></p>

<h2 id="å®ç°-æ•°æ®ç»“æ„">å®ç°-&gt;æ•°æ®ç»“æ„</h2>

<h3 id="æ ‘">æ ‘</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹åŒ…è£…">èŠ‚ç‚¹åŒ…è£…</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="å†…éƒ¨èŠ‚ç‚¹">å†…éƒ¨èŠ‚ç‚¹</h3>

<p>B+ æ ‘å¶å­èŠ‚ç‚¹å’Œå†…éƒ¨èŠ‚ç‚¹çš„å­—æ®µåŒºåˆ«è¿˜æ˜¯å¾ˆå¤§çš„ï¼Œæ˜¯å¦æ²¿ç”¨ä¹‹å‰çš„åŒæ„çš„è®¾è®¡æ˜¯ä¸ªå€¼å¾—æ€è€ƒçš„é—®é¢˜ã€‚</p>

<p>æˆ‘ä»¬æ¯”è¾ƒè¿™ä¸¤ç§è®¾è®¡çš„ drawbackï¼š</p>

<p>å¦‚æœé‡‡ç”¨åŒæ„ï¼š</p>

<ol>
  <li>ä¼šæœ‰å†—ä½™å­—æ®µï¼Œæ¯ä¸ªå­—æ®µéƒ½å äº†è‡³å°‘æ˜¯æŒ‡é’ˆå®½åº¦çš„ç©ºé—´ï¼›</li>
  <li>èŠ‚ç‚¹çœ‹èµ·æ¥æœ‰äº›æ‚ä¹±ï¼Œä¸¥é‡é™ä½ä»£ç å¯è¯»æ€§</li>
</ol>

<p>å¦‚æœé‡‡ç”¨å¼‚æ„ï¼š</p>

<ol>
  <li>ç”±äºä½¿ç”¨äº†æšä¸¾ï¼Œå¯¼è‡´ä¹‹å‰ç§¯ç´¯çš„å®æ²¡æ³•å„¿ä½¿ç”¨ï¼Œéœ€è¦é‡å†™ä¸€å¥—ï¼Œå¦å¤–è¿˜è¦ç¼–å†™é…å¥—çš„å†…éƒ¨èŠ‚ç‚¹çš„å±æ€§è®¿é—®ä»£ç </li>
</ol>

<p>çœ‹èµ·æ¥æ²¡æœ‰å“ªä¸€ä¸ªæ˜¯å†™èµ·æ¥åˆå¥½åˆå¿«çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å†ä»”ç»†è€ƒè™‘å‘ç°ï¼š</p>

<ol>
  <li>åŒæ„çš„è®¾è®¡è¿˜æ˜¯éœ€è¦ä¸€ä¸ªå•ç‹¬å­—æ®µæ¥å†…çœåœ°åˆ¤æ–­è‡ªå·±æ˜¯å¶å­èŠ‚ç‚¹è¿˜æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œå®ƒå’Œå¼‚æ„çš„æšä¸¾å®ç°çš„åŒºåˆ«æœ¬è´¨ä¸Šåªæ˜¯ä¸€ä¸ªæ˜¯æ‰‹æ“çš„ã€ç‰¹åŒ–çš„ï¼Œä¸€ä¸ªæ˜¯ç³»ç»Ÿçš„ã€æ³›åŒ–çš„ï¼›</li>
  <li>ç¼–ç¨‹ä¹Ÿæœ‰ä¸€ä¸ªä¸å¯èƒ½ä¸‰è§’ï¼š</li>
</ol>

<p><img src="/assets/img/bt_basic/prog_triangle.png" alt="" /></p>

<p>ä¸€èˆ¬åœ°ï¼Œæ¡ä»¶å…è®¸ä¸‹ï¼Œæ˜¯ç‰ºç‰²éƒ¨åˆ†ä»£ç ç®€æ´æ€§ï¼Œæ¥ä¿éšœå¦å¤–çš„ä¸¤ä¸ªç›®æ ‡ã€‚</p>

<p>å› æ­¤è¿™é‡Œæˆ‘è¿˜æ˜¯é‡‡ç”¨äº†å¼‚æ„çš„è®¾è®¡ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">keys</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<p>å†…éƒ¨èŠ‚ç‚¹çš„å±æ€§è®¿é—®æ–¹æ³•ï¼š</p>

<p>ä½¿ç”¨å®æ¥ç»Ÿä¸€æè¿°è¿™ä¸ªæ–¹æ³•ï¼Œæ¥é¿å…æ— è°“çš„ä»£ç </p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Node_ heap data field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__heap_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Node_ WeakNode field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__wn_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>äºæ˜¯å±æ€§è®¿é—®å°±å¯ä»¥å†™æˆï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>è¿™å°±å¯ä»¥å†™ B+ æ ‘ ä¸“å±çš„ç”Ÿæˆå®ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro_bpt</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="nv">$$val</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ç”¨å®ƒæ¥ç”ŸæˆèŠ‚ç‚¹åŒ…è£… <code class="language-plaintext highlighter-rouge">Node</code> çš„å±æ€§è®¿é—®çš„å®ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="å®ç°-åŸºç¡€æ–¹æ³•">å®ç°-&gt;åŸºç¡€æ–¹æ³•</h2>

<h3 id="æœç´¢åˆ°å¶å­èŠ‚ç‚¹">æœç´¢åˆ°å¶å­èŠ‚ç‚¹</h3>

<p>å’Œ B æ ‘çš„èŠ‚ç‚¹ä¸Šçš„é€’å½’æœç´¢æ–¹æ³•ä¸€æ ·ï¼Œåªæ˜¯å½“åœ¨ä¸­é—´èŠ‚ç‚¹é‡åˆ°ç›¸ç­‰çš„é”®æ—¶ä¸æ˜¯ç›´æ¥é€€å‡ºè€Œæ˜¯åœ¨å®ƒçš„å³å­©å­ä¸Šç»§ç»­æœç´¢ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æŸ¥è¯¢èŠ‚ç‚¹å±æ€§">æŸ¥è¯¢èŠ‚ç‚¹å±æ€§</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æœ€å°æœ€å¤§èŠ‚ç‚¹">æœ€å°/æœ€å¤§èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">min_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">max_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="åˆ›å»ºèŠ‚ç‚¹åŒ…è£…">åˆ›å»ºèŠ‚ç‚¹åŒ…è£…</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$keys:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">keys</span><span class="p">:</span> <span class="nv">$keys</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-ç®€å•æ–¹æ³•">å®ç°-&gt;ç®€å•æ–¹æ³•</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-èŒƒå›´æŸ¥è¯¢">å®ç°-&gt;èŒƒå›´æŸ¥è¯¢</h2>

<p>ä½¿ç”¨å‰é¢äºŒå‰æœç´¢æ ‘é‡Œçš„ <code class="language-plaintext highlighter-rouge">mut_self</code> å®æ¥å°‘äº›ä¸€ç‚¹å„¿ä»£ç </p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                <span class="c1">// Nil</span>
                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c1">// Leaf</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                        <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                    <span class="p">};</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_node</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">==</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="o">..</span><span class="p">];</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">range</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ent</span><span class="na">.1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="o">..</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-æ’å…¥">å®ç°-&gt;æ’å…¥</h2>

<h3 id="æ’å…¥ä¸»æµç¨‹">æ’å…¥ä¸»æµç¨‹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹æå‡æ–¹æ³•">èŠ‚ç‚¹æå‡æ–¹æ³•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-åˆ é™¤">å®ç°-&gt;åˆ é™¤</h2>

<p>è¿™é‡Œç‰¹åˆ«éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ</p>

<h3 id="åˆ é™¤ä¸»æµç¨‹">åˆ é™¤ä¸»æµç¨‹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>    

	<span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ›´æ–°ç´¢å¼•">æ›´æ–°ç´¢å¼•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_internal_key</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">internal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">i_idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">new_key</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="cm">/* check remain node */</span>

            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="c1">// right sib</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="cm">/* use default (left first)*/</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">internal</span><span class="p">)[</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹ä¸‹é™">èŠ‚ç‚¹ä¸‹é™</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Exclude leaf node and nil node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å°è¯•é‡å¹³è¡¡">å°è¯•é‡å¹³è¡¡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="c1">// Left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">);</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="åˆå¹¶èŠ‚ç‚¹">åˆå¹¶èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="c1">// update pred</span>
            <span class="k">if</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">pred!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-æµ‹è¯•">å®ç°-&gt;æµ‹è¯•</h2>

<h3 id="æ‰“å°æ–¹æ³•">æ‰“å°æ–¹æ³•</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
	<span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">writeln!</span><span class="p">(</span>
                            <span class="n">f</span><span class="p">,</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ€§è´¨æ ¡éªŒ">æ€§è´¨æ ¡éªŒ</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
    <span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert_eq!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                            <span class="s">"{child:?}"</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                            <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nd">assert_eq!</span><span class="p">(</span>
                                    <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span>
                                <span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="cm">/* search obsoleted key */</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nd">search_to_leaf!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">leaf</span><span class="nf">.is_none</span><span class="p">()</span>
                                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span>
                                    <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span>
                                <span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span>
                            <span class="p">{</span>
                                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Found obsoleted key: {k:?}"</span><span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                            <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="nd">last_key!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">last_key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ³¨è§£">æ³¨è§£</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>è¿™æ˜¯ç­‰ä»·è½¬æ¢åçš„è¯´æ³•ï¼ŒåŸå§‹è¯´æ³•æ˜¯æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½åªä¿ç•™é”®ï¼Œè€Œåœ¨åº•éƒ¨é¢å¤–åŠ ä¸€å±‚æ•°æ®èŠ‚ç‚¹Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>åè¯æ³•ï¼Œå¦‚æœé‚£ä¸ªå·¦é”®ä¸å¶å­èŠ‚ç‚¹ä¸Šçš„ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆé‚£ä¸ªå·¦é”®å°±æ‰¾ä¸åˆ°å¯¹åº”çš„é”®å€¼äº†Â <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[åœ¨å‰ä¸€ç¯‡çš„æ–‡ç« é‡Œä»‹ç»äº† B æ ‘ï¼Œè¿™é‡Œä»‹ç»å®ƒçš„å˜ç§ B+ æ ‘çš„åŸºæœ¬å®ç°ã€‚]]></summary></entry><entry><title type="html">å•è¯ä¸çŸ­è¯­</title><link href="/oth/WordAndPhase.html" rel="alternate" type="text/html" title="å•è¯ä¸çŸ­è¯­" /><published>2023-02-27T00:00:00+08:00</published><updated>2023-02-27T00:00:00+08:00</updated><id>/oth/WordAndPhase</id><content type="html" xml:base="/oth/WordAndPhase.html"><![CDATA[<h2 id="a">A</h2>

<h3 id="a-grinding-halt">a grinding halt</h3>

<p>é™·å…¥åœé¡¿</p>

<ol>
  <li>Memory-hogging programs can deplete the systemâ€™s memory, bringing the whole system to <strong>a grinding halt</strong>.</li>
</ol>

<h2 id="b">B</h2>

<h2 id="c">C</h2>

<h3 id="contemporary">Contemporary</h3>

<p><code class="language-plaintext highlighter-rouge">/kÉ™nËˆtempÉ™ËŒrerÄ“/</code></p>

<p>å½“ä»£çš„</p>

<ol>
  <li>Such devices are hard to find on <strong>contemporary</strong> computers.</li>
</ol>

<h3 id="consensus">Consensus</h3>

<p><code class="language-plaintext highlighter-rouge">/kÉ™nËˆsensÉ™s/</code></p>

<p>noun</p>

<p>å…±è¯†</p>

<ol>
  <li>However, it may take some time to come to a <strong>consensus</strong> on a final control solution.</li>
</ol>

<h2 id="d">D</h2>

<h3 id="deplete">Deplete</h3>

<p><code class="language-plaintext highlighter-rouge">/dÉ™ËˆplÄ“t/</code></p>

<p>verb</p>

<p>è€—å°½</p>

<ol>
  <li>Memory-hogging programs can <strong>deplete</strong> the systemâ€™s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h3 id="dedicate">Dedicate</h3>

<p><code class="language-plaintext highlighter-rouge">/ËˆdedÉ™ËŒkÄt/</code></p>

<p>verb</p>

<p>å¥‰çŒ®</p>

<h3 id="dedicated">Dedicated</h3>

<p><code class="language-plaintext highlighter-rouge">/ËˆdedÉ™ËŒkÄdÉ™d/</code></p>

<p>adj</p>

<p>ä¸“ç”¨çš„</p>

<p>This enables batch managers monitoring jobs running in <strong>dedicated</strong> cpusets to efficiently detect what level of memory pressure that job is causingã€‚</p>

<h2 id="e">E</h2>

<h2 id="f">F</h2>

<h2 id="g">G</h2>

<h2 id="h">H</h2>

<h3 id="hog">Hog</h3>

<p><code class="language-plaintext highlighter-rouge">/hÃ´É¡,hÃ¤É¡/</code></p>

<p>verb</p>

<p>æŠ¢å </p>

<ol>
  <li><strong>Memory-hogging</strong> programs can deplete the systemâ€™s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h2 id="i">I</h2>

<h3 id="imminent">Imminent</h3>

<p><code class="language-plaintext highlighter-rouge">/ËˆimÉ™nÉ™nt/</code></p>

<p>adj</p>

<p>è¿«åœ¨çœ‰ç«çš„</p>

<ol>
  <li>This can include the cgroup oom notifier behavior when a collection of tasks is completely out of memory, but can also warn when such a condition may be <strong>imminent</strong>.</li>
</ol>

<h3 id="initiative">Initiative</h3>

<p><code class="language-plaintext highlighter-rouge">/iËˆniSHÉ™div/</code></p>

<p>noun</p>

<p>ç§¯ææ€§ã€å€¡è®®</p>

<ol>
  <li>these new <strong>initiatives</strong> of offering better control to the user in selecting the process to be the sacrificial lamb are steps to a robust design to give more control to the user.</li>
</ol>

<h2 id="j">J</h2>

<h2 id="k">K</h2>

<h3 id="keep-account-of">keep account of</h3>

<p>è®°å½•</p>

<ol>
  <li>This chapter describes the structures used to <strong>keep account of</strong> memory banks, pages and the flags that affect VM behaviour.</li>
</ol>

<h2 id="l">L</h2>

<h2 id="m">M</h2>

<h3 id="metric">Metric</h3>

<p><code class="language-plaintext highlighter-rouge">/Ëˆmetrik/</code></p>

<p>adj</p>

<p>noun</p>

<p>ï¼ˆç³»ç»Ÿã€æ ‡å‡†ï¼‰è¡¡é‡</p>

<ol>
  <li>The memory_pressure of a cpuset provides a simple per-cpuset <strong>metric</strong> of the rate that the tasks in a cpuset are attempting to free up in use memory on the nodes of the cpuset to satisfy additional memory requests.</li>
</ol>

<h2 id="n">N</h2>

<h2 id="o">O</h2>

<h3 id="out-of-curiosity">out of curiosity</h3>

<p>å‡ºäºå¥½å¥‡</p>

<ol>
  <li><strong>Out of curiosity</strong> I compiled both versions and ran objdump on the binaries, to see how many bytes were saved.</li>
</ol>

<h3 id="overlook">Overlook</h3>

<p>verb</p>

<p>å¿½è§†</p>

<ol>
  <li>The primary reason is that they have been run passively, â€œfire and forgetâ€ style, with no additional analysis, and all problems were <strong>overlooked</strong>.</li>
</ol>

<p>ä»ä¸Šé¢çœ‹</p>

<h2 id="p">P</h2>

<h3 id="put-simply">put simply</h3>

<p>ç®€å•è¯´</p>

<ol>
  <li><strong>Put simply</strong>, it costs less to balance between two smaller sched domains than one big one, but doing so means that overloads in one of the two domains wonâ€™t be load balanced to the other one.</li>
</ol>

<h3 id="proper">Proper</h3>

<p>adj</p>

<p>æ­£ç¡®çš„</p>

<p>åˆé€‚çš„</p>

<ol>
  <li>Active benchmarking helps you accurately test the true target of the benchmark, and <strong>properly</strong> understand its results</li>
</ol>

<p>adv</p>

<ol>
  <li>ä»¤äººæ»¡æ„åœ°ã€æ­£ç¡®åœ°</li>
</ol>

<h3 id="properly">Properly</h3>

<p>adv</p>

<p>æ­£ç¡®åœ°</p>

<p>properly understand vs understand proper</p>

<h2 id="q">Q</h2>

<h2 id="r">R</h2>

<h3 id="rule-out">rule out</h3>

<p>æ’é™¤</p>

<ol>
  <li>This approach can specify only one name at a time, <strong>ruling out</strong> the possibility of a hierarchy</li>
</ol>

<h2 id="s">S</h2>

<h3 id="substantial">Substantial</h3>

<p><code class="language-plaintext highlighter-rouge">/ËŒsÉ™bËˆstan(t)SHÉ™l/</code></p>

<p>adj</p>

<ol>
  <li>
    <p>ç›¸å½“æ•°é‡çš„</p>
  </li>
  <li>
    <p>å®è´¨æ€§çš„</p>
  </li>
  <li>
    <p>This policy can provide <strong>substantial</strong> improvements for jobs that need to place thread local data on the corresponding node</p>
  </li>
</ol>

<h3 id="stall">Stall</h3>

<p><code class="language-plaintext highlighter-rouge">/stÃ´l/</code></p>

<p>n.</p>

<p>ï¼ˆå¸‚åœºï¼‰æ‘Šä½ã€éš”é—´</p>

<p>ï¼ˆé©¬å©ã€è°·ä»“ä¸­åŠ¨ç‰©çš„ï¼‰éš”é—´</p>

<p>verb</p>

<p>ï¼ˆå¼•æ“ï¼‰åœæ­¢è¿è¡Œ</p>

<ol>
  <li>Itâ€™s intended to be simple, minimizing variation caused by cache misses, <strong>stall cycles</strong>, and branch misprediction.</li>
</ol>

<p>åœæ»ï¼ˆå–å¾—è¿›å±•ï¼‰</p>

<h2 id="t">T</h2>

<h3 id="tame">Tame</h3>

<p><code class="language-plaintext highlighter-rouge">/tÄm/</code></p>

<p>adj æ¸©é¡ºçš„</p>

<p>verb é©¯æœ</p>

<ol>
  <li>This calls for a different design to <strong>tame</strong> the OOM killer.</li>
</ol>

<h2 id="u">U</h2>

<h3 id="utilize">Utilize</h3>

<p><code class="language-plaintext highlighter-rouge">/ËˆyoÍodlËŒÄ«z/</code></p>

<p>verb</p>

<p>åˆ©ç”¨</p>

<p>underutilize æœªåˆ©ç”¨</p>

<ol>
  <li>If one CPU is <strong>underutilized</strong>, kernel code running on that CPU will look for tasks on other more overloaded CPUs and move those tasks to itself,</li>
</ol>

<h2 id="v">V</h2>

<h2 id="w">W</h2>

<h2 id="x">X</h2>

<h2 id="y">Y</h2>

<h2 id="z">Z</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[A]]></summary></entry><entry><title type="html">BT(0) - Bæ ‘</title><link href="/algs/BT-0-BT.html" rel="alternate" type="text/html" title="BT(0) - Bæ ‘" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/algs/BT-0-BT</id><content type="html" xml:base="/algs/BT-0-BT.html"><![CDATA[<p>B æ ‘æ˜¯æ³¢éŸ³å®éªŒå®¤çš„ <a href="https://en.wikipedia.org/wiki/Rudolf_Bayer">Rudolf Bayer</a> and <a href="https://en.wikipedia.org/wiki/Edward_M._McCreight">Edward M. McCreight</a> æœ€åˆå‘æ˜ç”¨æ¥å­˜å‚¨å¤§é‡ç´¢å¼•ï¼ˆè¶…è¿‡ä¸»å†…å­˜ï¼‰çš„æ•°æ®ç»“æ„ï¼Œåœ¨ 1970 å¹´çš„è®ºæ–‡é‡Œæ­£å¼æå‡ºã€‚</p>

<p>æœ¬ç³»åˆ—å°†ä»‹ç» B æ ‘ä»¥åŠ B+ æ ‘ã€B+ æ ‘çš„ TreeMap å®ç°ã€ B+* æ ‘ç­‰ä¸€äº›åˆ—ç®—æ˜¯ B æ ‘çš„å˜ç§ã€‚</p>

<h2 id="æ¦‚å¿µåŸºç¡€">æ¦‚å¿µåŸºç¡€</h2>

<p>B æ ‘æ˜¯<strong>å®Œå…¨å¹³è¡¡</strong>çš„<strong>å¤šè·¯æœç´¢æ ‘</strong>ï¼ŒåŸºæœ¬ä¸Šå·²ç»æ˜¯ä¼ ç»Ÿçº¢é»‘æ ‘çš„ä¸Šä½æ›¿ä»£ã€‚</p>

<ol>
  <li>èŠ‚ç‚¹æ•°çš„å‡å°‘ï¼Œæå¤§åœ°èŠ‚çœäº†å†…å­˜ï¼›</li>
  <li>åœ¨ Intel è¿™æ ·çš„å¤§ç¼“å­˜ CPU æ¶æ„ä¸‹ï¼Œæ€§èƒ½æ˜æ˜¾é«˜äºä¼ ç»ŸäºŒå‰æœç´¢æ ‘</li>
</ol>

<p><strong>å®Œå…¨å¹³è¡¡</strong>æŒ‡å¾—æ˜¯æ¯ä¸ªå¶å­èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„æ·±åº¦ç›¸ç­‰ã€‚</p>

<p>B æ ‘èŠ‚ç‚¹ä¸€èˆ¬å¯ä»¥åˆ†ä¸ºæœ€åä¸€å±‚çš„å¶å­èŠ‚ç‚¹ï¼ˆleafï¼‰å’Œä¸­é—´çš„èŠ‚ç‚¹ï¼ˆinternalï¼‰ï¼Œå½“B æ ‘åªæœ‰ä¸€å±‚çš„æ—¶å€™ï¼Œé‚£å°±åªæœ‰å¶å­èŠ‚ç‚¹ã€‚</p>

<p>å¯¹äº $m$ é˜¶ B æ ‘ï¼ˆæœ€å¤šæœ‰ $m$ ä¸ªå­©å­ï¼‰æœ‰è¿™æ ·çš„æ€§è´¨ï¼š</p>

<ol>
  <li>ä¸­é—´èŠ‚ç‚¹çš„é”®æ•° $N_{\large\text{key}} \in [\lceil {\large\frac{m}{2}}\rceil-1,m)$</li>
  <li>å¶å­èŠ‚ç‚¹çš„é”®æ•° $N_{\large\text{key}} \in [1,m)$</li>
</ol>

<p>å…¶ä¸­æ ¹èŠ‚ç‚¹æ¯”è¾ƒç‰¹æ®Šï¼Œå¯¹äºé«˜åº¦å¤§äº $1$ çš„ B æ ‘ï¼Œæ ¹èŠ‚ç‚¹æ˜¾ç„¶å±äºæ˜¯ä¸­é—´èŠ‚ç‚¹ï¼Œä½†å®ƒå¯ä»¥åƒå¶å­èŠ‚ç‚¹ä¸€æ ·æœ€å°‘åªæœ‰å•é”®<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>ã€‚å› æ­¤ä¸€äº›ä»‹ç»é‡ŒæŠŠ internal èŠ‚ç‚¹çš„æ¦‚å¿µå®šä¹‰ä¸ºä¸åŒ…æ‹¬æ ¹èŠ‚ç‚¹ï¼Œè€Œå¦å¤–çš„ä»‹ç»é‡Œåˆ™ä¿ç•™è¿™ç§çŸ›ç›¾ï¼Œè¿™æ˜¯è®©åˆå­¦è€…å¾ˆå›°æƒ‘çš„ä¸€ä¸ªåœ°æ–¹ã€‚</p>

<p>è€Œä¸­é—´èŠ‚ç‚¹çš„æœ€å°é”®æ•° $\lceil {\large\frac{m}{2}}\rceil-1$  ï¼Œæ˜¯ç”±ä¸€ä¸ªæº¢å‡ºèŠ‚ç‚¹çš„åˆ†è£‚è¿‡ç¨‹æ¨å¯¼å‡ºçš„ï¼š</p>

<p>å‡è®¾ä¸€ä¸ªèŠ‚ç‚¹æº¢å‡ºäº†ï¼Œåˆ™æ­¤æ—¶å®ƒæœ‰ $m$ ä¸ªé”®ï¼Œæ­¤æ—¶åº”è¯¥å–å‡ºä¸­é—´çš„ä¸€ä¸ªé”®ï¼Œæ¨åˆ°çˆ¶èŠ‚ç‚¹ä¸Šï¼Œç„¶åæŠŠå·¦å³ä¸¤è¾¹çš„é”®å¹³åˆ†ä¸ºä¸¤ä¸ªèŠ‚ç‚¹ã€‚è¿™ç§æƒ…å†µä¸‹ $\lceil{\large\frac{m}{2}}\rceil + \lceil{\large\frac{m}{2}}\rceil - 2 = m + 1 - 2 = m - 1$ ã€‚</p>

<p>å¹¶ä¸”æ˜¾ç„¶ï¼Œåº”è¯¥æœ‰ $m \geqslant 3$ ï¼ŒäºŒå‰æ ‘ä¸€ä¸ªèŠ‚ç‚¹é‡Œåªæœ‰ä¸€ä¸ªé”®ï¼Œæ²¡æœ‰èŠ‚ç‚¹åˆ†è£‚ä¸åˆå¹¶çš„ç©ºé—´ã€‚</p>

<h2 id="é‡å¹³è¡¡">é‡å¹³è¡¡</h2>

<p>æˆ‘ä»¬æŠŠå¯¹æ’å…¥æ—¶èŠ‚ç‚¹é”®å€¼æº¢å‡ºå’Œåˆ é™¤æ—¶èŠ‚ç‚¹é”®å€¼ä¸è¶³çš„æƒ…å†µçš„å¤„ç†æ“ä½œï¼ŒæŒ‰ç…§å‰æ–‡äºŒå‰æœç´¢æ ‘çš„æƒ¯ä¾‹ï¼Œä¹Ÿä¸€æ ·åœ°ç§°ä¹‹ä¸ºé‡å¹³è¡¡ã€‚</p>

<p>æ–‡å­—è¯´æ˜æœªå¿…ç›´è§‚ï¼Œå¯ä»¥é€šè¿‡<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">åœ¨çº¿çš„ B æ ‘çš„æ¨¡æ‹Ÿé¡µé¢</a>ç›´è§‚åœ°ä½“éªŒç®—æ³•è¿‡ç¨‹</p>

<h3 id="æ’å…¥">æ’å…¥</h3>

<p>å½“æ’å…¥æŸä¸ªé”®åå‘ç°èŠ‚ç‚¹æº¢å‡ºäº†ï¼Œå°±è¦åˆ†è£‚èŠ‚ç‚¹ï¼š</p>

<ol>
  <li>æŠŠä¸­é—´çš„ä¸€ä¸ªé”®æå‡åˆ°çˆ¶èŠ‚ç‚¹ï¼Œå…¶ä½™çš„é”®åˆ†åˆ°å·¦å³ä¸¤ä¸ªæ–°èŠ‚ç‚¹<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> ï¼›</li>
  <li>é€’å½’åœ°åœ¨çˆ¶èŠ‚ç‚¹ä¸Šè°ƒç”¨ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ï¼›</li>
  <li>å½“æ ¹èŠ‚ç‚¹æº¢å‡ºæ—¶ï¼Œä¸­é—´çš„é”®å•ç‹¬æ„æˆä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>ï¼Œç®—æ³•ç»ˆæ­¢</li>
</ol>

<h3 id="åˆ é™¤">åˆ é™¤</h3>

<p>å½“åˆ é™¤æŸä¸ªé”®åå‘ç°èŠ‚ç‚¹ä¸è¶³ï¼Œå°±è¦<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">4</a></sup>ï¼š</p>

<ol>
  <li>å°è¯•<strong>èŠ‚ç‚¹é‡å¹³è¡¡</strong>ï¼›</li>
  <li>å¦‚æœå¹³è¡¡å¤±è´¥ï¼Œé€’å½’åœ°<strong>åˆå¹¶èŠ‚ç‚¹</strong></li>
</ol>

<p>å°è¯•<strong>èŠ‚ç‚¹é‡å¹³è¡¡</strong>ï¼ˆtry rebalancingï¼‰ï¼š</p>

<ol>
  <li>å¦‚æœæœ‰å·¦é‚»å±…ï¼Œæ£€æŸ¥å·¦é‚»å±…èŠ‚ç‚¹æ˜¯å¦æœ‰å¤šä½™çš„é”®ï¼š
    <ol>
      <li>å¦‚æœæœ‰ï¼Œå¼¹å‡ºæœ€å¤§çš„é”®æ›¿æ¢çˆ¶èŠ‚ç‚¹çš„é”®ï¼Œè€ŒæŠŠåŸçˆ¶èŠ‚ç‚¹çš„é”®æ’å…¥åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ†é…æˆåŠŸï¼›</li>
      <li>å¦åˆ™ï¼Œç»§ç»­æ£€æŸ¥</li>
    </ol>
  </li>
  <li>å¦‚æœæœ‰å³é‚»å±…ï¼Œæ£€æŸ¥å³é‚»å±…èŠ‚ç‚¹æ˜¯å¦æœ‰å¤šä½™çš„é”®ï¼š
    <ol>
      <li>å¦‚æœæœ‰ï¼Œå¼¹å‡ºæœ€å°çš„é”®æ›¿æ¢çˆ¶èŠ‚ç‚¹çš„é”®ï¼Œè€ŒæŠŠåŸçˆ¶èŠ‚ç‚¹çš„é”®æ’å…¥åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ†é…æˆåŠŸï¼›</li>
      <li>å¦åˆ™ï¼Œé‡å¹³è¡¡å¤±è´¥</li>
    </ol>
  </li>
</ol>

<p>ä¸‹å›¾å‡è®¾äº†ä¸€ä¸ª $m=3$ çš„ B æ ‘åˆ é™¤æƒ…å†µï¼Œç©ºç™½èŠ‚ç‚¹æ˜¯è¢«åˆ é™¤çš„ $4$ ï¼š</p>

<p><img src="/assets/img/bt_basic/rebalancing_1.png" alt="" /></p>

<p>ä¹‹åæƒ…å†µå˜ä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<p><img src="/assets/img/bt_basic/rebalancing_2.png" alt="" /></p>

<p>é€’å½’åœ°<strong>åˆå¹¶èŠ‚ç‚¹</strong>ï¼š</p>

<ol>
  <li>æŠŠå·¦é‚»å±…èŠ‚ç‚¹ã€å¯¹åº”çˆ¶èŠ‚ç‚¹çš„é”®å’Œç›®æ ‡èŠ‚ç‚¹åˆå¹¶<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup>ï¼›</li>
  <li>é€’å½’åœ°åœ¨çˆ¶èŠ‚ç‚¹ä¸Šè°ƒç”¨ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ï¼›</li>
  <li>å½“æ ¹èŠ‚ç‚¹çš„é”®ä¸è¶³æ—¶ï¼Œå¼¹å‡ºå®ƒçš„å­©å­<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>ä½œä¸ºæ–°çš„æ ¹èŠ‚ç‚¹<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup></li>
</ol>

<h2 id="å®ç°-æ•°æ®ç»“æ„">å®ç°-&gt;æ•°æ®ç»“æ„</h2>

<h3 id="è¾…åŠ©å®">è¾…åŠ©å®</h3>

<p>å°±åƒå‰æ–‡äºŒå‰æœç´¢æ ‘é‚£æ ·ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡ä¸€ä¸ªå®ï¼Œæ¥æè¿°è¿™ä¸ªç³»åˆ—çš„ B æ ‘çš„ä»£ç ç»“æ„ï¼Œæ¥é¿å…æ— è°“çš„é‡å¤<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>ï¼š</p>

<p>å…¶ä¸­ M è¡¨ç¤ºé˜¶æ•°ï¼Œè¿™ä¹Ÿæš—ç¤ºæˆ‘ä»¬çš„èŠ‚ç‚¹å°†ä¸å†åƒäºŒå‰æœç´¢æ ‘é‚£æ ·åœ¨å­—æ®µåä¸Šåˆ†å‡ºé”®å’Œå­©å­çš„é¡ºåºï¼Œè€Œæ˜¯é‡‡ç”¨æ›´ä¸€èˆ¬åŒ–åœ°å®‰æ’ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_tree</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span>
        <span class="nv">$treename:ident</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr:meta]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="k">=&gt;</span>
    <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
        <span class="k">pub</span> <span class="k">struct</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_low_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="k">fn</span> <span class="nf">entries_high_bound</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
                <span class="n">M</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>èŠ‚ç‚¹åŒ…è£… <code class="language-plaintext highlighter-rouge">Node&lt;K, V&gt;</code> æ²¿ç”¨<a href="/algs/BST-0-Basic.html#å®Œæ•´åŒ…è£…">äºŒå‰æœç´¢æ ‘é‡Œçš„å®ç°</a>ã€‚</p>

<p>è€Œæˆ‘å¯¹å±æ€§è®¿é—®ç›¸å…³çš„å® <code class="language-plaintext highlighter-rouge">attr</code> å’Œ <code class="language-plaintext highlighter-rouge">def_attr_macro</code> ï¼Œä¸ºäº†æ›´åŠ ä¸°å¯Œçš„åŠŸèƒ½å’Œå®Œæ•´ä¸€è‡´çš„è¯­ä¹‰è€Œè¿›è¡Œäº†é‡æ„ï¼š</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Evil hack for Rc&lt;RefCell&lt;T&gt;&gt;</span>
<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">_bor</span>.<span class="nv">$attr</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nv">$ty</span><span class="p">;</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="n">_attr</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bor</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
            <span class="n">bor</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span> <span class="o">=</span> <span class="nv">$val</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$</span><span class="p">((</span><span class="nv">$name:ident</span><span class="p">,</span><span class="nv">$ty:ty</span><span class="p">)),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="k">ref</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">ref_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$ty</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">];</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="n">clone</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="nd">#[allow(unused)]</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="b-æ ‘ç»“æ„">B-æ ‘ç»“æ„</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B-Trees</span>
    <span class="cd">///</span>
    <span class="cd">/// Panic: M &gt; 2</span>
    <span class="cd">///</span>
    <span class="cd">/// Recommend: maybe 60, 90, 250</span>
    <span class="cd">/// (Rust use M=12 (B=6, M=2B-1+1) maybe increase it in the futer)</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="n">BT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="b-æ ‘èŠ‚ç‚¹">B-æ ‘èŠ‚ç‚¹</h3>

<p>å‰é¢éƒ½æ˜¯å…¬å…±çš„ä»£ç ï¼Œè€Œå¯¹äºçœŸæ­£èŠ‚ç‚¹çš„å®šä¹‰ <code class="language-plaintext highlighter-rouge">Node_</code> çš„å®šä¹‰æ˜¯çœŸæ­£ç‹¬ç‰¹è®¾è®¡çš„ä½“ç°ï¼Œè¿™é‡Œæœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„çš„ï¼š</p>

<ol>
  <li>æ™®é€šçš„ B æ ‘å°±åƒäºŒå‰æœç´¢æ ‘ä¸€æ ·ç›´æ¥æŠŠé”®å€¼å­˜åœ¨ä¸€èµ·ï¼Œè¿™é‡Œç”¨ <code class="language-plaintext highlighter-rouge">KVEntry</code> æŠŠå®ƒä»¬ç›´æ¥æ”¾åˆ°ä¸€èµ·ä¾¿äºé›†ä¸­ç®¡ç†ï¼Œ<code class="language-plaintext highlighter-rouge">KVEntry</code> æ˜¯ä¸€ä¸ªä»¥ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºæ’åºé”®çš„äºŒå…ƒç»„ã€‚</li>
  <li>å¯¹èŠ‚ç‚¹å†…é”®çš„å­˜å‚¨ä½¿ç”¨äº†è¿ç»­åœ°å€çš„å‘é‡ç»“æ„ï¼Œè¿™æ˜¯æˆ‘åœ¨å®ç°æ—¶çš„ç¬¬ä¸€é€‰æ‹©ï¼Œåœ¨ç»å…¸çš„ CPU æ¶æ„ä¸‹ï¼Œè¿™æ ·ä¸è¶…è¿‡ $100$ ä¸ª æŒ‡é’ˆå®½åº¦çš„æ•°ç»„çš„è¯»å†™æ˜¯æœ€ä¼˜çš„<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">9</a></sup></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">clone</span><span class="p">|</span>
    <span class="n">paren</span>
<span class="p">);</span>
<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="k">ref</span><span class="p">|</span>
    <span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">),</span>
    <span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="cd">/// å³ä½¿æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¹Ÿè¦ä¿æŒå­©å­æ•°é‡ = k-v æ•°é‡ + 1</span>
    <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="kventry">KVEntry</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="n">K</span><span class="p">,</span> <span class="k">pub</span> <span class="n">V</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">drain</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="p">,</span> <span class="k">self</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialEq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">==</span> <span class="n">other</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">PartialOrd</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-åŸºç¡€æ–¹æ³•">å®ç°-&gt;åŸºç¡€æ–¹æ³•</h2>

<p>å¦‚æœæ˜¯ä»äºŒå‰æœç´¢æ ‘ç¬¬ä¸€æ¬¡æ¥è§¦åˆ° B æ ‘è¿™æ ·çš„ $m$ è·¯æœç´¢æ ‘ï¼ˆ$m \geqslant 3$ï¼‰ï¼Œä¼šæ„Ÿåˆ°å¾ˆå¤šè§‚å¿µä¸Šçš„ä¸é€‚åº”ï¼Œä¸€äº›åŸºç¡€æ“ä½œåˆ°åº•æ€ä¹ˆå®ç°ï¼Œéš¾ä»¥æƒ³å¾—å¾ˆæ¸…æ¥š<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">10</a></sup>ã€‚</p>

<p>ä¸€ä¸ªå…³é”®çš„åŒºåˆ«åœ¨äºäºŒå‰æœç´¢æ ‘ä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªé”®ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé”®å°±æ˜¯èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹å°±æ˜¯é”®ï¼Œæ‰¾åˆ°äº†èŠ‚ç‚¹å°±æ‰¾åˆ°äº†é”®ï¼Œåä¹‹äº¦ç„¶ã€‚</p>

<p>è€Œ B æ ‘è¿™æ ·çš„å¤šè·¯æœç´¢æ ‘ä¸æ­¢æœ‰ä¸€ä¸ªé”®ï¼Œæ‰¾åˆ°äº†èŠ‚ç‚¹åè¿˜è¦åœ¨èŠ‚ç‚¹é‡Œå¯»æ‰¾é”®ï¼Œä¸ä»…è€ƒè™‘å¾—æ˜¯èŠ‚ç‚¹é—´çš„å…³ç³»ï¼Œè¿˜è¦è€ƒè™‘èŠ‚ç‚¹å†…é”®ä¹‹é—´çš„å…³ç³»ï¼Œä»¥åŠæŸä¸ªé”®çš„å¯¹åº”çš„å·¦å³å­©å­çš„ç´¢å¼•ä½ç½®ã€‚</p>

<p>å› æ­¤è¿™é‡Œæˆ‘ä»¬é¦–å…ˆè¦ç‚¹å‡ºé”®å’Œå­©å­åœ¨èŠ‚ç‚¹å†…çš„å¸ƒå±€ã€‚</p>

<h3 id="èŠ‚ç‚¹å¸ƒå±€">èŠ‚ç‚¹å¸ƒå±€</h3>

<ol>
  <li>å¯¹äºé”®ï¼ŒæŒ‰å‘é‡çš„åœ°å€å¢é•¿é¡ºåºä»å°åˆ°å¤§æ’åˆ—ï¼›</li>
  <li>å¯¹äºå­©å­ï¼Œä¹ŸæŒ‰ç…§åŒæ ·åœ°é¡ºåºæ’åˆ—</li>
</ol>

<p>è¿™æ ·æœ‰ $\text{len(keys) + 1 = len(children)}$ ï¼Œå¹¶ä¸”èŠ‚ç‚¹å†…ç´¢å¼•ä¸º $i$ çš„é”®å¯¹åº”çš„å·¦å³å­©å­åˆ†åˆ«ä¸º $\text{children}[i]$ å’Œ $\text{children}[i+1]$ ã€‚</p>

<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å­©å­åŒç¼–å·çš„æ˜¯å³é‚»å±…é”®ï¼Œæ¯ä¸ªé”®ä¸å®ƒçš„å·¦å­©å­åŒç¼–å·ï¼š</p>

<p><img src="/assets/img/bt_basic/key_children_idx.png" alt="" /></p>

<h3 id="åˆ›å»ºèŠ‚ç‚¹">åˆ›å»ºèŠ‚ç‚¹</h3>

<p>æˆ‘ä»¬åŒæ ·å¯ä»¥ä½¿ç”¨äºŒå‰æœç´¢æ ‘é‚£é‡Œç”¨è¿‡çš„ <code class="language-plaintext highlighter-rouge">node</code> å®æ¥ç®€åŒ–èŠ‚ç‚¹çš„åˆ›å»ºã€‚</p>

<p>åˆ›å»ºæ–°èŠ‚ç‚¹çš„æƒ…æ™¯æœ‰ä¸¤ç§ï¼š</p>

<ol>
  <li>æ ‘ä¸ºç©ºçš„æ—¶å€™ï¼Œä»æ–°å¼€å§‹åˆ›å»ºä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œè¿™æ—¶åªéœ€è¦æŒ‡æ˜é”®å€¼å¯¹å„¿å³å¯ï¼›</li>
  <li>èŠ‚ç‚¹åˆ†è£‚ä»¥åŠ <code class="language-plaintext highlighter-rouge">push_new_level</code> çš„æ—¶å€™ï¼Œè¿™æ—¶éœ€è¦æŒ‡æ˜èŠ‚ç‚¹çš„å„ä¸ªå±æ€§</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">coll</span><span class="p">::{</span> <span class="o">*</span><span class="p">,</span> <span class="n">node</span> <span class="k">as</span> <span class="n">aux_node</span> <span class="p">};</span>

<span class="c1">// ...</span>

<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">;</span> <span class="mi">2</span><span class="p">];</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ±‚å–å­èŠ‚ç‚¹ç´¢å¼•">æ±‚å–å­èŠ‚ç‚¹ç´¢å¼•</h3>

<p>åœ¨äºŒå‰æœç´¢æ ‘çš„ç³»åˆ—é‡Œå¸¸ç”¨åˆ°ä¸€ä¸ªç»™å‡ºå­èŠ‚ç‚¹ï¼Œæ±‚å®ƒæ˜¯çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­è¿˜æ˜¯å³å­©å­çš„æ“ä½œï¼Œä½¿ç”¨è¿™ä¸ª <code class="language-plaintext highlighter-rouge">index_of_child</code> å®ã€‚</p>

<p>åœ¨ B æ ‘ä¸Šæ›´æœ‰è¿™æ ·éœ€æ±‚ï¼Œä¸ç®¡æ˜¯è·å–é”®è¿˜æ˜¯å­©å­ã€‚</p>

<p><strong>æœ€æ™®éæ€§çš„æ–¹æ³•æ˜¯éå†çˆ¶èŠ‚ç‚¹çš„å­©å­ç´¢å¼•</strong>ï¼š</p>

<p>æ˜¾ç„¶å®ƒçš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œæ˜¯ $O(m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(M)</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child_by_rc</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">idx</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"There are no matched child"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>è™½ç„¶ $m$ ä¹Ÿä¸ä¼šå¾ˆå¤§ï¼Œä½†æ˜¯çº¿æ€§æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶æœ‰æ”¹è¿›çš„ä½™åœ°ã€‚</p>

<p>æˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡åˆ©ç”¨å­©å­èŠ‚ç‚¹é‡Œä»»ä¸€ä¸€ä¸ª<strong>é”®åœ¨çˆ¶èŠ‚ç‚¹ä¸Šæ‰§è¡ŒäºŒåˆ†æŸ¥æ‰¾</strong>ï¼š</p>

<p>æ—¶é—´å¤æ‚åº¦å°±å˜æˆå¯¹æ•°çº§çš„ï¼Œæ˜¯ $O(\text{log}\ m)$</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// O(logM) search by key</span>
<span class="nd">macro_rules!</span> <span class="n">index_of_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.binary_search</span><span class="p">(</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Dup key on {oldidx}"</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">inseridx</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[track_caller]</span>
    <span class="k">fn</span> <span class="nf">last_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">ent</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"EMPTY entries"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ä½†æ˜¯è¿™ä¸ªæ–¹æ³•å­˜åœ¨é™åˆ¶ï¼Œæ— æ³•é€‚ç”¨äºç©ºèŠ‚ç‚¹çš„æƒ…å†µï¼Œåœ¨åˆ é™¤é”®çš„ä¸€äº›æƒ…å¢ƒä¸‹åªèƒ½å›å½’åˆ°æ™®éæ€§çš„ç®—æ³•ä¸Šã€‚</p>

<h3 id="æœç´¢åˆ°å¶å­èŠ‚ç‚¹">æœç´¢åˆ°å¶å­èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// æ¼‚äº®çš„å°¾é€’å½’</span>
    <span class="k">fn</span> <span class="n">search</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">((</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-ä¸€èˆ¬å…¬å¼€æ–¹æ³•">å®ç°-&gt;ä¸€èˆ¬å…¬å¼€æ–¹æ³•</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">self</span>
        <span class="py">.root</span>
        <span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">node</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-æ’å…¥æ–¹æ³•">å®ç°-&gt;æ’å…¥æ–¹æ³•</h2>

<h3 id="æœç´¢æ’å…¥">æœç´¢ã€æ’å…¥</h3>

<p>è¿™ä¸ªæ’å…¥çš„ä¸»æµç¨‹å’ŒäºŒå‰æœç´¢æ ‘çš„æ’å…¥ç»“æ„ä¸Šæ˜¯ç±»ä¼¼çš„ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>

                    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span>
                <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">y</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹æå‡">èŠ‚ç‚¹æå‡</h3>

<p>Rust æ ‡å‡†åº“é‡Œçš„ <code class="language-plaintext highlighter-rouge">Vec</code> ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€åˆ‡çš„ä¾¿åˆ©æ–¹æ³•ï¼Œä»äºŒåˆ†æŸ¥æ‰¾åˆ°å‘é‡åˆ†å‰²ï¼ˆ<code class="language-plaintext highlighter-rouge">split_off</code>ï¼‰ã€‚ä¸è¿‡ä¸å…¶è¯´æ˜¯ Rust ä¸ºæˆ‘ä»¬æä¾›äº†ä¾¿åˆ©ï¼Œä¸å¦‚è¯´æ˜¯å®ƒçš„ API è®¾è®¡æŒ‡å¯¼äº†æˆ‘ä»¬çš„ä»£ç é£æ ¼ã€‚</p>

<p>å›é¡¾ä¹‹å‰çš„<a href="#æ’å…¥">èŠ‚ç‚¹æå‡çš„ç®—æ³•</a>ï¼Œå¯¹æ¯”ä¸‹è¿™é‡Œçš„ä»£ç å®ç°ï¼š</p>

<h4 id="åˆ†ç¦»èŠ‚ç‚¹">åˆ†ç¦»èŠ‚ç‚¹</h4>

<ol>
  <li>ç›®æ ‡èŠ‚ç‚¹çš„é”®å€¼æŒ‰ç…§ $\lceil {\large\frac{m}{2}}\rceil$ åˆ†å‡ºå³åŠéƒ¨åˆ†ï¼Œå·¦åŠéƒ¨åˆ†å¼¹å‡ºå°¾éƒ¨çš„é”®å€¼ä½œä¸ºæå‡ï¼›</li>
  <li>ç›®æ ‡èŠ‚ç‚¹çš„å­©å­æŒ‰ç…§ $\lceil {\large\frac{m}{2}}\rceil$ åˆ†å‡ºå³åŠéƒ¨åˆ†ï¼ŒæŠŠåˆ†å‡ºçš„è¿™äº›é”®å€¼å’Œå­©å­ç»„åˆæˆæ–°çš„å³é‚»å±…èŠ‚ç‚¹ï¼›</li>
  <li>ä¸è¦å¿˜è®°æ›´æ–°æ–°èŠ‚ç‚¹çš„å­©å­çš„åå‘å¼•ç”¨æŒ‡å‘è‡ªå·±</li>
</ol>

<h4 id="æ£€æŸ¥æ˜¯å¦åœæ­¢">æ£€æŸ¥æ˜¯å¦åœæ­¢</h4>

<ol>
  <li>å¦‚æœåˆ°è¾¾æ ¹èŠ‚ç‚¹ï¼ŒæŠŠæå‡çš„é”®å€¼ï¼Œå’Œåˆ†è£‚å‡ºçš„ä¸¤ä¸ªå­©å­ç»„åˆæˆæ–°çš„æ ¹èŠ‚ç‚¹ï¼›</li>
  <li>å¦åˆ™æŠŠæå‡çš„é”®å€¼å’Œå³é‚»èŠ‚ç‚¹æ’å…¥åˆ°å¯¹åº”çš„çˆ¶èŠ‚ç‚¹ä¸­ï¼Œæ£€æŸ¥çˆ¶èŠ‚ç‚¹æ˜¯å¦æº¢å‡ºï¼Œé€’å½’åœ°è¿›è¡Œæå‡</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// æ¼‚äº®çš„å°¾é€’å½’</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">split_pos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entries_x</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">entry_head</span> <span class="o">=</span> <span class="n">entries_x</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">split_pos</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
        <span class="nd">children_revref!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* push new level */</span>

            <span class="k">let</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">entry_head</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into paren node */</span>

            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">entry_head</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.downgrade</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>   
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">children_revref</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$x</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="å®ç°-åˆ é™¤æ–¹æ³•">å®ç°-&gt;åˆ é™¤æ–¹æ³•</h2>

<h3 id="æœç´¢åˆ é™¤">æœç´¢ã€åˆ é™¤</h3>

<p>åˆ é™¤çš„ä¸»æµç¨‹ï¼ŒåŒæ ·ç±»ä¼¼äºäºŒå‰æœç´¢æ ‘çš„ç®—æ³•ï¼Œæ‰¾åˆ°ç›®æ ‡é”®ï¼Œå’Œåç»§é”®äº¤æ¢ï¼Œç¡®ä¿æœ€ç»ˆè¦åˆ é™¤çš„é”®ä½äºå¶å­èŠ‚ç‚¹ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="k">mut</span> <span class="n">x</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>

            <span class="cm">/* Swap with its successor leaf node */</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">succ</span><span class="p">,</span> <span class="n">succ_idx</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="nf">.minimum</span><span class="p">();</span>

                <span class="nf">swap</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">succ</span><span class="p">)[</span><span class="n">succ_idx</span><span class="p">],</span>
                <span class="p">);</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">succ</span><span class="p">;</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">succ_idx</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">();</span>

            <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="n">popped</span><span class="na">.1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Left most</span>
    <span class="k">fn</span> <span class="nf">minimum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="k">Self</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èŠ‚ç‚¹ä¸‹æ²‰">èŠ‚ç‚¹ä¸‹æ²‰</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Exclude leaf node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* merge with sib node (rebalance failed means that each node are small) */</span>

            <span class="c1">// merge left child</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// merge right child</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">());</span>
                    <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="å°è¯•é‡å¹³è¡¡">å°è¯•é‡å¹³è¡¡</h3>

<p>è¿™é‡Œä½¿ç”¨äº†äºŒå‰æœç´¢æ ‘é‡Œå®šä¹‰çš„ <code class="language-plaintext highlighter-rouge">Dir</code> æšä¸¾ç»“æ„ï¼Œæä¾›æ–¹å‘æ ‡è¯†ã€‚</p>

<p>å¯¹èŠ‚ç‚¹çš„é‡å¹³è¡¡å½“åˆæ˜¯ç”¨å®æ¥æè¿°çš„ï¼Œä½†å®Œå…¨å¯ä»¥æ›¿æ¢æˆä¸€èˆ¬çš„æ–¹æ³•ã€‚</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">bst</span><span class="p">::{</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">};</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// (parent, left-idx, sib_dir)</span>
<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="n">child</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
	<span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="åˆå¹¶èŠ‚ç‚¹">åˆå¹¶èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// (parent, left-idx)</span>
<span class="nd">macro_rules!</span> <span class="n">merge_node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// merge right's children to the left</span>

        <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// merge entries</span>
        <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="å®ç°-æµ‹è¯•æ–¹æ³•">å®ç°-&gt;æµ‹è¯•æ–¹æ³•</h2>

<p>è¿™é‡Œä»‹ç»äº†æµ‹è¯•ä¸è°ƒè¯•ç›¸å…³çš„ä»£ç </p>

<h3 id="æ‰“å°èŠ‚ç‚¹">æ‰“å°èŠ‚ç‚¹</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="nv">$x</span><span class="p">)[</span><span class="nv">$idx</span><span class="p">]</span><span class="na">.0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">kn</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}, "</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">kn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ‰“å°æ ‘">æ‰“å°æ ‘</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    	<span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}</span>

                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: {p:?})"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="æ€§è´¨æ ¡éªŒ">æ€§è´¨æ ¡éªŒ</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
    	<span class="n">K</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="nd">assert_eq!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                        <span class="s">"{child:?}"</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                        <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                        <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="nd">assert!</span><span class="p">(</span>
                        <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="p">);</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                        <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">child</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span><span class="nf">.last_entry</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="æ³¨è§£">æ³¨è§£</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>è¿™æ˜¯ä¸ºäº†è®©æ’å…¥æå‡èƒ½å¤Ÿåœ¨æ ¹èŠ‚ç‚¹å¤„ç»ˆæ­¢Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>å½“ç„¶å®é™…ä¸Šå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æ˜¯æ—§èŠ‚ç‚¹çš„é‡æ–°åˆ©ç”¨Â <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>è¿™ä¸ªè¿‡ç¨‹åœ¨å¾ˆå¤šå®ç°é‡Œè¢«æƒ¯ä¾‹åœ°ç§°ä¸º <code class="language-plaintext highlighter-rouge">push_new_level</code> ä¹‹ç±»çš„åå­—Â <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>ä¹Ÿå¯ä»¥é‡‡ç”¨æƒ°æ€§åˆ é™¤çš„æ–¹æ³•ï¼Œä½†è¿™é‡Œå°±ä¸ä»‹ç»äº†Â <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>å½“ç„¶ä¹Ÿå¯ä»¥åˆå¹¶ç›®æ ‡èŠ‚ç‚¹ã€çˆ¶èŠ‚ç‚¹é”®å’Œå³é‚»å±…èŠ‚ç‚¹Â <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>æ ¹èŠ‚ç‚¹é”®ä¸è¶³çš„æ—¶å€™ä¹Ÿå°±æ˜¯åªæœ‰ç©ºèŠ‚ç‚¹å’Œä¸€ä¸ªå­©å­çš„æƒ…å†µÂ <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>è¿™ä¸ªé™ä½æ ‘é«˜çš„è¿‡ç¨‹å¯ä»¥ç§°ä¸º <code class="language-plaintext highlighter-rouge">pop_level</code>Â <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>å¦‚æœå¯ä»¥ï¼Œæˆ‘ä¸æ„¿æ„å¤šæ‰“å“ªæ€•ä¸€ä¸ªé‡å¤çš„å­—ç¬¦Â <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>åé¢çš„ä»¥ä¸€ç§å®ç°çš„æ€§èƒ½æµ‹è¯•å®é™…å®Œå…¨éªŒè¯äº†æˆ‘çš„è¿™ç§è®¤è¯†Â <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>å¯¹äºæˆ‘æ¥è®²ï¼Œæƒ³ä¸æ¸…æ¥šçš„å°±èººåºŠä¸Šæ…¢æ…¢æƒ³ï¼Œè¿™ä¹Ÿæ˜¯ç¬›å¡å°”æ€è€ƒé—®é¢˜çš„åŠæ³•ï¼Œå½“åˆè§£æå‡ ä½•çš„æƒ³æ³•å°±æ˜¯åœ¨åºŠä¸Šæƒ³å‡ºæ¥çš„Â <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[B æ ‘æ˜¯æ³¢éŸ³å®éªŒå®¤çš„ Rudolf Bayer and Edward M. McCreight æœ€åˆå‘æ˜ç”¨æ¥å­˜å‚¨å¤§é‡ç´¢å¼•ï¼ˆè¶…è¿‡ä¸»å†…å­˜ï¼‰çš„æ•°æ®ç»“æ„ï¼Œåœ¨ 1970 å¹´çš„è®ºæ–‡é‡Œæ­£å¼æå‡ºã€‚]]></summary></entry><entry><title type="html">ç–‘éš¾æ‚ç—‡å¤‡å¿˜å½•</title><link href="/oth/BackNotes.html" rel="alternate" type="text/html" title="ç–‘éš¾æ‚ç—‡å¤‡å¿˜å½•" /><published>2023-02-20T00:00:00+08:00</published><updated>2023-02-20T00:00:00+08:00</updated><id>/oth/BackNotes</id><content type="html" xml:base="/oth/BackNotes.html"><![CDATA[<h4 id="q1">Q1:</h4>

<p>Ubuntu 22.04 å åŠ å‡ æ¬¡éœ€è¦é‡å¯çš„æ›´æ–°åé‡å¯å‘ç°WiFiæ¨¡å—æ‰¾ä¸åˆ°äº†</p>

<p>A: å†æ¬¡é‡å¯æˆ–å…³æœºé‡å¯éƒ½æ²¡æœ‰ç”¨ï¼Œæœ€åæ˜¯é‡æ–°å…³é—­å’Œå¯ç”¨äº†WiFié©±åŠ¨ï¼ˆåœ¨è½¯ä»¶æ›´æ–°é‡Œï¼‰è§£å†³çš„é—®é¢˜</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[Q1:]]></summary></entry><entry><title type="html">å­˜å‚¨ä»‹è´¨ï¼ˆ0ï¼‰- åŸºç¡€</title><link href="/oth/StorageMedium-0-Basic.html" rel="alternate" type="text/html" title="å­˜å‚¨ä»‹è´¨ï¼ˆ0ï¼‰- åŸºç¡€" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%200%20-%20Basic</id><content type="html" xml:base="/oth/StorageMedium-0-Basic.html"><![CDATA[<h2 id="åˆ†ç±»">åˆ†ç±»</h2>

<p>æŒ‰ç…§è®°å½•æ•°æ®çš„è½½ä½“ï¼Œå¯ä»¥åˆ†ä¸º<strong>ç£æ€§å­˜å‚¨ï¼ˆmagneticï¼‰</strong>ã€<strong>å…‰å­¦å­˜å‚¨ï¼ˆopticalï¼‰</strong>å’Œ<strong>é›†æˆç”µè·¯å­˜å‚¨</strong></p>

<h2 id="ç£æ€§å­˜å‚¨">ç£æ€§å­˜å‚¨</h2>

<ol>
  <li>æœºæ¢°ç¡¬ç›˜</li>
  <li>è½¯ç›˜ï¼ˆfloppy diskï¼‰</li>
  <li>ç£å¸¦é¼“</li>
</ol>

<p>ä¸€ä¸ªæ¯”ä¸€ä¸ªè€ï¼Œç£å¸¦é¼“æ›´æ˜¯è€èµ„æ ¼</p>

<h2 id="å…‰å­¦å­˜å‚¨">å…‰å­¦å­˜å‚¨</h2>

<ol>
  <li>å…‰ç›˜</li>
</ol>

<h2 id="é›†æˆç”µè·¯å­˜å‚¨">é›†æˆç”µè·¯å­˜å‚¨</h2>

<p>é›†æˆç”µè·¯ï¼ˆIntegrated Circuitï¼Œ ICï¼‰ï¼Œä¸ç®¡æœ‰æ²¡æœ‰æ™¶ä½“ç®¡ï¼Œéƒ½æ˜¯æœ‰æœ‰åŠå¯¼ä½“ææ–™ï¼Œä¹Ÿç›´æ¥å«åšåŠå¯¼ä½“å­˜å‚¨ã€‚</p>

<p>åœ¨è¿™æ ·ç”µè·¯å®ç°åˆ†ä¸ºï¼š<strong>RAM</strong> å’Œ <strong>ROM</strong></p>

<h2 id="ram">RAM</h2>

<p>RAMï¼ˆRandom-access memoryï¼‰ åˆ†ä¸ºï¼š<strong>SRAM</strong> å’Œ <strong>DRAM</strong></p>

<h3 id="sram">SRAM</h3>

<p>ä¼ ç»Ÿä¸Šä½¿ç”¨ $6$ ä¸ªæ™¶ä½“ç®¡ï¼Œæ˜¯â€œçœŸâ€åŠå¯¼ä½“å­˜å‚¨ã€‚</p>

<p>æ›´ä½çš„å°è£…å¯†åº¦ï¼Œæ›´å¿«çš„è®¿é—®é€Ÿåº¦ï¼Œæ›´å°‘çš„è€—ç”µã€‚</p>

<h4 id="åº”ç”¨å®ä¾‹">åº”ç”¨å®ä¾‹</h4>

<p>CPU ç¼“å­˜ã€CPU å¯„å­˜å™¨</p>

<h3 id="dram">DRAM</h3>

<p>éœ€è¦è„‰å†²åˆ·æ–°ï¼Œå¾ˆå°‘çš„æ™¶ä½“ç®¡ï¼Œå¤§éƒ¨åˆ†æ˜¯ç”µå®¹ï¼ˆå„ç§å„æ ·ç»ç¼˜ææ–™åˆ¶ä½œï¼‰</p>

<h4 id="åº”ç”¨å®ä¾‹-1">åº”ç”¨å®ä¾‹</h4>

<p>ç”µè„‘çš„å†…å­˜æ¡</p>

<h2 id="rom">ROM</h2>

<p>ROMï¼ˆRead-only memoryï¼‰</p>

<p>ROMåˆ†ä¸ºï¼š<strong>EPROM</strong>ã€<strong>E2PROM</strong>ã€<strong>Flash</strong></p>

<p>å¯æ“¦é™¤ã€ç”µå¯æ“¦é™¤ã€å¦ä¸€ä¸ªç”µå¯æ“¦é™¤çš„æ”¹ç‰ˆ</p>

<p>å®é™…ä¸Šåªæœ‰ <strong>E2PROM</strong>ã€<strong>Flash</strong></p>

<p>é‡ç¼–ç¨‹ ROM é‡å†™å…¥çš„æ¬¡æ•°æ˜¯æœ‰é™åˆ¶çš„</p>

<p>ä»æ¦‚å¿µä¸Šè®²ï¼ŒFlash å±äº E2PROM çš„èŒƒç•´ï¼Œä½†æ˜¯ä¸€èˆ¬è€Œè®²ï¼ŒFlash Memory é«˜é€Ÿé«˜å¯†åº¦ï¼Œæœ‰æ›´å¤§çš„æ“¦é™¤å—å’Œæ›´æœ‰é™çš„å†™å…¥æ¬¡æ•°ã€‚ç°åœ¨ä¸€èˆ¬ E2PROM éƒ½è¢« Flash æ›¿ä»£äº†ã€‚</p>

<h3 id="flash">Flash</h3>

<p>åˆ†ä¸º <strong>NOR</strong> å‹ å’Œåé¢å‘å±•çš„ <strong>NAND</strong> å‹</p>

<h4 id="nor">NOR</h4>

<p>è´´è¿‘åŸå§‹çš„E2PROMï¼Œæ”¯æŒéšæœºå­˜å–</p>

<h4 id="nand">NAND</h4>

<p>åªæ”¯æŒæŒ‰é¡µå­˜å–ï¼Œç›®æ ‡æ˜¯ä»£æ›¿å›ºæ€ç¡¬ç›˜ï¼ˆUç›˜ï¼Œå›ºæ€ç¡¬ç›˜ï¼Œå†…å­˜å¡ï¼‰</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[åˆ†ç±»]]></summary></entry><entry><title type="html">Diskä¸Šçš„å­˜å‚¨ç»“æ„</title><link href="/oth/StorageMedium-1-Disk.html" rel="alternate" type="text/html" title="Diskä¸Šçš„å­˜å‚¨ç»“æ„" /><published>2023-02-13T00:00:00+08:00</published><updated>2023-02-13T00:00:00+08:00</updated><id>/oth/StorageMedium%20-%201%20-%20Disk</id><content type="html" xml:base="/oth/StorageMedium-1-Disk.html"><![CDATA[<p>ä»‹ç»çš„æ˜¯ç£ç›˜çš„å­˜å‚¨ç»“æ„ï¼Œä½†æŠ€æœ¯åŸç†ä¸Šå¯¹äºå…‰ç›˜ä¹Ÿæ˜¯é€šç”¨çš„ã€‚</p>

<h2 id="ç›˜ç‰‡åˆ’åˆ†">ç›˜ç‰‡åˆ’åˆ†</h2>

<p>ä¸€ä¸ªç›˜ç‰‡çš„åŸºæœ¬ä¸¤çº§ç»“æ„æ˜¯ï¼š è½¨é“ï¼ˆTrackï¼‰- æ‰‡åŒºï¼ˆSectorï¼‰ã€‚</p>

<p>è½¨é“æ˜¯ç›˜ç‰‡ä¸Šçš„åŒå¿ƒåœ†ï¼ˆè€ƒè™‘åˆ°è½¨é“çš„å®½åº¦ï¼Œå®é™…ä¸Šæ˜¯å¾ˆçª„çš„åŒå¿ƒåœ†ç¯ï¼‰</p>

<p>è€Œæ‰‡åŒºåˆ™æ˜¯ä¸€æ¡è½¨é“ä¸ŠæŒ‰ç…§ä¸€å®šè§’åº¦åˆ’åˆ†çš„å¼§ï¼Œæ˜¯æœ€åŸºæœ¬çš„å­˜å‚¨å•å…ƒã€‚</p>

<p>æ³¨æ„è¿™ä¸ªæ¦‚å¿µæ˜¾ç„¶æœ‰åˆ«äºå‡ ä½•å­¦ä¸Šçš„æ‰‡åŒºï¼Œè¿™é‡Œçš„æ‰‡åŒºå®é™…æ˜¯å‡ ä½•æ„ä¹‰ä¸Šçš„æ‰‡åŒºåœ¨æŸä¸€è½¨é“ä¸Šçš„äº¤é›†ã€‚</p>

<h2 id="è½¨é“">è½¨é“</h2>

<h3 id="ç¼–å·ä¹ æƒ¯">ç¼–å·ä¹ æƒ¯</h3>

<p>è½¨é“çš„ç¼–å·ä¼ ç»Ÿä¸Šä»å°åˆ°å¤§æŒ‰ç…§ä»å¤–åˆ°å†…çš„é¡ºåºã€‚</p>

<h3 id="pmr-vs-smr">PMR vs SMR</h3>

<p>ç°åœ¨ä¸šç•Œç°åœ¨æœ‰ä¸¤ç§ä¸»æµçš„ä¸è½¨é“æ’å¸ƒç›¸å…³çš„ç£è®°å½•æ–¹å¼ï¼š<strong>å‚ç›´å¼ç£è®°å½•ï¼ˆPerpendicular magnetic recordingï¼ŒPMRï¼‰</strong>ã€<strong>å ç“¦å¼ç£è®°å½•ï¼ˆShingled magnetic recordingï¼ŒSMRï¼‰</strong></p>

<p><strong>PMR</strong> ä¹Ÿå¯ä»¥ç§°ä¸º<strong>ä¼ ç»Ÿå¼ç£è®°å½•ï¼ˆConventional magnetic recordingï¼ŒCMRï¼‰</strong>æœ‰ç€æ•°åå¹´çš„æ‚ ä¹…å†å²ã€‚</p>

<p><strong>SMR</strong> æ˜¯ä¸ºäº†å¢åŠ  PMR çš„å­˜å‚¨å¯†åº¦ä¸Šé™è€Œå‘æ˜çš„ï¼Œä½¿ç”¨äº†æ›´çª„çš„è½¨é“æ’å¸ƒå¸ƒå±€ï¼Œä»£ä»·æ˜¯å®‰å…¨æ€§å’Œè®¿é—®æ•ˆç‡éƒ½æœ‰æ‰€ä¸‹é™ã€‚</p>

<h2 id="æ‰‡åŒº">æ‰‡åŒº</h2>

<p>ä¼ ç»Ÿ HDD çš„æ‰‡åŒºæ˜¯ 512 bytesï¼ŒCD-ROM å’Œ DVD-ROM æ˜¯ 2048 bytesï¼Œç°ä»£ HDD çš„æ‰‡åŒºæ˜¯ 4096 bytesã€‚</p>

<h3 id="ç‰©ç†æ‰‡åŒºå’Œé€»è¾‘æ‰‡åŒº">ç‰©ç†æ‰‡åŒºå’Œé€»è¾‘æ‰‡åŒº</h3>

<p>ä¸ºäº†å‘åå…¼å®¹ï¼Œæ‰‡åŒºè¿˜åˆ†äº†<strong>é€»è¾‘æ‰‡åŒº</strong>å’Œ<strong>ç‰©ç†æ‰‡åŒº</strong>ä¸¤ä¸ªæ¦‚å¿µã€‚</p>

<p><strong>ç‰©ç†æ‰‡åŒº</strong>æ˜¯å®é™…ä¸Šçš„æ‰‡åŒºåˆ’åˆ†æ¯”å¦‚ 4096 bytesã€‚</p>

<p><strong>é€»è¾‘æ‰‡åŒº</strong>å®é™…ä¸Šæ˜¯åˆ’åˆ†äº†ç‰©ç†æ‰‡åŒºï¼Œæ¯”å¦‚ 512 bytesï¼Œä»¥æä¾›æ›´å°çš„æ‰‡åŒºçš„è®¿é—®çš„åå‘å…¼å®¹æ€§ï¼Œä½†è¿™ç§è®¿é—®æ˜¾ç„¶æ˜¯ä½æ•ˆçš„ï¼Œå› ä¸ºæ¯æ¬¡éƒ½è¦å–å‡ºæ•´ä¸ªç‰©ç†æ‰‡åŒºä¿®æ”¹åå†é‡æ–°å†™å›å»ã€‚å› æ­¤é™¤éå¿…è¦ï¼Œé»˜è®¤éƒ½é‡‡å–é€»è¾‘æ‰‡åŒºå’Œç‰©ç†æ‰‡åŒºä¸€æ ·å¤§å°ã€‚</p>

<h3 id="æ‰‡åŒºç»“æ„">æ‰‡åŒºç»“æ„</h3>

<p>header areaï¼ˆso-called IDï¼‰ + data area</p>

<h4 id="header">header</h4>

<p>åŒæ­¥å­—èŠ‚+åœ°å€æ ‡å¿—ç¬¦+ç¼ºé™·æ ‡å¿—ï¼ˆflaw flagï¼‰+é”™è¯¯æ£€æŸ¥å’Œçº æ­£ä¿¡æ¯ï¼Œå¦‚æœæ•°æ®åŒºä¸å¯é ï¼Œè¿˜å¯ä¸€åŒ…å«å¤‡ç”¨åœ°å€</p>

<h4 id="data">data</h4>

<p>åŒæ­¥å­—èŠ‚+å­˜å‚¨çš„æ•°æ®+é”™è¯¯çº æ­£ç ï¼ˆECCï¼‰</p>

<h3 id="åŒºä½è®°å½•">åŒºä½è®°å½•</h3>

<p>Zero bit recordingï¼ŒZBRã€‚</p>

<p>æŒ‰ç…§ä¼ ç»Ÿç£ç›˜æ‰‡åŒºçš„åˆ’åˆ†æ–¹å¼ï¼Œæ˜¾ç„¶è¶Šé å¤–é¢çš„å¼§è¶Šé•¿ï¼Œç£å¯†åº¦è¶Šå°ï¼Œç›¸å¯¹æœ€é‡Œé¢çš„å¼§ï¼Œæ˜¾ç„¶å­˜åœ¨ä¸¥é‡çš„æ•°æ®å®¹é‡ä¸Šçš„æµªè´¹ã€‚</p>

<p>å¦‚æœæŒ‰ç…§åŠå¾„èŒƒå›´ï¼ŒæŠŠç›˜ä¸Šæ‰€æœ‰çš„è½¨é“å½’ä¸ºå‡ ä¸ªä¸åŒçš„åˆ†åŒºï¼ˆZoneï¼‰ï¼ŒæŠŠä¸åŒçš„åˆ†åŒºä¸Šçš„è½¨é“çš„å¼§åˆ’åˆ†æˆä»1åˆ°nä¸ç­‰æ•°é‡çš„æ‰‡åŒºï¼Œè¶Šé å¤–çš„å¼§åˆ’åˆ†å‡ºçš„è½¨é“è¶Šå¤šã€‚</p>

<p>ä¸‹å›¾æ¥è‡ª <a href="https://en.wikipedia.org/wiki/Zone_bit_recording">wiki</a> ï¼Œå…¶ä¸­çº¢ç»¿ç°ä¸‰è‰²å°±æ˜¯ä¸‰ä¸ªåˆ†åŒºï¼Œä¸åŒåˆ†åŒºçš„å¼§åˆ†åˆ«å¯ä»¥æœ‰ $1$ã€$2$ã€$4$ ä¸ªæ‰‡åŒºã€‚</p>

<p><img src="/assets/img/disk/zone.svg" alt="" /></p>

<p>ZBRå®é™…ä¸Šæ˜¯æŠŠåŸæ¥çš„å›ºå®šè§’é€Ÿåº¦è½¬å˜ä¸ºå›ºå®šçº¿é€Ÿåº¦ï¼Œå¸¦æ¥äº†æ•°æ®å®¹é‡çš„æé«˜å’Œå¤–éƒ¨æ‰‡åŒºè®¿é—®é€Ÿåº¦çš„æå‡ã€‚</p>

<p>ä¸è¿‡ç”±äºç³»ç»Ÿç¼–å·ç®¡ç†æ˜¯ä»åˆ°å†…ï¼Œè¿™å°±å¸¦æ¥ä¸€ä¸ªç³»ç»Ÿåˆåˆ›æµ‹è¯•æ—¶æœŸå’Œåç»­ä½¿ç”¨è¿‡ç¨‹ä¸­è¾ƒå¤§çš„æ€§èƒ½å·®å¼‚çš„é—®é¢˜ï¼Œæœ‰çš„driveä¼šæ•…æ„å‡æ…¢è¯»å¤–å‘¨æ—¶çš„è½¬é€Ÿæ¥é¿å…è¿™ç§å·®å¼‚ã€‚</p>

<p>ç°ä»£çš„HDDæ™®éä½¿ç”¨äº† ZBR çš„è®¾è®¡</p>

<h2 id="æ–‡ä»¶ç³»ç»Ÿæ˜ å°„">æ–‡ä»¶ç³»ç»Ÿæ˜ å°„</h2>

<p>block æˆ– allocation unit æˆ– cluster ï¼ŒæŒ‡å¾—æ˜¯æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨çš„åŸºæœ¬å•ä½ï¼Œå¯¹åº”ä¸€èˆ¬ä» $1$ ä¸ªæ‰‡åŒº ($512$ bytes) åˆ° $128$ ä¸ªæ‰‡åŒº ($64$ Kbytes )ã€‚</p>

<p>è¿™æ ·çš„ cluster åŒ…å«çš„æ‰‡åŒºä¸ä¸€å®šè¦åœ¨ç‰©ç†ä¸Šæ˜¯è¿ç»­çš„ã€‚<em>æ³¨æ„ï¼šå®ƒä»¬ä¸æ˜¯ç¢ç‰‡ï¼Œå› ä¸ºåœ¨é€»è¾‘ä¸Šå®ƒä»¬æ˜¯è¿ç»­çš„</em></p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[ä»‹ç»çš„æ˜¯ç£ç›˜çš„å­˜å‚¨ç»“æ„ï¼Œä½†æŠ€æœ¯åŸç†ä¸Šå¯¹äºå…‰ç›˜ä¹Ÿæ˜¯é€šç”¨çš„ã€‚]]></summary></entry></feed>