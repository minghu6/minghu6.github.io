<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-04-22T10:40:08+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">分片级联（Fractional Cascading）</title><link href="/algs/FractionalCascading.html" rel="alternate" type="text/html" title="分片级联（Fractional Cascading）" /><published>2023-04-17T00:00:00+08:00</published><updated>2023-04-17T00:00:00+08:00</updated><id>/algs/FractionalCascading</id><content type="html" xml:base="/algs/FractionalCascading.html"><![CDATA[<p><em>本文主要参考 <a href="https://en.wikipedia.org/wiki/Fractional_cascading">wiki</a> ，对其中一些内容进行了拓展，对个别错误进行了修正。</em></p>

<p>分片级联是一种同时对多个有序列表进行二分查找的加速技术。</p>

<p>假设有 $k$ 个有序列表，给定一个元素 $q$ ，查询在每个有序列表上的位置。</p>

<h2 id="思路">思路</h2>

<h3 id="原始做法">原始做法</h3>

<p>依次在每个有序列表上执行二分查找，假设每个列表的<strong>平均长度为 $n$</strong> ，总长度 $N=kn$ ， 则时间复杂度为 $O(k\ \text{log}\ n)$ 。</p>

<h3 id="改进的做法">改进的做法</h3>

<p>可以提前处理下这 $k$ 个有序列表，为其中每个元素计算在每个列表的位置，然后把这些元素和对应的在每个列表的位置合成一个大的有序列表，查找的时候只需要在这个大的有序列表上进行一次二分查找就可以了。</p>

<p>根据查找到的元素对应的统计信息，直接得到全部 $k$ 个有序列表上的位置。</p>

<p>例如如下 $k=4$ 个有序列表的</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">L\i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td>24</td>
      <td>64</td>
      <td>65</td>
      <td>80</td>
      <td>93</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td>23</td>
      <td>25</td>
      <td>26</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td>13</td>
      <td>44</td>
      <td>62</td>
      <td>66</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td>11</td>
      <td>35</td>
      <td>46</td>
      <td>79</td>
      <td>81</td>
    </tr>
  </tbody>
</table>

<p>得到</p>

<table>
  <thead>
    <tr>
      <th>L[0,6,12]</th>
      <th>L[1,7,13]</th>
      <th>L[2,8,14]</th>
      <th>L[3,9,15]</th>
      <th>l[4,10,16]</th>
      <th>l[5,11,17]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>11[0,0,0,0]</td>
      <td>13[0,0,0,1]</td>
      <td>23[0,1,1,1]</td>
      <td>24[0,1,1,1]</td>
      <td>25[1,1,1,1]</td>
      <td>26[1,2,1,1]</td>
    </tr>
    <tr>
      <td>35[1,3,1,1]</td>
      <td>44[1,3,1,2]</td>
      <td>46[1,3,2,2]</td>
      <td>62[1,3,2,3]</td>
      <td>64[1,3,3,3]</td>
      <td>65[2,3,3,3]</td>
    </tr>
    <tr>
      <td>66[3,3,3,3]</td>
      <td>79[3,3,4,3]</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>具体说明这个统计信息，以 $46[1,3,2,2]$ 为例，表明 $46$ 在 $L_1$ 的位置为 1 ，在 $L_2$ 的位置为 $3$ ，在 $L_3$ 的位置为 $2$ , 在 $L_4$ 的位置为 $2$ 。</p>

<p>这样如果我们查找 $q=45$ ，发现落到 $46$ 的位置，就直接使用 $46$ 的索引统计 $q=45$ 的索引结果即可。</p>

<p>这种做法，花费 $(k-1)n\text{log}(n)$ 的预处理时间，和 $kN$ <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>的空间，以实现 $O(\text{log}N)$ 时间复杂度的单次查询。</p>

<p>这样，单次查询的时间复杂度，从 $O(k\text{log}n)$ 变为 $O(\text{log}kn)$ , 相当于把 $k$ 放进了 log 里，性能得到了提升。</p>

<p>但是空间上 $kN$ 是非常的昂贵。</p>

<h3 id="分片级联">分片级联</h3>

<p>那么如何<em>在尽量保持改进的查询时间复杂度的情况下</em>降低空间复杂度呢？ 这才引出来，我们分片级联的技术。</p>

<p><strong>分片</strong>指得是分片取样（fractional sampling），<strong>级联</strong>（cascading）指得是并不同时保存所有k个列表的索引信息，而只是保存紧邻下一级的索引信息，然后一层层进行连锁。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>具体说就是：</p>

<ol>
  <li>构建一个预处理的列表 $M$ ，它的每一级 $M_i$ 都是由对应 $L_i$ 和下一级的 $M_{i+1}$ 中的元素构成，$M_i$ 存储元素本身以及每个元素在 $L_i$ 上的索引位置和 $M_{i+1}$ 上索引位置，这样一直到最后一级 $M_k$ ，因为没有下一级，所以只保存 $L_k$ 的元素，这体现了级联；</li>
  <li>次一级的 $M_{i+1}$ 里面不是每个元素都提升到 $M_i$ 里，而是两两取样<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，</li>
</ol>

<p>例如上述例子为</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M\I</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td>24[0,1]</td>
      <td>25[1,1]</td>
      <td>35[1,3]</td>
      <td>64[1,5]</td>
      <td>65[2,5]</td>
      <td>79[3,5]</td>
      <td>80[3,6]</td>
      <td>93[4,6]</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td>23[0,1]</td>
      <td>25[1,1]</td>
      <td>26[2,1]</td>
      <td>35[3,1]</td>
      <td>62[3,3]</td>
      <td>79[3,5]</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td>13[0,1]</td>
      <td>35[1,1]</td>
      <td>44[1,2]</td>
      <td>62[2,3]</td>
      <td>66[3,3]</td>
      <td>79[4,3]</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td>11[0,0]</td>
      <td>35[1,0]</td>
      <td>46[2,0]</td>
      <td>79[3,0]</td>
      <td>81[4,0]</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>对于前面的，$q=45$ 的例子，假设取样的分片大小为 $f=2$</p>

<ol>
  <li>
    <p>对 $M_1$ ，进行二分查找，发现最小的 $\geqslant 45$ 的是 $64[1,5]$ ，于是对于 $L_1$ 的<strong>结果是 $1$</strong>，然后从 $M_2[5]$ 开始，直接根据所属分片的级联的信息，就像拉拉链一样，最多经过 $f-1$ 次比较就可以得到结果；</p>
  </li>
  <li>
    <p>然后比较 $M_2[5]$ 和它的前一项 $M_2[4]$ <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>发现 $M_2[5]=62[3,3]$ 是最小的 $\geqslant q$ 的一项，于是 $L_2$ 的<strong>结果是 $3$</strong>；</p>
  </li>
  <li>
    <p>比较 $M_3[3]$ 和 $M_3[2]$，发现 $M_3[3] =62[2,3]$ 是最小的 $\geqslant q$ 的项，于是 $L_3$ 的<strong>结果是 $2$</strong>；</p>
  </li>
  <li>
    <p>比较 $M_4[3]$ 和 $M_4[2]$ ，发现 $M_4[2]=46[2,0]$ 是最小的 $\geqslant q$ 的项，于是 $L_4$ 的<strong>结果是 $4$</strong>；</p>
  </li>
</ol>

<p>利用合并两个有序列表的方法处理每个 $L_i$ 和 $M_{i+1}$ 的分片，使用 $(k-1)n$ 的预处理时间，消耗的内存小于 $2N$ 个单元，对于数字类型来说，也就是 $3 * 2N = 6N$ 的空间复杂度。</p>

<h4 id="空间复杂度证明">空间复杂度证明</h4>

<p>预处理列表 M 每一层的空间（单元）：</p>

\[|M_i| = {\displaystyle n \sum_{j=1}^{k-i+1} (\frac{1}{f})^{j-1}}\]

<p>总共空间是（单元）：</p>

\[\begin{array}{l}
{\displaystyle \sum_{i=1}^k|M_i|} &amp;= {\displaystyle n\sum_{i=1}^k \sum_{j=1}^{k-i+1} (\frac{1}{f})^{j-1}}\\
&amp;\lt {\displaystyle n \sum_{i=1}^k \sum_{j=1}^{k+1} (\frac{1}{f})^{j-1}}\\
&amp;= {\displaystyle n \sum_{i=1}^k 1 + (\frac{1}{f}) + (\frac{1}{f})^2 ...,+(\frac{1}{f})^k}\\
&amp;\lt 2n{\displaystyle \sum_{i=1}^k 1}\\
&amp;= 2N
\end{array}\]

<h4 id="时间复杂度分析">时间复杂度分析</h4>

<p>由于 $M_1 \lt 2n$ ，因此单次查询的时间复杂度为 $O(\text{log}n + (f-1)k)$ 。</p>

<p>由于除了 log ，还多了一个 $k$ ,  于是情况就比较微妙了 。</p>

<ol>
  <li>
    <p>一方面，当 $k \ll n$ 时，分片级联的性能好于原始办法。</p>
  </li>
  <li>
    <p>但另一方面，如果 $k$ 相对 $n$ 较大，那分片级联相比于原始算法就没有优势，甚至更慢。</p>
  </li>
  <li>
    <p>而在几乎所有的情况下，只要 $k$ 不是特别小，改进算法还是最快的，是快好几倍的<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> ：很明显，对于 $\text{log}N$ ,即使 $N$ 取一个 <code class="language-plaintext highlighter-rouge">u64</code> 能表示的最大值，也就是相当于 $k=64$ 的大小，因此只要稍微大一点的 $k$ 都会使得查询性能不如改进算法</p>
  </li>
</ol>

<p>我们可以通过一个图表把这个问题看得更清楚，取一个固定的 $N$ ，让 $k$ 增长，观察</p>

<ol>
  <li>原始做法-raw</li>
  <li>改进做法-best</li>
  <li>$f=2$ 的分片级联-fc2</li>
  <li>$f=4$ 的分片级联-fc4</li>
</ol>

<p>的运行时间的变化：</p>

<p><img src="/assets/img/fc/time_stats1.svg" alt="" /></p>

<p>我们发现当 $k$ 从一个较小的值增长的时候，原始算法的性能会变得有些优于 $f=4$ 的分片级联。</p>

<p><img src="/assets/img/fc/time_stats2.svg" alt="" /></p>

<p>但如果拉长 $k$ 的取值话，发现分片级联还是明显优于原始做法。</p>

<h2 id="实现">实现</h2>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.3/coll/src/frac_casc.rs">源代码</a></p>

<h3 id="数据结构">数据结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">T</span><span class="p">]],</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>
</code></pre></div></div>

<p>对于 $q$ 的二分查找返回的结果是,  $\text{min}({x \in L,\ x &gt;= q})$</p>

<h3 id="构建">构建</h3>

<p>分片级联，对于输入有一些动态时才能检查的条件：</p>

<ol>
  <li>$k &gt; 0$；</li>
  <li>输入的 $k$ 个列表每个列表都不为空且都是有序的；</li>
  <li>分片大小 $f &gt; 0$</li>
</ol>

<p>构建 M 时：</p>

<ol>
  <li>采用 merge-sort 里面的 merge 操作合并 $L_i$ 和 $M_{i+1}$ ；</li>
  <li>对于列表中重复的元素只保留一份，因为标准的二分搜索不会区分不同位置的重复元素，留着也没用；</li>
  <li>同时注意如果 $M_{i+1}$ 的长度不能恰好被分片 $f$ 整除，需要把最后的尾元素补上，这样使得所有的完整的或者不完整的分片都有一个代表，就是分片的最大值，简化了比较逻辑</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]])</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.is_sorted</span><span class="p">()));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">F</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="o">!</span><span class="n">i</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="nf">.is_sorted</span><span class="p">()));</span>

        <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">build_m</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">build_m</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">m</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[];</span> <span class="n">k</span><span class="p">];</span>

        <span class="cm">/* Init m_k*/</span>

        <span class="k">let</span> <span class="n">l_k</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">m_k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">l_k</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_k</span><span class="nf">.push</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/* on guard */</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">m_i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">m_i</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">m2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">m_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">m1</span> <span class="o">=</span>
                <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="n">F</span><span class="p">));</span>

            <span class="cm">/* merge two sorted vec */</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="nd">macro_rules!</span> <span class="n">nxt_j</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$j:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// end</span>
                    <span class="k">if</span> <span class="nv">$j</span> <span class="o">==</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nv">$j</span> <span class="o">+</span> <span class="n">F</span> <span class="o">&gt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nv">$j</span> <span class="o">+</span> <span class="n">F</span>
                    <span class="p">}</span>
                <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="cm">/* skip dup */</span>

                        <span class="k">let</span> <span class="n">dup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                            <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()));</span>

                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Err</span><span class="p">(</span><span class="n">l1</span><span class="nf">.len</span><span class="p">()),</span> <span class="n">j</span><span class="p">));</span>

                <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">m</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询">查询</h3>

<p>按照 Rust 的 API 风格，查找元素时用 <code class="language-plaintext highlighter-rouge">Result&lt;usize, usize&gt;</code> 类型区分相等的情况和最小大于的情况。</p>

<h4 id="查询-1">查询</h4>

<p>主流程：</p>

<ol>
  <li>在 <code class="language-plaintext highlighter-rouge">m[0]</code> 上执行二分查找，找到“拉链头”；</li>
  <li>然后在后续的 <code class="language-plaintext highlighter-rouge">m[1..m.len()]</code> 上“拉拉链”，在每一级上，都会在分片大小的范围内找到结果</li>
</ol>

<p>考虑重复元素的情况，实际上前面讲的“区分相等的情况和最小大于的情况”的说法并不严谨，实际 API 返回值的要求应该是<strong>相等和插入后保持有序两种情况</strong> ，这意味着：</p>

<ol>
  <li>如果存在重复的最小大于的元素，不能随便选一个返回它的索引位置，而是应该返回最左边的那一个；</li>
  <li>在极端的最坏情况下，这可能会拖累性能到线性</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">find</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.find_</span><span class="p">(</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">find_handle_approx_result</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">find_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">FindHandler</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="k">self</span><span class="py">.m</span><span class="nf">.len</span><span class="p">()];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span><span class="p">;</span>

        <span class="c1">// 1. assign res[0]</span>
        <span class="c1">//</span>
        <span class="c1">// 2. m_idx</span>
        <span class="c1">//</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">x</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Err</span><span class="p">(</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">());</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="k">self</span><span class="py">.m</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">elected</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">elected</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cand</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">cand</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cand</span><span class="p">]</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="n">cand</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cand</span><span class="p">]</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="n">cand</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">elected</span> <span class="o">=</span> <span class="n">cand</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">elected</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">handler</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">elected</span><span class="p">);</span>

            <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">elected</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">find_handle_approx_result</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">dup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">unpack_result!</span><span class="p">(</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>

                <span class="c1">// go back (the worst case down to O(nk))</span>
                <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">unpack_result!</span><span class="p">(</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>

                <span class="c1">// go forward (the worst case down to O(nk))</span>
                <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dup</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FindHandler</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
    <span class="nb">usize</span><span class="p">,</span>
    <span class="nb">usize</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="快速查询">快速查询</h4>

<p>如果不考虑对重复元素的插入顺序的情况，可以直接这样写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Ignore duplicated case</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">quick_find</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.find_</span><span class="p">(</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">quick_find_handle_approx_result</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">quick_find_handle_approx_result</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">match</span> <span class="n">k</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>
</code></pre></div></div>

<h2 id="后续">后续</h2>

<h3 id="动态">动态</h3>

<p>关于动态分片级联的问题，也就是目标数组被修改时的更新。</p>

<p>这将完全抛弃数组结构而采用经典地采用树型结构，就像前文介绍过的在 B+ 树的数组实现明显区别于和 TreeMap 实现一样，实现的具体细节将完全不同。</p>

<p>由于<a href="https://en.wikipedia.org/wiki/Fractional_cascading#Dynamic_fractional_cascading">介绍</a>的细节繁杂，也没有详细的示例，深入下去必然耗费大量时间，且已经偏离了主要介绍的内容，因此等需要的时候再来回顾吧。</p>

<h3 id="应用">应用</h3>

<p><a href="https://en.wikipedia.org/wiki/Fractional_cascading#Applications">计算几何方面的问题</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>假设元素类型也是和索引位置一样的类型 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>总感觉分片级联就像斐波那契堆一样，对复杂度采取逐级抵抗的办法，应该进行可以一些类比 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>两两取样也就是分片的大小为 $2$ ，当然也可以选择其他的分片大小 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>因为分片大小是 $2$ ，所以比较两项，如果分片大小是 $4$ 那就比较 $4$ 项 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>可以视作对应分片 $f=1$ 的情况，虽然此时耗费多一半的空间 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[本文主要参考 wiki ，对其中一些内容进行了拓展，对个别错误进行了修正。]]></summary></entry><entry><title type="html">分段树（Segment Tree）</title><link href="/algs/SegmentTree.html" rel="alternate" type="text/html" title="分段树（Segment Tree）" /><published>2023-04-10T00:00:00+08:00</published><updated>2023-04-10T00:00:00+08:00</updated><id>/algs/SegmentTree</id><content type="html" xml:base="/algs/SegmentTree.html"><![CDATA[<p>更常见的名字是<strong>线段树</strong>，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？</p>

<p>本文基本算是对 <a href="https://cp-algorithms.com/data_structures/segment_tree.html">cp-algorithms - Segment Tree</a> 的一个 Rust 实现版本的介绍。</p>

<h2 id="基础概念">基础概念</h2>

<p>分段树是用来解决数组上区间查询问题的数据结构。</p>

<p>它把数组代表的区间不断二分，直到区间小到只含有单个元素，把它们用二叉树的结构组织起来，顶点代表整个区间，它的左孩子和右孩子分别代表整个区间的左右两半，以此类推，直到叶子节点。</p>

<p>如<a href="https://cp-algorithms.com/data_structures/segment_tree.html#structure-of-the-segment-tree">原文这里</a>所示。</p>

<p>它非常好地体现了分治<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>思想，有了这样的数据结构后，当面对一个区间查询时，只需要在从根到叶子对树递归时把已有的局部区间的答案进行组合，就能得到最终答案。</p>

<h3 id="查询的复杂度">查询的复杂度</h3>

<p>可以证明查询过程中每一层最多访问 $4$ 个节点。</p>

<p>使用归纳法证明，初始条件是一个节点，符合。</p>

<p>假设上一层访问不超过 $4$ 个节点：</p>

<ol>
  <li>如果上一层只访问了两个或更少的节点，那么这一层最多访问 $4$ 个；</li>
  <li>如果上一层访问 $3$ 个或 $4$ 个节点，由于访问的区间是连续的，中间部分正好对应分段树的区间，会直接返回，因此只有边缘的左右两个节点可能会向下访问，这一层仍然最多访问 $4$ 个</li>
</ol>

<p>证毕。</p>

<p>因此查询的时间复杂度由树高决定，是 $O(\text{log}n)$ 。</p>

<h2 id="实现前瞻">实现前瞻</h2>

<p>作为树型结构自然就有数组和指针两种实现，而分段树可以很容易地使用数组实现<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，这让它看起来非常靠谱！</p>

<p>接下来我们主要讨论的就是线段树的<a href="https://github.com/minghu6/rust-minghu6/tree/v0.1.3/coll/src/segment_tree">数组实现</a>。</p>

<h2 id="树的布局">树的布局</h2>

<p>我们首先想到的就是水平布局，也就是按照完全二叉树的结构，依次放置每一层的节点，我们可以称之为 BFS 型布局。</p>

<h3 id="bfs-型">BFS 型</h3>

<p>BFS 型有一个很好的性质就是计算节点的左右孩子的位置非常简单，如果我们的数组编号从 $1$ 开始，那么根据完全二叉树的性质， $t[i]$ 节点的左孩子和右孩子分别为 $t[2i]$ 和 $t[2i+1]$ 。</p>

<p>可以很容易地证明这一点：</p>

<p>首先，已知高度为 $h$ 的满的完全二叉树有 $2^h - 1$ 个节点<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>，高度为 $h$ 的层有 $2^{h-1}$ 个节点。</p>

<p>假设 $t[i]$ 节点在树的 $h$ 层，同一层的前面包括它在内，有 $x$ 个节点，后面有 $y$ 个节点，那么显然有:</p>

\[\begin{array}{l}
i &amp;= 2^{h-1} - 1 + x &amp;\quad(1)\\
x+y &amp;= 2^{h-1} &amp;\quad (2)\\
\end{array}\]

<p>而它与左孩子的距离 $d$ 有 $d=y+2(x-1)+1$ ，利用 $(2)$ 式消解掉 $y$ ，得到 $d=2^{h-1} + x - 1 = i$ ，也就是 $t[i]$ 节点的左孩子距离为 $i$ ，右孩子紧邻左孩子，距离为 $i+1$ ，证毕。</p>

<p>如果我们的编号不从 1 开始，而是从 0 开始，那么有 $i’ = i-1$ ，带入 ${\large i_{\text{left}}} = 2i$ ，有 ${\large i ’_{\text{left}}}+1=2(i’+1)$  ，于是：</p>

\[\begin{array}{l}
{\large i ’_{\text{left}}} &amp;=2i'+1\\
{\large i ’_{\text{right}}} &amp;=2i’+2
\end{array}\]

<p>需要指出的是，虽然我们按照完全二叉树的结构排列节点，但<strong>分段树本身并不一定是完全二叉树，最后一层的节点并不是规律地从左开始分布</strong><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，而是按照本身的奇偶性规律排布，比如考虑 $6$ 个元素的分段树：$(6)-(3, 3)-(2, 1, 2, 1)$ 。</p>

<p>按照水平布局，分段树数组需要的节点数按照满的完全二叉树来说是 $2^h -1 = 2^{\lceil \text{log}_2 n \rceil} - 1 &lt; 2^{\lceil \text{log}_2 n\rceil} \leqslant 4n$ ，因此即使以 $1$ 为基，也只需要分配 $4n$ 大小的空间。</p>

<h3 id="dfs-型">DFS 型</h3>

<p>仔细考虑一下分段树的形状，发现它准确说应该是一棵<a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">满二叉树（full binary tree）</a>，而满二叉树有这样的性质，就是如果叶子节点数为 $i$ ，那么中间节点数就是 $i-1$ ，整棵树的节点数就是 $2i-1$ 。</p>

<p>这个性质不需要特别证明，它直接就是定义给出的，满二叉树的直接定义是节点要么没有孩子，要么有两个孩子。但它还有一个递归定义：</p>

<ol>
  <li>单节点是满二叉树；</li>
  <li>根的两个孩子都是满二叉树的二叉树是满二叉树</li>
</ol>

<p>这个递归定义也就是我们诱导推理的过程：</p>

<ol>
  <li>单节点的时候，叶子节点比中间节点数多 $1$ ；</li>
  <li>假设根的两个孩子都是满二叉树，那么左右孩子上的叶子节点数之和比中间结点数之和多 $2$ ，加上作为中间节点的根节点，于是整棵树的叶子节点仍然比中间节点多 $1$</li>
</ol>

<p>证毕。</p>

<p>根据满二叉树这个性质，我们可以发现，<strong>为长度为 $n$ 的数组建立的分段树确定地含有 $2n-1$ 个节点</strong> ，这么一看，BFS 型申请的 $4n$ 的空间实在有些浪费，于是有了内存节省布局的 DFS 型。</p>

<p>DFS 顾名思义是垂直布局，放置根节点后，先放置整棵左树，再放置整棵右树。不过单纯地垂直布局并不会节省空间，真正关键的是在垂直分布中，我们使用了满二叉树的布局而不是完全二叉树的布局，这是因为在树上遍历的过程中，我们知道节点所代表的范围区间，也就是节点所代表的子树的叶子节点数，因此我们可以计算出整棵子树的大小。</p>

<p>这样我们就可以直接计算出左右孩子的位置，对节点 $t[i]$ ，设左孩子对应区间长度为 $l$ ，则它的左右孩子分别为 $t[i+1]$ 和 $t[i+2l-1 + 1]=t[i+2l]$ 。</p>

<p>这样即使仍然基 $1$ ，也只需要申请 $2n$ 大小的空间，比起 BFS 型整整节省了一半的空间！</p>

<p>全面地比较这两型布局：</p>

<p>时间性能上，由于我们的访问是逐层进行的，BFS 的分层布局使得左右两个孩子紧邻，有更好地局部性，但毕竟仍然是在同一个数组上访问，差距也大不到哪儿去，事实上经过一个简单测试，发现两型的性能几乎没有区别；</p>

<p>空间性能上，DFS 型完胜，BFS double 了空间占用，太差了；</p>

<p>易用性上，BFS 是普通人都能想到的，左右孩子的位置也很简单，不过 DFS 型经过我的讲解也是非常的简单易懂，两者没有明显差别。</p>

<p>综合以上比较，更推荐 DFS 型作为默认地数组上的默认布局。</p>

<h2 id="范式的描述">范式的描述</h2>

<p>我们尝试尽量用 Rust 的抽象机制勉强算是强大的伸缩性，把本篇涉及的所有概念这些可选项揉到一起。</p>

<h3 id="布局和游标">布局和游标</h3>

<p>为了描述分段树的布局，我们先用一个结构统一保存树上遍历需要的索引信息：分段数组的索引 <code class="language-plaintext highlighter-rouge">i</code> 和对应原数组的区间<code class="language-plaintext highlighter-rouge">[tl, tr]</code> ：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// (i, tl, tr)</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Cursor</span> <span class="p">{</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tl</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是可以定义树形布局的抽象：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TreeLayout</span><span class="p">:</span> <span class="nn">private</span><span class="p">::</span><span class="n">Sealed</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">private</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealed</span> <span class="p">{}</span>

    <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="k">super</span><span class="p">::</span><span class="n">BFS</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="k">super</span><span class="p">::</span><span class="n">DFS</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用了继承私有模块的公共 Trait 来封装暴露给下游的公共 Trait 的技巧，因为我们定义并暴露出 <code class="language-plaintext highlighter-rouge">TreeLayout</code> 只是为了允许用户自由选择他们需要的线段树布局，而并不期望用户实现它。</p>

<p>对于 BFS 和 DFS 两型：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TreeLayout</span> <span class="k">for</span> <span class="n">BFS</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">4</span> <span class="o">*</span> <span class="n">cap</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TreeLayout</span> <span class="k">for</span> <span class="n">DFS</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// left_i + 2(n(left)) - 1</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nd">tm!</span><span class="p">(</span><span class="n">c</span><span class="py">.tl</span><span class="p">,</span> <span class="n">c</span><span class="py">.tr</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="分段树">分段树</h3>

<p>此时我们可以初步地引出我们分段树的结构：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span> <span class="o">=</span> <span class="n">DFS</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="n">_note</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Count</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">combine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
    <span class="cd">/// identity element: any stats combine with e results itself</span>
    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>泛型 <code class="language-plaintext highlighter-rouge">T</code> 代表了分段树储存的对数组区间的统计信息，泛型 <code class="language-plaintext highlighter-rouge">C</code> 代表了统计方法，它提供了一个归并两个统计数据的方法和一个返回幺元的方法。</p>

<p>借着是分段树的创建，可一窥树上遍历的基本方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="nf">.is_empty</span><span class="p">());</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span> <span class="nn">L</span><span class="p">::</span><span class="nf">size</span><span class="p">(</span><span class="n">raw</span><span class="nf">.len</span><span class="p">())];</span>

        <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nn">Cursor</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="n">raw</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">root</span><span class="p">,</span>
            <span class="n">_note</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="n">build</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">],</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="py">.tl</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.raw_into_stats</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.i</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Cursor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="n">raw_len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">tl</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="n">raw_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tl</span> <span class="o">==</span> <span class="k">self</span><span class="py">.tr</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_matched</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tl</span> <span class="o">==</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.tr</span> <span class="o">==</span> <span class="n">r</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">godown_left</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="nn">L</span><span class="p">::</span><span class="nf">left_i</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">tl</span><span class="p">:</span> <span class="k">self</span><span class="py">.tl</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="nd">tm!</span><span class="p">(</span><span class="k">self</span><span class="py">.tl</span><span class="p">,</span> <span class="k">self</span><span class="py">.tr</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">godown_right</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="nn">L</span><span class="p">::</span><span class="nf">right_i</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">tl</span><span class="p">:</span> <span class="nd">tm!</span><span class="p">(</span><span class="k">self</span><span class="py">.tl</span><span class="p">,</span> <span class="k">self</span><span class="py">.tr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="k">self</span><span class="py">.tr</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">tm</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tl:expr</span><span class="p">,</span> <span class="nv">$tr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$tl</span> <span class="o">+</span> <span class="nv">$tr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">left</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$c:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$c</span><span class="py">.godown_left</span><span class="p">::</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">right</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$c:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$c</span><span class="py">.godown_right</span><span class="p">::</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里涉及了一个 <code class="language-plaintext highlighter-rouge">RawIntoStats</code> 的 Trait ，它提供了原始数组上的元素针对某种统计方法需要的某个统计类型进行转换的抽象：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询">查询</h3>

<p>尝试划分按照分段树的区间进行划分，直到一个错误的区间范围，这时直接返回幺元，比起检查返回值要简洁很多</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span><span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="p">),</span> <span class="k">self</span><span class="py">.root</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">,</span> <span class="n">r</span><span class="p">)),</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">((</span><span class="nf">max</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// -&gt; (l, r)</span>
<span class="nd">macro_rules!</span> <span class="n">parse_range</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$range:expr</span><span class="p">,</span> <span class="nv">$root:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nn">Bound</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="nv">$range</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">l</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">r</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.end_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"range upper is invalid (=0)"</span><span class="p">);</span>
                <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">}</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="nv">$root</span><span class="py">.tr</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新">更新</h3>

<p>如果原数组的某个值发生了更新，那么对应地，从分段树的根一直到该值所在的叶子，整条路径也需要更新：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.root.tr</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_val</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">assoc_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span> <span class="n">ti</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">clf</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">crh</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">clf</span><span class="py">.tr</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">new_val</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="n">crh</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">new_val</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">clf</span><span class="py">.i</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">crh</span><span class="py">.i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="经典问题">经典问题</h2>

<p>我们将会层层递进地介绍一些适用于上述分段树范式的经典问题。</p>

<p>但是在此之前，先介绍下一个方便对为数字类型批量实现 <code class="language-plaintext highlighter-rouge">RawIntoStats</code> 的辅助宏。出于一些考虑，Rust 并没有把数字，包括整型和浮点数型单独抽象出来，而是针对具体地实类型单独实现方法。不过它们也没有真的手写这些代码，也是用宏来批量实现的<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>，正如我前面某篇博文里吐槽过的，凡是 Rust 自己都觉得不方便而开发内部辅助结构的，下游用户一定会重新造轮子，一个它内部工具的复制品。</p>

<h3 id="辅助宏">辅助宏</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_raw_into_stats</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">monomorphic</span> <span class="p">|</span> <span class="nv">$struct:ident</span><span class="p">,</span> <span class="nv">$for_ty:ty</span><span class="p">,</span> <span class="nv">$stats_ty:ty</span> <span class="p">{</span> <span class="nv">$fn:item</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="nv">$struct</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nv">$stats_ty</span><span class="p">;</span>

            <span class="nv">$fn</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$struct:ident</span><span class="p">,</span> <span class="nv">$for_ty:ty</span><span class="p">,</span> <span class="nv">$stats_ty:ty</span> <span class="p">{</span> <span class="nv">$fn:item</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="nv">$struct</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nv">$stats_ty</span><span class="p">;</span>

            <span class="nv">$fn</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="n">all</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">int</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">float</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">int</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="n">sint</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">uint</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">float</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">f32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">f64</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">uint</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u128</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u64</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">usize</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u16</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u8</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="n">sint</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i128</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i64</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">isize</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i16</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i8</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个用于数字类型批量实现的辅助宏起始可以广泛地使用。</p>

<h3 id="简单单值">简单单值</h3>

<p>最简单的情况，就是统计类型和原数组值类型一致。</p>

<p>比如，查询原数组上给定区间范围的元素和。</p>

<p>这非常简单：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="n">l</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">+</span> <span class="n">r</span><span class="nf">.borrow</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">T</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="p">(</span><span class="n">sum_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">sum_stats</span> <span class="p">|</span> <span class="n">all</span><span class="p">);</span>
</code></pre></div></div>

<p>类似地，求解最大值，最大公约数，最小公倍数等等，都是类似的，这里不再赘述。</p>

<h3 id="复合类型">复合类型</h3>

<p>稍微复杂一点，统计给定区间的最大值和出现次数。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">Min&lt;T&gt;</code> Trait 是为所有数字类型实现的获取其最小值的抽象，相当于 <code class="language-plaintext highlighter-rouge">T::MIN</code> ,</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">MaxStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">MaxStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">l</span><span class="na">.0</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">l</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">l</span><span class="na">.1</span> <span class="o">+</span> <span class="n">r</span><span class="na">.1</span><span class="p">),</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">as</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">min</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">min</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="p">(</span><span class="n">max_stats_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">MaxStats</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="p">(</span><span class="nv">$for_ty</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">min</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">Min</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">min</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$for_ty</span> <span class="p">{</span>
                <span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span><span class="p">::</span><span class="n">MIN</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">min</span> <span class="p">|</span> <span class="n">all</span><span class="p">);</span>
<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">max_stats_stats</span> <span class="p">|</span> <span class="nb">int</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="排名位置">排名位置</h3>

<p>比如，统计 $0$ 的个数，并查找第 $k$ 个 $0$ 的位置</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">ZeroStats</span><span class="p">;</span>


<span class="k">impl</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">ZeroStats</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="o">*</span><span class="n">r</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">zero_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">monomorphic</span><span class="p">|</span><span class="n">ZeroStats</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>设计上，特殊的方法放到具体 Trait 上，下同。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ZeroStats</span> <span class="p">{</span>
    <span class="cd">/// Start from 0</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">find_nth</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">tree</span><span class="py">.root</span><span class="p">]</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">find_nth_</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">c</span><span class="py">.tl</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">clf</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">crh</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="n">clf</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tree</span><span class="p">[</span><span class="n">clf</span><span class="p">],</span> <span class="n">crh</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>类似地还有查找给定区间里的元素位置，使得它的前缀和不小于给定值。</p>

<h3 id="findfirst">FindFirst</h3>

<p>查找给定区间里第一个符合条件的元素的位置。</p>

<p>比如，查找给定区间里第一个严格大于给定值的值的位置。</p>

<p>首先构建一个统计最大值的分段树：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">l</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="p">,</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="p">,</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">max_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">max_stats</span> <span class="p">|</span> <span class="nb">int</span><span class="p">);</span>
</code></pre></div></div>

<p>在此基础上实现 findfirst 类型的问题：</p>

<p>从根开始下降，直到区间范围在给定的范围之内，这是 <code class="language-plaintext highlighter-rouge">query_first_gt_1</code> 做的事情，然后在这个区间里做<a href="#查找排名位置">前一个小节</a>里那样的查询。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">query_first_gt</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">query_first_gt_1</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// left or right</span>
        <span class="k">if</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">||</span> <span class="n">c</span><span class="py">.tr</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// inner</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">c</span><span class="py">.tr</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// cross</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// avoid bound overflow</span>
            <span class="k">let</span> <span class="n">left_res</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">left_res</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">left_res</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">query_first_gt_2</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">c</span><span class="py">.tl</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最大和的子分段">最大和的子分段</h3>

<p>这是一个特定的，但是复杂的问题：查找给定区间范围内的一个子区间，使得有区间里所有元素之和最大。</p>

<p>解决这个问题的构思还是比较巧妙的，利用一个复杂的统计结构，分而治之地分而治之，这个结构包含 4 个成员：</p>

<ol>
  <li>pref，最大前缀和；</li>
  <li>suff，最大后缀和；</li>
  <li>sum，区间元素之和；</li>
  <li>ans，区间答案，也就是最大的子区间和</li>
</ol>

<p>区间答案就是由三个后选值：</p>

<ol>
  <li>左区间的答案；</li>
  <li>右区间的答案；</li>
  <li>左区间最大后缀和 + 右区间最大前缀和</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone,</span> <span class="nd">Copy,</span> <span class="nd">Debug,</span> <span class="nd">Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// total sum of the segment</span>
    <span class="k">pub</span> <span class="n">sum</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// max prefix sum</span>
    <span class="k">pub</span> <span class="n">pref</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// max suffix sum</span>
    <span class="k">pub</span> <span class="n">suff</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// query answer of max sum of the segment</span>
    <span class="k">pub</span> <span class="n">ans</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">SubSegMaxSum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="n">SubSegMaxSumStats</span> <span class="p">{</span>
            <span class="n">sum</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">l</span><span class="py">.sum</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.sum</span><span class="p">,</span>
            <span class="n">pref</span><span class="p">:</span> <span class="nf">max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.pref</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.sum</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.pref</span><span class="p">))</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">suff</span><span class="p">:</span> <span class="nf">max</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.suff</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.sum</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.suff</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">ans</span><span class="p">:</span> <span class="nd">max!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.ans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.ans</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.suff</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.pref</span><span class="p">))</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">max</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$val:expr</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="nv">$</span><span class="p">(</span><span class="nv">$val</span><span class="p">),</span><span class="o">+</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">sub_seg_max_sum_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">SubSegMaxSum</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">non_neg</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="p">);</span>

                <span class="n">SubSegMaxSumStats</span> <span class="p">{</span>
                    <span class="n">sum</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span>
                    <span class="n">pref</span><span class="p">:</span> <span class="n">non_neg</span><span class="p">,</span>
                    <span class="n">suff</span><span class="p">:</span> <span class="n">non_neg</span><span class="p">,</span>
                    <span class="n">ans</span><span class="p">:</span> <span class="n">non_neg</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">sub_seg_max_sum_stats</span> <span class="p">|</span> <span class="n">sint</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="保存整个子数组">保存整个子数组</h2>

<p>有一种分段树是在每个点上保存原数组对应区间里的所有值。</p>

<p>如果保存的子数组是用有序向量存储的，那么这个分段树实际上是在空间上还原了归并排序的整个过程，因此它也可以叫做 “<strong>Merge Sort Tree</strong>” ，可以在上面执行一系列查询的操作。</p>

<p>存储有序向量对原数组的元素修改时成本较高，可以改为经典的以 TreeMap 为基础的 multiset <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>，</p>

<h3 id="findfirst-1">FindFirst</h3>

<p>分段树本身的查询复杂度是 $O(\text{log}n)$ ，有序向量或者 multiset 上查询的时间复杂度也是 $O(\text{log}n)$ ，因此总的时间复杂度是 $O(\text{log}^2n)$ 。</p>

<h3 id="分片级联">分片级联</h3>

<p>可以考虑使用 <a href="/algs/FractionalCascading.html">分片级联</a> 的思想来加速对 findfirst 问题查询的过程。</p>

<p>这样的话，在树的构建过程中，不只是存储整个子数组，而是分片级联里面的 $M$  列表，区别是原来是级联下一级，所以存储下一级的索引，而现在要级联左右孩子，需要存储左右孩子上的索引。</p>

<p>另外，由于需要保存整个子数组，所以只级联，不分片<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup> 。</p>

<p>于是查询的过程就变为，在根节点上进行一次二分查找，然后做最多树高度的拉链。</p>

<p>以 $3$ 倍的空间为代价，让查询的时间复杂度降到了 $O(\text{log}n)$ 。</p>

<h2 id="区间更新">区间更新</h2>

<p>分段树支持一种在给定区间上快速地批量更新元素<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup>的方法。</p>

<p>这个区间更新的方法利用了“惰性更新”的思想，不妨以 update-add ，也就是批量增加一个固定值为例：</p>

<h3 id="惰性方法">惰性方法<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">10</a></sup></h3>

<p>在更新的时候，只更新到给定区间覆盖到的分段树上的区间。</p>

<p>比如对于分段树 $t[0..7]$ ，更新区间 $[3..7]$ ，则惰性更新的路径为：</p>

\[\begin{array}{l}
t[0..7] &amp; \rightarrow [0..3] \rightarrow [2..3] \rightarrow [3]\\
        &amp; \rightarrow [4..7]
\end{array}\]

<p>这就需要在分段树的区间上额外存储惰性更新的值，为了不影响既有结构，我们用额外的一个辅助数组来存储它：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_updater</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">UpdaterAdd</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()],</span> <span class="n">PhantomData</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>惰性更新的过程与一般得分段树的查询过程一样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">AddAssign</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">assoc</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
        <span class="n">addend</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">addend</span><span class="p">,</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">assoc_</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">addend</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">addend</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.propagate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

            <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">)),</span>
                <span class="n">addend</span><span class="nf">.clone</span><span class="p">(),</span>
                <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
            <span class="p">);</span>
            <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span>
                <span class="n">addend</span><span class="p">,</span>
                <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
            <span class="p">);</span>

            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)],</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">is_marked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Lazy propagation</span>
    <span class="k">fn</span> <span class="nf">propagate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_marked</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>

            <span class="n">tree</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>

            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>惰性更新只有当查询到某一层时，才会把更新推到分段树的下一层：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">AddAssign</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="p">{</span>
        <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query_</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.propagate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

            <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
                    <span class="n">tree</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">)),</span>
                    <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
                    <span class="n">tree</span><span class="p">,</span>
                    <span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span>
                    <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="其他更新">其他更新</h3>

<p>对于给定区间的批量赋值，更加简单，只需要每个需要更新的区间存储一个标记位。</p>

<h2 id="推广到更高维度">推广到更高维度<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup></h2>

<p>简单的二维分段树基本按照先构建第一个维度，然后在第一个维度下降到叶子时再构建第二个维度。</p>

<h2 id="持久化版本">持久化版本</h2>

<p>谈到持久化版本，就是树型结构，而且是指针构造的树型结构。</p>

<p>分段树自然很容易做成持久化版本，更新的时候直接复制更新路径就可以。</p>

<p>但是需要从本来的数组实现转为指针实现，这让这个问题变得有点儿鸡肋，因为性能损失实在有些不可接受。</p>

<h2 id="动态分段">动态分段</h2>

<p>如果不能一次性地构建完整棵分段树，可以进行动态分段，只有当查询到某个区间的节点时再进行创建。</p>

<p>但是这也假设了指针实现版本的分段树，同样鸡肋。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>你不知道主语义是<strong>线</strong>状还是分<strong>段</strong> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>divide and rule <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>如果原数组的长度是确定的，那么对应的线段树也是确定的 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>由等比数列前项和 $S_n = a_1{\Large \frac{1-q^n}{1-q}} = 1·{\Large \frac{1-2^n}{1-2}} = 2^n - 1$ 可推 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>只要数组的大小不是 $2$ 的幂 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>这实在有些，说句文言，脱裤子放屁，还不如想办法用 Trait 数字类型给抽象出来 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>bag <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>或者说分片大小为 $1$ <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>比如批量地增加一个值，或者批量地赋予一个值 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Lazy propagation <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>树套树 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[更常见的名字是线段树，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦1的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？ 你不知道主语义是线状还是分段 &#8617;]]></summary></entry><entry><title type="html">最大公约数（Great Common Divisor）</title><link href="/algs/GCD.html" rel="alternate" type="text/html" title="最大公约数（Great Common Divisor）" /><published>2023-04-06T00:00:00+08:00</published><updated>2023-04-06T00:00:00+08:00</updated><id>/algs/GCD</id><content type="html" xml:base="/algs/GCD.html"><![CDATA[<p>假设对于非负整数，$a$ ,  $b$ ，求它们的最大公约数 $\text{gcd}(a, b)$ ，以下简写作 $g$ 。</p>

<p>数学上，最大公约数只有对两个非零整数才有意义，但是一般从实现的方面，规定：</p>

<ol>
  <li>$\text{gcd}(0, b) = a$ ,  $\text{gcd}(a, 0) = a$</li>
  <li>$\text{gcd}(0, 0) = 0$</li>
</ol>

<h2 id="辗转相减">辗转相减</h2>

<p>也是原始的欧几里得（Euclidean）算法。</p>

<p>根据定义有：</p>

\[\begin{array}{l}
a &amp;= ng \\
b &amp;= mg
\end{array}\]

<p>$\text{n}$ ,  $\text{m}$ 互质，对于 $a \neq b$ 的情况，不失一般性地假设 $a &gt; b$ ，也就是 $n &gt; m$ ，这样的话，$a-b = (n - m) g$ ，$b=mg$ 也有公约数 $g$<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> 。</p>

<p>这样取 $a=\text{max}(a-b, b)$ ,  $b=\text{min}(a-b,b)$ ，也就是如果 $n-m &gt; m$ 仍然成立就继续减，否则就是交换 $a$ ,  $b$ 的位置，在这个过程中  $n &gt; \text{max}(n-m,m) = \text{max}(n, m) &gt; \text{max}(n-m, m)$ 系数的上限不断下降，直到 $a=b$ 。</p>

<p>此时也有 $a=g$ ，$b=g$，此时就得出了最大公约数 $g$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="k">while</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">a</span> <span class="o">-=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></div>

<h2 id="辗转取余">辗转取余</h2>

<p>辗转取余是原始欧几里得算法的变种。</p>

<p>回过去观察相减的过程，如果 $a=qb+r, (q \geqslant 0,\ r &lt; b)$ ,  每次 $a-b$ 就是 $q-1$ ，直到 $q=0$ ，因为 $a=r&lt;b$ 然后就交换 $a,b$ 位置，可以通过取余的操作一步到位的完成，$a \% b$ 直接得到 $r$ , 然后和 $b$ ，即使开始时 $a &lt; b$ , 也不影响 $a\%b$ 的结果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></div>

<p>从实践上看，不考虑特殊指令优化的情况下，这种方法的效率是最佳的。</p>

<h2 id="拓展-gcd">拓展 GCD</h2>

<p>拓展 gcd 是在求解最大公约数的同时求解出一组解 $(x,y)$ 使得 $ax+by = \text{gcd}(a,b)$ <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="递归">递归</h3>

<p>通过递归的方式(辗转取余)求解是最容易理解的实现：</p>

\[\begin{array}{l}
g &amp;= a_0x_0 + b_0y_0 \\
  &amp;= a_1x_1+b_1y_1   \\
  &amp;= b_0x_1 + (a_0-\lfloor \frac{a_0}{b_0} \rfloor b_0) y_1\\
  &amp;= a_0y_1 + b_0(x_1 - \lfloor \frac{a_0}{b_0} \rfloor y1)
\end{array}\]

<p>按照对应项系数相等的方法，得到一组解：</p>

\[\begin{array}{l}
x_0 &amp;= y_1 \\
y_0 &amp;= x_1-\lfloor \frac{a_0}{b_0} \rfloor b_0y_1\\
    &amp;= x_1-\lfloor \frac{a_0}{b_0} \rfloor b_0x_0
\end{array}\]

<p>最后推到 $a_n=b, b_n=0$ 时，$g = b = 0x + 1b$ , 也就是取 $x_n = 0, y_n=1$ ，</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ext_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ext_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="展开">展开</h2>

<p>展开版本来源于 <a href="https://cp-algorithms.com/algebra/extended-euclid-algorithm.html#algorithm">cp-algorithms</a> ，你说我完全理解，我说我完全不理解！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ext_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>  
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span>
    
    <span class="k">while</span> <span class="n">b1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">b1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">x1</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span><span class="n">q</span> <span class="o">*</span> <span class="n">y1</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">,</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">b1</span>
    
    <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>但是后面可以发现，实际上应该有 $\text{gcd}(a-b, b)=\text{gcd}(a,b)$ 但是我们不能证明它 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>显然对于非零的$a,b$，$x, y$ 应该是一正一负两个整数 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[假设对于非负整数，$a$ , $b$ ，求它们的最大公约数 $\text{gcd}(a, b)$ ，以下简写作 $g$ 。]]></summary></entry><entry><title type="html">0685 - Redundant Connection II</title><link href="/oth/LeetCode0685.html" rel="alternate" type="text/html" title="0685 - Redundant Connection II" /><published>2023-03-31T00:00:00+08:00</published><updated>2023-03-31T00:00:00+08:00</updated><id>/oth/LeetCode0685</id><content type="html" xml:base="/oth/LeetCode0685.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/redundant-connection-ii/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>这题说难不难，没有复杂的数据结构和算法，但是情况比较繁琐细致，可以说非常贴近实际情况了。</p>

<p>具体来说，这个题的破题的关键在于搞清楚一棵有向树，多了一条边后，会形成什么样的情况。这不是一次就能全想清楚的 ，在代码失败了几次后，我们总结出三种情况：</p>

<ol>
  <li>形成双头节点（a-&gt;b, c-&gt;b, b就是双头节点）</li>
  <li>形成循环（a-&gt;b, b-&gt;c, c-&gt;a）</li>
  <li>形成带双头节点的环（a-&gt;b, b-&gt;c, c-&gt;a, d-&gt;b）</li>
</ol>

<p>双头节点容易检测出来，循环也可以检测出来，但是如何选择删除的边值得考虑：前两种情况都是删除最后的边即可，但第三种情况必须删除双头节点在环上的边，而不管它的顺序，这样才能同时消除环和双头节点。这是本题繁琐的地方。</p>

<h2 id="解1-一般图">解1： 一般图</h2>

<h3 id="思路">思路</h3>

<p>按照一般图的做法，不管三七二十一，先根据输入建立邻接表，以及反向引用的表。</p>

<p>这样的话，首先在反向引用表建立的过程，就能检出双头节点，如果它存在的话；</p>

<p>然后可以根据出度与入度，判断双头节点是否有在环上的边，在检测出度入度的时候要单独考虑两个点的环的情况；</p>

<p>最后检出环上边，返回最后一条。</p>

<h3 id="python-实现">Python 实现</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="c1"># O(n)
</span><span class="k">def</span> <span class="nf">findRedundantDirectedConnection</span><span class="p">(</span><span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">vmap</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># vertice map
</span>    <span class="n">rvmap</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># recersed vertice map
</span>
    <span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
    <span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
        <span class="n">Ein1</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Ein2</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Ein1</span>
    <span class="n">start</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">end</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># O(E)
</span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">vmap</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>

        <span class="k">if</span> <span class="n">rvmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Ein2</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rvmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Ein2</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">outd</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">vmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">def</span> <span class="nf">ind</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">rvmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="n">start2</span> <span class="o">=</span> <span class="n">rvmap</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">vmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">start2</span> <span class="ow">in</span> <span class="n">vmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">start2</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ind</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">outd</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">start2</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ind</span><span class="p">(</span><span class="n">start2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">outd</span><span class="p">(</span><span class="n">start2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>

        <span class="c1"># then anyway, use the latter (no cycle)
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]</span>

    <span class="c1"># Exact one circle structure
</span>    <span class="n">cirset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_circle_v</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visset</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">cirset</span>

        <span class="n">visset</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Noncircle
</span>            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">visset</span><span class="p">:</span>
                    <span class="n">cirset</span> <span class="o">=</span> <span class="n">visset</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_circle_v</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visset</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>

            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vmap</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">is_circle_v</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">cirset</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cirset</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>



<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]]),</span>
        <span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span>
        <span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span>
        <span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">output</span><span class="p">,</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">findRedundantDirectedConnection</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="n">output</span><span class="p">:</span>
            <span class="k">raise</span> <span class="sa">f</span><span class="s">'expect </span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s"> found </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s">'</span>

    <span class="n">findRedundantDirectedConnection</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
</code></pre></div></div>

<h2 id="解2-并查集反引用表">解2： 并查集<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>+反引用表</h2>

<h3 id="思路-1">思路</h3>

<p>使用并查集辅助是一个更普遍的，更规整化的思路，但对于有向树来说，单靠并查集也不能直接找到环，而并查集的路径压缩也会干扰对双头节点的判断，因此我们还需要一个单独的反向引用的表来维护直接父节点的信息。</p>

<p>除此之外，我们通过一个巧妙的构思，可以 One Pass 地求出需要的双头节点和环的信息：</p>

<ol>
  <li>
    <p>只需要当发现双头节点的时候，跳过去，不进行 Union ，相当于删除双头节点<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的两条边里顺序靠后的那一条，在这种情况下如果仍然发现有一条边的两个点在并查集里有一样的根，那么这条边就是环上的一条边，而且是环上顺序最后的一条边<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>；</p>
  </li>
  <li>
    <p>这样当我们通过反引用表找到了双头节点，并通过反引用表与并查集的配合找到了环上最后的边的时候，甚至可以提前退出循环，都不需要读完全部的边</p>
  </li>
</ol>

<p>根据双头节点和环的信息最后输出：</p>

<ol>
  <li>没发现双头节点。那必然只有环，直接输出环上最后一条边即可；</li>
  <li>没发现环。可能有两种，都是输出我们保存的双头节点顺序靠后的边即可：
    <ol>
      <li>有一个环，但是也是双头节点顺序靠后的一条边，因为跳过，所以没发现</li>
      <li>根本没有环</li>
    </ol>
  </li>
  <li>有双头节点但也发现了环。这说明双头节点顺序靠后的边不在环上，因此我们从反引用表里就可以得到双头节点在环上的边。</li>
</ol>

<h3 id="rust-实现">Rust 实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// improved edition after read other solutions</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">resolve_better</span><span class="p">(</span><span class="n">edges</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Aux</span> <span class="p">{</span>
        <span class="n">ds</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Aux</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">ds</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">cap</span><span class="p">],</span>
                <span class="n">p</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">cap</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.ds</span><span class="p">[</span><span class="n">v</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>

            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">v</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.ds</span><span class="p">[</span><span class="n">v</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

                <span class="k">self</span><span class="py">.ds</span><span class="p">[</span><span class="n">v</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cd">/// Ignore rank/height compare to save space as we have compressed the path.</span>
        <span class="nd">#[inline(always)]</span>
        <span class="k">fn</span> <span class="k">union</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">u_root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">v_root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">u_root</span> <span class="o">==</span> <span class="n">v_root</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(());</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="py">.ds</span><span class="p">[</span><span class="n">v_root</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_root</span><span class="p">;</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>

        <span class="nd">#[inline(always)]</span>
        <span class="k">fn</span> <span class="nf">direct_find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.p</span><span class="p">[</span><span class="n">v</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="nd">#[inline(always)]</span>
        <span class="k">fn</span> <span class="nf">direct_union</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.p</span><span class="p">[</span><span class="n">v</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">aux</span> <span class="o">=</span> <span class="nn">Aux</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">edges</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">double_head_cand</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cycle_cand</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">e</span> <span class="k">in</span> <span class="n">edges</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="c1">// found double head</span>
        <span class="k">if</span> <span class="n">aux</span><span class="nf">.direct_find</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">double_head_cand</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">aux</span><span class="nf">.direct_union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="c1">// found cycle (double head case has been excluded)</span>
        <span class="k">if</span> <span class="n">aux</span><span class="nf">.union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cycle_cand</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">double_head_cand</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cycle_cand</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">double_head_cand</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">cycle_cand</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 1. the last double head edge cover the cycle edge.</span>
    <span class="c1">// 2. no cycle edge.</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">cycle_cand</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">double_head_cand</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">double_head_cand</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">aux</span><span class="nf">.direct_find</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">unreachable!</span><span class="p">()</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sample</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="p">(</span><span class="nd">vec!</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
        <span class="p">(</span><span class="nd">vec!</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="p">(</span><span class="nd">vec!</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="p">(</span><span class="nd">vec!</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="p">];</span>

    <span class="k">let</span> <span class="n">norm_sample</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">sample</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">input</span><span class="p">,</span> <span class="n">expect</span><span class="p">)|</span>
        <span class="p">(</span>
            <span class="n">input</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">arr</span><span class="p">|</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span><span class="n">arr</span><span class="nf">.into_iter</span><span class="p">()))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;&gt;</span><span class="p">(),</span>

            <span class="nn">Vec</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span>
                <span class="n">expect</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">expect</span><span class="p">)</span> <span class="k">in</span> <span class="n">norm_sample</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">resolve_better</span><span class="p">(</span><span class="n">edges</span><span class="nf">.clone</span><span class="p">()),</span> <span class="n">expect</span><span class="p">,);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里对并查集的维护没有根据树的大小或者树高来选择合并的顺序，这主要是考虑到路径压缩已经足够优化，按照经验，再维护并查集树的平衡未必有明显的好处，相比花费额外的 $O(\text{n})$ 的空间<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> ，并不值当。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>有很多别名：UnionFind, MergeFind, Disjoint Set, Disjoint Set Union … <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>如果有双头节点的话 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>排除了双头节点的情况，也就是环上最后一条边一定是符合有向环的顺序的 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>相当于原来一半的空间花费 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">加速 Rust 构建</title><link href="/lang/SpeedupRustBuilding.html" rel="alternate" type="text/html" title="加速 Rust 构建" /><published>2023-03-22T00:00:00+08:00</published><updated>2023-03-22T00:00:00+08:00</updated><id>/lang/SpeedupRustBuilding</id><content type="html" xml:base="/lang/SpeedupRustBuilding.html"><![CDATA[<p>阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow</p>

<p>总结了加速的注意事项：</p>

<ol>
  <li>拆分过大的 crate ，一个基本编译单元至少是一个 crate，拆分 crate 可以利用多核优势</li>
  <li>检查不必要的依赖，某些依赖可能会大幅拖慢编译时间</li>
  <li>避免不必要的多态，缩减编译时间</li>
  <li>为 release 也开启增量编译 <code class="language-plaintext highlighter-rouge">incremental = true</code> ，这会让cold build 慢一点，但是大幅加速 hot build，</li>
  <li>是对于被工具压缩的 crate，debug 策略会非常慢，需要对这些包<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides">单独设置 debug 策略</a></li>
</ol>

<p>​</p>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow]]></summary></entry><entry><title type="html">基于前缀树的持久化向量（TrieVec）</title><link href="/algs/TrieVec.html" rel="alternate" type="text/html" title="基于前缀树的持久化向量（TrieVec）" /><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><id>/algs/TrieVec</id><content type="html" xml:base="/algs/TrieVec.html"><![CDATA[<p>在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下<a href="./SpeedupRustBuilding">另篇关于降低构建时间的笔记</a>。</p>

<h2 id="前言">前言</h2>

<p>本篇作为一个阶段性的总结篇，介绍一个基于前缀树（Trie）的持久化向量（Vector）的实现<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ，以下用 TrieVec 简称。</p>

<p>一方面，Vector 作为函数式编程语言里的允许随机读写的数据结构，本身有很重要的意义，没有它，传统的用类 C 描述的算法就无法落地；</p>

<p>另一方面，讲到持久化数据结构，其实大部分都已涉及，只有持久化向量比较陌生并且比较复杂，有必要专门看一下；</p>

<p>最后，在看这个实现的过程中，会发现这是一个总体概念陌生但局部细节熟悉的数据结构，它可以串起之前介绍过的诸多数据结构，不管是结构特点、设计方案还是实现方法，是一个合适的阶段尾声。</p>

<h2 id="概念基础">概念基础</h2>

<p>TrieVec 本质上就像我们在<a href="/algs/DaryHeap.html">多叉堆</a>上那样的做法，只不过多叉堆建立在数组上，而 TrieVec 则以树的的形式组织。</p>

<p>比如对于一棵节点数宽度为 $2$ ，也就是 $2^2 = 4$ 阶的树，访问 idx = 54</p>

\[\begin{array}{l}
54 &amp;=\underbrace{11}\ \underbrace{01}\ \underbrace{10}\\
&amp;=\ \ \ 3\quad\ \ \ 1\quad\quad 2
\end{array}\]

<p>情况如下图：</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_exp.svg" width="65%" /></div>

<p>这要求树的完全平衡，也就是每个叶子到根的高度都一样，然后把数据存储在每个叶子上，这一点又和我们在<a href="/algs/BT-1-BPT.html">B+ 树</a>上的情况相似。</p>

<p>而对树层级的定义又和 <a href="./BST-2-RB-Tree-2-AA">AA 树</a> 是一样，用 level 的概念来描述是非常恰当的，叶子层的 level 是 $1$ ，空树的 level 是 $0$ 。</p>

<p>对于持久化的要求来讲，每次操作，Push/Pop/Update etc. 只需要复制从根节点到叶子一条路径的节点，对数级别的开销是一个可以接受的代价。</p>

<p>另外，对于某些时间敏感的任务，Clojure 还允许把持久化的结构转变为易变的结构（Transient）来做就地修改，然后再转回持久性结构，以避免复制开销。这样的话需要在每个节点上做出标识来追踪节点的创建者，在下一部分的<a href="#标记">标记</a>一节具体讨论。</p>

<p>与易变向量的节点，以及区分历史上由不同线程创建的节点。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>这里有一个优化的小改动<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup>，就是把 TrieVec 最后一个节点（Bucket）从 Trie 中单独拿出来，作为尾节点，这会使得 Clojure 里像 <code class="language-plaintext highlighter-rouge">conj</code> 这样等价于 push 的操作在常量时间里完成。我们计算 TrieVec 的结构时候需要把尾部节点的长度扣除。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="常量定义">常量定义</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">BIT_WIDTH</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">const</span> <span class="n">NODE_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MASK</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">NODE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="从-trie-size-反推-trie-height">从 Trie size 反推 Trie height</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">h</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">trie_height</span><span class="p">(</span><span class="nd">tailoff!</span><span class="p">(</span><span class="nv">$self</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">fn</span> <span class="nf">trie_height</span><span class="p">(</span><span class="n">trie_size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">trie_size</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">x</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.ilog2</span><span class="p">()</span> <span class="o">/</span> <span class="n">BIT_WIDTH</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">h</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">h</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="根据总索引和当前层得到索引位置">根据总索引和当前层得到索引位置</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">idx</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$lv:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Precedence: '*' &gt; '&gt;&gt;' &gt; '&amp;'</span>
        <span class="nv">$idx</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nv">$lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BIT_WIDTH</span> <span class="o">&amp;</span> <span class="n">MASK</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="尾部偏移量">尾部偏移量</h4>

<p>也就是尾节点之前的元素数，也就是实际 Trie 的大小</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">tailoff</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">((</span><span class="nv">$self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">BIT_WIDTH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">BIT_WIDTH</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="标志">标志</h3>

<p>由于存在持久与易变版本间的转换，一个节点可能是持久版本的节点，也可能是历史上不同线程创建的易变节点。</p>

<p>这里使用 <code class="language-plaintext highlighter-rouge">u64</code> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>表示的 Thread id 作为标志，表示历史上创建易变节点的线程，Thread id 都大于 0 ，于是我们可以用 0 来表示持久版本的节点。</p>

<p>这样对于可编辑节点需要满足：</p>

<ol>
  <li>不是持久化节点</li>
  <li>不是历史上其他线程创建的节点</li>
</ol>

<p>不满足条件就需要复制节点，创造属于当前线程的节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.id</span><span class="p">()</span><span class="nf">.as_u64</span><span class="p">()</span><span class="nf">.get</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">no_edit</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">ID</span> <span class="o">=</span> <span class="nb">u64</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span> <span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ID</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 使用的是前面 <code class="language-plaintext highlighter-rouge">DaryHeap</code> 使用过的分配在堆上的静态数组；</li>
  <li><code class="language-plaintext highlighter-rouge">def_node__heap_access</code> 宏使用的之前 B+ 树里面使用过的宏</li>
</ol>

<h3 id="节点包装">节点包装</h3>

<p>考虑到持久化数据结构的跨线程使用的情况，节点包装里面的引用计数器将不再采用之前的 <code class="language-plaintext highlighter-rouge">std::rc::Rc</code> ，而改用同步版本的 <code class="language-plaintext highlighter-rouge">std::sync::Arc</code> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup> 。</p>

<p>但即使如此，由于 Rust 的严格限制，我们仍然不能把 <code class="language-plaintext highlighter-rouge">Node</code> 跨线程使用，即使我们确信作为持久化的结构时，是可以这样安全使用的。在 <code class="language-plaintext highlighter-rouge">std::sync</code> 的包里有各种各样的同步手段：</p>

<ol>
  <li>临界区（Exclusive）</li>
  <li>惰性锁（LazyLock）</li>
  <li>单写锁（OnceLock）</li>
  <li>栅栏（Barrier）</li>
  <li>条件变量（CondVar）</li>
  <li>锁（Mutex）</li>
  <li>单次锁 （Once）</li>
  <li>读写锁 （RwLock）</li>
</ol>

<p>看了让人直呼好家伙，上世纪的那点儿古董玩意儿都让它给复活了😅，但是这里面没有我们需要的，我们的持久化结构实际避免了同步的需求，但是需要有一种机制让编译器知道这个情况以便能通过 Trait 检查，而显然标准库里没有提供这种手段。</p>

<p>不过我们自己可以通过定义一个新的包装结构，为它实现 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Send</code> 两个 Trait 来实现持久化结构需要的 Trait 语义，<a href="https://github.com/bamidev/unsafe-send-sync">已经有人干得很好了</a>，我们在它的基础上按照我们的需求改进，得到一个告知编译器通过同步检查的包装结构，<code class="language-plaintext highlighter-rouge">UnsafeSendSync</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="cd">/// 一个自动实现Trait的宏，细节不展开了</span>
<span class="nd">impl_unpack!</span><span class="p">(</span><span class="n">UnsafeSendSync</span> <span class="p">|</span> <span class="nb">AsRef</span><span class="p">,</span> <span class="nb">AsMut</span><span class="p">,</span> <span class="n">Deref</span><span class="p">,</span> <span class="n">DerefMut</span><span class="p">,</span> <span class="nb">From</span><span class="p">);</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Sync</span> <span class="k">for</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">unwrap</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">as_ref_mut_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">_</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">_</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是我们重新修改了前面定义节点包装器的 <code class="language-plaintext highlighter-rouge">impl_node</code> 的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_node</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span><span class="p">(</span><span class="k">self</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span><span class="nv">$vis</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">rc</span><span class="nf">.as_ptr</span><span class="p">(),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="nv">$$</span><span class="p">(,)</span><span class="o">?</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
                    <span class="nf">.unwrap</span><span class="p">()</span>
                    <span class="nf">.into_inner</span><span class="p">()</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_node!</span><span class="p">(</span>
            <span class="nv">$vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">UnsafeSendSync</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;&gt;&gt;</span>
        <span class="p">);</span>
        <span class="nd">macro_rules!</span> <span class="n">aux_node</span> <span class="p">{</span>
            <span class="p">({</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
            <span class="p">(</span><span class="n">ENUM</span> <span class="nv">$ty:ident</span> <span class="p">{</span> <span class="nv">$$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">UnsafeSendSync</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Node_</span><span class="p">::</span><span class="nv">$ty</span> <span class="p">{</span>
                    <span class="nv">$$</span><span class="p">(</span>
                        <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
                    <span class="p">),</span><span class="o">*</span>
                <span class="p">}))))</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vis:vis</span> <span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g:ident</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">,</span> <span class="nv">$rc:ty</span><span class="p">,</span> <span class="nv">$wk:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$vis</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="cd">/// Used for reverse reference to avoid circular-reference</span>
        <span class="cd">///</span>
        <span class="cd">/// So we can easy auto drop</span>
        <span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nv">$wk</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">WeakNode</span><span class="p">(</span>
                    <span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                            <span class="o">&lt;</span><span class="nv">$rc</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="kc">false</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="nd">#[allow(unused)]</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="o">=</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">strong</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"weak node upgrade failed"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}))</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">oth</span><span class="p">:</span> <span class="k">Self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">oth</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="nv">$</span><span class="p">(</span><span class="nv">$g</span><span class="p">),</span><span class="o">+&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并更新节点包装的访问宏，增加新的用例：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"Call {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">self_unsafe_sync_mut</span> <span class="p">|</span> <span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="na">.0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span><span class="o">*</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.as_ref_mut_ptr</span><span class="p">()</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是得到我们自己定义的节点的访问宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">(</span><span class="k">pub</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">arc</span><span class="p">);</span>

<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">call_unsafe_sync</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
</code></pre></div></div>

<p>并用它们定义一些节点包装上的方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="n">self_unsafe_sync</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">values!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">id!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="简单方法">简单方法</h2>

<p>首先定义下向量的持久化版本和易变版本共通的一些方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_trie_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
                <span class="n">tail</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">ID</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="p">}</span>

        <span class="c1">// Alias as search to leaf, array_for, etc</span>
        <span class="k">fn</span> <span class="nf">down_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">)];</span>
                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cur</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>不同于 Clojure 里面的实现，我们检查尾节点的 <code class="language-plaintext highlighter-rouge">id</code> 而不是根节点的，因为尾节点才是首先被插入的节点</li>
</ol>

<h2 id="创建节点">创建节点</h2>

<p>定义一个创建节点的宏可以极大地方便我们后续持久性以及易变性数据结构推入或弹出节点的过程。</p>

<h3 id="基础创建">基础创建</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...</span>
    <span class="p">(</span><span class="n">single</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">);</span>
        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>
        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nv">$id</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">Array</span><span class="p">::</span><span class="nf">new_with_clone</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="带有容积参数的复制">带有容积参数的复制</h3>

<p>创建一个指定大小的数组，并在允许范围内复制一个既有节点。这既可以用在 <code class="language-plaintext highlighter-rouge">push</code> 时创建一个扩容的新节点，也可以用在 <code class="language-plaintext highlighter-rouge">pop</code> 时创建一个缩容的新节点，当然也可以原封不动地复制节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...    </span>
   <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nv">$cap</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">values!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$cap:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">cap</span> <span class="o">=</span> <span class="nv">$cap</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cap</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]</span><span class="nf">.clone_from_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>

        <span class="n">nod</span>
    <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>       
</code></pre></div></div>

<h3 id="复制时容量-1-1">复制时容量 +1/-1</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
	<span class="c1">// ...        </span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">values_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">inc</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
		
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="n">x</span><span class="nf">.len</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$v</span><span class="p">;</span>

        <span class="n">node</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">dec</span><span class="p">|</span> <span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span><span class="o">-</span><span class="n">with</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
</code></pre></div></div>

<p>值得注意的是，对 +1 复制与 -1 复制的实现行为有些不同，+1 复制要单独分为两种情况，这是因为它有一个额外的参数 <code class="language-plaintext highlighter-rouge">$v</code> ，也就是需要插入节点的值，而值的类型是异构的，不能动态地分发，只能手动静态地分发。</p>

<h2 id="push">Push</h2>

<h3 id="主流程">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建新路径">创建新路径</h3>

<p>创建一条从某 $\text{lv}$ 开始直到叶子( $\text{lv}=1$ )的新路径：</p>

<div class="sx-center">
<img src="/assets/img/trievec/trievec_new_path.svg" width="40%" /></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Top-down clone new path from lv (1..h)</span>
<span class="k">fn</span> <span class="n">new_path</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">ID</span><span class="p">,</span> <span class="n">lv</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>

    <span class="n">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用了递归的实现，在原版的作为 Clojure 标准库的 Java 实现里所有 Trie 上的操作都采用了类似结构的递归的实现，这或许能简化一些代码，但是严重牺牲了代码的可读性：一方面接口丑陋，作为递归函数的代价，包含了过多不应该属于接口而是栈上临时的参数；另一方面递归本身又隐藏了细节，让人难以看清楚到底这个过程做了什么事情。因此后面我们将使用我们自己的展开版本的实现作为替代。</p>

<h3 id="推入尾节点">推入尾节点</h3>

<p>当 <code class="language-plaintext highlighter-rouge">push</code> 时发现尾节点已满时，需要把旧的尾节点推入 Trie 里面，按照 Trie 树高可以分为三种情况：</p>

<ol>
  <li>$\text{lv}=0$ ，也就是 Trie 为空的情况，把旧尾节点作为 Trie 的根；</li>
  <li>$\text{lv}=1$ ，此时发现根溢出，于是创建一个新的节点包含原来的旧根和推入的尾节点。但是更进一步地，可以推广到包含 $\text{lv}=1$ 在内的全部根溢出的情况，此时新根插入的不是原来的尾节点，而是 <code class="language-plaintext highlighter-rouge">new_path</code> 创建的包含尾节点的一整条路径；</li>
  <li>$\text{lv} \ge 2$ ，从根节点开始复制，注意选择合适的数组容量，当中间节点超过一层时，自顶向下地复制每一层的节点，并把上一层中间节点里对本层节点的引用更新为新创建的节点，当发现新的节点在一个还未创建的路径时，可以直接使用 <code class="language-plaintext highlighter-rouge">new_path</code> 创建到叶子的新路径，然后插入到上一层节点。</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Complete trie including case lv == 1</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">p_i</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span>
                <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// Go down through the branch</span>
        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">cur</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">old_cur</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">cur_i</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                        <span class="n">dup</span> <span class="o">-</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span>
                        <span class="n">old_cur</span><span class="p">,</span>
                        <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">}</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="assoc">Assoc</h2>

<p>按照索引更新向量，如果索引和长度相等，就顺势插入。</p>

<p>和前面 <code class="language-plaintext highlighter-rouge">push_tail_into_trie</code> 同样自顶向下地复制一条只到叶子的路径，只不过前者相当于访问的索引是 <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> ，而这里使用的是传入的索引。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// idx in `[0, self.len()]` (update or push)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">old_cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">];</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">old_cur</span><span class="p">);</span>

                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="pop">Pop</h2>

<h3 id="主流程-1">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">tail</span><span class="p">;</span>

        <span class="c1">// Get empty vec</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// Get non-empty tail</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">dec</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// the last two idx</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

            <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tail</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="弹出尾节点">弹出尾节点</h3>

<p>与 <code class="language-plaintext highlighter-rouge">push</code> 的操作相对的，当弹出尾部元素后发现尾节点为空时，需要把 Trie 最后一个节点弹出来作为尾节点。</p>

<p>有两点值得一讲：</p>

<ol>
  <li>
    <p>使用 <code class="language-plaintext highlighter-rouge">self.cnt - 2</code> 作为对 Trie 上最后一个节点的访问索引，因为此时原尾节点上只有一个元素，因此 Trie 上有 <code class="language-plaintext highlighter-rouge">self.cnt - 1</code> 个元素；</p>
  </li>
  <li>
    <p>弹出尾节点可能会产生空路径，也就是唯一的子节点为空的节点，空路径可能会一路向上延伸，直到根节点<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>。对应推入尾节点时有根溢出的情况，这时应该叫做根不足吧😀。</p>

    <p>从结构上进行判断的话，需要从尾部再回溯到根，由于 Trie 节点没有对父节点的反向引用，所以在自顶向下过程中还要保存一下整条节点路径，然后进行检查。</p>

    <p>不过有更简单的，就是直接检查 Trie 的大小，是否弹出尾节点后后高度会下降</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
	<span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// Get empty tail</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// tail size 1</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* pop root */</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">root</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="易变版本实现">易变版本实现</h2>

<h3 id="数据结构-1">数据结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Send</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>由于 <code class="language-plaintext highlighter-rouge">Sync</code> 和 <code class="language-plaintext highlighter-rouge">Send</code> 是自动 Trait，由于 Node 因为我们定义的 <code class="language-plaintext highlighter-rouge">UnsafeSendSync</code> 自动实现了这两个 Trait ，因此 <code class="language-plaintext highlighter-rouge">PTrieVec</code> 和 <code class="language-plaintext highlighter-rouge">TTrieVec</code> 也都自动实现了这两个 Trait ，但我们不喜欢让 <code class="language-plaintext highlighter-rouge">TTrieVec</code> 能后被跨线程的分发与访问，于是通过“负实现”取消这两个 Trait 的自动实现。</p>

<h3 id="transient">transient</h3>

<p>把持久向量变为属于当前线程的可变向量。</p>

<p>不会马上复制整棵树的所有节点，而只是 TrieVec 的根节点和尾节点。</p>

<p>使用宏 <code class="language-plaintext highlighter-rouge">ensure_editable</code> 作为警戒哨，确保最后得到一个属于当前线程的可变的节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">ensure_editable</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$id:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nv">$id</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">id</span> <span class="o">==</span> <span class="n">x</span><span class="nf">.id</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="n">id</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">ensure_editable!</span><span class="p">(</span><span class="nd">edit!</span><span class="p">(),</span> <span class="nv">$x</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">transient</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">TTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="nd">ensure_editable!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push-1">push</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">}</span>

	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="c1">// trie is empty</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="nd">edit!</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// tail is available</span>
        <span class="c1">// WARNING: neq `tail.len` for it's array capcity</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NODE_SIZE</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">leaf_i</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span>
                    <span class="nd">node!</span><span class="p">(</span><span class="n">dup</span> <span class="o">-</span> <span class="n">with</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="n">leaf_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// tail is full</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push_tail_into_trie</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">single</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>


        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
   	<span class="k">fn</span> <span class="nf">push_tail_into_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">internal</span> <span class="p">|</span> <span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="c1">// at p's level</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                <span class="k">let</span> <span class="n">cur_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">p_i</span> <span class="o">=</span> <span class="n">cur_i</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span>
                    <span class="nf">new_path</span><span class="p">(</span><span class="k">self</span><span class="nf">.id</span><span class="p">(),</span> <span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">,</span> <span class="n">NODE_SIZE</span><span class="p">);</span>

                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基本过程和持久化版本高度一致，有一个区别是：</p>

<ol>
  <li>持久化版本扩容时容量最多增加 $1$ ，而易变版本直接分配满额的节点；</li>
  <li>直接修改 TrieVec 头，<code class="language-plaintext highlighter-rouge">self.root</code>, <code class="language-plaintext highlighter-rouge">self.tail</code></li>
</ol>

<h3 id="assoc-1">assoc</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>      
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>


        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="nf">.id</span><span class="p">()</span> <span class="o">==</span> <span class="k">self</span><span class="nf">.id</span><span class="p">());</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// at p's level</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

                    <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">values_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop-1">pop</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Can't pop empty vector"</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">values_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)[</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="nd">tailoff!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
                <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="nf">.down_to_leaf</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.pop_tail_from_trie</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">pop_tail_from_trie</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">lv</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">leaf_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.ensure_editable</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]);</span>

            <span class="n">lv</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">p_i</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">leaf_i</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">p_i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">NODE_SIZE</span> <span class="o">==</span> <span class="n">NODE_SIZE</span><span class="nf">.pow</span><span class="p">(</span><span class="nd">h!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="persistent">persistent</h3>

<p>把易变版本转换回持久化版本。改一下头尾节点的标记就可以。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>       
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">persistent</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PTrieVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_editable</span><span class="p">());</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="nd">id_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span> <span class="o">=</span> <span class="nd">no_edit!</span><span class="p">();</span>
        <span class="p">}</span>
        
        <span class="n">PTrieVec</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">,</span>
            <span class="n">root</span><span class="p">:</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 Rust 的编程模型，易变版本持久化后原来的易变版本保证无法访问，相比 Clojure 的 Java 实现会简化很多过程。</p>

<h2 id="调试方法">调试方法</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[cfg(test)]</span>
<span class="nd">macro_rules!</span> <span class="n">impl_trie_test_common</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[allow(unused)]</span>
        <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
        <span class="k">where</span>
            <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="p">{</span>
            <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.tail</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">fn</span> <span class="n">debug_print</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">tail</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"MAIN TRIE:"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cur_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">root</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {} #############</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lv</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{i:02}. {child:?}"</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">child_group</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="nf">.iter</span><span class="p">()</span>
                        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">())</span>
                        <span class="nf">.collect</span><span class="p">();</span>
                    <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_group</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">println!</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// print tail</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"###################################</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"TAIL: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">tail</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"empty."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="尾声">尾声</h2>

<p><a href="">代码参考</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>参考自 <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">hyPiRion 介绍的系列博文</a> 和 <a href="https://github.com/clojure/clojure/blob/clojure-1.11.0-alpha2/src/jvm/clojure/lang/PersistentVector.java">Clojure 源代码</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>https://hypirion.com/musings/understanding-persistent-vector-pt-3#the-rationale-for-tails <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>在原版 Clojure 的 Java 里，标志使用了原子类型，这主要是担心易变类型在跨线程使用时重新变为持久类型时的竞争问题，但是由于 Rust 的编程模型限制了易变类型不允许跨线程使用，因此就不需要变为原子类型 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Atomic Rc <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>对于树高至少为 $2$ 作为的 Trie 来讲，空路径应该是根节点的第二个孩子， <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下另篇关于降低构建时间的笔记。]]></summary></entry><entry><title type="html">BT(2) - B+树（TreeMap）</title><link href="/algs/BT-2-BPT2.html" rel="alternate" type="text/html" title="BT(2) - B+树（TreeMap）" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-2-BPT2</id><content type="html" xml:base="/algs/BT-2-BPT2.html"><![CDATA[<p>对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。</p>

<p>没错，现在我们就是要用前文实现的 B+ 树作为我们新 B+ 树的节点基础。当然这是一个递归的概念，我们也可以继续下去把这个新的 B+ 树的实现作为节点基础实现 B+ 树，如此 $3$ 层、$4$ 层的嵌套。但从 $m$ 常数的角度，两层就够了，再多也没有意义，通常 $m$ 也就是一百左右，次级的 B+ 树的 $m$ 最多也就是就是十几，已经什么空间了，何况因此获得的性能增长也呈指数级下降。</p>

<p>但是实现用前面实现的 B+ 树作为节点的基础，还需要实现额外的一些 public method ，包括增加字段，比如统计键值总数的 cnt 字段等等。但是如何扩写 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树一时难以论说，事实上扩写&amp;重构改动的代码比原代码还长，所以就把它放到下一篇介绍，那时将得到一个相对完整的 <code class="language-plaintext highlighter-rouge">Vec</code> 版本的 B+ 树。</p>

<p>这里会列出一个作为节点实现 B+ 树的 <a href="#方法统计">TreeMap 需要实现的方法</a>，既作为下一篇的索引，也作为用其他 TreeMap 代替实现时的参考。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>这里增加了 <code class="language-plaintext highlighter-rouge">cnt</code> 统计字段和 <code class="language-plaintext highlighter-rouge">min_node</code> 用于快速范查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees powered by B+ tree</span>
    <span class="cd">///</span>
    <span class="n">BPT2</span> <span class="p">{</span> <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>TreeMap 实现的 B+ 树和数组实现的 B+ 树在内部节点的设计上有质的不同。</p>

<p>数组版本的，键值和孩子是按照索引来排的，而 TreeMap 则是按照唯一的键值来排列的。这既省了事儿又另一方面多了事儿，整个节点状态维护的逻辑都发生了变化。</p>

<p>首先从节点布局上，内部节点的 <code class="language-plaintext highlighter-rouge">keys</code> 字段没有存在的意义，直接使用 <code class="language-plaintext highlighter-rouge">children</code> map，但是这样对 map 的键的维护就成了一个关键。如何选取一个合适的键来代表孩子呢？</p>

<p>有两种明显的思路：</p>

<ol>
  <li>就用节点的最小值作为键，这样查询起来非常快，可以快速失败，但是当节点的最小键发生变化时，必须向上更新 map 来维护这一性质；</li>
  <li>那么用任意孩子节点的任一一个键就不需要始终维护了，但这样的话查询的时候就不知道到底要落到哪一个键上，就查询左右两个键的孩子的所有键值也解决不了问题，因为它们也不一定都是最小键</li>
</ol>

<p>于是显然，我们采用把最小键最为子节点在父节点上的键的设计。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SUB_M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">SUB_M</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础方法">基础方法</h2>

<h3 id="搜索到叶子">搜索到叶子</h3>

<p>这里会用到 TreeMap 里面的一个配合方法，<code class="language-plaintext highlighter-rouge">low_bound_search</code> ，是搜索 $\geqslant k$ 的第一个节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf_r</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.low_bound_search</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x_</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点访问">节点访问</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">children!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.min_key</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">min_key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.min_key</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">k</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"No min-key {:?}"</span><span class="p">,</span> <span class="nv">$x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点">创建节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">BPT</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">entries</span><span class="nf">.insert</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">);</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="一般公开方法">一般公开方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min_node</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="范围查询">范围查询</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
                <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span> <span class="o">=</span> <span class="n">entries</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">fst</span><span class="p">;</span>

                    <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="n">ent</span>
                    <span class="p">}</span>

                    <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="插入">插入</h2>

<h3 id="主流程">主流程</h3>

<p>插入的时候，检查是否需要更新 map 的索引。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* new min none */</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/* insert into leaf */</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<p>索引更新需要一路向上检查</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">old_k</span> <span class="o">!=</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="cm">/* update x key */</span>

            <span class="k">let</span> <span class="n">old_p_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_p_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升">节点提升</h3>

<p>到目前位置 TreeMap 的节点实现给我们增加了很多麻烦，但当分裂节点的时候，就很简单了<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，这里的 <code class="language-plaintext highlighter-rouge">split_off</code> 的表现和 <code class="language-plaintext highlighter-rouge">Vec</code> 的一致。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span>
                <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">((</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children_x2</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x2_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x2</span><span class="p">);</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">bpt!</span> <span class="p">{</span>
                <span class="n">x_k</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">x2_k</span> <span class="k">=&gt;</span> <span class="n">x2</span>
            <span class="p">};</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="c1">// insert new or update</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x2_k</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="删除">删除</h2>

<h3 id="主流程-1">主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf_r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">remove_on_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old_k</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_k</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">popped</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<p><strong>在本方法和后面的重平衡方法里更新索引时很容易出错，需要仔细考虑，比如同时更新两个索引时可能会出现键值覆盖的问题。</strong></p>

<p><code class="language-plaintext highlighter-rouge">rank</code>：查询键排名，从 $0$ 开始</p>

<p><code class="language-plaintext highlighter-rouge">nth</code>：根据排名，返回键值，从 $0$ 开始</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>   
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.rank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">old_k</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// merge with left_sib (no need to update index)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_k</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sib_lf</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for right_sib (merge into left)</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="c1">// 由于没有prev，只能总是合并到左节点，好在此时叶子节点只有一个元素</span>
            <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">));</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// remove x from p</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

                <span class="c1">// 不需要更新索引，因为 sib_rh 值更大</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">old_key_sib_rh</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_key_sib_rh</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.drain_all</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">child_k</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.1</span><span class="p">;</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old_key</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">old_k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// try to redistribute with left</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_lf</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_lf</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_lf</span><span class="p">)</span><span class="nf">.pop_last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// try to redistribute with right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_sib_k</span><span class="p">,</span> <span class="n">sib_rh</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.nth</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sib_rh</span> <span class="o">=</span> <span class="n">sib_rh</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">old_k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// WARNING： it wll replace sib_rh with x</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">),</span> <span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">sib_rh</span><span class="nf">.is_internal</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">sib_rh_old_key</span> <span class="o">=</span> <span class="nd">min_key!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">sib_rh</span><span class="p">)</span><span class="nf">.pop_first</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>

                <span class="c1">// 不需要像叶子节点那样两段儿更新是因为在叶子更新的时候，已经对 x 向上更新过了</span>
                <span class="c1">// Self::update_index(old_k, x);</span>
                <span class="c1">// children_mut!(p).insert(min_key!(sib_rh), sib_rh);</span>

                <span class="k">Self</span><span class="p">::</span><span class="nf">update_index</span><span class="p">(</span><span class="n">sib_rh_old_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sib_rh</span><span class="p">);</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="测试">测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT2"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Internal</span> <span class="p">{</span> <span class="n">children</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">f</span>
                <span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Internal"</span><span class="p">)</span>
                <span class="nf">.field</span><span class="p">(</span><span class="s">"children"</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
                <span class="nf">.finish</span><span class="p">(),</span>
            <span class="k">Self</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">entries</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"Leaf"</span><span class="p">)</span><span class="nf">.field</span><span class="p">(</span><span class="s">"entries"</span><span class="p">,</span> <span class="n">entries</span><span class="p">)</span><span class="nf">.finish</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">#[cfg(test)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="cm">/* print header */</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{self:?}"</span><span class="p">);</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"############ Level: {lv} #############"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">println!</span><span class="p">(</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">println!</span><span class="p">();</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="校验方法">校验方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT2</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">);</span>

                        <span class="c1">// children!(child).validate();</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="c1">// entries!(child).validate();</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from_iter</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.values</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">(),</span>
                        <span class="p">);</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="方法统计">方法统计</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">BPT</th>
      <th style="text-align: center">Tree Map</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">select/select_mut</td>
      <td style="text-align: center">select_mut</td>
    </tr>
    <tr>
      <td style="text-align: center">remove etc.</td>
      <td style="text-align: center">remove</td>
    </tr>
    <tr>
      <td style="text-align: center">insert etc.</td>
      <td style="text-align: center">insert</td>
    </tr>
    <tr>
      <td style="text-align: center">search_to_leaf_r</td>
      <td style="text-align: center">low_bound_search</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">len</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min</td>
    </tr>
    <tr>
      <td style="text-align: center">promote</td>
      <td style="text-align: center">split_off</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">nth</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">rank</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote</td>
      <td style="text-align: center">push_back</td>
    </tr>
    <tr>
      <td style="text-align: center">unpromote/try_rebalancing</td>
      <td style="text-align: center">pop_first/pop_last</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">min_key</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h2 id="总结">总结</h2>

<p>运行一个简单的基准测试，结果符合预期：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">环境</th>
      <th style="text-align: left">值</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CPU</td>
      <td style="text-align: left">Intel Haswell Core i5-4590</td>
    </tr>
    <tr>
      <td style="text-align: left">Memory</td>
      <td style="text-align: left">16 GB</td>
    </tr>
    <tr>
      <td style="text-align: left">Key Size</td>
      <td style="text-align: left">8 Bytes</td>
    </tr>
  </tbody>
</table>

<p>最优配置：</p>

<p>$\text{SUB_M} = 20$</p>

<p>$10 \leqslant M \leqslant 20$</p>

<ol>
  <li>查询性能非常好，<strong>比 Rust 标准库里 HashMap 的查询速度还要快25%！</strong>但是这种加速不是 B+ 树结构本身所导致的，而是 Map 的使用使得节点的内存布局在缓存上更有利，也就是单一数组的 TreeMap 比起分离的两个数组更有利，换言之，<strong>直接使用单一数组实现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的 Map 性能会更好！</strong></li>
  <li>插、删的性能介于传统 BST 和 B 树、B+ 树之间</li>
</ol>

<p>这个结果符合了理论和经验上的预期，最后再补充一个对比测试：</p>

<p>B+ Tree <code class="language-plaintext highlighter-rouge">push_back</code>-<code class="language-plaintext highlighter-rouge">pop_first</code> vs Vec <code class="language-plaintext highlighter-rouge">push</code>-<code class="language-plaintext highlighter-rouge">remove(0)</code> on <code class="language-plaintext highlighter-rouge">u64</code></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M</th>
      <th>batch CroSS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">105</td>
      <td>1150</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td>2500</td>
    </tr>
  </tbody>
</table>

<p>也就是说当数据量要足够大才能发挥出算法上的性能才能抵消缓存的优势，而在最佳 M 范围下，数组实现具有明显优势。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>只不过看起来 <code class="language-plaintext highlighter-rouge">split_off</code> 大概也是得自己实现 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">比如 Vec&lt;KVEntry&lt;K, V&gt;&gt;</code> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。]]></summary></entry><entry><title type="html">BT(3) - B+树完整版以及B*性质</title><link href="/algs/BT-3-BPT_complete_with_star.html" rel="alternate" type="text/html" title="BT(3) - B+树完整版以及B*性质" /><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><id>/algs/BT-3-BPT_complete_with_star</id><content type="html" xml:base="/algs/BT-3-BPT_complete_with_star.html"><![CDATA[<p>继承前两篇 <a href="/algs/BT-1-BPT.html">B+树(Vec)</a> 和 <a href="/algs/BT-2-BPT2.html">B+树(TreeMap)</a> 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在<a href="https://github.com/minghu6/rust-minghu6/tree/snapshot-2">这里</a></p>

<h2 id="数据结构">数据结构</h2>

<h3 id="树">树</h3>

<p>为了 <code class="language-plaintext highlighter-rouge">pop_first</code> / <code class="language-plaintext highlighter-rouge">pop_last</code> 增加了最小、最大节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">min_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">max_node</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h2 id="新增简单方法">新增简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cnt</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">nodes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">cur</span><span class="nf">.clone</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">entries</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.nodes</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">keys</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">values</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.entries</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">drop</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">}</span>
    
    <span class="cd">/// collect all item without drop itself used for BPT2::remove</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">drain_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">nxt</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">ent</span><span class="nf">.drain</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.min_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.max_node</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
            <span class="nf">.max_key</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">K</span><span class="p">)</span> <span class="p">})</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="修改的既有方法">修改的既有方法</h2>

<h3 id="插入">插入</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">x2</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* merge node */</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_internal</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span> <span class="p">{</span>
        <span class="n">f</span><span class="nf">.debug_struct</span><span class="p">(</span><span class="s">"BPT"</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"cnt"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.cnt</span><span class="p">)</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"min_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.field</span><span class="p">(</span><span class="s">"max_node"</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span>
            <span class="nf">.finish</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="新增方法">新增方法</h2>

<h3 id="push_back">push_back</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into max</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="push_front">push_front</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// push into min</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="c1">// self.insert_into_leaf(x, k, v);</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.min_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_first">pop_first</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_first</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* min-key has no internal index */</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pop_last">pop_last</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_last</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">internal_and_idx</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">p</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rank">rank</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Start from 0 O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">rank</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">is_err</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">;</span>
                <span class="n">is_err</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">rem</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">rem</span> <span class="o">+=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">rk</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">is_err</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">rk</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nth">nth</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return Nth child (start from 0), O(n/M)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min_node</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.1</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="split_off">split_off</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// return [at, ...)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">split_off</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">oth</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">at</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.cnt</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">oth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">oth</span><span class="nf">.bulk_push_front</span><span class="p">(</span><span class="k">self</span><span class="nf">.bulk_pop</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span> <span class="o">-</span> <span class="n">at</span><span class="p">));</span>

        <span class="n">oth</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="b-性质">B* 性质</h2>

<p>B* 就是在键值插入的时候如果发生节点溢出时，不急着先分裂节点，而是和删除时一样，首先尝试从邻居节点进行平衡操作。</p>

<h3 id="try_balacing">try_balacing</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="k">if</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="cd">/// parent, x idx of parent</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Try left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try right then</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="o">&amp;&amp;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">try_node_redistribution_eager</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">try_node_redistribution_eager</span><span class="p">(</span>
        <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">sib_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">use</span> <span class="nn">common</span><span class="p">::</span><span class="n">vec_even_up</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                    <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">left_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">right_old_len</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">();</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="nf">vec_even_up</span><span class="p">(</span><span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">())</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
                    <span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left_old_len</span> <span class="o">&lt;</span> <span class="n">right_old_len</span>  <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_old_len</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.len</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">children_revref!</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="o">..</span><span class="nd">children!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span><span class="o">-</span><span class="n">right_old_len</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="vec_even_up">vec_even_up</h3>

<p>保持左右的顺序前提下，平分左右两个数组。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Even up two vector using clone</span>
<span class="cd">///</span>
<span class="cd">/// (This implementation is inspired by Vec::remove)</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">/// use m6_common::vec_even_up;</span>
<span class="cd">///</span>
<span class="cd">/// /* case-0 left max for pop is easy (odd) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..7).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-1 the left is samller (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..2).collect();</span>
<span class="cd">/// let mut v1 = (4..8).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 4]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7]);</span>
<span class="cd">///</span>
<span class="cd">/// /* case-2 the left is larger (even) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..4).collect();</span>
<span class="cd">/// let mut v1 = (4..6).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2]);</span>
<span class="cd">/// assert_eq!(v1, vec![3, 4, 5]);</span>
<span class="cd">///</span>
<span class="cd">///</span>
<span class="cd">/// /* case-3-0 the left is larger (given more than old_len) */</span>
<span class="cd">///</span>
<span class="cd">/// let mut v0 = (0..7).collect();</span>
<span class="cd">/// let mut v1 = (7..9).collect();</span>
<span class="cd">/// vec_even_up(&amp;mut v0, &amp;mut v1);</span>
<span class="cd">/// assert_eq!(v0, vec![0, 1, 2, 3, 4,]);</span>
<span class="cd">/// assert_eq!(v1, vec![5, 6, 7, 8]);</span>
<span class="cd">///</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">vec_even_up</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v0</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v0_old_len</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">v1_old_len</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">tnt</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">+</span> <span class="n">v1_old_len</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">cnt_lf</span> <span class="o">=</span> <span class="n">tnt</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">cnt_rh</span> <span class="o">=</span> <span class="n">tnt</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

    <span class="cm">/* Check if it's balanced? */</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">==</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">v1</span><span class="nf">.len</span><span class="p">(),</span> <span class="n">cnt_rh</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">v0_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">v1_old_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::{</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy_nonoverlapping</span><span class="p">,</span> <span class="n">read</span> <span class="p">};</span>

    <span class="c1">// V0 is smaller</span>
    <span class="k">if</span> <span class="n">v0_old_len</span> <span class="o">&lt;</span> <span class="n">cnt_lf</span> <span class="p">{</span>
        <span class="c1">// let v0_get = cnt_lf - v0_old_len;</span>
        <span class="k">let</span> <span class="n">v1_given</span> <span class="o">=</span> <span class="n">v1_old_len</span> <span class="o">-</span> <span class="n">cnt_rh</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">v0</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">v</span>
        <span class="p">});</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v1_given</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">cnt_rh</span>
            <span class="p">);</span>

            <span class="n">v1</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// V0 is larger</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v0_given</span> <span class="o">=</span> <span class="n">v0_old_len</span> <span class="o">-</span> <span class="n">cnt_lf</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">v0_ptr</span> <span class="o">=</span> <span class="n">v0</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="n">v1</span><span class="nf">.resize_with</span><span class="p">(</span><span class="n">cnt_rh</span><span class="p">,</span> <span class="k">move</span> <span class="p">||</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Fill with dirty data</span>
            <span class="c1">// read(v0_ptr)</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">zeroed</span><span class="p">()</span>
        <span class="p">});</span>

        <span class="c1">// get ptr after resize to avoid realloc issue</span>
        <span class="k">let</span> <span class="n">v1_ptr</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.as_mut_ptr</span><span class="p">();</span>

        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nf">copy</span><span class="p">(</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v1_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">v0_given</span><span class="p">),</span>
                <span class="n">v1_old_len</span>
            <span class="p">);</span>

            <span class="nf">copy_nonoverlapping</span><span class="p">(</span>
                <span class="n">v0_ptr</span><span class="nf">.add</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">),</span>
                <span class="n">v1_ptr</span><span class="p">,</span>
                <span class="n">v0_given</span>
            <span class="p">);</span>

            <span class="n">v0</span><span class="nf">.set_len</span><span class="p">(</span><span class="n">cnt_lf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>B* 没什么用，对插入的性能改进没有什么帮助</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[继承前两篇 B+树(Vec) 和 B+树(TreeMap) 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在这里]]></summary></entry><entry><title type="html">BT(1) - B+树（Vec）</title><link href="/algs/BT-1-BPT.html" rel="alternate" type="text/html" title="BT(1) - B+树（Vec）" /><published>2023-03-13T00:00:00+08:00</published><updated>2023-03-13T00:00:00+08:00</updated><id>/algs/BT-1-BPT</id><content type="html" xml:base="/algs/BT-1-BPT.html"><![CDATA[<p>在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。</p>

<p>如果说之前好不容易把观念从二叉搜索树转换到了 B 树，那么从现在开始，从 B 树到 B+ 树又需要有一个很大的观念转变。不过请放心，本文讲得是依靠 <code class="language-plaintext highlighter-rouge">Vec</code> 实现的 B+ 树，后面还会介绍用 <code class="language-plaintext highlighter-rouge">TreeMap</code> 实现的 B+ 树，那时又需要一个很大的观念转变。</p>

<p>整个 B 树系列计划了四篇文章，即使层层铺叠，每篇间的学习曲线都很陡峭，可谓是一山四绝弯！</p>

<h2 id="概念基础">概念基础</h2>

<p>B+ 树区别于普通 B 树的主要特点是中间节点有键无值<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> ，而在最底层的叶子上存储数据。另外叶子节点存储有 next 指针，指向它的后继节点，为得是高效的范围查询。</p>

<p>由于更好的缓存适应性，B+ 树的基础操作 查/增/删 都明显快于普通 B 树，完全可以当做普通 B 树的上位替代。</p>

<h3 id="观念挑战">观念挑战</h3>

<p>虽然看起来只是一个小小的改变，但又一次颠覆了习惯的概念。</p>

<ol>
  <li>从二叉搜索树到 B 树，我们一直习惯的是键就是键值的代名词，但正如前面节点不再是键的代名词，这里键与值的关系也分开了；</li>
  <li>进一步考虑，这就出现了叶子上必然存在一个键，而中间节点里可能还存在一个重复的键；</li>
  <li>也就是说父节点的键与子节点键的大小关系也不同了，不仅是大于或者小于，还有可能是相等的关系</li>
</ol>

<p>因此这里还要明确一下：B+ 树父节点的键可能与子节点的最小键相等，这符合左闭右开的惯例。</p>

<h3 id="索引的重要性质">索引的重要性质</h3>

<p>不是叶子节点上的每一个键值都在内部节点上有一个键，在内部节点的键有两种情况：</p>

<p><img src="/assets/img/bt_bpt_vec/dupidx.png" alt="" /></p>

<ol>
  <li>每个根的叶子节点，除了第一个以外，每个叶子的最小键，都在这个这个根上有对应的键，就是左键<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>；</li>
  <li>第一个叶子节点除了最小的根以外，在根或者根的祖先上也有对应的键</li>
</ol>

<p>也就是说，<strong>所有中间节点的键由且仅由除了第一个节点以外的每个叶子节点的最小键组成</strong></p>

<p>在我做调查的过程中发现这个索引的性质在有的实现里并没有被尊重，这不会直接影响功能的实现，却破坏了 B+ 树的性质，引入了潜在的 Bug ：删除会导致中间节点存在废弃的键。</p>

<h3 id="重平衡">重平衡</h3>

<p>过程与 B 树一致，只是分裂节点时由弹出中间的键改为克隆中间的键，合并节点的时候只删除父节点对应键而不是并入节点，因此这里就不再赘述。</p>

<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">在线的 B+ 树的模拟页面</a></p>

<h2 id="实现-数据结构">实现-&gt;数据结构</h2>

<h3 id="树">树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// B+ Trees</span>
    <span class="cd">///</span>
    <span class="n">BPT</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="节点包装">节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="内部节点">内部节点</h3>

<p>B+ 树叶子节点和内部节点的字段区别还是很大的，是否沿用之前的同构的设计是个值得思考的问题。</p>

<p>我们比较这两种设计的 drawback：</p>

<p>如果采用同构：</p>

<ol>
  <li>会有冗余字段，每个字段都占了至少是指针宽度的空间；</li>
  <li>节点看起来有些杂乱，严重降低代码可读性</li>
</ol>

<p>如果采用异构：</p>

<ol>
  <li>由于使用了枚举，导致之前积累的宏没法儿使用，需要重写一套，另外还要编写配套的内部节点的属性访问代码</li>
</ol>

<p>看起来没有哪一个是写起来又好又快的，但是我们再仔细考虑发现：</p>

<ol>
  <li>同构的设计还是需要一个单独字段来内省地判断自己是叶子节点还是中间节点，它和异构的枚举实现的区别本质上只是一个是手搓的、特化的，一个是系统的、泛化的；</li>
  <li>编程也有一个不可能三角：</li>
</ol>

<p><img src="/assets/img/bt_basic/prog_triangle.png" alt="" /></p>

<p>一般地，条件允许下，是牺牲部分代码简洁性，来保障另外的两个目标。</p>

<p>因此这里我还是采用了异构的设计：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">keys</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="cd">/// Successor (Leaf)</span>
        <span class="n">succ</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">Node_</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<p>内部节点的属性访问方法：</p>

<p>使用宏来统一描述这个方法，来避免无谓的代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Node_ heap data field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__heap_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on leaf"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">,</span> <span class="nv">$ret:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">$ret</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$ret</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Node_ WeakNode field access</span>
<span class="nd">macro_rules!</span> <span class="n">def_node__wn_access</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="nv">$name:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nv">$name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                    <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                    <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="nf">.upgrade</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
            <span class="k">fn</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                    <span class="n">Internal</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span>
                        <span class="s">"Get `{}` on internal node"</span><span class="p">,</span>
                        <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">Leaf</span> <span class="p">{</span> <span class="nv">$name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="nv">$name</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="nf">.replace</span><span class="p">(</span><span class="n">x</span><span class="nf">.downgrade</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是属性访问就可以写成：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">Leaf</span> <span class="p">{</span> <span class="o">..</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">internal</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>
    <span class="nd">def_node__heap_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">both</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">succ</span><span class="p">);</span>
    <span class="nd">def_node__wn_access!</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">pred</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这就可以写 B+ 树 专属的生成宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro_bpt</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="nv">$name</span><span class="p">()</span>
                    <span class="p">};</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="n">set_</span> <span class="nv">$name</span><span class="o">&gt;</span><span class="p">](</span><span class="nv">$$val</span><span class="p">)</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>

            <span class="nn">coll</span><span class="p">::</span><span class="nd">paste!</span><span class="p">(</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">attr!</span><span class="p">(</span><span class="n">self_mut</span> <span class="p">|</span> <span class="nv">$$node</span><span class="p">)</span>.<span class="p">[</span><span class="o">&lt;</span><span class="nv">$name</span> <span class="n">_mut</span><span class="o">&gt;</span><span class="p">]()</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">);</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用它来生成节点包装 <code class="language-plaintext highlighter-rouge">Node</code> 的属性访问的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro_bpt!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">entries</span><span class="p">,</span> <span class="n">children</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="实现-基础方法">实现-&gt;基础方法</h2>

<h3 id="搜索到叶子节点">搜索到叶子节点</h3>

<p>和 B 树的节点上的递归搜索方法一样，只是当在中间节点遇到相等的键时不是直接退出而是在它的右孩子上继续搜索。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">search_to_leaf</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询节点属性">查询节点属性</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_internal</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nd">attr!</span><span class="p">(</span><span class="k">self</span> <span class="p">|</span> <span class="k">self</span><span class="p">)</span><span class="nf">.is_leaf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">min_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">entries!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.first</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小最大节点">最小/最大节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">min_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">max_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">x</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="创建节点包装">创建节点包装</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">kv</span><span class="p">|</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="c1">// overflow is M</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
        <span class="n">entries</span><span class="nf">.push</span><span class="p">(</span><span class="nf">KVEntry</span><span class="p">(</span><span class="nv">$k</span><span class="p">,</span> <span class="nv">$v</span><span class="p">));</span>

        <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="n">entries</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">())</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">leaf</span><span class="p">|</span> <span class="nv">$entries:expr</span><span class="p">,</span> <span class="nv">$succ:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Leaf</span> <span class="p">{</span>
            <span class="n">entries</span><span class="p">:</span> <span class="nv">$entries</span><span class="p">,</span>
            <span class="n">succ</span><span class="p">:</span> <span class="nv">$succ</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="n">basic</span><span class="o">-</span><span class="n">internal</span><span class="p">|</span> <span class="nv">$keys:expr</span><span class="p">,</span> <span class="nv">$children:expr</span><span class="p">,</span> <span class="nv">$paren:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="nd">aux_node!</span><span class="p">(</span><span class="n">FREE</span><span class="o">-</span><span class="n">ENUM</span> <span class="n">Internal</span> <span class="p">{</span>
            <span class="n">keys</span><span class="p">:</span> <span class="nv">$keys</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="nv">$children</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nv">$paren</span>
        <span class="p">})</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-简单方法">实现-&gt;简单方法</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"M should be greater than 2"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.get_mut</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="c1">// Nil</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// Leaf</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>

            <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-范围查询">实现-&gt;范围查询</h2>

<p>使用前面二叉搜索树里的 <code class="language-plaintext highlighter-rouge">mut_self</code> 宏来少些一点儿代码</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.select_mut</span><span class="p">(</span><span class="n">range</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="o">&amp;*</span><span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">select_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">Q</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* find start_node */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">());</span>

                <span class="c1">// Nil</span>
                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="c1">// Leaf</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                        <span class="nf">Err</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
                    <span class="p">};</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_node</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">==</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_generator</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="n">idx</span><span class="o">..</span><span class="p">];</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">ent</span> <span class="k">in</span> <span class="n">entries</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">range</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ent</span><span class="na">.1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">cur</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">entries</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">cur</span><span class="p">)[</span><span class="o">..</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-插入">实现-&gt;插入</h2>

<h3 id="插入主流程">插入主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">search_to_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.insert_into_leaf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">insert_into_leaf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* NonInternal Node */</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="nf">.is_internal</span><span class="p">());</span>

        <span class="cm">/* Nil */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">kv</span> <span class="p">|</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* Leaf */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="cm">/* insert into leaf */</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nf">KVEntry</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点提升方法">节点提升方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">promote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="cm">/* split node */</span>

        <span class="k">let</span> <span class="n">lpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_floor</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">M</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">head_key</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x2</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="c1">// keep key for leaf</span>
            <span class="k">let</span> <span class="n">entries_x2</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">lpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="n">entries_x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">leaf</span> <span class="p">|</span> <span class="n">entries_x2</span><span class="p">,</span>
                <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.downgrade</span><span class="p">(),</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">keys_x2</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">head_key</span> <span class="o">=</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">children_x2</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">hpos</span><span class="p">);</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span>
                <span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys_x2</span><span class="p">,</span>
                <span class="n">children_x2</span><span class="p">,</span>
                <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* push new level */</span>
        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">keys</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">head_key</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>

            <span class="k">self</span><span class="py">.root</span> <span class="o">=</span>
                <span class="nd">node!</span><span class="p">(</span><span class="n">basic</span> <span class="o">-</span> <span class="n">internal</span> <span class="p">|</span> <span class="n">keys</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>

            <span class="nd">children_revref!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* insert into paren node */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span><span class="p">,</span> <span class="n">head_key</span><span class="p">);</span>
            <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="nd">paren!</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">p</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.promote</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-删除">实现-&gt;删除</h2>

<p>这里特别需要注意的是，</p>

<h3 id="删除主流程">删除主流程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.root</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">k_</span><span class="p">|</span> <span class="n">k_</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="nf">.is_none</span><span class="p">());</span>
                    <span class="n">internal_and_idx</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">));</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">idx</span><span class="p">;</span>
        <span class="k">match</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="n">ent</span><span class="na">.0</span><span class="nf">.borrow</span><span class="p">())</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx_</span><span class="p">,</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.remove_on_leaf</span><span class="p">(</span><span class="n">internal_and_idx</span><span class="p">,</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>    

	<span class="k">fn</span> <span class="nf">remove_on_leaf</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">internal_and_idx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* Update internal key with its succsessor key */</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">internal_and_idx</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_internal_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal</span><span class="p">,</span> <span class="n">i_idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.remove_retracing</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">popped</span><span class="na">.0</span><span class="p">,</span> <span class="n">popped</span><span class="na">.1</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新索引">更新索引</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_internal_key</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">internal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">i_idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_leaf</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">p</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">new_key</span><span class="p">;</span>

        <span class="k">if</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x_idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

            <span class="cm">/* check remain node */</span>

            <span class="c1">// left first</span>
            <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="c1">// right sib</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="cm">/* use default (left first)*/</span>
            <span class="k">else</span> <span class="k">if</span> <span class="n">x_idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">x_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.max_key</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">internal</span><span class="p">)[</span><span class="n">i_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="节点下降">节点下降</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">unpromote</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1">// Exclude leaf node and nil node</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>
        <span class="nd">debug_assert!</span><span class="p">(</span>
            <span class="n">x</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">||</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">merge_node!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// pop new level</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.unpromote</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尝试重平衡">尝试重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_rebalancing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="cm">/* Check if siblings has remains */</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child_by_rc!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

        <span class="c1">// Left first</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">try_node_redistribution!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Err</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">try_node_redistribution</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$idx:expr</span><span class="p">,</span> <span class="nv">$sib_dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$p</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nv">$idx</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="nv">$sib_dir</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span> <span class="n">left</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">right</span> <span class="p">};</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// sib is right</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span>
                    <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">);</span>

                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">right</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">sib</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sib_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="nf">replace</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">);</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">right</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nf">replace</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="k">mut</span> <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span>
                    <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">));</span>

                <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="合并节点">合并节点</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="cd">/// (parent, left-idx)</span>
    <span class="k">fn</span> <span class="nf">merge_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">children</span> <span class="o">=</span> <span class="nd">children!</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// for leaf node</span>
        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="nd">entries_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">entries_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// update succ</span>
            <span class="nd">succ!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="c1">// update pred</span>
            <span class="k">if</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">pred!</span><span class="p">(</span><span class="nd">succ!</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="c1">// update max_node</span>
            <span class="k">if</span> <span class="n">right</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.max_node</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
                <span class="c1">// update max_node</span>
                <span class="k">self</span><span class="py">.max_node</span> <span class="o">=</span> <span class="n">left</span><span class="nf">.downgrade</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// for internal node</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.push</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
            <span class="nd">keys_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">keys_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">));</span>

            <span class="c1">// merge right's children to the left</span>
            <span class="k">let</span> <span class="n">left_children</span> <span class="o">=</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="nd">children_mut!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="nf">.drain</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">left</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="n">left_children</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// remove right from p</span>
        <span class="nd">children_mut!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现-测试">实现-&gt;测试</h2>

<h3 id="打印方法">打印方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
	<span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="cm">/* print header */</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="cm">/* print body */</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

                    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"({i:02}): {x:?} (p: [{p:?}])"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">succ</span> <span class="o">=</span> <span class="nd">succ!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                        <span class="nd">writeln!</span><span class="p">(</span>
                            <span class="n">f</span><span class="p">,</span>
                            <span class="s">"({i:02}): {x:?} (p: [{p:?}], succ: [{succ:?}])"</span>
                        <span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
            <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="性质校验">性质校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>  
    <span class="k">fn</span> <span class="nf">validate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

        <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">vecdeq</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()]];</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">cur_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="nd">vecdeq!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">leaf_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">internal_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">group</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">assert!</span><span class="p">(</span><span class="n">child</span><span class="nf">.is_some</span><span class="p">());</span>

                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_internal</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nd">assert_eq!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">(),</span>
                            <span class="s">"{child:?}"</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">,</span>
                            <span class="s">"{child:?}: {}"</span><span class="p">,</span>
                            <span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                        <span class="p">);</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_high_bound</span><span class="p">()</span>
                        <span class="p">);</span>
                    <span class="p">}</span>

                    <span class="c1">// Exclude leaf</span>
                    <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                                <span class="nd">assert_eq!</span><span class="p">(</span>
                                    <span class="nd">keys!</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                                    <span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span>
                                <span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">leaf_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Exclude the root (which is always one when it's internal node)</span>
                        <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span>
                                <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span>
                                    <span class="o">&gt;=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">entries_low_bound</span><span class="p">()</span>
                            <span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="cm">/* search obsoleted key */</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">leaf</span> <span class="o">=</span> <span class="nd">search_to_leaf!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                            <span class="k">if</span> <span class="n">leaf</span><span class="nf">.is_none</span><span class="p">()</span>
                                <span class="p">||</span> <span class="nd">entries!</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="nf">.binary_search_by_key</span><span class="p">(</span>
                                    <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="p">|</span><span class="n">ent</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">ent</span><span class="na">.0</span>
                                <span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span>
                            <span class="p">{</span>
                                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Found obsoleted key: {k:?}"</span><span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">internal_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_children</span> <span class="o">=</span>
                            <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">children!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="n">nxt_children</span><span class="nf">.push_front</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                        <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">nxt_children</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// All leaves are in same level</span>
                <span class="nd">assert!</span><span class="p">(</span>
                    <span class="n">leaf_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">internal_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s">"leaf: {leaf_num}, internal: {internal_num}"</span>
                <span class="p">);</span>

                <span class="c1">// Ordered</span>
                <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">last_child</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.pop_back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">group</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">child</span><span class="nf">.is_leaf</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">entries!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">keys!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="nf">.is_sorted</span><span class="p">());</span>
                        <span class="p">}</span>

                        <span class="k">let</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="nd">last_key!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                        <span class="k">let</span> <span class="n">branch_key</span> <span class="o">=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                        <span class="nd">assert!</span><span class="p">(</span>
                            <span class="n">child_max_key</span> <span class="o">&lt;</span> <span class="n">branch_key</span><span class="p">,</span>
                            <span class="s">"child: {child_max_key:?}, branch:{branch_key:?}"</span>
                        <span class="p">);</span>

                        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="nd">assert!</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="nd">assert!</span><span class="p">(</span><span class="nd">last_key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nd">key!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_child</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">cur_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这是等价转换后的说法，原始说法是所有的节点都只保留键，而在底部额外加一层数据节点 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>反证法，如果那个左键与叶子节点上的不相等，那么那个左键就找不到对应的键值了 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。]]></summary></entry><entry><title type="html">单词与短语</title><link href="/oth/WordAndPhase.html" rel="alternate" type="text/html" title="单词与短语" /><published>2023-02-27T00:00:00+08:00</published><updated>2023-02-27T00:00:00+08:00</updated><id>/oth/WordAndPhase</id><content type="html" xml:base="/oth/WordAndPhase.html"><![CDATA[<h2 id="a">A</h2>

<h3 id="a-grinding-halt">a grinding halt</h3>

<p>陷入停顿</p>

<ol>
  <li>Memory-hogging programs can deplete the system’s memory, bringing the whole system to <strong>a grinding halt</strong>.</li>
</ol>

<h2 id="b">B</h2>

<h3 id="bimodal">Bimodal</h3>

<p>Bi-Modal</p>

<p>双峰</p>

<ol>
  <li>The distribution is <strong>bimodal</strong>, with the dark line at the bottom showing that many disk I/O completed with sub-millisecond latency: cache hits.</li>
</ol>

<h2 id="c">C</h2>

<h3 id="contemporary">Contemporary</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈtempəˌrerē/</code></p>

<p>当代的</p>

<ol>
  <li>Such devices are hard to find on <strong>contemporary</strong> computers.</li>
</ol>

<h3 id="consensus">Consensus</h3>

<p><code class="language-plaintext highlighter-rouge">/kənˈsensəs/</code></p>

<p>noun</p>

<p>共识</p>

<ol>
  <li>However, it may take some time to come to a <strong>consensus</strong> on a final control solution.</li>
</ol>

<h3 id="coincide">Coincide</h3>

<p>` /ˌkoʊ.ɪnˈsaɪd/`</p>

<p>v.</p>

<p>吻合的</p>

<ol>
  <li>And the recursion ends, whenever the boundaries of the current query segment <strong>coincides</strong> with the boundaries of the segment of the current vertex.</li>
</ol>

<h3 id="coefficient">Coefficient</h3>

<p><code class="language-plaintext highlighter-rouge">/ˌkoʊ.ɪˈfɪʃ.ənt/</code></p>

<p>n.</p>

<p>系数</p>

<ol>
  <li>Extended Euclidean algorithm also finds integer coefficients x and y such that: ax + by = gcd(a, b)</li>
</ol>

<h2 id="d">D</h2>

<h3 id="deplete">Deplete</h3>

<p><code class="language-plaintext highlighter-rouge">/dəˈplēt/</code></p>

<p>verb</p>

<p>耗尽</p>

<ol>
  <li>Memory-hogging programs can <strong>deplete</strong> the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h3 id="dedicate">Dedicate</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkāt/</code></p>

<p>v.</p>

<p>奉献</p>

<h3 id="dedicated">Dedicated</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈdedəˌkādəd/</code></p>

<p>adj</p>

<p>专用的</p>

<p>This enables batch managers monitoring jobs running in <strong>dedicated</strong> cpusets to efficiently detect what level of memory pressure that job is causing.</p>

<h3 id="deem">Deem</h3>

<p><code class="language-plaintext highlighter-rouge">/diːm/</code></p>

<p>v.</p>

<p>视为</p>

<p>That BPF code is compiled to BPF byte code and then sent to the kernel, where a verifier may reject it if it is <strong>deemed</strong> unsafe.</p>

<h2 id="e">E</h2>

<h2 id="f">F</h2>

<h2 id="g">G</h2>

<h3 id="grity">Grity</h3>

<p>adj. 粗糙的</p>

<p>adj. 真实的（困难、不愉快）</p>

<ol>
  <li>This example is a little <strong>gritty</strong>, which is both good (realistic) and bad (intimidating).</li>
</ol>

<p>adj. 勇敢、坚韧的</p>

<h2 id="h">H</h2>

<h3 id="hog">Hog</h3>

<p><code class="language-plaintext highlighter-rouge">/hôɡ,häɡ/</code></p>

<p>verb</p>

<p>抢占</p>

<ol>
  <li><strong>Memory-hogging</strong> programs can deplete the system’s memory, bringing the whole system to a grinding halt.</li>
</ol>

<h3 id="hyposize">Hyposize</h3>

<p>(UK, hyposise)</p>

<p><code class="language-plaintext highlighter-rouge">/haɪˈpɑː.θə.saɪz/</code></p>

<p>v.</p>

<p>假设</p>

<ol>
  <li><strong>Hypothesize</strong> that the issue is with that component</li>
</ol>

<h2 id="i">I</h2>

<h3 id="imminent">Imminent</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈimənənt/</code></p>

<p>adj</p>

<p>迫在眉睫的</p>

<ol>
  <li>This can include the cgroup oom notifier behavior when a collection of tasks is completely out of memory, but can also warn when such a condition may be <strong>imminent</strong>.</li>
</ol>

<h3 id="initiative">Initiative</h3>

<p><code class="language-plaintext highlighter-rouge">/iˈniSHədiv/</code></p>

<p>n.</p>

<p>积极性、倡议</p>

<ol>
  <li>these new <strong>initiatives</strong> of offering better control to the user in selecting the process to be the sacrificial lamb are steps to a robust design to give more control to the user.</li>
</ol>

<h3 id="intimidating">Intimidating</h3>

<p><code class="language-plaintext highlighter-rouge">/ɪnˈtɪm.ɪ.deɪ.tɪŋ/</code></p>

<p>adj.</p>

<p>令人紧张的</p>

<ol>
  <li>This example is a little gritty, which is both good (realistic) and bad (<strong>intimidating</strong>).</li>
</ol>

<h3 id="involuntary">Involuntary</h3>

<p>adj.</p>

<p>被迫地</p>

<p>vs voluntary（adj. 自愿地）</p>

<p>vs volunteer（n. 志愿者）</p>

<ol>
  <li>Threads can leave CPU for a number of reasons, including I/O and locks, but also some that are unrelated to the current thread’s execution, including <strong>involuntary</strong> context switching due to high demand for CPU resources, and interrupts.</li>
</ol>

<h2 id="j">J</h2>

<h2 id="k">K</h2>

<h3 id="keep-account-of">keep account of</h3>

<p>记录</p>

<ol>
  <li>This chapter describes the structures used to <strong>keep account of</strong> memory banks, pages and the flags that affect VM behaviour.</li>
</ol>

<h2 id="l">L</h2>

<h3 id="laborious">Laborious</h3>

<p><code class="language-plaintext highlighter-rouge">/ləˈbɔːr.i.əs/</code></p>

<p>adj.</p>

<p>费时的</p>

<ol>
  <li>Compared to bpftrace, bcc Python is far more verbose and <strong>laborious</strong> to code.</li>
</ol>

<h2 id="m">M</h2>

<h3 id="metric">Metric</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈmetrik/</code></p>

<p>adj</p>

<p>noun</p>

<p>（系统、标准）衡量</p>

<ol>
  <li>The memory_pressure of a cpuset provides a simple per-cpuset <strong>metric</strong> of the rate that the tasks in a cpuset are attempting to free up in use memory on the nodes of the cpuset to satisfy additional memory requests.</li>
</ol>

<h2 id="n">N</h2>

<h2 id="o">O</h2>

<h3 id="out-of-curiosity">out of curiosity</h3>

<p>出于好奇</p>

<ol>
  <li><strong>Out of curiosity</strong> I compiled both versions and ran objdump on the binaries, to see how many bytes were saved.</li>
</ol>

<h3 id="overlook">Overlook</h3>

<p>verb</p>

<p>忽视</p>

<ol>
  <li>The primary reason is that they have been run passively, “fire and forget” style, with no additional analysis, and all problems were <strong>overlooked</strong>.</li>
</ol>

<p>从上面看</p>

<h2 id="p">P</h2>

<h3 id="put-simply">put simply</h3>

<p>简单说</p>

<ol>
  <li><strong>Put simply</strong>, it costs less to balance between two smaller sched domains than one big one, but doing so means that overloads in one of the two domains won’t be load balanced to the other one.</li>
</ol>

<h3 id="proper">Proper</h3>

<p>adj</p>

<p>正确的</p>

<p>合适的</p>

<ol>
  <li>Active benchmarking helps you accurately test the true target of the benchmark, and <strong>properly</strong> understand its results</li>
</ol>

<p>adv</p>

<ol>
  <li>令人满意地、正确地</li>
</ol>

<h3 id="properly">Properly</h3>

<p>adv</p>

<p>正确地</p>

<p>properly understand vs understand proper</p>

<h2 id="q">Q</h2>

<h2 id="r">R</h2>

<h3 id="rule-out">rule out</h3>

<p>排除</p>

<ol>
  <li>This approach can specify only one name at a time, <strong>ruling out</strong> the possibility of a hierarchy</li>
</ol>

<h2 id="s">S</h2>

<h3 id="substantial">Substantial</h3>

<p><code class="language-plaintext highlighter-rouge">/ˌsəbˈstan(t)SHəl/</code></p>

<p>adj</p>

<ol>
  <li>
    <p>相当数量的</p>
  </li>
  <li>
    <p>实质性的</p>
  </li>
  <li>
    <p>This policy can provide <strong>substantial</strong> improvements for jobs that need to place thread local data on the corresponding node</p>
  </li>
</ol>

<h3 id="stall">Stall</h3>

<p><code class="language-plaintext highlighter-rouge">/stôl/</code></p>

<p>n.</p>

<p>（市场）摊位、隔间</p>

<p>（马厩、谷仓中动物的）隔间</p>

<p>verb</p>

<p>（引擎）停止运行</p>

<ol>
  <li>It’s intended to be simple, minimizing variation caused by cache misses, <strong>stall cycles</strong>, and branch misprediction.</li>
</ol>

<p>停滞（取得进展）</p>

<h3 id="saturation">Saturation</h3>

<p>` /ˌsætʃ.əˈreɪ.ʃən/`</p>

<p>n.</p>

<p>饱和度</p>

<p>check for the degree of <strong>saturation</strong> using the “r” column.</p>

<h2 id="t">T</h2>

<h3 id="tame">Tame</h3>

<p><code class="language-plaintext highlighter-rouge">/tām/</code></p>

<p>adj 温顺的</p>

<p>verb 驯服</p>

<ol>
  <li>This calls for a different design to <strong>tame</strong> the OOM killer.</li>
</ol>

<h2 id="u">U</h2>

<h3 id="utilize">Utilize</h3>

<p><code class="language-plaintext highlighter-rouge">/ˈyo͞odlˌīz/</code></p>

<p>v.</p>

<p>利用</p>

<p>underutilize 未利用</p>

<ol>
  <li>If one CPU is <strong>underutilized</strong>, kernel code running on that CPU will look for tasks on other more overloaded CPUs and move those tasks to itself,</li>
</ol>

<h3 id="underearth">UnderEarth</h3>

<p>` /ʌnˈɜːθ/`</p>

<p>v.</p>

<p>发掘</p>

<ol>
  <li>It tours various bcc tools to analyze different targets, which may <strong>unearth</strong> activity you were previously unaware of.</li>
</ol>

<h2 id="v">V</h2>

<h2 id="w">W</h2>

<h2 id="x">X</h2>

<h2 id="y">Y</h2>

<h2 id="z">Z</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[A]]></summary></entry></feed>