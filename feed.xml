<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-06-18T12:16:54+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">0850 - Rectangle Area II</title><link href="/oth/LeetCode0850.html" rel="alternate" type="text/html" title="0850 - Rectangle Area II" /><published>2023-06-11T00:00:00+08:00</published><updated>2023-06-11T00:00:00+08:00</updated><id>/oth/LeetCode0850</id><content type="html" xml:base="/oth/LeetCode0850.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/rectangle-area-ii/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>要求矩形覆盖的面积，在做了<a href="/oth/LeetCode0218.html">天际线问题</a>和<a href="/oth/LeetCode0391.html">完美矩形问题</a>后，这个问题的思路就看得非常清楚了，只需要沿着某一轴扫描，计算在另一轴上覆盖的长度，计算的时机是遇到每个矩形的入边或者出边的（重复的不算），这样拆分成一个个小矩形，就得到了覆盖的面积和。</p>

<p>于是问题的关键，不妨以 $x$ 轴为扫描方向，就在于如何动态地计算 $y$ 轴上的覆盖长度。</p>

<p>由于本题的限制相当宽松，建筑的数量最多只到 $200$ ，因此可以允许其他非最优解的多种复杂度的方法。</p>

<h2 id="解">解①：</h2>

<p>在 $y$ 轴，对每个矩形竖直的边，$[y_1, y_2]$ ，把边的开始位置 $y_1$，标记 $1$ ，它的结束位置标记 $-1$ ，把这些标记按照 $y$ 轴上的坐标进行排序，对这些标记进行累加，最后的和一定是 $0$ ，它的变化过程一定是从 $0$ 到正值再到 $0$ ，每一次归 $0$ 就意味着一条线段的结束，把这些分离的线段累加起来，这就得到了此时的 $y$ 轴上的线段和。</p>

<p>由于每次扫描都需要排序并重新装填 $y$ 坐标，因此总的时间复杂度为 $O(n\cdot (n\text{log}n + n)) = O(n^2\text{log}n)$ 。</p>

<p>这有可以优化的地方，如果提前把 $y$ 轴离散化，就可以直接做坐标-排名的映射，就不需要每次都排序 $y$ 坐标，于是就只剩下装填所有的 $y$ 坐标的成本，时间复杂度就可以降低为 $O(n^2)$ 。</p>

<h2 id="解-1">解②：</h2>

<p>更直接地，把 $x$ 轴坐标也离散化，与离散化地 $y$ 轴坐标构成二维数组，每个矩形（的 $4$ 个顶点）在这个二维数组上映射，然后扫描这个二维数组计算面积。</p>

<p>时间复杂度是离散化+矩形映射+统计： $O(n\text{log}n + n + n^2)$  = $O(n^2)$</p>

<h2 id="解-2">解③：</h2>

<p>上述地算法之所以不够优，关键在于每扫描到一个位置，就要用至少 $O(n)$ 的时间复杂度装填 $y$ 坐标，而拿到这道题目后，第一眼可以看出，我们应该可以用前面的分段树或者树状数组来在 $O(\text{log}n)$ 的时间内装填 $y$ 坐标。</p>

<p>这看起来非常简单，但是，但是，在开始写的时候，才发现这道题并不如想象中那么简单，它有别于<a href="/oth/LeetCode0218.html">天际线那道题</a>的关键是建筑都是连续的，不存在从半空中开始涨起，而矩形没有这个性质，它在 $y$ 轴上的排列可能是不连续的。</p>

<h3 id="线段的取消">线段的取消</h3>

<p>这样的话似乎只能在 y 轴空间上存储整个线段，但是如何在矩形结束的时候准确撤销它所属的线段呢？ 但是分段树可以按照区间<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> 额外存储该区间边的数量，这样在新的边加入时，更新的时候把它覆盖的区间的边的数量增 $1$ ，取消边的时候就把区间的边的数量减 $1$ ，在二分区间向下更新的时候，如果某个区间的边数不为零，那么这个区间的值就是它代表的整个线段的长度，否则，就要由子区间的值求和得到。</p>

<p>这样分段树全区间的值，就是 $y$ 轴上线段的总长度。</p>

<h3 id="区间的表示">区间的表示</h3>

<p>以为解决了边的添加和取消就完事大吉了吗？，不，还有很大的问题：如果分段树上每个点对应某个坐标，就像习惯得那样，这就面临坐标划分与区间划分二者不一致的问题，对于用坐标表示的边来说，坐标是可重叠的，而分段树的区间划分两端是不可重叠的。举例说，对于 [0, 2] 的边的划分，按照坐标来说就是 $[0, 1]$ 和 $[1, 2]$ ，而按照区间划分则为 $[0,1]$ 和 $[2, 2]$ 。</p>

<p>这实在是不好解决，因为分段树上 $[a, b]$ 的区间不能表示为坐标上 $[a, b]$ 的边，必须寻找一个新的与分段树区间划分一致地表示。于是我们可以考虑坐标可以重叠，但是区间不会重叠，可以定义标号 $i$ 表示坐标从 $[i, i+1]$ 的区间，这样分段树上的 $[a, b]$ 就不再表示坐标 $[a, b]$ 的边，而是标号 $a$~$b$ ，一共 $b-a+1$ 个单位区间的和，这样问题就解决了！</p>

<h3 id="取模与数据类型">取模与数据类型</h3>

<p>最后由于计算结果过大，需要对结果取模，其中模数给得是 $10^9+7$ ，是个质数，这有什么说法吗？</p>

<p>质数取模得可以想到的是中国剩余定理，如果一个一元线性同余<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>方程的模数两两互质，那么这个方程是有解的而且可以构造出来，但它显然和我们这里没什么关系，事实上可以取任何一个大小符合条件的数，至于质不质地也没什么关系。</p>

<p>至于取模运算本身倒是（对我们有用的）运算性质：</p>

\[\begin{array}{l}
&amp;a \cdot b\pmod{N} &amp;\equiv (a\pmod{N} \cdot b\pmod{N})\pmod{N}\\
&amp;(a+b) \pmod{N} &amp;\equiv (a\pmod{N} + b\pmod{N})\pmod{N}
\end{array}{}\]

<p>另外需要吐槽得是本题 LeetCode 习惯性地给出的 <code class="language-plaintext highlighter-rouge">i32</code> 类型就不适当，它在例题上，在对结果取模前就数值溢出了，你必须手动把它提到更大的整数类型上。</p>

<h3 id="统一排序">统一排序</h3>

<p>由于在每个不同坐标的矩形的进入或离开时都要计算面积，因此像之前把入边和出边分开保存排序的做法<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>会让代码显得很冗余吗，于是直接把 $x$ 坐标、入边出边的类型标记和 $y$ 轴两坐标，构成一个 $4$ 元组，统一排序。</p>

<h3 id="rust-实现">Rust 实现<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></h3>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.3/0850_rectangle_area_2">源代码</a></p>

<h4 id="分段树">分段树</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SegmentTree</span> <span class="p">{</span>
    <span class="cd">/// (coverd edges number, range_sum)</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">y_end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="cd">/// DFS 型</span>
<span class="k">impl</span> <span class="n">SegmentTree</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">y_data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">y_end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">SegmentTree</span> <span class="p">{</span>
            <span class="c1">// numbers of interval units</span>
            <span class="n">data</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">(</span><span class="n">y_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">y_end</span><span class="p">,</span>
            <span class="n">y_data</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">mark</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.y_end</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mark</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">mark</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">sub_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sub_len</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">mark</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.y_data</span><span class="p">[</span><span class="n">tr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">self</span><span class="py">.y_data</span><span class="p">[</span><span class="n">tl</span><span class="p">])</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">tl</span> <span class="o">!=</span> <span class="n">tr</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">]</span><span class="na">.1</span> <span class="o">+</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">]</span><span class="na">.1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.1</span> <span class="k">as</span> <span class="nb">i32</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">y_end</code> 指得是原坐标的排名，加一后的值，表示总共排名的数量或者总的不同 $y$ 坐标的数量。内部构成的区间数应该比总的不同 $y$ 坐标数少一。</p>

<h4 id="完整过程">完整过程</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">cmp</span><span class="p">::{</span><span class="n">max</span><span class="p">,</span> <span class="n">min</span><span class="p">},</span>
    <span class="nn">collections</span><span class="p">::{</span><span class="n">BTreeSet</span><span class="p">,</span> <span class="n">HashMap</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">1_000_000_000</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">rectangles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">y_map</span><span class="p">)</span> <span class="o">=</span> <span class="nf">build_y_discrezation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rectangles</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">lines</span> <span class="o">=</span> <span class="nf">build_x_lines</span><span class="p">(</span><span class="n">rectangles</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_map</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">SegmentTree</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">y_map</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="k">in</span> <span class="n">lines</span> <span class="p">{</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">x0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">tree</span><span class="nf">.sum</span><span class="p">();</span>

            <span class="n">acc</span> <span class="o">+=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u64</span> <span class="o">*</span> <span class="n">h</span> <span class="k">as</span> <span class="nb">u64</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span><span class="p">;</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tree</span><span class="nf">.update</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ty</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="p">(</span><span class="n">acc</span> <span class="k">as</span> <span class="nb">u64</span> <span class="o">%</span> <span class="n">M</span><span class="p">)</span> <span class="k">as</span> <span class="nb">i32</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">build_y_discrezation</span><span class="p">(</span><span class="n">rectangles</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">rec</span> <span class="k">in</span> <span class="n">rectangles</span> <span class="p">{</span>
        <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="p">(</span>
        <span class="n">set</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
        <span class="n">set</span><span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">))</span>
            <span class="nf">.collect</span><span class="p">(),</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">build_x_lines</span><span class="p">(</span>
    <span class="n">rectangles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">y_map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">rectangles</span><span class="nf">.len</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">rec</span> <span class="k">in</span> <span class="n">rectangles</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">y1</span> <span class="o">=</span> <span class="o">*</span><span class="n">y_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rec</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">*</span><span class="n">y_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rec</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="n">lines</span><span class="nf">.push</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">));</span>  <span class="c1">// 0  true for enter</span>
        <span class="n">lines</span><span class="nf">.push</span><span class="p">((</span><span class="n">x2</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">));</span> <span class="c1">// 1  false for exit</span>
    <span class="p">}</span>

    <span class="n">lines</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">lines</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>用树状数组好像也不好解决这个问题 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>同余就是余数相同的意思 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>为了理论上减少排序的负担 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>就像前面吐槽用 Python 主要是因为它足够慢，足够缺少优化，这个 Rust 实现运行基本在 0-2 ms，内存 2.x MB，很难说有测量比较的意义 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">1851 - Minimum Level to Include</title><link href="/oth/LeetCode1851.html" rel="alternate" type="text/html" title="1851 - Minimum Level to Include" /><published>2023-06-11T00:00:00+08:00</published><updated>2023-06-11T00:00:00+08:00</updated><id>/oth/LeetCode1851</id><content type="html" xml:base="/oth/LeetCode1851.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/minimum-interval-to-include-each-query/description/">问题描述</a></p>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.4/1851_minimum_interval/rs1851">源代码</a></p>

<h2 id="破题">破题</h2>

<h3 id="一般性思路">一般性思路</h3>

<p>看起来像是区间上的查询问题，而分段树总是可以解决这样的问题。</p>

<p>用区间的长度表示一个区间的值，重叠部分取最小值，离散化区间坐标后建树，这些都是容易的，但问题是，对每次查询的值又要对它使用哪个或哪些离散化的坐标的查询结果进行表示？</p>

<h4 id="不可能的在线查询">不可能的在线查询</h4>

<p>一开始我的考虑是如果对查询的值在区间坐标上做二分查找，如果成功的话就用那个找到的坐标在树上查询，如果失败的话就比较左右两个临近坐标的是区间的结束还是开始，但是这样也无法正确解决问题，因为左右两个坐标是区间取得到的，它的结果可能是多个区间重叠得到的，而在查询值的位置其中决定最小值的区间可能已经结束了，此时查询值就取到了错误的值。</p>

<p>只能把区间值和查询值一并离散化，然后直接查询，详见解①。</p>

<h3 id="离线思路">离线思路</h3>

<p>在实现完分段树版本后就在考虑，有没有树状数组的实现？ 按照一般思路这是难以想象的，但是这个过程中意识到既然所有的查询都是提前已知的，那么完全可以做离线查询，如果把查询值进行排序，按照顺序进行扫描，<strong>这不就完全回到了<a href="/oth/LeetCode0218.html">天际线问题</a> ?！</strong> 而这个思路也就是扫描线的思路。</p>

<p>对应有树状数组的解② 和 优先级队列的解③</p>

<h2 id="解">解①：</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">cmp</span><span class="p">::{</span><span class="n">max</span><span class="p">,</span> <span class="n">min</span><span class="p">},</span>
    <span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.cloned</span><span class="p">()</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="n">queries</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">())</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">data</span><span class="nf">.sort_unstable</span><span class="p">();</span>
    <span class="n">data</span><span class="nf">.dedup</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">data_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">data</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.cloned</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">SegmentTree</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">data_map</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">for</span> <span class="n">interval</span> <span class="k">in</span> <span class="n">intervals</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">data_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">data_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="n">tree</span><span class="nf">.update</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">queries</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">for</span> <span class="n">q</span> <span class="k">in</span> <span class="n">queries</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">tree</span><span class="nf">.query</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">combine</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$inplace</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="nv">$inplace</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="nv">$val</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nv">$inplace</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="nv">$inplace</span> <span class="o">=</span> <span class="nv">$val</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// DFS 型</span>
<span class="k">struct</span> <span class="n">SegmentTree</span> <span class="p">{</span>
    <span class="cd">/// range update</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">range_end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SegmentTree</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">range_end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">range_end</span> <span class="o">*</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">range_end</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.range_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">update_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="p">{</span>
            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">sub_len</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sub_len</span><span class="p">;</span>

            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">],</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">],</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.update_</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.range_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">sub_len</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sub_len</span><span class="p">;</span>

            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">],</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">],</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="k">let</span> <span class="n">lv</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">rv</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">rv</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">rv</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">lv</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nf">min</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>这道题的输入数据和查询数据都有相当的规模，区间数量有 $10^5$ ，查询数量有 $10^7$，这对性能还是有一定要求的，</p>

<p>运行时间： $250$ ms</p>

<h2 id="解-1">解②：</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="k">mut</span> <span class="n">intervals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">intervals</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">queries</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">queries</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">queries</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.0</span><span class="p">)</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="n">intervals</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">data</span><span class="nf">.sort_unstable</span><span class="p">();</span>
    <span class="n">data</span><span class="nf">.dedup</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">data_map</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">data</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.cloned</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">bit</span> <span class="o">=</span> <span class="nn">FakeBIT</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">data_map</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">queries</span><span class="nf">.len</span><span class="p">()];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev_q_raw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev_ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">q_raw</span><span class="p">,</span> <span class="n">q_idx</span><span class="p">)</span> <span class="k">in</span> <span class="n">queries</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">prev_q_raw</span> <span class="o">==</span> <span class="n">q_raw</span> <span class="p">{</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">q_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_ans</span><span class="p">;</span>

            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">data_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_raw</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">q_raw</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">q_raw</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">bit</span><span class="nf">.add</span><span class="p">(</span><span class="o">*</span><span class="n">data_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">bit</span><span class="nf">.suffix</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="k">if</span> <span class="n">suffix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">suffix</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

        <span class="n">ans</span><span class="p">[</span><span class="n">q_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>

        <span class="n">prev_q_raw</span> <span class="o">=</span> <span class="n">q_raw</span><span class="p">;</span>
        <span class="n">prev_ans</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">combine</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$inplace</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="nv">$inplace</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="nv">$val</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nv">$inplace</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="nv">$inplace</span> <span class="o">=</span> <span class="nv">$val</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">range</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">(((</span><span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">((</span><span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">))</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">FakeBIT</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FakeBIT</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">range_end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">range_end</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">addend</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">addend</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nd">range!</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">-=</span> <span class="nd">range!</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// query i</span>
    <span class="k">fn</span> <span class="nf">suffix</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">combine!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">acc</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="nd">range!</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">acc</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>本实现对树状数组的活用的具体解释在<a href="/oth/LeetCode0218.html">天际线问题</a>的相关章节里。</p>

<p>运行时间：$115$ ms</p>

<h2 id="解-2">解③：</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">,</span> <span class="nn">cmp</span><span class="p">::</span><span class="n">Reverse</span><span class="p">};</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="k">mut</span> <span class="n">intervals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">intervals</span><span class="nf">.sort_unstable_by_key</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">queries</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">queries</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">queries</span><span class="nf">.len</span><span class="p">()];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev_q_raw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prev_ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">heap</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">q_raw</span><span class="p">,</span> <span class="n">q_idx</span><span class="p">)</span> <span class="k">in</span> <span class="n">queries</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">prev_q_raw</span> <span class="o">==</span> <span class="n">q_raw</span> <span class="p">{</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">q_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_ans</span><span class="p">;</span>

            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>

            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">q_raw</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">q_raw</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">heap</span><span class="nf">.push</span><span class="p">(</span><span class="nf">PQE</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nf">Reverse</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="nf">PQE</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">*</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">q_raw</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">v</span><span class="na">.0</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">heap</span><span class="nf">.pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">ans</span><span class="p">[</span><span class="n">q_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>

        <span class="n">prev_q_raw</span> <span class="o">=</span> <span class="n">q_raw</span><span class="p">;</span>
        <span class="n">prev_ans</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>


<span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Ord)]</span>
<span class="k">struct</span> <span class="nf">PQE</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="n">Reverse</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">PQE</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.1</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="na">.1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>运行时间：$60$ ms ，beats 100%</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0391 - Perfect Rectangle</title><link href="/oth/LeetCode0391.html" rel="alternate" type="text/html" title="0391 - Perfect Rectangle" /><published>2023-06-08T00:00:00+08:00</published><updated>2023-06-08T00:00:00+08:00</updated><id>/oth/LeetCode0391</id><content type="html" xml:base="/oth/LeetCode0391.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/perfect-rectangle/description/">问题描述</a></p>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.2/0391_perfect_rectangle">源代码</a></p>

<h2 id="破题">破题</h2>

<p>求一个完美覆盖的矩形，首先想到的就是通过面积比较进行判断，也就是所有矩形的最右、最上、最左、最下4个坐标构成的矩形的面积是否等于各小矩形的面积之和。但是只有面积的比较还不足以证明是“完美覆盖”，因为面积相等还包括空隙和重叠并存的情况，必须要确保小矩形之间没有空隙或者没有覆盖。</p>

<p>在面积相等的情况下，如果小矩形之间有空隙，则必然还存在重叠，反之有重叠必然也有空隙，因此只要能检查任意空隙或者重叠任意一项即可。</p>

<h2 id="解扫描线">解①：扫描线</h2>

<p>说到重叠，就可以回到经典的扫描线+分段树/树状数组的解决方案：可以扫描一个维度然后在另一个维度上建树，利用数据结构做区间更新后的区间查询，以观察是否有重叠的边。</p>

<p>比如可以扫描 $x$ 轴，在 $y$ 轴上建树，每扫描到一个小矩形 $[x, y, a, b]$，就把它在 $y$ 轴上的区间 $[y, b]$ 更新到树上，在这个过程中检查 $[y, b]$ 是否完全未被覆盖，如果未完全未覆盖，意思是当前扫描线位置存在重叠的边，直接返回 <code class="language-plaintext highlighter-rouge">false</code>；当这个小矩形结束时，再把 $[y, b]$ 的更新取消，就这样扫描到最后一个小矩形，如果都没问题，就说明不存在重叠的情况。</p>

<h3 id="区间闭合性">区间闭合性</h3>

<p>前面讲对于小矩形 $[x, y, a, b]$ 更新 $y$ 轴上的区间 $[y, b]$ ，但这是不准确的，因为对于完美矩形，小矩形紧挨着的情况是正确的<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>而不是错误的，因此不能用两端闭合的区间表示，而需要用半闭半开区间，不妨用底部闭合顶部开放的区间<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup>，这样就是更新区间 $[y, b-1]$ 。</p>

<p>同样对于扫描线的 $x$ 轴来说，也需要半闭半开区间来容纳小矩形的边紧挨的情况。</p>

<h3 id="数据离散化和排序">数据离散化和排序</h3>

<p>照例，建树的那一轴，这里是 $y$ 轴，其上的数据需要离散化处理，但有点儿意外得是，给定的小矩形列表并没有按照任何一个轴来排序，这是什么用意呢，暗示了什么呢？暂且按下不表，我们这次要手动排序了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedList</span><span class="p">,</span> <span class="n">SortedSet</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isRectangleCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rectangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">rectangles</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">rectangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">y_data</span> <span class="o">=</span> <span class="n">SortedSet</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">y_data</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y_data</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">y_map</span> <span class="o">=</span> <span class="p">{</span> <span class="n">y</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_data</span><span class="p">)}</span>

    <span class="c1"># ...
</span></code></pre></div></div>

<p>$x$ 轴也要排序，在计算小矩形面积之和的遍历过程中顺便进行在线地对矩形的竖边按照 $x$ 坐标排序，理论上应当比完整列表上的排序快，$x$ 坐标分为了小矩形的入边和出边，分别用 <code class="language-plaintext highlighter-rouge">ent</code> 和 <code class="language-plaintext highlighter-rouge">ex</code> 表示<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c1"># ... def solve
</span>    
    <span class="n">area_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ent</span> <span class="o">=</span> <span class="n">SortedList</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ex</span> <span class="o">=</span> <span class="n">SortedList</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">area_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">y</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">y_map</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">y_map</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="n">ent</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">ex</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">del</span> <span class="n">y_map</span>
    
    <span class="c1"># ...
</span></code></pre></div></div>

<p>$x$ 轴和 $y$ 轴数据排序后就可以计算大矩形的面积，然后进行面积的比较</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c1"># ... def solve
</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">ent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_a</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">y_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_b</span> <span class="o">=</span> <span class="n">y_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cover_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_a</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_b</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">area_sum</span> <span class="o">!=</span> <span class="n">cover_area</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    
    <span class="c1"># ...
</span></code></pre></div></div>

<h3 id="解分段树">解⒈⒈：分段树</h3>

<p>分段树的如何赋值来表示一个区间的覆盖，这需要考虑。乍一看，好像只需要一个布尔类型的标记，赋值在对应的区间上就可以了，但是这样不能精确表示区间的覆盖程度，比如如果一个父区间下的某个子区间被覆盖了，那么这个父区间是被覆盖了还是没被覆盖？</p>

<p>于是（在更新的时候）我们使用区间的长度来赋值所覆盖区间，这样递归完成后向上更新父区间，到时候只要检查区间的值是否等于区间长度就可以判断该区间是否完全被覆盖，或者是否等于零，表示区间完全未被覆盖。</p>

<p>通过抛出异常传递区间存在重合的情况。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># ... def solve
</span>
    <span class="n">segtree</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>

    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ent</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">j_end</span> <span class="ow">and</span> <span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">segtree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">segtree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="s">"""DFS型"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">marked</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">range_len</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">range_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="s">"""It would raise when try to mark an occupied position"""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">range_len</span> <span class="o">=</span> <span class="n">tr</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># can't catch class don't inherrit from BaseException
</span>                <span class="c1"># however so what we could use except to catch
</span>                <span class="k">raise</span> <span class="s">"Occupied"</span>

            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_len</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">sub_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">val</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">range_len</span><span class="p">:</span>
                <span class="k">raise</span> <span class="s">"Occupied"</span>

            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">val</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">sub_l</span><span class="p">)</span>

            <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">marked</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">sub_l</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="解树状数组">解⒈⒉：树状数组</h3>

<p>是对树状数组做区间更新后的区间查询，标记区间就是区间里的每个位置的值加一，区间取消标记就是区间里每个位置的值加负一，于是可以通过查询区间和是否为零来测试区间是否有覆盖的情况。</p>

<p>具体算法的公式<a href="/algs/FenwickTree.html">这里</a>的有关章节已有详细介绍，就不再赘述。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># ... def solve
</span>    <span class="n">cobit</span> <span class="o">=</span> <span class="n">CoBIT</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">))</span>

    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ent</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">j_end</span> <span class="ow">and</span> <span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">cobit</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">ex</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">cobit</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">cobit</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">CoBIT</span><span class="p">:</span>
    <span class="s">"""Range Update &amp; Range Query"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">range_len</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">b2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">range_len</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="s">"""range add x for [l, r]"""</span>

        <span class="n">CoBIT</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">CoBIT</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b1</span><span class="p">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>

        <span class="n">CoBIT</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="n">CoBIT</span><span class="p">.</span><span class="n">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b2</span><span class="p">,</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">prefix</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">prefix</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CoBIT</span><span class="p">.</span><span class="n">_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">-</span> <span class="n">CoBIT</span><span class="p">.</span><span class="n">_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="n">bit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bit</span><span class="p">):</span>
            <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">_prefix</span><span class="p">(</span><span class="n">bit</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">+=</span> <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<h2 id="解顶点计数">解②：顶点计数</h2>

<p>扫描线思路是常规做法，但是回到前面埋下的伏笔：给出的小矩形列表没有按照任何一个轴的方向排序，实际上存在着不需要扫描线加区间查询的数据结构的更Tricky的做法。</p>

<p>可以通过统计每个点的出现次数，判断是否存在小矩形重叠的情况。</p>

<p>在面积相等情况下，重叠与否的充分必要条件是：如果点位于大矩形的四角，那么它们只能出现 $1$ 次；如果位于边上，只能出现 $2$ 次；如果位于其他位置，也就是大矩形内部，那么只能出现 $2$ 或 $4$ 次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isRectangleCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rectangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">rectangles</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">rectangles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">vertexs</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
    <span class="n">max_a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_b</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">area_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">max_a</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">max_b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">vertexs</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">vertexs</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">vertexs</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">vertexs</span><span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">area_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">y</span><span class="p">)</span>

    <span class="n">cover_area</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_a</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_b</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">area_sum</span> <span class="o">!=</span> <span class="n">cover_area</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">vertexs</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y0</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="n">max_b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y0</span> <span class="ow">in</span> <span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="n">max_b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>这里面 <code class="language-plaintext highlighter-rouge">Counter</code> 这个类比较甜，它实际上起到了一个提供默认值的默认数组的功能<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>。</p>

<h2 id="解微积分">解③：微积分</h2>

<p>可以用曲面积分相关知识简化求解过程，事实上所有计算几何相关的问题总有数学上的解决思路，但由于这并不是我们专注的领域，就不介绍了。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>唯一正确的 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>当然也可以选择顶部闭合、底部开放，这没什么区别 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>用 <code class="language-plaintext highlighter-rouge">ex</code> 而不是 <code class="language-plaintext highlighter-rouge">exit</code> 主要是为了避免和 Python 关键字冲突，（这个冲突）会造成代码高亮上的问题 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>我是真的服了，在习惯了 Rust 风格库的事无巨细，我从来发现 Python 的库提供的 API 如此匮乏，<code class="language-plaintext highlighter-rouge">DefaultDict</code> 居然只提供c传默认值构造方法的参数而没有提供传一个固定默认值的参数 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0218 - The Skyline Problem</title><link href="/oth/LeetCode0218.html" rel="alternate" type="text/html" title="0218 - The Skyline Problem" /><published>2023-06-01T00:00:00+08:00</published><updated>2023-06-01T00:00:00+08:00</updated><id>/oth/LeetCode0218</id><content type="html" xml:base="/oth/LeetCode0218.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/the-skyline-problem/description/">问题描述</a></p>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.1/0218_the_skyline_problem">源代码</a></p>

<h2 id="破题">破题</h2>

<p>这道题的关键是能观察到：关键点是顺着 $x$ 轴的方向，当剪影的高度发生变化时确定的。</p>

<p>这样，如果能确定每个 $x$ 坐标对应的建筑物的最大高度，就能求出关键点。</p>

<h2 id="解分段树">解①：分段树</h2>

<p>最直接的一个思路是把建筑列表里的每栋建筑的高度在它所属区间上标识出，这样就可以查询每个 $x$ 坐标的最大高度。</p>

<p>分段树（Segment Tree）就适用于这种情况：考虑分段树的里的批量更新，既支持批量累加，又支持批量赋值，而批量赋值就适用于当前这种给定区间标记高度的任务。</p>

<p>需要注意：</p>

<ol>
  <li>由于建筑间区间重叠，因此批量赋值和查询时要取（建筑高度）的最大值，作为剪影的代表；</li>
  <li>建筑的右边缘的高度是无效的，也就是对于左右端的坐标分别为 $l$ 和 $r$ 的建筑，它的高度有效范围为 $[l, r)$</li>
</ol>

<h3 id="python-实现">Python 实现<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h3>

<p><strong>分段树</strong></p>

<p>使用<a href="/algs/SegmentTree.html">DFS 型的分段树</a>来节省一半的内存。</p>

<p>由于实际上我们只使用批量赋值的信息，而不需要原信息，因此直接省略了树本身，只保留更新的结构。</p>

<p>有一点， Python 的函数调用是真的消耗时间，在 Rust 里面你可以随意地使用函数包装，实际上调用的成本几乎都可以被优化掉，因此可以基于 API 的人体工程学考虑，用 Cursor 类别处理“分段”信息，但在 Python 上，这种频繁调用地包装函数会导致运行时间变为 3 倍，于是我们不使用包装，而是把参数就地直接展开。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">():</span>
    <span class="s">"""DFS Layout,
    left: i+1,
    right: 2+2l
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># Just ignore self.tree
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data_len</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">data_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""Override the smaller value"""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_assign</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">subl</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="p">.</span><span class="n">_assign</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_assign</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subl</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s">"""query [l, r] -&gt; (x, h)"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_query</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">subl</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">tl</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subl</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subl</span><span class="p">],</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="p">.</span><span class="n">assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">lv</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_query</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_query</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subl</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>数据离散化</strong></p>

<p>在测试里有专门的 $x$ 坐标很大的建筑物，如果直接按照 $x$ 坐标建树，性能将是不可接受的，需要进行离散化处理。</p>

<p>我们可以取建筑两端的 $x$ 坐标，用它们的排名压缩坐标轴。需要注意一点，如果用向量和下标的方式储存坐标与排名的对应关系，需要跳过重复的元素，否会产生同一坐标不同排名的情况，从而妨碍正确结果的求出。</p>

<p><strong>完整过程</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getSkyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="c1"># 数据离散化 (Discretization)
</span>
    <span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">buildings</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">x_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">x_data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="c1"># i != 0 for right x-axis
</span>        <span class="k">if</span> <span class="n">x_data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">x_data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">x_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_data</span><span class="p">)}</span>

    <span class="c1"># Build Segment Tree by Batch Update
</span>
    <span class="n">segtree</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">x_map</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">x_map</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
		<span class="c1"># [l, r)
</span>        <span class="n">segtree</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Sweep Line
</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_data</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">segtree</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">res</span>

<span class="c1"># 分段树定义如上
</span></code></pre></div></div>

<h2 id="解树状数组">解②：树状数组</h2>

<p>如果说前面对分段树的改动还比较小<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，那么<a href="/algs/FenwickTree.html">树状数组</a>的思路里面对树状数组的改动就比较tricky了，因为普通的树状数组，以下简称 BIT（Binary Indexed Tree）， 用某个点的前缀和表示该点的高度，那么任何 $x$ 轴靠前坐标上的高度更新都会影响后面位置的高度的计算。</p>

<p>因此我们对树状数组的改动是让它前面位置的更新不影响后面位置前缀和的计算，假如，考虑一种情况，所有建筑的右边缘都是 $\infty$ ，而更新和查询就像前面分段树一样，都是取所有相关位置值的最大：也就是更新的时候扫描所有祖先节点，取其位置既有值和当前更新值的最大，查询的时候扫描所有前缀位置，取最大值，那么此时就可以用树状数组正确地更新高度和单点查询。</p>

<p>因为此时的更新要么不影响后面位置的高度，要么影响得都是建筑区间重叠的部分：</p>

<p>假设两栋建筑的区间分别为 $[l_0, \infty)$ 和 $[l_1, \infty)$ 高度分别为 $h_0$ 和 $h_1$ ，如果 $l_0 \neq l_1$ ，不妨令 $l_0 \lt l_1$ ，那么在 $[l_0, l_1)$ 的区间上，两者互不影响，因为这个区域只有 $l_0$ 的更新，而在 $[l_1, \infty)$ 的区域，两者本来就是区间重叠，用两个值中的最大值覆盖即可。这样在查询高度的时候，对于位置 $x$ ，如果 $x\in [l_0, l_1)$ ，那它的高度是 $h_0$ ，如果 $x\in [l_1, \infty)$ ，那它的高度是 $\max (h_0, h_1)$ 。</p>

<p>当然 $\infty$ 的情况既不可能，也无法计算，但是如果说所有建筑的右边缘都是重合的，都是 $r$ ，而所有超过 $r$ 的 $x$ 轴上的位置都不不需要查询，那么问题也是等价的。</p>

<p>那么回到当前问题，如果建筑能够按照右边缘的 $x$ 轴位置从右到左的顺序排列，然后我们从右向左扫描，只在扫描到建筑的右边缘时才把该建筑（所代表的一个区间的高度）更新到树状数组里，然后对扫描线位置进行高度查询，这样我们就可以确保所有建筑的右边缘都是重合的，并且不需要查询超过重合点之后的位置。</p>

<p>但是，但是，且不说我们的建筑是按照左边缘的从左到右的顺序排列的，关键问题是题目要求地关键点是按照从左到右扫描的顺序得到的，根本不能从右向左扫描，这要怎么解决呢？</p>

<p>于是有了这里比较Tricky地树状数组地构造<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>：</p>

<p>既然一定要从左向右扫描，我™ 😡直接从数组的尾部开始建立这个树状数组！</p>

<p>这样某个位置的高度就是它的后缀最大值，而它的祖先节点就在它的左边，从左向右扫描时就完美符合了前面假设得树状数组的适应情况！</p>

<p><strong>反向树状数组</strong></p>

<p>对于 base 1 的数组，$x$ 所辖区间长度是 <code class="language-plaintext highlighter-rouge">x &amp; (-x)</code> ，而对于 base 0 的数组则是 <code class="language-plaintext highlighter-rouge">(x+1) &amp; -(x+1)</code> ，对于从尾部建立起来的树状数组，$x’ = n - x - 1$ ，其中 $n$ 为数组长度。</p>

<p>树状数组更新的时候实际上只需要更新到扫描线的位置（也就是代码里的 <code class="language-plaintext highlighter-rouge">until</code> ）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RevBIT</span><span class="p">():</span>
    <span class="s">"""Reversed Binary Indexed Tree"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># base 0
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_len</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">until</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">until</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">-=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span>

        <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p><strong>总体过程</strong></p>

<p>总体过程首先是 $x$ 轴坐标的排序和离散化，和前面分段树的处理一样，后面在扫描过程中更新建筑到树状数组上和即时地查询，显然对于每栋建筑，我们只需要更新建筑的右边缘的坐标<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>和高度。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getSkyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">buildings</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">x_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="n">x_data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">x_data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">x_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_data</span><span class="p">)}</span>

    <span class="n">bit</span> <span class="o">=</span> <span class="n">RevBIT</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">))</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_data</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">==</span> <span class="n">buildings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">buildings</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

            <span class="n">bit</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">x_map</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">bit</span><span class="p">.</span><span class="n">suffix</span><span class="p">(</span><span class="n">x_map</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>但是，在仔细考虑下我们对反向建构的树状数组的使用🤔，发现虽然我们扫描后缀，但只要一个位置来保存高度，而不需要真地计算前缀和，那么我们完全可以用一个普通的树状数组的结构，但是用父节点保存高度，更新的时候向前更新节点（查询扫描的逆过程，比如 $7 \rightarrow 6 \rightarrow 4 \rightarrow 2 \rightarrow 1$）<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，查询的时候向后扫描所有父节点。</p>

<p><strong>徒有其表地树状数组</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FakeBIT</span><span class="p">():</span>
    <span class="s">"""Fake Binary Indexed Tree whose prefix for update and suffix for query"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_len</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># base 0
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_len</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">until</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">until</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">-=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p>总体过程和反向树状数组一样，只需要把 <code class="language-plaintext highlighter-rouge">bit = RevBIT(len(x_data))</code> 替换为 `    bit = FakeBIT(len(x_data))`</p>

<h2 id="解优先级队列">解③：优先级队列</h2>

<p>借着上文，我们从反向树状数组推到假树状数组，于是可以想到，为什么不干脆用优先级队列取代上面树状数组的作用？每次扫描的时候把把建筑更新到优先级队列里，保存一个右边缘坐标和高度，查询的时候就从对队首弹出所有右边缘不符合条件的元素，然后新的队首的元素的高度就是我们需要的该位置的最大高度，当然如果队列为空，就是高度为 $0$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">insort</span>
<span class="kn">from</span> <span class="nn">sortedcontainers</span> <span class="kn">import</span> <span class="n">SortedList</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getSkyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">buildings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">]</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
        <span class="n">insort</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">SortedList</span><span class="p">([],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_buildings</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_buildings</span> <span class="ow">and</span> <span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># pop outdated from priority queue
</span>
        <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sortedcontainers</code> 是 LeetCode 承诺地自动包含进 Python 环境里的第三方库，它是一个纯 Python 但是足够高效地有序集合的库，只包含三个有序集合：<code class="language-plaintext highlighter-rouge">SortedList</code>，<code class="language-plaintext highlighter-rouge">SortedSet</code>，<code class="language-plaintext highlighter-rouge">SortedDict</code> ，用来补充标准库缺乏地功能。<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup><sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>python 3.10 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>只是在批量赋值和查询的时候有一个额外的求取最大值的操作，这是为了确保重叠区间的高度是上面所有建筑高度的最大值 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>我很欣赏这种设计，它就是非常清楚这个数据结构地构造和实质，然后就可以保留实质，根据需要随意地解构然后重构，这种使用可以说已入化境 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>当然准确说是 $r-1$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>计算节点的关键是把握子区间的长度 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>但是我不得不吐槽得是，Python 作为曾经地号称“自带电池”地方便语言，但现在很多方面已经非常老迈（虽然正在尝试追赶），特别是相对于Rust而言，基本上如果不是为了比较不同实现的性能，出于方便考虑我宁可用 Rust ，Rust的问题就是优化太好、运行太快了，测试结果几乎总是 0 ms ，而 Python在这里的优势居然是足够慢，便于测试中能发现性能上的问题😅。 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>我真的为了寻找一个提供优先级队列功能地容器，花费了不少时间，Python 标准库里面有几个看起来很像地，但都不很合适，一个是 <code class="language-plaintext highlighter-rouge">queue.PriorityQueue</code> 名字就叫做优先级队列，但是是用来做进线程调度地😅； 另一个是它的底层实现 <code class="language-plaintext highlighter-rouge">heapq.[heapify, heappush, heappop]</code> ，简直就和 C 语言的函数一样，可以传一个列表，然后构建基于堆地优先级队列，但是连个自定义 <code class="language-plaintext highlighter-rouge">key</code> 的功能都没有，还需要专门用一个数据包装，来自定义比较函数，实在绷不住；还有一个是 <code class="language-plaintext highlighter-rouge">collections.OrderedDict</code> 但它保持地是插入顺序。 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>但是第三方地 <code class="language-plaintext highlighter-rouge">sortedcontainers.SortedList</code> 也令人不太满意，首先方法非常简单，只供最基本地使用，另外实在不知道它加一些 <code class="language-plaintext highlighter-rouge">not implemented，use xxx replace</code> 的方法到实现里有什么好处，调用不存在的方法本来就会报错，又不需要它来做警戒哨，这只是在混淆代码的静态分析程序，让智能提示里出现错误地选项，让每个第一次使用它的人浪费几十秒的时间，去发现正确的方法😡。 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">Topological Sort</title><link href="/algs/GraphTarjanDFS2.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2023-05-25T00:00:00+08:00</published><updated>2023-05-25T00:00:00+08:00</updated><id>/algs/GraphTarjanDFS2</id><content type="html" xml:base="/algs/GraphTarjanDFS2.html"><![CDATA[<p>是解决有前置课程限制的课表安排之类的问题，用有向边代表一个事件和它的前置事件，那么这样构成的有向图的拓扑排序（结果并不唯一）就是一个规划方案。</p>

<p>拓扑排序的对图的要求是有向无环图（Directed Acyclic Graph，DAG），可以使用一个基于 DFS 的拓扑排序的方法，可以在线性时间里进行拓扑排序，并且能够检查环的存在。</p>

<p>这个基于 DFS 的线性的拓扑排序的算法很可能也是来源于 Tarjan<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，基本思路和前面介绍的<a href="/algs/GraphTarjanDFS.html">TarjanDFS</a>也是类似，关注边的回溯情况，非常简单，直接看实现。</p>

<h2 id="思路">思路</h2>

<p>区别于前面为每个点维护 $\text{index}$ 和 $\text{lowpt}$，来求解寻找强连通分量，拓扑排序只需要检测环是否存在，因此可以简化为一个三元值，指示点的未访问、访问中和访问结束三个状态，如果 DFS 过程中遇到了一个访问中的点，那么一定存在环。</p>

<p>对于拓扑排序本身，按照 DFS 过程中，在所有出边访问结束后把当前点加入向量中，这就得到了一个拓扑排序的一个逆序结果，最后再把向量逆序回来，就得到了最终结果</p>

<h2 id="实现">实现</h2>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.7/coll_graph/src/toposort.rs">源代码</a></p>

<h3 id="数据结构">数据结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(u8)]</span>
<span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">DFSMeta</span> <span class="p">{</span>
    <span class="nd">#[default]</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Yellow</span><span class="p">,</span>
    <span class="n">Red</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">DFSMeta</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="整体过程">整体过程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">toposort_tarjan</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">DFSMeta</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span> <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">u</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">Green</span> <span class="p">{</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vertexs</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">ans</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span><span class="nf">.reverse</span><span class="p">();</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="dfs子过程">DFS子过程</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">vertexs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DFSMeta</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ans</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yellow</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">Green</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">dfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Yellow</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span> <span class="c1">// found edge on cycle</span>
            <span class="p">}</span>
            <span class="n">Red</span> <span class="k">=&gt;</span> <span class="p">(),</span> <span class="c1">// just skip</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">Red</span><span class="p">;</span>
    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=lazJixIAAAAJ&amp;cstart=20&amp;pagesize=80&amp;citation_for_view=lazJixIAAAAJ:p2g8aNsByqUC">Edge-disjoint spanning trees and depth-first search</a> RE Tarjan Acta Informatica 6 (2), 171-185 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[是解决有前置课程限制的课表安排之类的问题，用有向边代表一个事件和它的前置事件，那么这样构成的有向图的拓扑排序（结果并不唯一）就是一个规划方案。]]></summary></entry><entry><title type="html">Tarjan DFS</title><link href="/algs/GraphTarjanDFS.html" rel="alternate" type="text/html" title="Tarjan DFS" /><published>2023-05-20T00:00:00+08:00</published><updated>2023-05-20T00:00:00+08:00</updated><id>/algs/GraphTarjanDFS</id><content type="html" xml:base="/algs/GraphTarjanDFS.html"><![CDATA[<p><em>本文资料来源于<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></em></p>

<p>Tarjan 其实是老朋友了，之前介绍过的<a href="/algs/FibHeap.html">斐波那契堆</a>（1986），他就是它的两位作者之一， 现在是要介绍他早期（1972、1973）发表的通过图上 DFS 来线性时间解决<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">3</a></sup>：</p>

<ol>
  <li>在无向图上划分双联通分量</li>
  <li>查找强连通分量</li>
</ol>

<p>其中一些概念也是（可能）后续一些基于 DFS 的算法的基础。</p>

<h2 id="深度优先遍历">深度优先遍历</h2>

<p>对一个连通无向（简单）图，如下所示：</p>

<p><img src="/assets/img/tarjandfs/graph.png" alt="图1" /></p>

<p>（<em>默认按照字母顺序</em>）进行深度优先地图上遍历：</p>

\[\begin{array}{l}
\text{A}\rightarrow \text{B}\rightarrow \text{C}\rightarrow \text{D}\rightarrow &amp;\text{E}\rightarrow &amp;\text{F}\curvearrowright \text{A}\\
&amp;&amp; \text{F}\rightarrow&amp;\text{G}\curvearrowright\text{D}\\
&amp;&amp;&amp;\text{G}\curvearrowright\text{B}\\
&amp;\text{E}\rightarrow&amp;\text{H}\curvearrowright \text{A}\\
&amp;&amp;\text{H}\curvearrowright \text{C}
\end{array}\]

<p>得到一个包含一棵生成树 $\text{T}$ 的有向图 $\text{P}$，并按照访问顺序，从 $1$ 开始给 $\text{P}$ 上每个点编号：</p>

<p><img src="/assets/img/tarjandfs/dfs.png" alt="" /></p>

<p>后面的算法都以 DFS 构建的有向图 $\text{P}$ 为基础，观察它的回溯边的情况。</p>

<p><strong>回溯边</strong>，可以分为两种情况：</p>

<ol>
  <li>如上图所示，从某个点回到它的一个祖先节点的一条边，比如 $\text{G}\curvearrowright\text{D}$ ，可以叫它<strong>叶边（frond）</strong>；</li>
  <li>上图没有的，从某个点回到不是它祖先节点（但是也比它更早访问到）的一条边，比如$\text{G}\curvearrowright\text{H}$ ，可以叫它<strong>横叉边（cross link）</strong></li>
</ol>

<p>如果 $\text{P}$ 的所有回溯边都是叶边，那么可以称它为<strong>棕榈树（palm tree）</strong><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>。</p>

<p>可以发现，在任意无向连通图上做 DFS ，构建的有向图 $\text{P}$ 一定是棕榈树；反之任意棕榈树 $\text{P}$ 一定可以由一个它的无向图版本做 DFS 得到。</p>

<p>换言之，无向图 DFS，不存在横叉边。运用反证法：因为是无向图，如果存在横叉边，那么它就应该作为 DFS 过程中生成树上的一条边，而不是回溯边。</p>

<p>根据某个点的所有后代的回溯边所能到达的编号最小的点，引出一个关键概念 – <strong>LOWPT</strong><sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">5</a></sup>：</p>

<p>$\text{lowpt}(v)$ 定义为从 $v$ 出发，经过零个或更多的树弧，和最多一条回溯边，所能到达的编号最小的点（我们不妨用 $\text{index}(v)$ 表示 $v$ 点的编号）。</p>

<h2 id="双联通分量">双联通分量</h2>

<p>有了前面的知识铺垫，我们可以通过 DFS ，首先来解决在无向图上的双连通分量（biconnected component, bcc）的划分问题，而在具体讨论之前，有必要先理清下概念：</p>

<h3 id="概念">概念</h3>

<p><strong>2-连通图</strong></p>

<p>读作 $2$ 点连通图，是 <a href="https://en.wikipedia.org/wiki/K-vertex-connected_graph">$k$ 点连通图</a>的一个实例，也就是一个连通图里有只有删除两个点才能导致图不连通。</p>

<p><strong>双连通图</strong></p>

<p>双联通图（biconnected graph）大多数情况下和 2-连通图（2-connected graph）是等价的，只在一个例外，就是只包含一条边的图仍然是双联通图，但一般不被视为 2-连通图<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">6</a></sup><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">7</a></sup>。</p>

<p>双连通图之所以有这么个特殊例外，就是为了方便把图按双连通分量进行划分，对剩下的散碎边，每条边都可以视为一个最小的双连通分量。</p>

<h3 id="算法">算法</h3>

<p>划分双连通分量的关键在于寻找分量之间的衔接点（articulation point）<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>。</p>

<p>衔接点可以利用计算的 $\text{lowpt}$ 寻找：在 DFS 构建的有向图 $\text{P}$ 上，如果一个点的 $\text{lowpt}$ 不低于它的父节点的编号，那么它的父节点就是一个衔接点。</p>

<p>比如，对于下图</p>

<p><img src="/assets/img/tarjandfs/bcc_raw.png" alt="" /></p>

<p>DFS 构建的有向图：</p>

<p><img src="/assets/img/tarjandfs/bcc_tree.png" alt="" /></p>

<p>上图 G 点的 $\text{lowpt}(3)=2=\text{index}(2)$ ，因此 $3$ 的父节点 $2$ 就是一个衔接点，如果此时把之前遍历过程中入栈的边 $2\rightarrow 3$ ，$3\rightarrow 4$，$4\rightarrow2$ 从栈顶依次弹出，那么就收集了一个双联通分量的划分。</p>

<p>最终如下图：</p>

<p><img src="/assets/img/tarjandfs/bcc_bccs.png" alt="" /></p>

<p>伪代码有些吃力不讨好，不如直接看实现</p>

<h3 id="实现">实现</h3>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.6/coll_graph/src/bcc.rs">源代码</a></p>

<h4 id="数据结构">数据结构</h4>

<p>每个点要保存它的 DFS 编号和 $\text{lowpt}$ ，用 <code class="language-plaintext highlighter-rouge">Option</code> 类型指示该点是否被访问。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">DFSMeta</span> <span class="p">{</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lowpt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="整体过程">整体过程</h4>

<p>假设图中每个点都是连续地，并且从 $1$ 开始，使用一个数组作为 Map 保存每个点的信息。</p>

<p>对图上每个点遍历，如果该点没有被标记过，就执行 DFS 子过程，这么做是考虑到给定的图不一定是连通的，需要在不同分量上分别进行 DFS。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">bcc_tarjan</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bccs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">g</span><span class="py">.e</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">bccs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">DFSMeta</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span> <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">u</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_bcc</span><span class="p">(</span>
                <span class="n">g</span><span class="p">,</span>
                <span class="n">u</span><span class="p">,</span>
                <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bccs</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stack</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">index</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vertexs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">bccs</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dfs-子过程">DFS 子过程</h4>

<p><strong>部分参数解释</strong></p>

<ol>
  <li>$p$ ，对于无向（简单）图，需要传一个父节点参数 $p$ ，来避免对边进行重复访问；</li>
  <li>$bccs$ 保存划分出的双连通分量的边集，用边集而不是点集是因为双连通分量之间有点是有交合的（就是衔接点），但是边集是不相交的；</li>
  <li>$stack$ 保存 DFS 过程访问过的边，用来发现衔接点后收集新的双连通分量的边</li>
</ol>

<p><strong>过程解释</strong></p>

<p>初始化被访问点的编号 $\text{index}$ 和 $\text{lowpt}$ ，其中 $\text{lowpt}$ 初始化的时候与编号一致。</p>

<p>遍历访问点 $u$ 所有的出边，如果出边的头节点 $v$ 未被编号，就推边入栈，并在 $v$ 上执行 DFS 操作，之后利用 $\text{lowpt}(v)$ 更新 $\text{lowpt}(u)$ ，并检查 $\text{lowpt}(v)$ 是否不小于 $\text{index}(u)$ <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup>，如果是，就收集栈上的边，直到收集完起点为 $u$ 的边<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">10</a></sup>；</p>

<p>如果 $v$ 已被编号，就用它的编号更新 $\text{lowpt}(u)$ ，当然要排除父节点的情况，避免重复访问同一条边。</p>

<p>另外如果对边集里的边和边集的顺序有要求，那么这个过程还要进行一个插入排序。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dfs_bcc</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">bccs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">stack</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">vertexs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DFSMeta</span><span class="o">&gt;</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="o">*</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFSMeta</span> <span class="p">{</span>
        <span class="n">index</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">),</span>
        <span class="n">lowpt</span><span class="p">:</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">stack</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="nf">dfs_bcc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bccs</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">);</span>

            <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="o">=</span>
            <span class="nf">min</span><span class="p">(</span><span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowpt</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">==</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="p">{</span>
                <span class="c1">// u is cut point</span>
                <span class="c1">// get biconnected component</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">bcc</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">ordered_insert!</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bcc</span><span class="p">,</span>
                        <span class="k">if</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span> <span class="p">{</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="p">}</span>
                    <span class="p">);</span>

                    <span class="k">if</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">u</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">ordered_insert!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">bccs</span><span class="p">,</span> <span class="n">bcc</span><span class="p">,</span> <span class="p">|</span><span class="n">bcc</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">|</span> <span class="n">bcc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">p</span> <span class="p">{</span>
            <span class="n">stack</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="o">=</span>
            <span class="nf">min</span><span class="p">(</span><span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>ordered_insert</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">ordered_insert</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$vec:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="nv">$vec</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">vec</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec</span><span class="p">[</span><span class="n">oldidx</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">vec</span><span class="nf">.insert</span><span class="p">(</span><span class="n">inseridx</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                <span class="nb">None</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vec:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$f:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="nv">$vec</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nv">$f</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">vec</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec</span><span class="p">[</span><span class="n">oldidx</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">vec</span><span class="nf">.insert</span><span class="p">(</span><span class="n">inseridx</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                <span class="nb">None</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度">时间复杂度</h3>

<p>不考虑对结果的标准化问题，时间复杂度显然为 $O(V)+O(E)$</p>

<h2 id="强连通分量">强连通分量</h2>

<p>前面讲了无向图上双连通分量的划分，但对于有向图而言，DFS 将不会是一个简单的棕榈树的结构，因为边的方向是固定的，而不是双向都可以的，但（据作者说：“The more complicated structure which results in this case is still simple enough to prove useful in at least one application.”）</p>

<p>不过不管那些，还可以用一个与上述算法非常相似的过程解决有寻找<strong>向图上的强连通分量问题（strong connected component，scc）</strong>。</p>

<h3 id="算法-1">算法</h3>

<p>如果从一个点出发，最后又回到了该点，那么这个点就是强连通分量的根节点。也就是说，如果在 $u$ 点的所有出边 DFS 结束后，发现 $\text{index}(u)=\text{lowpt}(u)$ ，那么 $u$ 就是一个强连通分量的根节点，而此时收集栈上所有编号大于 $u$ 的点，就得到了这个强连通分量的点集。</p>

<h3 id="实现-1">实现</h3>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.6/coll_graph/src/scc.rs">源代码</a></p>

<p>数据结构</p>

<p>新字段 <code class="language-plaintext highlighter-rouge">on_stack</code> 用来指示当前节点是否在栈上，这样相比用单独的哈希集合来维护，有更好的局部性。而之所以要检查节点是否在栈上，后面会解释。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">DFSMeta</span> <span class="p">{</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lowlink</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">on_stack</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="整体过程-1">整体过程</h4>

<p>和划分 BCC 时一样，区别只在于，使用了点集取代边集，这是因为只需要寻找从 SCC 而不是对图进行划分。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">scc_tarjan</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">comps</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">g</span><span class="py">.e</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">comps</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">DFSMeta</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span> <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">u</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_scc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">comps</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stack</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vertexs</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">comps</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dfs子过程">DFS子过程</h4>

<p>同样类似于划分 BCC ，需要注意得是在 DFS 过程中，由于是有向图，所以要考虑 $u$ 的出边节点 $v$ 不与它在同一 SCC 的情况，判断方法是：如果不在同一 SCC ，那么在 DFS 过程中必然已经划分到其他的 SCC 中去了，因此已经从栈上弹出了，所以只需要检查该点是否还在栈上就可以，这就是 <code class="language-plaintext highlighter-rouge">on_stack</code> 字段的作用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dfs_scc</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">comps</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">stack</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">vertexs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DFSMeta</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFSMeta</span> <span class="p">{</span>
        <span class="n">index</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">),</span>
        <span class="n">lowlink</span><span class="p">:</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
        <span class="n">on_stack</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="o">*</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_scc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">);</span>

            <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">=</span>
            <span class="nf">min</span><span class="p">(</span><span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowlink</span><span class="p">);</span>
        <span class="p">}</span> 
        <span class="k">else</span> <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span> <span class="o">&amp;&amp;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.on_stack</span>
        <span class="p">{</span>
            <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">=</span>
            <span class="nf">min</span><span class="p">(</span><span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* start a new scc */</span>

    <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">==</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_comp</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">ordered_insert!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">new_comp</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
            <span class="n">vertexs</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="py">.on_stack</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">u</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">ordered_insert!</span><span class="p">(</span><span class="n">comps</span><span class="p">,</span> <span class="n">new_comp</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">|</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>不考虑对结果的标准化问题，时间复杂度显然为 $O(V)+O(E)$</p>

<h3 id="无向图">无向图</h3>

<p>显然上述求取有向图上 SCC 的算法也完全适应于求取无向图上的连通分量问题。一般使用并查集（multiset union, disjoint set union, union find, etc.）直接计算的话，每条边需要额外付出并查集的 $O(\text{log}(V))$ 的时间复杂度，表现要差于 Tarjan 算法。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://scholar.google.com/scholar?oi=bibs&amp;cluster=15533190727229683002&amp;btnI=1&amp;hl=en">Depth-first search and linear graph algorithms</a> R Tarjan - SIAM journal on computing, 1972 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://scholar.google.com/scholar?oi=bibs&amp;cluster=15317103615758324241&amp;btnI=1&amp;hl=en">Algorithm 447: efficient algorithms for graph manipulation</a> J Hopcroft, R Tarjan - Communications of the ACM, 1973 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>第二篇论文还提到了在双联通分量上的简单路径划分，但是既缺乏具体解释，流程图也模糊不清，伪代码还是 goto 结构的，令人实在没有时间去看了 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>“棕榈树”和“叶边”都是作者在论文<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>里起的形象名字 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>曾经，在第一篇论文里，作者提出的<strong>LOWPT</strong>的定义是：“That is, LOWPT(v) is the smallest vertex reachable from v by traversing zero or more tree arcs followed by at most one frond. ”；还提出了另外一个相似的概念 <strong>LOWLINK</strong>：“That is, LOWLINK (v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one frond or cross-link.” 。这两者的本质上显然是相同的，区别只在于一个是应用在无向图上（划分bcc）所以回溯边只经过叶边，而另一个是应用在有向图上（划分scc）所以回溯边可能经过叶边或者横叉边，至于“在同一个分量里”的说法，只能说是回溯的必然结果，而不是限制。而在第二篇论文里，作者也不再区分，而是统一使用了LOWPT。 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Biconnected_graph# <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>当然单点图，也就是不含边的图既不是双连通图也不是2-连通图 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>也就是割点（cut point），但是割点有些抽象，我们不会进入那个领域 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>这里直接检查了 $\text{lowpt}(u)$ 是否被更新得更小 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>注意栈上的顺序与访问的顺序是反向的 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[本文资料来源于12 Depth-first search and linear graph algorithms R Tarjan - SIAM journal on computing, 1972 &#8617; Algorithm 447: efficient algorithms for graph manipulation J Hopcroft, R Tarjan - Communications of the ACM, 1973 &#8617;]]></summary></entry><entry><title type="html">树状数组</title><link href="/algs/FenwickTree.html" rel="alternate" type="text/html" title="树状数组" /><published>2023-04-24T00:00:00+08:00</published><updated>2023-04-24T00:00:00+08:00</updated><id>/algs/FenwickTree</id><content type="html" xml:base="/algs/FenwickTree.html"><![CDATA[<p><em>本文主要参考 <a href="https://oi-wiki.org/ds/fenwick">OI-wiki</a> 以及 <a href="https://cp-algorithms.com/data_structures/fenwick.html">cp-algorithms.com</a> 相关页面</em><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>树状数组（Binary Indexed Tree, Fenwick Tree）<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，以下简称 BIT，其命名是由于 <a href="https://en.wikipedia.org/w/index.php?title=Peter_Fenwick_(computer_scientist)&amp;action=edit&amp;redlink=1">Peter Fenwick</a> 在 1994 年发表的文章里描述了这一结构，<strong>它的本质是通过高效地计算数组的前缀和来解决相关的问题</strong>。</p>

<h2 id="vs-分段树">VS 分段树</h2>

<p>因此树状数组也能解决诸如给定区间的和之类的问题，<strong>只要这类问题可以转换为几个前缀和的运算</strong>。</p>

<p>而前面介绍过的<a href="/algs/SegmentTree.html">分段树</a>也可以解决这类问题，区别是：</p>

<p><strong>时间复杂度：</strong></p>

<p>都是 $O(\text{log}n)$，但树状数组的性能远好于分段树，测算可能差了 10 倍</p>

<p><strong>空间复杂度：</strong></p>

<p>都是 $O(n)$ ，但树状数组空间和源数组大小相等，是 $1n$ ，而分段树 DFS 型需要 $2n$ ，BFS 型更是需要 $4n$</p>

<p><strong>代码复杂度</strong></p>

<p>树状数组的代码更简单</p>

<p>因此只要能用树状数组解决的问题，都优先使用树状数组<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<h2 id="概念">概念</h2>

<p>可以通过一个图直接看一下树状数组的结构<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>，下图是数组 $a[1..16]$ 的 BIT 结构：</p>

<p><img src="/assets/img/bit/bit.svg" alt="" /></p>

<p>图中每个节点都代表一段长度至少为 $1$ 的区间，比如 $2$ 包含区间 $[1..2]$ ，$4$ 包含区间 $[1..4]$ ，$6$ 包含区间 $[5..6]$ 。</p>

<p>让我们省略掉重复的元素，会对结构看得更清晰：</p>

<p><img src="/assets/img/bit/bit2.png" alt="" /></p>

<p>我们发现 BIT 实际上就是由我们前面介绍<a href="/algs/FibHeap.html">斐波那契堆</a>时提过的二项树组成。</p>

<p>比如 $8$ 是一棵 $\text{rank}=3$ 的二项树，$12$ 是一棵 $\text{rank}=2$ 的二项树。</p>

<p>二项堆是说每个孩子都是 $\text{rank}$ 独特的二项树，同时满足小顶堆的性质，而 BIT 自然不需要满足堆的性质，但是也要求 $\text{rank}$ 独特，并且 rank 是连续的并且严格递减的，比如上述 BIT 分别是由 $\text{rank}= 3，2，1，0$ 的二项树组成。</p>

<p>树状数组就是在每个位置存储所代表的区间的元素的和。</p>

<h3 id="分片长度">分片长度</h3>

<p><strong>那么如何计算某个索引位置代表的区间的长度呢？</strong></p>

<p>观察发现，一个序号越是能被更大的 $2$ 的幂整除，代表的区间就越大 。</p>

<p>实际上，区间长度，或者说区间的元素数，就是由序号的二进制的最低有效位<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>与后面 $0$ 构成的数字决定的。</p>

<p>比如 $12 = (1100)_2$ ，最低有效位是 $3$ ，与后面的 $0$ 构成的数字是 $(100)_2=4$ ，代表 4 ；</p>

<p>比如 $15 = (1111)_2$ ，最低有效位是 $1$ ，与后面的 $0$ 构成的数字是 $(1)_2=1$ ，代表 1</p>

<p>那么如何求取一个序号的最低有效位构成的数字呢？</p>

<p>假设序号为 x，那么对 x 按位取反再加 1 ，再按位与原值，就可以求出 x 的最低有效位的构成数字。</p>

<p><strong>为什么是这样呢？</strong></p>

<p>仔细考虑一下这个过程就清楚了：</p>

<ol>
  <li>根据定义，最低有效位是 $1$ ，后面更低位全都是 $0$ ，比如 $(100)_2$ ，$x$ 取反后，变为 $(011)_2$ ，加一后，又变回 $(100)_2$ ，因此按位与时最低有效位的 $1$ 以及后面的更低位的 $0$ 被原封不动地保留下来；</li>
  <li>由于进位已经停在最低有效位上，因此更高的位只是取反，按位与后就被清除掉了</li>
</ol>

<p>这样就得到了最低有效位和后面的 $0$ 构成的数字。</p>

<p>于是我们证明了 <code class="language-plaintext highlighter-rouge">x &amp; (!x+1)</code> 可以得到区间的长度。</p>

<p><strong>但是这个书写形式还可以简化</strong></p>

<p>因为整型数字在计算机中的存储形式是 2 的补码（two’s complement），按照定义，对于一个数取反加一就得到了它对应的负值。</p>

<p>因此区间长度可以简化为 <code class="language-plaintext highlighter-rouge">x &amp; -x</code> 。</p>

<h2 id="实现">实现</h2>

<p>定义下结构，这里继续使用了前面分段树里定义的抽象组件：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span> <span class="o">=</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">_note</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="建树">建树</h3>

<p>首先我们可以进一步通过观察上述的图，发现两个 BIT 的性质：</p>

<ol>
  <li>每个位置，都可以由它自身和它的直接孩子求和得到，比如 $t[4] = a[4] + t[3] + t[2]$ ；</li>
  <li>每个位置，它到直接父母的距离就是它所代表的区间的大小，或者说它代表了父节点所辖地一半的元素数，比如 $4$ 到直接父母 $8$ 的距离就是 $4$ 所代表区间 $[1..4]$ 的长度，也就是 $4$</li>
</ol>

<p>利用上述性质，可以直接在 $O(n)$ 的时间复杂度内完成的树的构造：</p>

<p>用 $0$ 初始化 BIT，遍历原数组 $a[..]$ ，把它的每个值加到 BIT 对应位置，然后再用 BIT 这个位置的数值每次更新它的直接父母。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">range_len</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">((</span><span class="nv">$i</span> <span class="k">as</span> <span class="nb">isize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="nv">$i</span> <span class="k">as</span> <span class="nb">isize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">as</span> <span class="nb">usize</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="nf">.is_empty</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="n">raw</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">_note</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">build</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span> <span class="n">raw</span><span class="nf">.len</span><span class="p">()];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">raw</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.raw_into_stats</span><span class="p">());</span>

            <span class="c1">// direct parent</span>
            <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nd">range_len!</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">raw</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">data</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>计算区间长度的时候，如果是基于 $0$ 的数组，注意需要把索引位置加一，得到前面讨论的代表数量的编号。</p>

<h3 id="前缀和">前缀和</h3>

<p>计算前缀和也只需统计查询位置前面的区间，方法是每次向前跳索引代表的一个区间的长度：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">prefix</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acc</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nd">range_len!</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">-=</span> <span class="nd">range_len!</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">acc</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>计算两个端点的前缀和，就可以求出给定区间的区间和：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Sub</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">self</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>宏 <code class="language-plaintext highlighter-rouge">parse_range</code> 来源于前面分段树里面定义的宏，给出 $[l, r]$ 的两个端点 $l$ 和 $r$ 。</p>

<h2 id="批量更新">批量更新</h2>

<p>除了查询区间和之类的问题，树状数组也可以处理对原数组的批量更新的问题。</p>

<h3 id="单点查询">单点查询</h3>

<p>最简单的情况是批量更新后，只要求对某一个点进行查询。</p>

<p>这时，用一个 BIT 保存每个位置更新的累加值，初始化为 0 。</p>

<p>当查询原数组某个点的值时，就是求取 BIT 上该点的前缀和，再加上原值 。</p>

<p><strong>那么如何更新 BIT 的累加值？</strong></p>

<p>当对给定区间 $[l, r]$ 累加 $x$ 时，就在 $l$ 点处增加 $x$ ，并在 $r+1$ 点处减少 $x$ ，来取消对后面点的前缀和的影响。</p>

<p><em>为了省事儿，我们不再对此概念进行抽象，而是直接假定操作对象就是数字类型</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">range_add_for_origin</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span> <span class="n">addend</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.add</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">addend</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对 BIT 某点上进行更新的时候，需要连带更新它的所有父节点</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span> <span class="p">{</span>            
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">addend</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addend</span><span class="p">);</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="nd">range_len!</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="区间和查询">区间和查询</h3>

<p>如果批量更新后还要查询区间和（的更新），那么前面（通过前缀和的方式）仅对某一个点的更新值的记录就不够了。</p>

<p>怎么做呢？</p>

<p>解决方法并不那么直观，不妨先一步一步地考虑：</p>

<p>如果给定区间 $[l, r]$ 上批量加上 $x$ ，那么加值的前缀和应该是这样的：</p>

\[\text{sum}[0,i]=
\begin{cases}
0 &amp; i &lt; l \\\\
x \cdot (i-l+1) &amp; l \leqslant i \leqslant r \\\\
x \cdot (r-l+1) &amp; r \lt i \\
\end{cases}\]

<p>这个前缀和可以拆分为两部分：</p>

\[\text{sum}[0,i]=
\begin{cases}
0 \cdot i - 0 &amp; i &lt; l \\\\
x\cdot i - x\cdot (l-1) &amp; l \leqslant i \leqslant r \\\\
(x-x)\cdot i - (x \cdot (l-1) - x\cdot r) &amp; r \lt i \\
\end{cases}\]

<p>可以用前面区间更新后单点查询的思路，用一个树状数组 $\text{B}_1$ 表示前一部分的数值：</p>

\[\text{sum}(\text{B}_1)[0,i]=
\begin{cases}
0&amp; i &lt; l \\\\
x &amp; l \leqslant i \leqslant r \\\\
x-x &amp; r \lt i \\
\end{cases}\]

<p>用另一个树状数组 $\text{B}_2$ ，表示后一部分的值：</p>

\[\text{sum}(\text{B}_2)[0,i]=
\begin{cases}
0 &amp; i &lt; l \\\\
x\cdot (l-1) &amp; l \leqslant i \leqslant r \\\\
x \cdot (l-1) - x\cdot r &amp; r \lt i \\
\end{cases}\]

<p>计算 $\text{B}_1$：</p>

\[\begin{array}{l}
\text{add}(\text{B}_1,\ l,\ x)\\
\text{add}(\text{B}_1,\ r+1,\ -x)
\end{array}\]

<p>计算 $\text{B}_2$：</p>

\[\begin{array}{l}
\text{add}(\text{B}_2,\ l,\ x\cdot(l-1))\\
\text{add}(\text{B}_2,\ r+1,\ -x\cdot r)
\end{array}\]

<p>前缀和：</p>

\[\text{sum}[0,i] = \text{sum}(\text{B}_1)\cdot i - \text{sum}(\text{B}_2)\]

<p>给定区间 $[l, r]$ 的累积更新的和：</p>

\[\text{sum}[l, r] = \text{sum}[0,r] - \text{sum}[0,l-1]\]

<p>再加上原数组的区间和，就是更新后的数组的区间和。</p>

<p><strong>实现</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">RangeAddQuerySum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BIT</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,;</span>

<span class="k">impl</span> <span class="n">BIT</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_range_add_query_sum_aux</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="n">RangeAddQuerySum</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="nn">RangeAddQuerySum</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.len</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RangeAddQuerySum</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="n">BIT</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">cap</span><span class="p">],</span>
            <span class="n">_note</span><span class="p">:</span> <span class="n">PhantomData</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">add</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span> <span class="n">addend</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="na">.0</span><span class="nf">.add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">addend</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="k">as</span> <span class="nb">i32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.add</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">addend</span> <span class="o">*</span> <span class="n">r</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cd">/// Get update accumulation</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span> <span class="n">bit1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">BIT</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">bit1</span><span class="p">)</span> <span class="o">-</span> <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">self</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bit1</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">prefix</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">bit1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">BIT</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="n">bit1</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i32</span> <span class="o">-</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.prefix</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种实现可以利用之前为批量更新单点查询建立的树状数组。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>没有找到讲得特别清楚又特别详细的资料，cp-algorithms.com 本篇的从风格到质量都有失水准，反而 OI-wiki 还比较详细，明明是早已有的概念，却有相当多的内容上是近期更新的 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>我喜欢这个命名，简单形象不故弄玄虚 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>但是分段树能通过拆分区间，处理很多树状数组处理不了的在连续区间上的查询问题 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>图片来源于 https://www.baeldung.com/cs/fenwick-tree <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>数字的二进制表示里最低的一个 $1$ 的位置 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[本文主要参考 OI-wiki 以及 cp-algorithms.com 相关页面1 没有找到讲得特别清楚又特别详细的资料，cp-algorithms.com 本篇的从风格到质量都有失水准，反而 OI-wiki 还比较详细，明明是早已有的概念，却有相当多的内容上是近期更新的 &#8617;]]></summary></entry><entry><title type="html">分片级联（Fractional Cascading）</title><link href="/algs/FractionalCascading.html" rel="alternate" type="text/html" title="分片级联（Fractional Cascading）" /><published>2023-04-17T00:00:00+08:00</published><updated>2023-04-17T00:00:00+08:00</updated><id>/algs/FractionalCascading</id><content type="html" xml:base="/algs/FractionalCascading.html"><![CDATA[<p><em>本文主要参考 <a href="https://en.wikipedia.org/wiki/Fractional_cascading">wiki</a> ，对其中一些内容进行了拓展，对个别错误进行了修正。</em></p>

<p>分片级联是一种同时对多个有序列表进行二分查找的加速技术。</p>

<p>假设有 $k$ 个有序列表，给定一个元素 $q$ ，查询在每个有序列表上的位置。</p>

<h2 id="思路">思路</h2>

<h3 id="原始做法">原始做法</h3>

<p>依次在每个有序列表上执行二分查找，假设每个列表的<strong>平均长度为 $n$</strong> ，总长度 $N=kn$ ， 则时间复杂度为 $O(k\ \text{log}\ n)$ 。</p>

<h3 id="改进的做法">改进的做法</h3>

<p>可以提前处理下这 $k$ 个有序列表，为其中每个元素计算在每个列表的位置，然后把这些元素和对应的在每个列表的位置合成一个大的有序列表，查找的时候只需要在这个大的有序列表上进行一次二分查找就可以了。</p>

<p>根据查找到的元素对应的统计信息，直接得到全部 $k$ 个有序列表上的位置。</p>

<p>例如如下 $k=4$ 个有序列表的</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">L\i</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td>24</td>
      <td>64</td>
      <td>65</td>
      <td>80</td>
      <td>93</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td>23</td>
      <td>25</td>
      <td>26</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td>13</td>
      <td>44</td>
      <td>62</td>
      <td>66</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td>11</td>
      <td>35</td>
      <td>46</td>
      <td>79</td>
      <td>81</td>
    </tr>
  </tbody>
</table>

<p>得到</p>

<table>
  <thead>
    <tr>
      <th>L[0,6,12]</th>
      <th>L[1,7,13]</th>
      <th>L[2,8,14]</th>
      <th>L[3,9,15]</th>
      <th>l[4,10,16]</th>
      <th>l[5,11,17]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>11[0,0,0,0]</td>
      <td>13[0,0,0,1]</td>
      <td>23[0,1,1,1]</td>
      <td>24[0,1,1,1]</td>
      <td>25[1,1,1,1]</td>
      <td>26[1,2,1,1]</td>
    </tr>
    <tr>
      <td>35[1,3,1,1]</td>
      <td>44[1,3,1,2]</td>
      <td>46[1,3,2,2]</td>
      <td>62[1,3,2,3]</td>
      <td>64[1,3,3,3]</td>
      <td>65[2,3,3,3]</td>
    </tr>
    <tr>
      <td>66[3,3,3,3]</td>
      <td>79[3,3,4,3]</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>具体说明这个统计信息，以 $46[1,3,2,2]$ 为例，表明 $46$ 在 $L_1$ 的位置为 1 ，在 $L_2$ 的位置为 $3$ ，在 $L_3$ 的位置为 $2$ , 在 $L_4$ 的位置为 $2$ 。</p>

<p>这样如果我们查找 $q=45$ ，发现落到 $46$ 的位置，就直接使用 $46$ 的索引统计 $q=45$ 的索引结果即可。</p>

<p>这种做法，花费 $(k-1)n\text{log}(n)$ 的预处理时间，和 $kN$ <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>的空间，以实现 $O(\text{log}N)$ 时间复杂度的单次查询。</p>

<p>这样，单次查询的时间复杂度，从 $O(k\text{log}n)$ 变为 $O(\text{log}kn)$ , 相当于把 $k$ 放进了 log 里，性能得到了提升。</p>

<p>但是空间上 $kN$ 是非常的昂贵。</p>

<h3 id="分片级联">分片级联</h3>

<p>那么如何<em>在尽量保持改进的查询时间复杂度的情况下</em>降低空间复杂度呢？ 这才引出来，我们分片级联的技术。</p>

<p><strong>分片</strong>指得是分片取样（fractional sampling），<strong>级联</strong>（cascading）指得是并不同时保存所有k个列表的索引信息，而只是保存紧邻下一级的索引信息，然后一层层进行连锁。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>具体说就是：</p>

<ol>
  <li>构建一个预处理的列表 $M$ ，它的每一级 $M_i$ 都是由对应 $L_i$ 和下一级的 $M_{i+1}$ 中的元素构成，$M_i$ 存储元素本身以及每个元素在 $L_i$ 上的索引位置和 $M_{i+1}$ 上索引位置，这样一直到最后一级 $M_k$ ，因为没有下一级，所以只保存 $L_k$ 的元素，这体现了级联；</li>
  <li>次一级的 $M_{i+1}$ 里面不是每个元素都提升到 $M_i$ 里，而是两两取样<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，</li>
</ol>

<p>例如上述例子为</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">M\I</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td>24[0,1]</td>
      <td>25[1,1]</td>
      <td>35[1,3]</td>
      <td>64[1,5]</td>
      <td>65[2,5]</td>
      <td>79[3,5]</td>
      <td>80[3,6]</td>
      <td>93[4,6]</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td>23[0,1]</td>
      <td>25[1,1]</td>
      <td>26[2,1]</td>
      <td>35[3,1]</td>
      <td>62[3,3]</td>
      <td>79[3,5]</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td>13[0,1]</td>
      <td>35[1,1]</td>
      <td>44[1,2]</td>
      <td>62[2,3]</td>
      <td>66[3,3]</td>
      <td>79[4,3]</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td>11[0,0]</td>
      <td>35[1,0]</td>
      <td>46[2,0]</td>
      <td>79[3,0]</td>
      <td>81[4,0]</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>对于前面的，$q=45$ 的例子，假设取样的分片大小为 $f=2$</p>

<ol>
  <li>
    <p>对 $M_1$ ，进行二分查找，发现最小的 $\geqslant 45$ 的是 $64[1,5]$ ，于是对于 $L_1$ 的<strong>结果是 $1$</strong>，然后从 $M_2[5]$ 开始，直接根据所属分片的级联的信息，就像拉拉链一样，最多经过 $f-1$ 次比较就可以得到结果；</p>
  </li>
  <li>
    <p>然后比较 $M_2[5]$ 和它的前一项 $M_2[4]$ <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>发现 $M_2[5]=62[3,3]$ 是最小的 $\geqslant q$ 的一项，于是 $L_2$ 的<strong>结果是 $3$</strong>；</p>
  </li>
  <li>
    <p>比较 $M_3[3]$ 和 $M_3[2]$，发现 $M_3[3] =62[2,3]$ 是最小的 $\geqslant q$ 的项，于是 $L_3$ 的<strong>结果是 $2$</strong>；</p>
  </li>
  <li>
    <p>比较 $M_4[3]$ 和 $M_4[2]$ ，发现 $M_4[2]=46[2,0]$ 是最小的 $\geqslant q$ 的项，于是 $L_4$ 的<strong>结果是 $4$</strong>；</p>
  </li>
</ol>

<p>利用合并两个有序列表的方法处理每个 $L_i$ 和 $M_{i+1}$ 的分片，使用 $(k-1)n$ 的预处理时间，消耗的内存小于 $2N$ 个单元，对于数字类型来说，也就是 $3 * 2N = 6N$ 的空间复杂度。</p>

<h4 id="空间复杂度证明">空间复杂度证明</h4>

<p>预处理列表 M 每一层的空间（单元）：</p>

\[|M_i| = {\displaystyle n \sum_{j=1}^{k-i+1} (\frac{1}{f})^{j-1}}\]

<p>总共空间是（单元）：</p>

\[\begin{array}{l}
{\displaystyle \sum_{i=1}^k|M_i|} &amp;= {\displaystyle n\sum_{i=1}^k \sum_{j=1}^{k-i+1} (\frac{1}{f})^{j-1}}\\
&amp;\lt {\displaystyle n \sum_{i=1}^k \sum_{j=1}^{k+1} (\frac{1}{f})^{j-1}}\\
&amp;= {\displaystyle n \sum_{i=1}^k 1 + (\frac{1}{f}) + (\frac{1}{f})^2 ...,+(\frac{1}{f})^k}\\
&amp;\lt 2n{\displaystyle \sum_{i=1}^k 1}\\
&amp;= 2N
\end{array}\]

<h4 id="时间复杂度分析">时间复杂度分析</h4>

<p>由于 $M_1 \lt 2n$ ，因此单次查询的时间复杂度为 $O(\text{log}n + (f-1)k)$ 。</p>

<p>由于除了 log ，还多了一个 $k$ ,  于是情况就比较微妙了 。</p>

<ol>
  <li>
    <p>一方面，当 $k \ll n$ 时，分片级联的性能好于原始办法。</p>
  </li>
  <li>
    <p>但另一方面，如果 $k$ 相对 $n$ 较大，那分片级联相比于原始算法就没有优势，甚至更慢。</p>
  </li>
  <li>
    <p>而在几乎所有的情况下，只要 $k$ 不是特别小，改进算法还是最快的，是快好几倍的<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> ：很明显，对于 $\text{log}N$ ,即使 $N$ 取一个 <code class="language-plaintext highlighter-rouge">u64</code> 能表示的最大值，也就是相当于 $k=64$ 的大小，因此只要稍微大一点的 $k$ 都会使得查询性能不如改进算法</p>
  </li>
</ol>

<p>我们可以通过一个图表把这个问题看得更清楚，取一个固定的 $N$ ，让 $k$ 增长，观察</p>

<ol>
  <li>原始做法-raw</li>
  <li>改进做法-best</li>
  <li>$f=2$ 的分片级联-fc2</li>
  <li>$f=4$ 的分片级联-fc4</li>
</ol>

<p>的运行时间的变化：</p>

<p><img src="/assets/img/fc/time_stats1.svg" alt="" /></p>

<p>我们发现当 $k$ 从一个较小的值增长的时候，原始算法的性能会变得有些优于 $f=4$ 的分片级联。</p>

<p><img src="/assets/img/fc/time_stats2.svg" alt="" /></p>

<p>但如果拉长 $k$ 的取值话，发现分片级联还是明显优于原始做法。</p>

<h2 id="实现">实现</h2>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.3/coll/src/frac_casc.rs">源代码</a></p>

<h3 id="数据结构">数据结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">T</span><span class="p">]],</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>
</code></pre></div></div>

<p>对于 $q$ 的二分查找返回的结果是,  $\text{min}({x \in L,\ x &gt;= q})$</p>

<h3 id="构建">构建</h3>

<p>分片级联，对于输入有一些动态时才能检查的条件：</p>

<ol>
  <li>$k &gt; 0$；</li>
  <li>输入的 $k$ 个列表每个列表都不为空且都是有序的；</li>
  <li>分片大小 $f &gt; 0$</li>
</ol>

<p>构建 M 时：</p>

<ol>
  <li>采用 merge-sort 里面的 merge 操作合并 $L_i$ 和 $M_{i+1}$ ；</li>
  <li>对于列表中重复的元素只保留一份，因为标准的二分搜索不会区分不同位置的重复元素，留着也没用；</li>
  <li>同时注意如果 $M_{i+1}$ 的长度不能恰好被分片 $f$ 整除，需要把最后的尾元素补上，这样使得所有的完整的或者不完整的分片都有一个代表，就是分片的最大值，简化了比较逻辑</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]])</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.is_sorted</span><span class="p">()));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">F</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">l</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="o">!</span><span class="n">i</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="nf">.is_sorted</span><span class="p">()));</span>

        <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">build_m</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">build_m</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">]])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">METype</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">m</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[];</span> <span class="n">k</span><span class="p">];</span>

        <span class="cm">/* Init m_k*/</span>

        <span class="k">let</span> <span class="n">l_k</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">m_k</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">l_k</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_k</span><span class="nf">.push</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/* on guard */</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">m_i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">m_i</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">m2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">m_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">m1</span> <span class="o">=</span>
                <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="n">F</span><span class="p">));</span>

            <span class="cm">/* merge two sorted vec */</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="nd">macro_rules!</span> <span class="n">nxt_j</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$j:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// end</span>
                    <span class="k">if</span> <span class="nv">$j</span> <span class="o">==</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nv">$j</span> <span class="o">+</span> <span class="n">F</span> <span class="o">&gt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nv">$j</span> <span class="o">+</span> <span class="n">F</span>
                    <span class="p">}</span>
                <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="cm">/* skip dup */</span>

                        <span class="k">let</span> <span class="n">dup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                            <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">j</span><span class="p">));</span>

                        <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()));</span>

                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m2</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">m1</span><span class="nf">.push</span><span class="p">((</span><span class="n">m2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nf">Err</span><span class="p">(</span><span class="n">l1</span><span class="nf">.len</span><span class="p">()),</span> <span class="n">j</span><span class="p">));</span>

                <span class="n">j</span> <span class="o">=</span> <span class="nd">nxt_j!</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">m</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询">查询</h3>

<p>按照 Rust 的 API 风格，查找元素时用 <code class="language-plaintext highlighter-rouge">Result&lt;usize, usize&gt;</code> 类型区分相等的情况和最小大于的情况。</p>

<h4 id="查询-1">查询</h4>

<p>主流程：</p>

<ol>
  <li>在 <code class="language-plaintext highlighter-rouge">m[0]</code> 上执行二分查找，找到“拉链头”；</li>
  <li>然后在后续的 <code class="language-plaintext highlighter-rouge">m[1..m.len()]</code> 上“拉拉链”，在每一级上，都会在分片大小的范围内找到结果</li>
</ol>

<p>考虑重复元素的情况，实际上前面讲的“区分相等的情况和最小大于的情况”的说法并不严谨，实际 API 返回值的要求应该是<strong>相等和插入后保持有序两种情况</strong> ，这意味着：</p>

<ol>
  <li>如果存在重复的最小大于的元素，不能随便选一个返回它的索引位置，而是应该返回最左边的那一个；</li>
  <li>在极端的最坏情况下，这可能会拖累性能到线性</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">find</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.find_</span><span class="p">(</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">find_handle_approx_result</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">find_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">handler</span><span class="p">:</span> <span class="n">FindHandler</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nf">Err</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="k">self</span><span class="py">.m</span><span class="nf">.len</span><span class="p">()];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span><span class="p">;</span>

        <span class="c1">// 1. assign res[0]</span>
        <span class="c1">//</span>
        <span class="c1">// 2. m_idx</span>
        <span class="c1">//</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">x</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Err</span><span class="p">(</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">());</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="k">self</span><span class="py">.m</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">elected</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">elected</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cand</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">cand</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cand</span><span class="p">]</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="n">cand</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cand</span><span class="p">]</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="n">cand</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">elected</span> <span class="o">=</span> <span class="n">cand</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">elected</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">handler</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">elected</span><span class="p">);</span>

            <span class="n">j</span> <span class="o">=</span> <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">elected</span><span class="p">]</span><span class="na">.2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">find_handle_approx_result</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">dup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">k</span><span class="nf">.borrow</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">unpack_result!</span><span class="p">(</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>

                <span class="c1">// go back (the worst case down to O(nk))</span>
                <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">idx</span> <span class="o">=</span> <span class="nd">unpack_result!</span><span class="p">(</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>

                <span class="c1">// go forward (the worst case down to O(nk))</span>
                <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dup</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dup</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">Err</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FindHandler</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
    <span class="nb">usize</span><span class="p">,</span>
    <span class="nb">usize</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="快速查询">快速查询</h4>

<p>如果不考虑对重复元素的插入顺序的情况，可以直接这样写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">FractionalCascading</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Ignore duplicated case</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">quick_find</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.find_</span><span class="p">(</span><span class="n">k</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="k">Self</span><span class="p">::</span><span class="n">quick_find_handle_approx_result</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">quick_find_handle_approx_result</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">match</span> <span class="n">k</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="na">.1</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>   
<span class="p">}</span>
</code></pre></div></div>

<h2 id="后续">后续</h2>

<h3 id="动态">动态</h3>

<p>关于动态分片级联的问题，也就是目标数组被修改时的更新。</p>

<p>这将完全抛弃数组结构而采用经典地采用树型结构，就像前文介绍过的在 B+ 树的数组实现明显区别于和 TreeMap 实现一样，实现的具体细节将完全不同。</p>

<p>由于<a href="https://en.wikipedia.org/wiki/Fractional_cascading#Dynamic_fractional_cascading">介绍</a>的细节繁杂，也没有详细的示例，深入下去必然耗费大量时间，且已经偏离了主要介绍的内容，因此等需要的时候再来回顾吧。</p>

<h3 id="应用">应用</h3>

<p><a href="https://en.wikipedia.org/wiki/Fractional_cascading#Applications">计算几何方面的问题</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>假设元素类型也是和索引位置一样的类型 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>总感觉分片级联就像斐波那契堆一样，对复杂度采取逐级抵抗的办法，应该进行可以一些类比 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>两两取样也就是分片的大小为 $2$ ，当然也可以选择其他的分片大小 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>因为分片大小是 $2$ ，所以比较两项，如果分片大小是 $4$ 那就比较 $4$ 项 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>可以视作对应分片 $f=1$ 的情况，虽然此时耗费多一半的空间 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[本文主要参考 wiki ，对其中一些内容进行了拓展，对个别错误进行了修正。]]></summary></entry><entry><title type="html">分段树（Segment Tree）</title><link href="/algs/SegmentTree.html" rel="alternate" type="text/html" title="分段树（Segment Tree）" /><published>2023-04-10T00:00:00+08:00</published><updated>2023-04-10T00:00:00+08:00</updated><id>/algs/SegmentTree</id><content type="html" xml:base="/algs/SegmentTree.html"><![CDATA[<p>更常见的名字是<strong>线段树</strong>，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？</p>

<p>本文基本算是对 <a href="https://cp-algorithms.com/data_structures/segment_tree.html">cp-algorithms - Segment Tree</a> 的一个 Rust 实现版本的介绍。</p>

<h2 id="基础概念">基础概念</h2>

<p>分段树是用来解决数组上区间查询问题的数据结构。</p>

<p>它把数组代表的区间不断二分，直到区间小到只含有单个元素，把它们用二叉树的结构组织起来，顶点代表整个区间，它的左孩子和右孩子分别代表整个区间的左右两半，以此类推，直到叶子节点。</p>

<p>如<a href="https://cp-algorithms.com/data_structures/segment_tree.html#structure-of-the-segment-tree">原文这里</a>所示。</p>

<p>它非常好地体现了分治<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>思想，有了这样的数据结构后，当面对一个区间查询时，只需要在从根到叶子对树递归时把已有的局部区间的答案进行组合，就能得到最终答案。</p>

<h3 id="查询的复杂度">查询的复杂度</h3>

<p>可以证明查询过程中每一层最多访问 $4$ 个节点。</p>

<p>使用归纳法证明，初始条件是一个节点，符合。</p>

<p>假设上一层访问不超过 $4$ 个节点：</p>

<ol>
  <li>如果上一层只访问了两个或更少的节点，那么这一层最多访问 $4$ 个；</li>
  <li>如果上一层访问 $3$ 个或 $4$ 个节点，由于访问的区间是连续的，中间部分正好对应分段树的区间，会直接返回，因此只有边缘的左右两个节点可能会向下访问，这一层仍然最多访问 $4$ 个</li>
</ol>

<p>证毕。</p>

<p>因此查询的时间复杂度由树高决定，是 $O(\text{log}n)$ 。</p>

<h2 id="实现前瞻">实现前瞻</h2>

<p>作为树型结构自然就有数组和指针两种实现，而分段树可以很容易地使用数组实现<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，这让它看起来非常靠谱！</p>

<p>接下来我们主要讨论的就是线段树的<a href="https://github.com/minghu6/rust-minghu6/tree/v0.1.4/coll/src/segment_tree">数组实现</a>。</p>

<h2 id="树的布局">树的布局</h2>

<p>我们首先想到的就是水平布局，也就是按照完全二叉树的结构，依次放置每一层的节点，我们可以称之为 BFS 型布局。</p>

<h3 id="bfs-型">BFS 型</h3>

<p>BFS 型有一个很好的性质就是计算节点的左右孩子的位置非常简单，如果我们的数组编号从 $1$ 开始，那么根据完全二叉树的性质， $t[i]$ 节点的左孩子和右孩子分别为 $t[2\cdot i]$ 和 $t[2\cdot i+1]$ 。</p>

<p>可以很容易地证明这一点：</p>

<p>首先，已知高度为 $h$ 的满的完全二叉树有 $2^h - 1$ 个节点<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>，高度为 $h$ 的层有 $2^{h-1}$ 个节点。</p>

<p>假设 $t[i]$ 节点在树的 $h$ 层，同一层的前面包括它在内，有 $x$ 个节点，后面有 $y$ 个节点，那么显然有:</p>

\[\begin{array}{l}
i &amp;= 2^{h-1} - 1 + x &amp;\quad(1)\\
x+y &amp;= 2^{h-1} &amp;\quad (2)\\
\end{array}\]

<p>而它与左孩子的距离 $d$ 有 $d=y+2(x-1)+1$ ，利用 $(2)$ 式消解掉 $y$ ，得到 $d=2^{h-1} + x - 1 = i$ ，也就是 $t[i]$ 节点的左孩子距离为 $i$ ，右孩子紧邻左孩子，距离为 $i+1$ ，证毕。</p>

<p>如果我们的编号不从 1 开始，而是从 0 开始，那么有 $i’ = i-1$ ，带入 ${\large i_{\text{left}}} = 2i$ ，有 ${\large i ’_{\text{left}}}+1=2(i’+1)$  ，于是：</p>

\[\begin{array}{l}
{\large i ’_{\text{left}}} &amp;=2i'+1\\
{\large i ’_{\text{right}}} &amp;=2i’+2
\end{array}\]

<p>需要指出的是，虽然我们按照完全二叉树的结构排列节点，但<strong>分段树本身并不一定是完全二叉树，最后一层的节点并不是规律地从左开始分布</strong><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，而是按照本身的奇偶性规律排布，比如考虑 $6$ 个元素的分段树：$(6)-(3, 3)-(2, 1, 2, 1)$ 。</p>

<p>按照水平布局，分段树数组需要的节点数按照满的完全二叉树来说是 $2^h -1 = 2^{\lceil \text{log}_2 n \rceil} - 1 &lt; 2^{\lceil \text{log}_2 n\rceil} \leqslant 4n$ ，因此即使以 $1$ 为基，也只需要分配 $4n$ 大小的空间。</p>

<h3 id="dfs-型">DFS 型</h3>

<p>仔细考虑一下分段树的形状，发现它准确说应该是一棵<a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">满二叉树（full binary tree）</a>，而满二叉树有这样的性质，就是如果叶子节点数为 $i$ ，那么中间节点数就是 $i-1$ ，整棵树的节点数就是 $2\cdot i-1$ 。</p>

<p>这个性质不需要特别证明，它直接就是定义给出的：满二叉树的直接定义是节点要么没有孩子，要么有两个孩子，但它还有一个递归定义：</p>

<ol>
  <li>单节点是满二叉树；</li>
  <li>根的两个孩子都是满二叉树的二叉树是满二叉树</li>
</ol>

<p>这个递归定义也就是我们诱导推理的过程：</p>

<ol>
  <li>单节点的时候，叶子节点比中间节点数多 $1$ ；</li>
  <li>假设根的两个孩子都是满二叉树，那么左右孩子上的叶子节点数之和比中间结点数之和多 $2$ ，加上作为中间节点的根节点，于是整棵树的叶子节点仍然比中间节点多 $1$</li>
</ol>

<p>证毕。</p>

<p>根据满二叉树这个性质，我们可以发现，<strong>为长度为 $n$ 的数组建立的分段树确定地含有 $2n-1$ 个节点</strong> ，这么一看，BFS 型申请的 $4n$ 的空间实在有些浪费，于是有了内存节省布局的 DFS 型。</p>

<p>DFS 顾名思义是垂直布局，放置根节点后，先放置整棵左树，再放置整棵右树。不过单纯地垂直布局并不会节省空间，真正关键的是在垂直分布中，我们使用了满二叉树的布局而不是完全二叉树的布局，这是因为在树上遍历的过程中，我们知道节点所代表的范围区间，也就是节点所代表的子树的叶子节点数，因此我们可以计算出整棵子树的大小。</p>

<p>这样我们就可以直接计算出左右孩子的位置，对节点 $t[i]$ ，设左孩子对应区间长度为 $l$ ，则它的左右孩子分别为 $t[i+1]$ 和 $t[i+2\cdot l-1 + 1]=t[i+2\cdot l]$ 。</p>

<p>这样即使仍然基 $1$ ，也只需要申请 $2n$ 大小的空间，比起 BFS 型整整节省了一半的空间！</p>

<p>全面地比较这两型布局：</p>

<p>时间性能上，由于我们的访问是逐层进行的，BFS 的分层布局使得左右两个孩子紧邻，有更好地局部性，但毕竟仍然是在同一个数组上访问，差距也大不到哪儿去，事实上经过一个简单测试，发现两型的性能几乎没有区别；</p>

<p>空间性能上，DFS 型完胜，BFS double 了空间占用，太差了；</p>

<p>易用性上，BFS 是普通人都能想到的，左右孩子的位置也很简单，不过 DFS 型经过我的讲解也是非常的简单易懂，两者没有明显差别。</p>

<p>综合以上比较，更推荐 DFS 型作为默认地数组上的默认布局。</p>

<h2 id="范式的描述">范式的描述</h2>

<p>我们尝试尽量用 Rust 的抽象机制把本篇涉及的所有概念这些可选项揉到一起。</p>

<h3 id="布局和游标">布局和游标</h3>

<p>为了描述分段树的布局，我们先用一个结构统一保存树上遍历需要的索引信息：分段数组的索引 <code class="language-plaintext highlighter-rouge">i</code> 和对应原数组的区间<code class="language-plaintext highlighter-rouge">[tl, tr]</code> ：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// (i, tl, tr)</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Cursor</span> <span class="p">{</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tl</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tr</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是可以定义树形布局的抽象：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TreeLayout</span><span class="p">:</span> <span class="nn">private</span><span class="p">::</span><span class="n">Sealed</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">private</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Sealed</span> <span class="p">{}</span>

    <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="k">super</span><span class="p">::</span><span class="n">BFS</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Sealed</span> <span class="k">for</span> <span class="k">super</span><span class="p">::</span><span class="n">DFS</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用了继承私有模块的公共 Trait 来封装暴露给下游的公共 Trait 的技巧，因为我们定义并暴露出 <code class="language-plaintext highlighter-rouge">TreeLayout</code> 只是为了允许用户自由选择他们需要的线段树布局，而并不期望用户实现它。</p>

<p>对于 BFS 和 DFS 两型：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TreeLayout</span> <span class="k">for</span> <span class="n">BFS</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">4</span> <span class="o">*</span> <span class="n">cap</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TreeLayout</span> <span class="k">for</span> <span class="n">DFS</span> <span class="p">{</span>
    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">left_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">right_i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// i + 2(n(left))</span>
        <span class="n">c</span><span class="py">.i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nd">tm!</span><span class="p">(</span><span class="n">c</span><span class="py">.tl</span><span class="p">,</span> <span class="n">c</span><span class="py">.tr</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="n">cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="分段树">分段树</h3>

<p>此时我们可以初步地引出我们分段树的结构：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span> <span class="o">=</span> <span class="n">DFS</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="n">_note</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Count</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">combine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
    <span class="cd">/// identity element: any stats combine with e results itself</span>
    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>泛型 <code class="language-plaintext highlighter-rouge">T</code> 代表了分段树储存的对数组区间的统计信息，泛型 <code class="language-plaintext highlighter-rouge">C</code> 代表了统计方法，它提供了一个归并两个统计数据的方法和一个返回幺元的方法。</p>

<p>借着是分段树的创建，可一窥树上遍历的基本方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="nf">.is_empty</span><span class="p">());</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span> <span class="nn">L</span><span class="p">::</span><span class="nf">size</span><span class="p">(</span><span class="n">raw</span><span class="nf">.len</span><span class="p">())];</span>

        <span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nn">Cursor</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="n">raw</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">root</span><span class="p">,</span>
            <span class="n">_note</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="n">build</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">U</span><span class="p">],</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="py">.tl</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.raw_into_stats</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.i</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Cursor</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="n">raw_len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">tl</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="n">raw_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tl</span> <span class="o">==</span> <span class="k">self</span><span class="py">.tr</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="nf">is_matched</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tl</span> <span class="o">==</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.tr</span> <span class="o">==</span> <span class="n">r</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">godown_left</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="nn">L</span><span class="p">::</span><span class="nf">left_i</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">tl</span><span class="p">:</span> <span class="k">self</span><span class="py">.tl</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="nd">tm!</span><span class="p">(</span><span class="k">self</span><span class="py">.tl</span><span class="p">,</span> <span class="k">self</span><span class="py">.tr</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline(always)]</span>
    <span class="k">fn</span> <span class="n">godown_right</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="nn">L</span><span class="p">::</span><span class="nf">right_i</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">tl</span><span class="p">:</span> <span class="nd">tm!</span><span class="p">(</span><span class="k">self</span><span class="py">.tl</span><span class="p">,</span> <span class="k">self</span><span class="py">.tr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">tr</span><span class="p">:</span> <span class="k">self</span><span class="py">.tr</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">tm</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tl:expr</span><span class="p">,</span> <span class="nv">$tr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">(</span><span class="nv">$tl</span> <span class="o">+</span> <span class="nv">$tr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">left</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$c:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$c</span><span class="py">.godown_left</span><span class="p">::</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">right</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$c:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$c</span><span class="py">.godown_right</span><span class="p">::</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里涉及了一个 <code class="language-plaintext highlighter-rouge">RawIntoStats</code> 的 Trait ，它提供了原始数组上的元素针对某种统计方法需要的某个统计类型进行转换的抽象：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="查询">查询</h3>

<p>尝试划分按照分段树的区间进行划分，直到一个错误的区间范围，这时直接返回幺元，比起检查返回值要简洁很多</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span><span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">self</span><span class="py">.root</span><span class="p">),</span> <span class="k">self</span><span class="py">.root</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">,</span> <span class="n">r</span><span class="p">)),</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">((</span><span class="nf">max</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// -&gt; (l, r)</span>
<span class="nd">macro_rules!</span> <span class="n">parse_range</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$range:expr</span><span class="p">,</span> <span class="nv">$root:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nn">Bound</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="nv">$range</span><span class="p">;</span>
		<span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="nv">$root</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">l</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">r</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.start_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">root</span><span class="py">.tl</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">match</span> <span class="n">range</span><span class="nf">.end_bound</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Included</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
            <span class="nf">Excluded</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="o">*</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"range upper is invalid (=0)"</span><span class="p">);</span>
                <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">}</span>
            <span class="n">Unbounded</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">root</span><span class="py">.tr</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更新">更新</h3>

<p>如果原数组的某个值发生了更新，那么对应地，从分段树的根一直到该值所在的叶子，整条路径也需要更新：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>        
	<span class="k">pub</span> <span class="k">fn</span> <span class="nf">assoc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.root.tr</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_val</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">assoc_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span> <span class="n">ti</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">new_val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">clf</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">crh</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">ti</span> <span class="o">&lt;=</span> <span class="n">clf</span><span class="py">.tr</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">new_val</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span><span class="n">crh</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">new_val</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">c</span><span class="py">.i</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">clf</span><span class="py">.i</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">crh</span><span class="py">.i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="经典问题">经典问题</h2>

<p>我们将会层层递进地介绍一些适用于上述分段树范式的经典问题。</p>

<p>但是在此之前，先介绍下一个方便对为数字类型批量实现 <code class="language-plaintext highlighter-rouge">RawIntoStats</code> 的辅助宏。出于一些考虑，Rust 并没有把数字，包括整型和浮点数型单独抽象出来，而是针对具体地实类型单独实现方法。不过它们也没有真的手写这些代码，也是用宏来批量实现的<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>，正如我前面某篇博文里吐槽过的，凡是 Rust 自己都觉得不方便而开发内部辅助结构的，下游用户一定会重新造轮子，一个它内部工具的复制品。</p>

<h3 id="辅助宏">辅助宏</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_raw_into_stats</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">monomorphic</span> <span class="p">|</span> <span class="nv">$struct:ident</span><span class="p">,</span> <span class="nv">$for_ty:ty</span><span class="p">,</span> <span class="nv">$stats_ty:ty</span> <span class="p">{</span> <span class="nv">$fn:item</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="nv">$struct</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nv">$stats_ty</span><span class="p">;</span>

            <span class="nv">$fn</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$struct:ident</span><span class="p">,</span> <span class="nv">$for_ty:ty</span><span class="p">,</span> <span class="nv">$stats_ty:ty</span> <span class="p">{</span> <span class="nv">$fn:item</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">RawIntoStats</span><span class="o">&lt;</span><span class="nv">$struct</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nv">$stats_ty</span><span class="p">;</span>

            <span class="nv">$fn</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="n">all</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">int</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">float</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">int</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="n">sint</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">uint</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">float</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">f32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">f64</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="nb">uint</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u128</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u64</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">usize</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u16</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">u8</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$name:ident</span><span class="p">|</span><span class="n">sint</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i128</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i64</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">isize</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i32</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i16</span><span class="p">);</span>
        <span class="nd">impl_for_num!</span><span class="p">(</span><span class="nv">$name</span><span class="p">|</span><span class="nb">i8</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个用于数字类型批量实现的辅助宏起始可以广泛地使用。</p>

<h3 id="简单单值">简单单值</h3>

<p>最简单的情况，就是统计类型和原数组值类型一致。</p>

<p>比如，查询原数组上给定区间范围的元素和。</p>

<p>这非常简单：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">Sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="n">l</span><span class="nf">.borrow</span><span class="p">()</span> <span class="o">+</span> <span class="n">r</span><span class="nf">.borrow</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">T</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="p">(</span><span class="n">sum_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">sum_stats</span> <span class="p">|</span> <span class="n">all</span><span class="p">);</span>
</code></pre></div></div>

<p>类似地，求解最大值，最大公约数，最小公倍数等等，都是类似的，这里不再赘述。</p>

<h3 id="复合类型">复合类型</h3>

<p>稍微复杂一点，统计给定区间的最大值和出现次数。</p>

<p>这里的 <code class="language-plaintext highlighter-rouge">Min&lt;T&gt;</code> Trait 是为所有数字类型实现的获取其最小值的抽象，相当于 <code class="language-plaintext highlighter-rouge">T::MIN</code> ,</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">MaxStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">MaxStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">l</span><span class="na">.0</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="na">.0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">l</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">l</span><span class="na">.1</span> <span class="o">+</span> <span class="n">r</span><span class="na">.1</span><span class="p">),</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">as</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">min</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">trait</span> <span class="n">Min</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">min</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    
    <span class="p">(</span><span class="n">max_stats_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">MaxStats</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="p">(</span><span class="nv">$for_ty</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">min</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span> <span class="n">Min</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">min</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$for_ty</span> <span class="p">{</span>
                <span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span><span class="p">::</span><span class="n">MIN</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">min</span> <span class="p">|</span> <span class="n">all</span><span class="p">);</span>
<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">max_stats_stats</span> <span class="p">|</span> <span class="nb">int</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="排名位置">排名位置</h3>

<p>比如，统计 $0$ 的个数，并查找第 $k$ 个 $0$ 的位置</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">ZeroStats</span><span class="p">;</span>


<span class="k">impl</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">ZeroStats</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="o">*</span><span class="n">r</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">zero_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">monomorphic</span><span class="p">|</span><span class="n">ZeroStats</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>设计上，特殊的方法放到具体 Trait 上，下同。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ZeroStats</span> <span class="p">{</span>
    <span class="cd">/// Start from 0</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">find_nth</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">tree</span><span class="py">.root</span><span class="p">]</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">find_nth_</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">c</span><span class="py">.tl</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">clf</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">crh</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="n">clf</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">clf</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">find_nth_</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">tree</span><span class="p">[</span><span class="n">clf</span><span class="p">],</span> <span class="n">crh</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>类似地还有查找给定区间里的元素位置，使得它的前缀和不小于给定值。</p>

<h3 id="findfirst">FindFirst</h3>

<p>查找给定区间里第一个符合条件的元素的位置。</p>

<p>比如，查找给定区间里第一个严格大于给定值的值的位置。</p>

<p>首先构建一个统计最大值的分段树：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">l</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="p">,</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="p">,</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">max_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="nv">$for_ty</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">self</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">max_stats</span> <span class="p">|</span> <span class="nb">int</span><span class="p">);</span>
</code></pre></div></div>

<p>在此基础上实现 findfirst 类型的问题：</p>

<p>从根开始下降，直到区间范围在给定的范围之内，这是 <code class="language-plaintext highlighter-rouge">query_first_gt_1</code> 做的事情，然后在这个区间里做<a href="#查找排名位置">前一个小节</a>里那样的查询。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Max</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span><span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">query_first_gt</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="n">x</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">query_first_gt_1</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// left or right</span>
        <span class="k">if</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">||</span> <span class="n">c</span><span class="py">.tr</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// inner</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">c</span><span class="py">.tr</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="py">.tl</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// cross</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// avoid bound overflow</span>
            <span class="k">let</span> <span class="n">left_res</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">left_res</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">left_res</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_1</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">query_first_gt_2</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">Self</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_end</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">c</span><span class="py">.tl</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">query_first_gt_2</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最大和的子分段">最大和的子分段</h3>

<p>这是一个特定的，但是复杂的问题：查找给定区间范围内的一个子区间，使得有区间里所有元素之和最大。</p>

<p>解决这个问题的构思还是比较巧妙的，利用一个复杂的统计结构，分而治之地分而治之，这个结构包含 4 个成员：</p>

<ol>
  <li>pref，最大前缀和；</li>
  <li>suff，最大后缀和；</li>
  <li>sum，区间元素之和；</li>
  <li>ans，区间答案，也就是最大的子区间和</li>
</ol>

<p>区间答案就是由三个后选值：</p>

<ol>
  <li>左区间的答案；</li>
  <li>右区间的答案；</li>
  <li>左区间最大后缀和 + 右区间最大前缀和</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone,</span> <span class="nd">Copy,</span> <span class="nd">Debug,</span> <span class="nd">Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// total sum of the segment</span>
    <span class="k">pub</span> <span class="n">sum</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// max prefix sum</span>
    <span class="k">pub</span> <span class="n">pref</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// max suffix sum</span>
    <span class="k">pub</span> <span class="n">suff</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="cd">/// query answer of max sum of the segment</span>
    <span class="k">pub</span> <span class="n">ans</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Count</span> <span class="k">for</span> <span class="n">SubSegMaxSum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">type</span> <span class="n">Stats</span> <span class="o">=</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">combine</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Stats</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="n">SubSegMaxSumStats</span> <span class="p">{</span>
            <span class="n">sum</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">l</span><span class="py">.sum</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.sum</span><span class="p">,</span>
            <span class="n">pref</span><span class="p">:</span> <span class="nf">max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.pref</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.sum</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.pref</span><span class="p">))</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">suff</span><span class="p">:</span> <span class="nf">max</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.suff</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.sum</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.suff</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span>
            <span class="n">ans</span><span class="p">:</span> <span class="nd">max!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.ans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.ans</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="py">.suff</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">r</span><span class="py">.pref</span><span class="p">))</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">e</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">max</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$val:expr</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="p">[</span><span class="nv">$</span><span class="p">(</span><span class="nv">$val</span><span class="p">),</span><span class="o">+</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">impl_for_num</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">(</span><span class="n">sub_seg_max_sum_stats</span><span class="p">|</span> <span class="nv">$for_ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">impl_raw_into_stats!</span><span class="p">(</span><span class="n">SubSegMaxSum</span><span class="p">,</span> <span class="nv">$for_ty</span><span class="p">,</span> <span class="n">SubSegMaxSumStats</span><span class="o">&lt;</span><span class="nv">$for_ty</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">raw_into_stats</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Stats</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">non_neg</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="p">);</span>

                <span class="n">SubSegMaxSumStats</span> <span class="p">{</span>
                    <span class="n">sum</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span>
                    <span class="n">pref</span><span class="p">:</span> <span class="n">non_neg</span><span class="p">,</span>
                    <span class="n">suff</span><span class="p">:</span> <span class="n">non_neg</span><span class="p">,</span>
                    <span class="n">ans</span><span class="p">:</span> <span class="n">non_neg</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">impl_for_num!</span><span class="p">(</span><span class="n">sub_seg_max_sum_stats</span> <span class="p">|</span> <span class="n">sint</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="保存整个子数组">保存整个子数组</h2>

<p>有一种分段树是在每个点上保存原数组对应区间里的所有值。</p>

<p>如果保存的子数组是用有序向量存储的，那么这个分段树实际上是在空间上还原了归并排序的整个过程，因此它也可以叫做 “<strong>Merge Sort Tree</strong>” ，可以在上面执行一系列查询的操作。</p>

<p>存储有序向量对原数组的元素修改时成本较高，可以改为经典的以 TreeMap 为基础的 multiset <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>，</p>

<h3 id="findfirst-1">FindFirst</h3>

<p>分段树本身的查询复杂度是 $O(\text{log}n)$ ，有序向量或者 multiset 上查询的时间复杂度也是 $O(\text{log}n)$ ，因此总的时间复杂度是 $O(\text{log}^2n)$ 。</p>

<h3 id="分片级联">分片级联</h3>

<p>可以考虑使用 <a href="/algs/FractionalCascading.html">分片级联</a> 的思想来加速对 findfirst 问题查询的过程。</p>

<p>这样的话，在树的构建过程中，不只是存储整个子数组，而是分片级联里面的 $M$  列表，区别是原来是级联下一级，所以存储下一级的索引，而现在要级联左右孩子，需要存储左右孩子上的索引。</p>

<p>另外，由于需要保存整个子数组，所以只级联，不分片<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup> 。</p>

<p>于是查询的过程就变为，在根节点上进行一次二分查找，然后做最多树高度的拉链。</p>

<p>以 $3$ 倍的空间为代价，让查询的时间复杂度降到了 $O(\text{log}n)$ 。</p>

<h2 id="区间更新">区间更新</h2>

<p>分段树支持一种在给定区间上快速地批量更新元素<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup>的方法。</p>

<p>这个区间更新的方法利用了“惰性更新”的思想，不妨以 update-add ，也就是批量增加一个固定值为例：</p>

<h3 id="惰性方法">惰性方法<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">10</a></sup></h3>

<p>在更新的时候，只更新到给定区间覆盖到的分段树上的区间。</p>

<p>比如对于分段树 $t[0..7]$ ，更新区间 $[3..7]$ ，则惰性更新的路径为：</p>

\[\begin{array}{l}
t[0..7] &amp; \rightarrow [0..3] \rightarrow [2..3] \rightarrow [3]\\
        &amp; \rightarrow [4..7]
\end{array}\]

<p>这就需要在分段树的区间上额外存储惰性更新的值，为了不影响既有结构，我们用额外的一个辅助数组来存储它：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_updater</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">UpdaterAdd</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()],</span> <span class="n">PhantomData</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>惰性更新的过程与一般得分段树的查询过程一样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">AddAssign</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">assoc</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
        <span class="n">addend</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">addend</span><span class="p">,</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">assoc_</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">addend</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">addend</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.propagate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

            <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">)),</span>
                <span class="n">addend</span><span class="nf">.clone</span><span class="p">(),</span>
                <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
            <span class="p">);</span>
            <span class="k">self</span><span class="nf">.assoc_</span><span class="p">(</span>
                <span class="n">tree</span><span class="p">,</span>
                <span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span>
                <span class="n">addend</span><span class="p">,</span>
                <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
            <span class="p">);</span>

            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)],</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">is_marked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Lazy propagation</span>
    <span class="k">fn</span> <span class="nf">propagate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_marked</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>

            <span class="n">tree</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+</span> <span class="o">&amp;</span><span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>

            <span class="k">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>惰性更新只有当查询到某一层时，才会把更新推到分段树的下一层：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Count</span><span class="o">&lt;</span><span class="n">Stats</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="n">TreeLayout</span><span class="o">&gt;</span> <span class="n">UpdaterAdd</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">Default</span> <span class="o">+</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">AddAssign</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="nb">Add</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="p">,</span>
    <span class="k">for</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">query</span><span class="o">&lt;</span><span class="n">R</span><span class="p">:</span> <span class="n">RangeBounds</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">range</span><span class="p">:</span> <span class="n">R</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="p">{</span>
        <span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
            <span class="n">tree</span><span class="p">,</span>
            <span class="nd">parse_range!</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">tree</span><span class="py">.root</span><span class="p">),</span>
            <span class="n">tree</span><span class="py">.root</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">query_</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">L</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">c</span><span class="p">:</span> <span class="n">Cursor</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">C</span><span class="p">::</span><span class="nf">e</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">c</span><span class="nf">.is_matched</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="nf">.clone</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.propagate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

            <span class="nn">C</span><span class="p">::</span><span class="nf">combine</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
                    <span class="n">tree</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tr</span><span class="p">)),</span>
                    <span class="nd">left!</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="nf">.query_</span><span class="p">(</span>
                    <span class="n">tree</span><span class="p">,</span>
                    <span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="py">.tl</span><span class="p">),</span> <span class="n">r</span><span class="p">),</span>
                    <span class="nd">right!</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="其他更新">其他更新</h3>

<p>对于给定区间的批量赋值，更加简单，只需要每个需要更新的区间存储一个标记位。当然如果是多个批量赋值，还是要一个完整的值的辅助数组。</p>

<h2 id="推广到更高维度">推广到更高维度<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup></h2>

<p>简单的二维分段树基本按照先构建第一个维度，然后在第一个维度下降到叶子时再构建第二个维度。</p>

<h2 id="持久化版本">持久化版本</h2>

<p>谈到持久化版本，就是树型结构，而且是指针构造的树型结构。</p>

<p>分段树自然很容易做成持久化版本，更新的时候直接复制更新路径就可以。</p>

<p>但是需要从本来的数组实现转为指针实现，这让这个问题变得有点儿鸡肋，因为性能损失实在有些不可接受。</p>

<h2 id="动态分段">动态分段</h2>

<p>如果不能一次性地构建完整棵分段树，可以进行动态分段，只有当查询到某个区间的节点时再进行创建。</p>

<p>但是这也假设了指针实现版本的分段树，同样鸡肋。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>你不知道主语义是<strong>线</strong>状还是分<strong>段</strong> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>divide and rule <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>如果原数组的长度是确定的，那么对应的线段树也是确定的 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>由等比数列前项和 $S_n = a_1{\Large \frac{1-q^n}{1-q}} = 1·{\Large \frac{1-2^n}{1-2}} = 2^n - 1$ 可推 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>只要数组的大小不是 $2$ 的幂 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>这实在有些，说句文言，脱裤子放屁，还不如想办法用 Trait 数字类型给抽象出来 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>bag <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>或者说分片大小为 $1$ <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>比如批量地增加一个值，或者批量地赋予一个值 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Lazy propagation <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>树套树 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[更常见的名字是线段树，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦1的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？ 你不知道主语义是线状还是分段 &#8617;]]></summary></entry><entry><title type="html">最大公约数（Great Common Divisor）</title><link href="/algs/GCD.html" rel="alternate" type="text/html" title="最大公约数（Great Common Divisor）" /><published>2023-04-06T00:00:00+08:00</published><updated>2023-04-06T00:00:00+08:00</updated><id>/algs/GCD</id><content type="html" xml:base="/algs/GCD.html"><![CDATA[<p>假设对于非负整数，$a$ ,  $b$ ，求它们的最大公约数 $\text{gcd}(a, b)$ ，以下简写作 $g$ 。</p>

<p>数学上，最大公约数只有对两个非零整数才有意义，但是一般从实现的方面，规定：</p>

<ol>
  <li>$\text{gcd}(0, b) = a$ ,  $\text{gcd}(a, 0) = a$</li>
  <li>$\text{gcd}(0, 0) = 0$</li>
</ol>

<h2 id="辗转相减">辗转相减</h2>

<p>也是原始的欧几里得（Euclidean）算法。</p>

<p>根据定义有：</p>

\[\begin{array}{l}
a &amp;= ng \\
b &amp;= mg
\end{array}\]

<p>$\text{n}$ ,  $\text{m}$ 互质，对于 $a \neq b$ 的情况，不失一般性地假设 $a &gt; b$ ，也就是 $n &gt; m$ ，这样的话，$a-b = (n - m) g$ ，$b=mg$ 也有公约数 $g$<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> 。</p>

<p>这样取 $a=\text{max}(a-b, b)$ ,  $b=\text{min}(a-b,b)$ ，也就是如果 $n-m &gt; m$ 仍然成立就继续减，否则就是交换 $a$ ,  $b$ 的位置，在这个过程中  $n &gt; \text{max}(n-m,m) = \text{max}(n, m) &gt; \text{max}(n-m, m)$ 系数的上限不断下降，直到 $a=b$ 。</p>

<p>此时也有 $a=g$ ，$b=g$，此时就得出了最大公约数 $g$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="k">while</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">a</span> <span class="o">-=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></div>

<h2 id="辗转取余">辗转取余</h2>

<p>辗转取余是原始欧几里得算法的变种。</p>

<p>回过去观察相减的过程，如果 $a=qb+r, (q \geqslant 0,\ r &lt; b)$ ,  每次 $a-b$ 就是 $q-1$ ，直到 $q=0$ ，因为 $a=r&lt;b$ 然后就交换 $a,b$ 位置，可以通过取余的操作一步到位的完成，$a \% b$ 直接得到 $r$ , 然后和 $b$ ，即使开始时 $a &lt; b$ , 也不影响 $a\%b$ 的结果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>
</code></pre></div></div>

<p>从实践上看，不考虑特殊指令优化的情况下，这种方法的效率是最佳的。</p>

<h2 id="拓展-gcd">拓展 GCD</h2>

<p>拓展 gcd 是在求解最大公约数的同时求解出一组解 $(x,y)$ 使得 $ax+by = \text{gcd}(a,b)$ <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="递归">递归</h3>

<p>通过递归的方式(辗转取余)求解是最容易理解的实现：</p>

\[\begin{array}{l}
g &amp;= a_0x_0 + b_0y_0 \\
  &amp;= a_1x_1+b_1y_1   \\
  &amp;= b_0x_1 + (a_0-\lfloor \frac{a_0}{b_0} \rfloor b_0) y_1\\
  &amp;= a_0y_1 + b_0(x_1 - \lfloor \frac{a_0}{b_0} \rfloor y1)
\end{array}\]

<p>按照对应项系数相等的方法，得到一组解：</p>

\[\begin{array}{l}
x_0 &amp;= y_1 \\
y_0 &amp;= x_1-\lfloor \frac{a_0}{b_0} \rfloor b_0y_1\\
    &amp;= x_1-\lfloor \frac{a_0}{b_0} \rfloor b_0x_0
\end{array}\]

<p>最后推到 $a_n=b, b_n=0$ 时，$g = b = 0x + 1b$ , 也就是取 $x_n = 0, y_n=1$ ，</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ext_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ext_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="展开">展开</h2>

<p>展开版本来源于 <a href="https://cp-algorithms.com/algebra/extended-euclid-algorithm.html#algorithm">cp-algorithms</a> ，你说我完全理解，我说我完全不理解！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ext_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>  
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span>
    
    <span class="k">while</span> <span class="n">b1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">b1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">x1</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span><span class="n">q</span> <span class="o">*</span> <span class="n">y1</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">,</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">b1</span>
    
    <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>但是后面可以发现，实际上应该有 $\text{gcd}(a-b, b)=\text{gcd}(a,b)$ 但是我们不能证明它 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>显然对于非零的$a,b$，$x, y$ 应该是一正一负两个整数 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[假设对于非负整数，$a$ , $b$ ，求它们的最大公约数 $\text{gcd}(a, b)$ ，以下简写作 $g$ 。]]></summary></entry></feed>