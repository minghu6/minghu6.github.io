<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-12-14T17:21:15+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">0174 - Dungeon Game</title><link href="/oth/LeetCode0174.html" rel="alternate" type="text/html" title="0174 - Dungeon Game" /><published>2023-12-11T00:00:00+08:00</published><updated>2023-12-11T00:00:00+08:00</updated><id>/oth/LeetCode0174</id><content type="html" xml:base="/oth/LeetCode0174.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/dungeon-game/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>绝对标准地 <em>Hard</em> 难度的问题。</p>

<p>给一个二维的地图，从左上角走到右下角，看起来非常像之前做过的譬如 <a href="/oth/LeetCode0085.html">0085 - Maximal Rectangle</a> 这样的题目，只需要从上到下地逐行扫描，计算从起点到每一行的每个位置的子问题的解，直到最后一行的最后一个位置。</p>

<p>但是对于本题这样做是不行的，因为一般到某个位置的路线有两条，一条是从上到下的，一条是从左到右的，而有两个指标用来选择最小生命值的路线，一个是到当前位置为止整个路径上出现过的路径和的最小值，另一个是到当前位置的路径和。这两个指标可能是矛盾的，比如有一条路线的最小值较大但是路径和较小，导致选择该路线最终在后面得到了较小的最小值，从而得到了不正确的结果。</p>

<p>换句话说，前面的子问题的路线选择受后面位置数值的影响，这个 DP 的解法存在<strong>后效性</strong>，因此这个解法是不能成立的。</p>

<p>这样问题就陷入了困局，实际上我花了几天的时间去考虑这个题，终于发现我们可以从终点开始做 DP 这样就避开了后效性的问题，于是引入了新的 DP 思路：<strong>后效翻转</strong> 。</p>

<p>对于这道题来说，子问题变成从前面的位置到终点的最小生命值，这样从后向前找，路线的选择是确定的，只需要比较两条路线：下方和右方对应的解，选较大的即可，而当前位置子问题的解则是比较</p>

<ol>
  <li>后面的解加上当前位置值；</li>
  <li>当前位置的值，取这两个的最小值</li>
</ol>

<p>顺带一讲，这个解应该是路径上的最小值，而路径的选择是让这个路径最小值取到最大，这样才可以付出最小生命。最后的最小生命就是把这个最小值取反，比较它与零的大小，取一个最大值，把结果加上 1 ，这样保证最后至少有一点生命值。</p>

<h2 id="解迭代版本">解①迭代版本：</h2>

<p>或者说 BFS，比起递归版本，这个版本通常有更多地细节去深入。</p>

<p>这个解法的复杂之处在于需要考虑下受地图矩形的长度和宽度两个因素限制的坐标位置，特别是如果我们想要用一维数组来存储子问题解的话。</p>

<p>计算的整个过程是从终点倒退回起点，计算每一步可到位置的子问题解，就如下图所示：</p>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map1.svg" style="zoom:150%;" /></div>

<p>灰色线连起来的区域就是每一步可能到达的位置，这里用步数作为控制流程的变量，并为了方便以终点为原点建立坐标系，等到访问 <code class="language-plaintext highlighter-rouge">dungeon</code> 数组（以下简写作 $D$ ）时再把坐标转换为以左上角为原点的坐标系。</p>

<p>这样地话，对于 $m$ 行 $n$ 列的 $D$ 数组 假设当前步数是 $l$ ，那么</p>

<p>能够到达的最大的高度 $h=\min(m,l)$ ，最大宽度 $w=\min(n,l)$ 。</p>

<p>因此在当前步数的从左下到右上的可达范围里</p>

<p>左下位置 $(x_0,y_0): (l-w+1,w)$ ，右上位置 $(x_1,y_1): (h, l-h+1)$ 。</p>

<p>这样的话，每一步的位置范围就是从 $x_0 \rightarrow x_1$ ，记录下它的差 $d_\text{max} = x_1-x_0$ ，可以用来指示当前步数最后一个位置的在一维数组里的下标。</p>

<p>由于每步的位置数并不相同，因此交替使用两个一维的数组（$\text{low}_1$ 和 $\text{low}_0$）来存储当前步数和之前步数的子问题解，而解的计算要根据所处位置分为三个阶段、四种情况。三个阶段是随着步数的增加会出现的，矩形长宽都没有限制的<strong>前场</strong>、较短一维限制而较长一维没有限制的<strong>中场</strong>，以及两个维度都被限制的<strong>后场</strong>。</p>

<h3 id="1-矩形前场">1. 矩形前场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map5.svg" style="zoom:120%;" /></div>
<p><br /></p>

<p>矩形前场就是在从终点开始的扫描过程中，随着步数增加，$h$ 和 $w$ 增加的情况。此时最左下角只能从它的右方得到，右上角只能从它的下方得到，其余位置都可以从两边得到。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\lt d_\text{max})
\end{array}
\right.\]

<h3 id="2-宽矩形中场">2. 宽矩形中场</h3>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map2.svg" style="zoom:120%;" /></div>
</p>
<p>所谓中场，就是随着步数增加，$d_\text{max}$ 却保持不变的阶段，是在步数超过较短一维的长度时进入而在步数达到较长一维的长度时退出的一个阶段。
\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\leqslant d_\text{max})
\end{array}
\right.\)</p>

<h3 id="3-高矩形中场">3. 高矩形中场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map3.svg" style="zoom:120%;" /></div>
<p>\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\lt d_\text{max})
\end{array}
\right.\)</p>

<h3 id="4-矩形后场">4. 矩形后场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map4.svg" style="zoom:120%;" /></div>

<p>后场就是当中场结束时，也就是步长超过较长一维时进入的阶段。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\leqslant d_\text{max})\]

<p>于是我们便得到了代码。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">low0</span> <span class="o">=</span> <span class="p">[</span><span class="n">dungeon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">low1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">tot</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">d_max</span> <span class="o">=</span> <span class="n">x1</span><span class="o">-</span><span class="n">x0</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 矩形前半场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 宽矩形中间场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 高矩形中间场 (x0 != 1)
</span>            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 矩形后半场
</span>            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="n">low0</span><span class="p">,</span> <span class="n">low1</span> <span class="o">=</span> <span class="n">low1</span><span class="p">,</span> <span class="n">low0</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：69 ms (beats 81.50%, ~100%, 55 ms)，内存占用：17.5 MB (beats 63.73%, ~100%)。</p>

<h2 id="解">解②：</h2>

<p>或者说 DFS。</p>

<p>在上面的迭代版本或者BFS版本里，不管是分析还是代码都显得有些冗长，这主要是因为我们不愿意直接把判断放在循环里，而要弄清楚所有的过程细节，而对于递归版本，可以很简单地实现。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：78 ms (beats 39.60%, ~100%)，内存占用：20.21 MB (beats 5.06%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0152 - Maximum Product Subarray</title><link href="/algs/LeetCode0152.html" rel="alternate" type="text/html" title="0152 - Maximum Product Subarray" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/LeetCode0152</id><content type="html" xml:base="/algs/LeetCode0152.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-product-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>经典 <em>Medium</em> 但是 <em>Hard</em> ，这道题单独看可以算作 Medium 类型的题目，但是作为 DP 标签就显得很 Hard，因为题目和一般的 DP 思路好像有关系，实质是没有关系，如果再类比 <a href="/algs/LeetCode0053.html">0053 - Maximum Subarray</a> 的思路那就更困难了，难就难在干扰项。</p>

<p>同样也是正、负、零三种整数，而累积和累和的区别在于累积的符号会翻转而且幅度越来越大，最大数可以由正数乘积得到，或者负数的乘积遇到负数翻而来。</p>

<h2 id="解常规">解①常规：</h2>

<p>用 $0$ 把数组分段，按照负数的数量分情况讨论：</p>

<p>$=0$：直接累乘</p>

<p>$=1$：比较两边的正数的累积结果，</p>

<p>$=2$：直接累积</p>

<p>$\geqslant$ 3：</p>

<p>​	3.1. 奇数，比较从第一个负数后的正数开始乘到尾和从头开始乘到最后一个负数前的正数；</p>

<p>​	3.2. 偶数，累乘</p>

<p>这样只需要记录负数的坐标（不需要记全，对于超过了两个的，只需要记录第一个和最后一个负数的坐标即可）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#  i-zero &gt; 2
</span>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

            <span class="n">zero</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">neg</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">cand</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">cand</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：76 ms (beats 78.56%, ~100%)，内存占用：16.2 MB (beats 99.98%)。</p>

<h2 id="解正负值">解②正负值：</h2>

<p>可以在一遍的过程中计算这些数，只需要两个变量来存储状态，pos 表示最大的正数，neg 表示最小的负数（或者绝对值最大的负数。</p>

<p>这两个变量代表的子数组拥有相同的后缀，也就是扫描到的位置。</p>

<p>在开始或者遇到 $0$ 时，pos 和 neg 都设为 None，如果在 None 的时候遇到同符号的数值时，赋值给它们，否则就继续累乘；如果不为 None 则当遇到反符号的时候，就给反符号赋值（注意保存被覆盖的值，这时分组赋值就很合适）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">*=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">neg</span> <span class="o">*=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">neg</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>

                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：73 ms (beats 88.24%, ~100%), 内存占用：16.95 MB (~100%)。</p>

<h2 id="解前后缀">解③前后缀：</h2>

<p>由于实际上的差异只是由，也可以不考虑正负值的变化情况，直接从前缀和后缀两个方向计算累乘，当发现累积归为 0 时，就改乘为赋值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">postfix</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">postfix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">postfix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：80 ms (beats 54.67%, ~100%)，内存占用：16.76 MB (~100%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">最大子数组</title><link href="/algs/MaxSubArr.html" rel="alternate" type="text/html" title="最大子数组" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/MaxSubArr</id><content type="html" xml:base="/algs/MaxSubArr.html"><![CDATA[<p>收集一系列有关最大子数组的问题。</p>

<h2 id="最大子数组和"><a href="/algs/LeetCode0053.html">最大子数组和</a></h2>

<h2 id="最大子数组积"><a href="./LeetCode0152">最大子数组积</a></h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[收集一系列有关最大子数组的问题。]]></summary></entry><entry><title type="html">1458 - Max Dot Product of Two Subsequences</title><link href="/algs/LeetCode1458.html" rel="alternate" type="text/html" title="1458 - Max Dot Product of Two Subsequences" /><published>2023-10-17T00:00:00+08:00</published><updated>2023-10-17T00:00:00+08:00</updated><id>/algs/LeetCode1458</id><content type="html" xml:base="/algs/LeetCode1458.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.20/1458_max_dot_prod_of_two_seq/py1458">源代码</a></p>

<p>一般地<a href="/algs/TwoStrDP.html">两串上的DP</a>是从两个前缀子串开始的更小规模的问题扩展到全串，从而直接解决题目要求的问题，而本题特殊的地方是子序列并不是完整的前缀子串。</p>

<p>不妨把前缀子串视为 border，而譬如子序列则是  content ，它和 border之间有 padding ，其他普通的问题可以通过 border 就可以直接计算出来，而对于子序列这样的问题，需要额外考虑是否需要“填充” padding。</p>

<p>“padding” 的引入让问题稍微复杂了一点，但主要还是干扰了我们破题的思路，如果我们能把保持一个清晰的思路，解题还是很容易的。</p>

<h2 id="第一版">第一版：</h2>

<p>因为乘积存在负数，并且不允许空的点积序列，因此先排除乘积全是负数的情况。</p>

<p>之后在 DP 过程中只需要考虑是否把非负的乘积加进来即可，这也暗示了“padding”的判断方法：只有正的乘积会被加进来，负的会被视为“padding”跳过。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="k">return</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums2</span><span class="p">))</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>282 ms (beats 82.09%), 19.02 MB (beats 66.24%)</p>

<h2 id="改进">改进：</h2>

<ol>
  <li>采用了一个稍微更好一点的对于乘积全是负数的情况的判断方法，取两个极值进行比较，但是因此要分两种情况进行判断；</li>
  <li>按照前面滚动数组的思路讲空间占用压缩到一维；</li>
  <li>合并了 DP 核心算法里的分支判断</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">nums1_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_max</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_max</span> <span class="o">*</span> <span class="n">nums2_min</span>

    <span class="n">nums1_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_min</span> <span class="o">*</span> <span class="n">nums2_max</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>183 ms (beats 95.32%), 16.34 MB (beats 92.92%, ~100%)</p>

<h2 id="另版">另版：</h2>

<p>还有一点稍稍不同思路的是把全负乘积考虑进一般情况，但是对于压缩的 DP 数组来说，需要额外处理初始值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>189 ms (beats 95.32%), 16.29 MB (beats 97.06%, ~100%)</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Best Time to Buy and Sell Stock</title><link href="/oth/LeetCodeBuySellStock.html" rel="alternate" type="text/html" title="LeetCode Best Time to Buy and Sell Stock" /><published>2023-10-01T00:00:00+08:00</published><updated>2023-10-01T00:00:00+08:00</updated><id>/oth/LeetCodeBuySellStock</id><content type="html" xml:base="/oth/LeetCodeBuySellStock.html"><![CDATA[<h2 id="0121-best-time-to-buy-and-sell-stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">0121. Best Time to Buy and Sell Stock</a></h2>

<p><em>Easy</em></p>

<p>单次交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0122-best-time-to-buy-and-sell-stock-ii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">0122. Best Time to Buy and Sell Stock II</a></h2>

<p><em>Medium</em></p>

<p>不限次数交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0123-best-time-to-buy-and-sell-stock-iii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">0123. Best Time to Buy and Sell Stock III</a></h2>

<p><em>Hard</em></p>

<p>限制两次交易</p>

<h3 id="破题">破题</h3>

<p>题目的复杂程度终于提升到了有点儿意思的程度，这里的关键是搞清楚“最多两次”交易的限制条件到底对我们的模型意味着什么？</p>

<p>可以认为，做两次交易的收益总是不差于一次交易，只要在计算模型上把一次交易视为两次交易的边缘值。</p>

<h3 id="解两遍扫描">解①两遍扫描</h3>

<p>把价格表分为两部分，左边用于第一次交易，右边用于第二次交易，这样只需要检查每个位置的两次交易之和，求一个最大值即可。可以让左边分割的串从空串开始，这样就包含了一次交易的情况。</p>

<p>每次分割的左边串的最大收益可以依靠前面 <a href="#0121-best-time-to-buy-and-sell-stock">0121. Best Time to Buy and Sell Stock</a> 来计算，而分割的右边串则可以预先运用同样的算法反向扫描，保存个位置的计算结果，在从左开始扫描的时候查询表即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


    <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：760 ms (beats 98.06%)，内存占用：30.5 MB (beats 72.56%, ~100%)</p>

<h3 id="解规范解">解②规范解</h3>

<p>在上一个解的时候，我们通过组合单次求解的方法来计算两次交易得到的最大收益，而这个单次求解的方法好像扫描一个个位置就可以进行该位置的更新，（因为当天交易收益总是零，因此是否允许当天交易都不重要），这暗示我们很可能有一个扫描每个位置就可以计算出两次交易的最大收益的模型。</p>

<p>这才引出对股票买卖问题的统一模型：</p>

<p>累积计算每次买或卖的收益，买的收益是 $-\text{price}$ ，卖的收益是买的收益加上 $\text{price}$ ，下次交易的收益基础是之前的收益。</p>

<p>对于两次买卖就有：</p>

\[\begin{align}
\text{buy}_1 &amp;= \max(\text{buy}_1',\text{-price})\\
\text{sell}_1 &amp;= \max(\text{buy}_1',\text{price})\\
\text{buy}_2 &amp;= \max(\text{sell}_1',\text{-price})\\
\text{sell}_2 &amp;= \max(\text{buy}_2',\text{price})\\
\end{align}\]

<p>也就是：$\text{buy}_1 \rightarrow \text{sell}_1 \rightarrow \text{buy}_2 \rightarrow \text{sell}_2$</p>

<p>有必要解释下，按照自然流程，两次交易至少应该是第一天 $\text{buy}_1$ ，第二天 $\text{sell}_1$ ，第三天 $\text{buy}_2$，第四天 $\text{sell}_2$，是一个 $4$ 天的窗口，但是这需要额外检查下数据长度，而把这些操作压缩到一天，并不影响结果，而且可以适应长度不足 $4$ 的情况。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy1
</span>    <span class="n">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy2
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">buy1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell1</span> <span class="o">&lt;</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell1</span> <span class="o">=</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span>
        <span class="k">if</span> <span class="n">buy2</span> <span class="o">&lt;</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy2</span> <span class="o">=</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell2</span> <span class="o">&lt;</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell2</span> <span class="o">=</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell2</span>
</code></pre></div></div>

<p>运行时间：670 ms (beats 99.76%)，内存占用：30.5 MB (beats 88.72%, ~100%) 。</p>

<p>这个统一模型在一遍扫描就解决了问题，并且省掉了前面的 $O(n)$ 的内存占用<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> 。</p>

<h2 id="0188-best-time-to-buy-and-sell-stock-iv"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">0188. Best Time to Buy and Sell Stock IV</a></h2>

<p><em>Hard</em></p>

<p>上面问题的一般化，不是限制两次交易，而是给定的参数 $k$ 次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># buy[i] - sell[i+1]
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
                <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span>
            <span class="k">elif</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
                <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：59 ms (Beats 99.16%, ~100%)，内存占用：16.36MB (Beats 82.07%，~100%)。</p>

<h2 id="0309-best-time-to-buy-and-sell-stock-with-cooldown"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">0309. Best Time to Buy and Sell Stock with Cooldown</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有冷冻期</p>

<h3 id="破题-1">破题</h3>

<p>购买冷冻期机制的引入改变了整个的模型，使得我们不能像前面的那个无限次数交易那样简单统计所有增量，就可以得到答案。</p>

<p>如果遵循股票买卖整个系列的顺序来做题，题解可能格外困难，因为很容易受到前面解题思路的影响，而重构整个模型并没有那么直观，因此我认为应该把这道题标记为 Hard 难度。</p>

<p>因此，让我们先从最简单地、最基本地方法开始：一个基于递归，使用记忆化优化的，穷举所有可能的解决方法。</p>

<h3 id="解递归记忆化">解①递归记忆化</h3>

<p>逐个读取价格表，分两个模式：等待购入和等待卖出。下面分别用 $\text{Buy}$ 和 $\text{Sell}$ 表示这两个模式，在 $\text{Buy}$ 模式下有两种选择：在当前价格日卖出和下一天再说，同样地 $\text{Sell}$ 模式也有两种选择，以当前价格卖出和下一天再说。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">Buy</span> <span class="o">=</span> <span class="n">auto</span><span class="p">(),</span>
    <span class="n">Sell</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">recur</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：52 ms (beats 44.28%, ~100%)，内存占用：21.06 MB (beats 31.05%)。</p>

<h3 id="解迭代dp">解②迭代DP</h3>

<p>上面的递归实现，可以帮助我们理清普通 DP 版本的实现思路。</p>

<p>对于交易有限次数的股票模型，可以穷举所有所有轮次买和卖的状态，但是对于不限次数的模型，则不能这样穷举，只能区分买和卖，不能辨别轮次。</p>

<p>尝试从正面看这个问题，分别用 <code class="language-plaintext highlighter-rouge">buy</code> 和 <code class="language-plaintext highlighter-rouge">sell</code> 两个数组代表一个前缀价格串上的最后操作是买或卖带来的最大收益。</p>

<p>这样，</p>

<ol>
  <li>
    <p>买的最大收益是要比较前一天买的最大收益（意味着当前没有买卖）以及包含冷冻期在内的卖的最大收益加上当前价格；</p>
  </li>
  <li>
    <p>卖的最大收益则是前一天卖的最大收益（意味着当前没有买卖）或者前一天买的最大收益加上当前价格（当前卖出）</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：36 ms (beats 98.07%, ~100%)，内存占用：16.39 MB (beats 99.34%) 。</p>

<p>当然，仔细观察代码，会发现 $O(n)$ 的内存占用是不必要的，实际上只需要维护三个持久变量：$\text{buy}_0$, $\text{buy}_1$ 和 $\text{sell}_0$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">buy0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy0</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sell0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy1</span><span class="p">,</span> <span class="n">sell0</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell0</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">sell0</span> <span class="o">=</span> <span class="n">sell1</span>
        <span class="n">buy1</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">=</span> <span class="n">buy2</span><span class="p">,</span> <span class="n">buy1</span>

    <span class="k">return</span> <span class="n">sell0</span>
</code></pre></div></div>

<p>运行时间：45 ms (beats 79.16%, ~100%)，内存占用：16.56 MB (beats 87.33%. ~100%) 。</p>

<h2 id="0714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">0714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有交易费</p>

<h3 id="解状态dp">解①状态DP</h3>

<p>直接按照前面交易冻结日的股票交易模型，易得</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">,</span> <span class="n">sell</span><span class="o">-</span><span class="n">price</span><span class="p">)</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">,</span> <span class="n">buy</span><span class="o">+</span><span class="n">price</span><span class="o">-</span><span class="n">fee</span><span class="p">)</span>

        <span class="n">buy</span> <span class="o">=</span> <span class="n">buy1</span>
        <span class="n">sell</span> <span class="o">=</span> <span class="n">sell1</span>

    <span class="k">return</span> <span class="n">sell</span>
</code></pre></div></div>

<p>运行时间：566 ms (beats 77%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h3 id="解贪心">解②贪心</h3>

<p>但是还是有方法利用像 <a href="#0122-best-time-to-buy-and-sell-stock-ii">0122. Best Time to Buy and Sell Stock</a> 问题那样直接地算法来解决。</p>

<p>只需要把交易费用加在购入价格上即可。</p>

<p>注意这里的 $\text{buy}$ 区别于分状态 DP 问题里面的  $\text{buy}$ ，它表示得不是购入的最大收益，而是最低价格。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">fee</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span>
        <span class="k">elif</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">price</span><span class="o">-</span><span class="n">buy</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：495 ms (beats 99.5%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>虽然形式上压缩到了一天，但是我们的计算公式也暗示，实际上不可能同时更新，实质上全部更新还是至少需要四天，对于一次交易也至少需要两天 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>虽然在测试上也看不这个内存节省的区别来，但毕竟是 Python 嘛，内存模型并不节省 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[0121. Best Time to Buy and Sell Stock]]></summary></entry><entry><title type="html">0115 - Distinct Subsequences</title><link href="/oth/LeetCode0115.html" rel="alternate" type="text/html" title="0115 - Distinct Subsequences" /><published>2023-09-30T00:00:00+08:00</published><updated>2023-09-30T00:00:00+08:00</updated><id>/oth/LeetCode0115</id><content type="html" xml:base="/oth/LeetCode0115.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/distinct-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.18/0115_distinct_subseq/py0115">源代码</a></p>

<p>判断一个串的所有（非连续）子序列里，等于目标串的数量。</p>

<p>这里要特别关注<strong>解3：子序列的窗口范式</strong></p>

<h2 id="解正解">解①正解：</h2>

<p>这个是最直接的推导思路，考虑 $s$ 的前缀从 $s[..0]$ 逐个增加字符直到 $s[..n]$ ，观察对样本串 $t$ 它的前缀随之的变化。</p>

<p>假设增加了一个字符 $x$ ，那么对于样本串 $t$ ，所有出现 $x$ 的位置的前缀都会因此受到影响。</p>

<p>假设 $x$ 出现在 $t$ 的所有位置是 P，则有 $\text{dp}[P] := \text{dp}[P] + \text{dp}[P-1]$，也就是 $x$ 前面的前缀会因为 $x$ 的加入，而使得包含 $x$ 的前缀数量增加。特别地，当 $t$ 的前缀是空串的时候，设定值总是为 $1$ ，这样可以方便统一地计算。</p>

<p>那么该如何计算出 $x$ 出现在 $t$ 的所有位置呢，正好字符集很小（大小写字母），直接用列表保存最节省内存，可以在对 $t$ 的一遍扫描过程中把坐标加进对应字符的坐标列表里。</p>

<p>于是得到了下面的实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>
        <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">pre_v</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pre_i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">c_i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">pre_i</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre_v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">pre_v</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">pre_i</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>有几点需要特别说明的：</p>

<h4 id="1-快速失败地优化">1. 快速失败地优化</h4>

<p>譬如</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>这样的代码，几乎总是可以明显提高我们的运行表现，为一些应该很优，但由于 Python 匮乏地运行时优化而表现一般地实现挽尊：—— 。</p>

<h4 id="2-dp-数组的特异处">2. DP 数组的特异处</h4>

<p>从代码上乍看起来，这里的 $\text{dp}$ 数组和之前那些一般的 $\text{dp}$ 数组是一样的，我们只是照样把二维压缩到一维。</p>

<p>但这里特别地是，从计算过程上看，每一行并不是所有的数据都会被更新，没有被计算的数据应该继承自上一行，而不是被置为一个固定的初始值。</p>

<p>这样使用二维不仅浪费空间，而且并不方便，使用一维的空间，总是更好的选择。</p>

<h4 id="3-一维地实现">3. 一维地实现</h4>

<p>同样地，在使用压缩地 $\text{dp}$ 数组时，为了避免数据被覆盖，需要提前保存上一行的前一个位置的数据，但是我们预计算的位置并不一定是连续的，因此需要进行判断。对于不连续的位置，就不会存在数据覆盖的问题。</p>

<p>运行时间 94 ms (beats 92.81%)，内存占用：16.46 MB (beats 96.82%, ~100%) 。</p>

<h2 id="解递归迭代">解②递归+迭代：</h2>

<p>实际上如果我们理解了解①，那么可以把它转换成我们更熟悉地 $\text{dp}$ 实现。</p>

<p>只要考虑：</p>

<ol>
  <li>要么当 $s$ 的前缀拓展一个字符时，$t$ 也拓展一个字符，这只当 s 和 t 拓展的字符相等时才可以；</li>
  <li>要么无条件地跳过当前字符，也就是 $s$ 拓展字符，但是 $t$ 不拓展</li>
</ol>

<p>这样当：</p>

<ol>
  <li>$s$ 的长度小于 $t$ 时，当然返回 $0$；</li>
  <li>而当 $s$ 长度等于 $t$ 时，进行比较，返回 $1$ 或者 $0$；</li>
  <li>当 $m$ 长度为 $0$ 时，也就是递归的一般返回点，或者说初试情况，返回 $1$</li>
</ol>

<p>递归地版本最简洁，表现也最好：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p>运行时间：70 ms (beats 93.39%)，内存占用：34.2 MB (beats 72.33%) 。</p>

<p>迭代的版本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：95 ms (beats 92.78%)，内存占用：16.5 MB (beats 96.74%) 。</p>

<h2 id="解另一个范式">解③另一个范式：</h2>

<p>这里要介绍得是规模递增的另一个范式，很少提到，但是由于有更好地迭代次数，是最快的实现。</p>

<p>对于上面的一般思路来说，是增加 $s$ 的前缀的字符，把问题规模一步步拓展到全局，而对于子序列地匹配，还可以这样考虑：</p>

<p>每一个文本串 $s$ 上面可以匹配目标串 $t$ 的子序列都可以看做，由某些在 $s$ 上的 $t$ 长度模式的对应位置字符构成。</p>

<p>这些构成 $t$ 的子序列的字符可以是连续的，也就是在同一个模式上，也可以不连续，那就是在不同的模式上。</p>

<p>这看起来就像是一个固定窗口在 $s$ 上滑动，探寻窗口对应位置的字符与 $t$ 上对应字符是否相等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="tips">Tips：</h3>

<ol>
  <li>由于在外循环固定减少了 $m$ 长度的轮次，因此是相比上述更快的一个实现；</li>
  <li>同时快速失败地优化也被省略掉了，因为已经不能提升它的表现了</li>
</ol>

<p>运行时间：44 ms (beats 99.44%, ~100%)，内存占用：16.29 MB (beats 99.85%, ~100%) 。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0087 - Scramble String</title><link href="/oth/LeetCode0087.html" rel="alternate" type="text/html" title="0087 - Scramble String" /><published>2023-09-19T00:00:00+08:00</published><updated>2023-09-19T00:00:00+08:00</updated><id>/oth/LeetCode0087</id><content type="html" xml:base="/oth/LeetCode0087.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/scramble-string/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.17/0087_scramble_str/py0087">源代码</a></p>

<p>因为这道题是 3k点赞，1k点踩， 于是看了下评论，结果为我的解题带来了非常大的负面影响：有一个评论里讲什么这道题的题解非常困难，但是用4套嵌套循环实现非常简单，这一直影响我的思路。</p>

<p>然而实际上这只是一道普通的 Top-down DP，或者说，记忆化搜索就可以通过的题目。</p>

<p>另外让人不爽地是这个文本：“<strong>Randomly</strong> decide to swap the two substrings……” ，随机地决定这种说法就很误导，让人搞不清问题到底是个什么类型的问题。</p>

<p>实际上这个问题很简单，把串按位置划分，从 $1\dots n-1 $，确保得到的两个子串的长度至少为 $1$；</p>

<p>而这两个子串有两种可能：保持原序或者颠倒顺序；</p>

<p>然后试着对子串继续应用这个划分，直到子串的长度为 $1$ 。</p>

<p>最终目的是检查 $s_1$ 能否变换到 $s_2$ 。</p>

<h2 id="解">解①：</h2>

<p>这个问题天然地适合利用递归解决，只不过可以通过保存一些中间结果来进行优化。</p>

<p>具体说就是遍历每一个划分子串的位置，然后对划分后的两种情况：原序和反序，分别进行判断。</p>

<p>对于原序，就是检查较小规模地同一问题 $s_1[0..i-1]$ 能够变换到 $s_2[0..i-1]$ ；以及 $s_1[i..n-1]$ 能够变换到 $s_2[i..n-1]$ ；</p>

<p>对于反序，就是检查$s_1[0..i-1]$ 能够变换到 $s_2[n-i..n-1]$；以及 $s_1[i..n-1]$ 能够变换到 $s_2[0..n-i-1]$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="p">:])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[:</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>特别地，这里检查了字符集合是否相等，作为一个快速失败地（预测）优化<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<p>运行时间：58 ms (beats 78.15%, ~100%)，内存占用：17.9 MB (beats 36.12%, ~100%)。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>而用 <code class="language-plaintext highlighter-rouge">sorted</code> 比 <code class="language-plaintext highlighter-rouge">set</code> 明显要快，对于本题的最终结果的影响是差了 20 ms 。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">编辑距离</title><link href="/algs/EditDistance.html" rel="alternate" type="text/html" title="编辑距离" /><published>2023-08-26T00:00:00+08:00</published><updated>2023-08-26T00:00:00+08:00</updated><id>/algs/EditDistance</id><content type="html" xml:base="/algs/EditDistance.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>编辑距离是从一个串变换到另一个串，需要的基础操作的数量，用来衡量两个串的相似度，用在</p>

<ul>
  <li>自然语言处理上，比如拼写检查；</li>
  <li>生物学上，做 DNA 序列对比</li>
  <li>其他</li>
</ul>

<p>这里的基础操作包括：</p>

<ul>
  <li>插入一个字符</li>
  <li>删除一个字符</li>
  <li>替换一个字符（substitution）</li>
  <li>交换两个字符（transposition）</li>
</ul>

<p>编辑距离有：</p>

<h3 id="莱文斯坦距离">莱文斯坦距离</h3>

<p>Lavenshtein Distance，最常见的编辑距离，通常也会冠以“编辑距离”之名。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
  <li>替换</li>
</ul>

<h3 id="达梅劳-莱文斯坦距离">达梅劳-莱文斯坦距离</h3>

<p>Damerau-Lavenshtein Distance，莱文斯坦距离的变种，开始是用于拼写检查，补充了第四种基本的拼写错误，近邻序顺倒颠，但后来也推广用于衡量蛋白质序列间的变异。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
  <li>替换</li>
  <li>（邻近）交换</li>
</ul>

<h3 id="lcs-距离">LCS 距离：</h3>

<p>最长公共子序列距离。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
</ul>

<h3 id="汉明距离">汉明距离</h3>

<p>Hamming Distance，用于网络传输，作为学习网络传输都会了解到的流的校验码 。</p>

<p>基本操作：</p>

<ul>
  <li>替换</li>
</ul>

<p>而且只允许同样长度的字符串。</p>

<h3 id="哈罗距离">哈罗距离</h3>

<p>Jaro Distance，只允许交换两个字符。</p>

<h2 id="dp-实现">DP 实现</h2>

<p>这些编辑距离，特别是类似于莱文斯坦距离这样的编辑距离都有一个常规地运用 DP 概念的实现。</p>

<p>时间复杂度是 $O(nm)$ ，空间复杂度是 $O(\min(n,m))$ 。</p>

<p>具体参考 <a href="/algs/TwoStrDP.html">两串DP</a></p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">双串DP</title><link href="/algs/TwoStrDP.html" rel="alternate" type="text/html" title="双串DP" /><published>2023-08-26T00:00:00+08:00</published><updated>2023-08-26T00:00:00+08:00</updated><id>/algs/TwoStrDP</id><content type="html" xml:base="/algs/TwoStrDP.html"><![CDATA[<h2 id="前言">前言</h2>

<p>两个串，一个模板串，一个测试串，使之“匹配” 。</p>

<p>如果更小规模，这里就是指两个串的前缀子串，的子问题的解决能适用贪心算法，直接被利用，计算出更大规模的问题。</p>

<h2 id="正则匹配">正则匹配</h2>

<p><a href="/oth/LeetCode0010.html">0010 - Regular Expression Matching</a></p>

<h3 id="简化版">简化版</h3>

<p><a href="/oth/LeetCodePacket1.html">0044 - Wildcard Matching</a></p>

<h2 id="编辑距离">编辑距离</h2>

<p>以莱文斯坦距离为例，对应有 LeetCode 原题： <a href="/oth/LeetCode0072.html">0072 - Edit Distance</a> 。</p>

<h2 id="问题变形">问题变形：</h2>

<h3 id="1-有任意填充的双串问题">1. 有任意填充的双串问题</h3>

<p>作为子问题的前缀子串并不是题目要求的内容，而是要进一步取舍。</p>

<p><a href="/algs/LeetCode1458.html">Max Dot Product of Two Subsequences</a></p>

<h2 id="代码模板">代码模板</h2>

<p>总有一个模板，利用惰性更新节省内存到一个单位的 $O(\min(n,m))$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">m</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="c1">// init cache[0]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="c1">// calc cache[i]</span>

        <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">cache</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">0053 - Maximum Subarray</title><link href="/algs/LeetCode0053.html" rel="alternate" type="text/html" title="0053 - Maximum Subarray" /><published>2023-08-18T00:00:00+08:00</published><updated>2023-08-18T00:00:00+08:00</updated><id>/algs/LeetCode0053</id><content type="html" xml:base="/algs/LeetCode0053.html"><![CDATA[<h2 id="前言">前言</h2>

<p>这篇的重点在于讲述从启发式算法到对 <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm">Kadane算法</a> 的独立再发现的过程。</p>

<h3 id="难度定位">难度定位</h3>

<p>对于 LeetCode 来说，本题的定位在 Medium 难度，只能说这是一个令人不满意的折中的结果。</p>

<p>首先这实在是一道太经典的题目，有很简单的解决方法，对于那些接触过它的人来说，只需要不到一分钟的时间就能写完，从这个角度上说，可以直接定位在 Easy 。</p>

<p>但对于那些并没有正式接触过的人来说，就题论题，从输入的数据规模来看，这道题的难度是非常高的，对于运行时语言来说，实际上只有 $O(n)$ 的解法能过，而且还必须是不太慢的 $O(n)$ 解法，而其他类似类型题目，通常 $O(n^2)$ 就能过，但从这一点，这就一定是 Hard 难度的题目。</p>

<p>总地来说，我们没有任何理由去假设用户的学习履历，而这道题本身就是一道 Hard 难度的题目，因此它定位就应该在 Hard 。</p>

<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.14/0053_max_subarr/py0053">源代码</a></p>

<p>求一个数组的最大值子序列。</p>

<p>首先可以想到<a href="/algs/SegmentTree.html">分段树</a>上有一个经典应用，就是计算最大子段和，这个时间复杂度是最优的，但一定不是最快的，在纯运行时语言里，这种复杂数据结构的表现都不会太好，因为本来可以忽略掉的无关操作都对时间有显著地影响。</p>

<p>何况这种方法写起来也不是很简单，因此先把这种方法放到最后，作为比较。</p>

<h2 id="解简单dptle">解⓪简单DP：TLE：</h2>

<p>最简单地记录两头索引的 DP，用前缀和数组 $O(1)$ 地计算区间和，时间复杂度为 $O(n^2)$ ，即使做了很多优化，比如压缩数组，排除负数（需要处理全是负数的情况），也仍然过不了关。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">accumulate</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">pref_sum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pref_sum</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">pref_sum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pref_sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>

<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">nums2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">nums2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nums2</span>
</code></pre></div></div>

<h2 id="解启发式算法">解①启发式算法：</h2>

<p>这一节是本篇的重点，讲述我个人如何一步步从一个直觉地和局部经验地算法设计出本质上就是 Kadane 算法的过程。</p>

<h3 id="1-观察">1. 观察：</h3>

<p>最大子段和如果都是正数，那么整个数组的和就是最大子段和，这个题目就没有意义了，一定是有负数才让问题具有复杂性，当然如果全都是负数那么问题也很简单，就是最大的那一个单个负数（或者说绝对值最小的那个负数），而更多地应该是正数和负数混合的情况（零总是可以被简单忽略掉）。</p>

<p>这样地话，排除全负数地情况后考虑，如果数组结尾的的数字是非正数，那么它可以直接被忽略掉；但如果结尾是正数，那就要看它后面可能存在的来自负数的减益与来自正数的增益哪一个更大。</p>

<p>为了考虑方便和编写代码，可以就像前面算法一样对数组进行压缩：<code class="language-plaintext highlighter-rouge">compress</code>，合并临近的正值和非正值，这样总是可以得到一个正负相间的数组。</p>

<p>在这个基础上考虑什么时候能够保留结尾的正数呢？就是正数邻接的负数的绝对值小于这个正数，这样正负加起来一定对最大和有增益。反之，如果正负加起来小于等于零，那么显然这一段儿就可以被扔掉，因为没有任何增益。</p>

<h3 id="2-问题">2. 问题：</h3>

<p>那么如果一个正负组之后还有一个正负组该怎么样呢：</p>

<ol>
  <li>如果那个正负组仍然是非负收益，那么仍然可以保留；</li>
  <li>可是如果是负收益，又该如何判断是否该保留呢？</li>
</ol>

<p>试着考虑在数组的另一端也如此处理来压缩问题规模，但是这样仍然会遇到一个正收益的正负组后面的一个负收益的正负组问题。</p>

<h3 id="3-解决方法">3. 解决方法：</h3>

<p>看来不得不正面考虑正收益的正负组后面的出现负收益的正负组的问题，考虑直接合并我们遇到的正负组，就像我们压缩数组一样，如果是正收益就保留，如果是非负收益就抛弃，这样好像问题就解决了！</p>

<h3 id="4-观察">4. 观察：</h3>

<p>这样如果从两边开始一层层剥掉两头的正负组，是不是问题就能在 $O(n)$ 的时间内解决？！我们现在好像已经从对问题局部的优化开始，窥得了最优解的思路。我自己就把这个思路称为“洋葱变换”（Onion Transform）</p>

<p>像这样剥下去，最后应该得到：</p>

<ol>
  <li>一个“去核”洋葱，也就是剥到最后，发现里面什么都没有；</li>
  <li>或者带芯儿洋葱，最后剩下一个孤正数，因为前面都是正负组，而整个压缩后的数组是正负相间的。</li>
</ol>

<p>这样好像只要计算最后剩下的皮加上可能存在的芯的值，就能得到整个数组的最大子序列和。</p>

<h3 id="5-问题">5. 问题：</h3>

<p>但是，两头剥洋葱实际还有第三种情况，就是这根本是个“假洋葱”（Fake Onion），剥到最后发现里面剩一个负数，这应该是不存在的情况，但就是发生了，因为两头的正负组存在重叠，这样我们就不能正确计算了。</p>

<h3 id="6-解决方法">6. 解决方法：</h3>

<p>由于存在负芯儿的“假洋葱”，不能从两头剥，考虑直接从一头剥，这样肯定就不会出现正负组重叠的情况。</p>

<h3 id="7-观察">7. 观察：</h3>

<p>但这样好像就得到了一个未曾设想的局面：一段段儿由负数隔开的正值的最大子序列，也就是说在压缩正负组的过程就可以计算得到最大子序和。</p>

<p>至此为止我们得到了一个可运行的算法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">max_unit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># get max unit
</span>
    <span class="c1"># Onion Transform
</span>
    <span class="n">max_seq</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">layer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layer</span>

            <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_unit</span><span class="p">,</span> <span class="n">max_seq</span><span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：622 ms (beats 74.97%)，内存占用：30.42 MB (beats 83.1%) 。</p>

<p>（后来发现这个运行时间已经相当好了）</p>

<h3 id="8-思路推广">8. 思路推广：</h3>

<p>这个算法应该有更简洁、更一般化地表示，不需要数组压缩、也不必考虑正负组，只要能带来非负收益，就可以进行压缩。</p>

<h3 id="9-思路推广">9. 思路推广：</h3>

<p>使用一个追踪边的累积变量 <code class="language-plaintext highlighter-rouge">acc</code>，用它来代替对输入的边缘点的修改，同时也不需要直接检测收益是否为负，先计算加和，取它与新的边缘点的最大值。</p>

<p>这样可以得到一个非常简洁地形式：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>总是使用前一个计算的值作为状态，也就是 <code class="language-plaintext highlighter-rouge">x</code> ，<code class="language-plaintext highlighter-rouge">y</code> 是当前的边缘点</p>

<p>这个版本并不是我写的，因为它使用 <code class="language-plaintext highlighter-rouge">itertools</code> 里面的工具虽然让代码看起来很简单，但根据以往经验，我就知道这个性能表现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>并不怎么样，实际果然如此：</p>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：592 ms (beats 87.39%)，内存占用：30.56 MB (beats 51.70%) 。</p>

<p>运行时间相比前一个朴素版本不仅提升有限，内存占用甚至还更多了！足可见 <code class="language-plaintext highlighter-rouge">itertools</code> 有非常大的优化空间。</p>

<p>更适合当前版本的应该是：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">acc</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：537 ms (beats 99.80%)，内存占用：26.77 MB (beats 99.95%) 。</p>

<p>核心有三点：</p>

<ol>
  <li>普通循环替代 <code class="language-plaintext highlighter-rouge">itertools</code></li>
  <li>普通条件判断替代 <code class="language-plaintext highlighter-rouge">max</code></li>
  <li>预先计算一个变量也有有意义地性能提升</li>
</ol>

<p>实在是有些无语<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="与kadane算法">与Kadane算法：</h3>

<p>到了这一步，这可以发现，这就是 Kadane 算法做的事，我们只是独立地重新发明了它<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup></p>

<h3 id="与其他思路">与其他思路：</h3>

<p>这个最终的解决方法还可以通过 DP 或者说其他地算法思想推导得到，但总是实质一样，我并不考虑这里一定要使用什么思想来解决，就是一步步地想，如果最终要对它总结，我更愿意把它归类为在时间上进行 DP 的算法。</p>

<h2 id="解分段树">解②分段树：</h2>

<p>经典地一个分段树应用的题目，因为求得是整个数组的最大子序列和，因此只需要写建树的代码即可，返回根节点的值即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">min_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="s">""" DFS型 """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_build</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" pref  0 # max prefix sum
        suff  1 # max suffix sum
        sum   2 # all sum
        ans   3 # max range sum
    """</span>

    <span class="k">if</span> <span class="n">tl</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span><span class="o">+</span><span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sub_lf</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="n">tl</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i_lf</span><span class="o">+</span><span class="n">sub_lf</span>

    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">)</span>

    <span class="n">data_lf</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">]</span>
    <span class="n">data_rh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">]</span>

    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：1067 ms (beats 5.02%)，内存占用：53.78 MB (beats 6.15%) 。</p>

<p>同样没有使用 Python 的类，而是元组，来保存每个点的 4 个基本信息，因为类实在是太慢啦！</p>

<h3 id="与其他思想">与其他思想</h3>

<p>如果不从分段树地角度看，也可以直接使用分治地思想做类似地操作，但是也依赖递归，区别是我们把递归需要保存的堆栈信息显式地存储到了起来。</p>

<h2 id="注解">注解</h2>

<p>###</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>至少是当前的 Python 3.10 版本 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>我认为从根本上讲，是原作者的观念保守，为了维持 Python 的纯解释性，从而放弃了很多更进一步地优化，并且也没有引进 JIT 的机制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>可能区别是原始的 Kadane 算法面对的问题是只返回非负值，如果全都是负数就返回 $0$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry></feed>