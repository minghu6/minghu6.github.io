<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-11-24T18:25:09+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">N叉堆实现（Rust）</title><link href="/algs/DaryHeap.html" rel="alternate" type="text/html" title="N叉堆实现（Rust）" /><published>2022-11-23T00:00:00+08:00</published><updated>2022-11-23T00:00:00+08:00</updated><id>/algs/DaryHeap</id><content type="html" xml:base="/algs/DaryHeap.html"><![CDATA[<p>一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为<a href="/algs/FibHeap.html">斐波那契堆</a>的上位替代。</p>

<p>下图 $q=2^1$</p>

<div class="sx-center"><img src="/../assets/img/daryheap/layout.svg" title="" /></div>

<h2 id="数据结构">数据结构</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Min Heap, I is unique, T is weight</span>
<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">DaryHeap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">E</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">raw</span><span class="p">:</span> <span class="n">Array</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>注解：</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Array</code> 是自己实现的简单堆上数组，因为需要初始化，所以包裹了 <code class="language-plaintext highlighter-rouge">Option</code></li>
  <li>直接使用“索引-权重“二元组来作为节点的结构</li>
</ol>

<h2 id="基础操作">基础操作</h2>

<p>值得稍微想一想的就是树上父、子位置与索引的换算关系。以下假设我们的叉堆的基是 $2^E$ 。</p>

<h3 id="索引">索引</h3>

<p>基本的索引与位置的换算关系靠得是等比数列前 $n$ 项和：</p>

<p>$a_1$ 为首项， $q$ 为比值</p>

\[S_n = \left\{\begin{array}{l} 
 &amp; na_1 &amp;(q=1)\\
 &amp;{\large \frac{a_1(1-q^n)}{1-q}} &amp;(q \neq 1)\\
\end{array}\right.\]

<p>对于我们的 d-ary 堆，$a_1 = 1$， $q=2^E$ ，于是有：</p>

\[S_n = \frac{2^{En} - 1}{2^E - 1}\]

<p>定义一系列宏来做索引转换的工作</p>

<h4 id="定义基">定义基</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2^E</span>
<span class="nd">macro_rules!</span> <span class="n">base</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">E</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// (2^E)^n</span>
<span class="nd">macro_rules!</span> <span class="n">basen</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">E</span> <span class="o">*</span> <span class="p">(</span><span class="nv">$n</span><span class="p">)</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="从编号转换到行列位置">从编号转换到行列位置</h4>

<p>编号和行列位置都从 $1$ 开始，逆转 $S_n$ 公式：</p>

\[2^{En} = S_n(2^E - 1) + 1\]

<p>得出 $n$</p>

\[n = \frac{\log_{2}({S_n(2^E - 1) + 1})}{E}\]

<p>设当前编号为 $N$，行号为 $\text{ln}$ ，列号为 $\text{col}$，则</p>

\[\begin{array}{l}
\text{ln} &amp;= \lfloor \frac{\log_{2}({N(2^E - 1) + 1})}{E} \rfloor \\
\text{col} &amp;= N - S_{\text{ln}-1}
\end{array}\]

<p>当然这里要采用<strong>整数上的数学函数</strong>进行运算</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

            <span class="c1">// = q^n</span>
            <span class="k">let</span> <span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="nd">base!</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">var</span><span class="nf">.ilog2</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">/</span> <span class="n">E</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">ln</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">col</span> <span class="o">=</span> <span class="nd">basen!</span><span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// total number for lv complete d-ary</span>
<span class="nd">macro_rules!</span> <span class="n">total</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ln:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">ln</span> <span class="o">=</span> <span class="nv">$ln</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">ln</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">E</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="c1">// 1 * 1-q^n / (1-q)</span>
            <span class="p">(</span><span class="nd">basen!</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nd">base!</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$ln:expr</span><span class="p">,</span> <span class="nv">$col:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">ln</span> <span class="o">=</span> <span class="nv">$ln</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">col</span> <span class="o">=</span> <span class="nv">$col</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">ln</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">ln</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">col</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">col</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="当前位置到父母或孩子的位置">当前位置到父母或孩子的位置</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">paren_pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$pos:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pos</span><span class="p">;</span>

            <span class="p">(</span><span class="n">ln</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nd">base!</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// first child pos</span>
<span class="nd">macro_rules!</span> <span class="n">child_pos</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$pos:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pos</span><span class="p">;</span>

            <span class="p">(</span><span class="n">ln</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nd">base!</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="数组下标到父母或孩子下标">数组下标到父母或孩子下标</h4>

<p>最后我们就有了直接的实际数据结构里的索引到它父母或孩子的索引的最终算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">paren</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nd">paren_pos!</span><span class="p">(</span><span class="nd">pos!</span><span class="p">(</span><span class="nv">$idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

            <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$idx:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="nd">child_pos!</span><span class="p">(</span><span class="nd">pos!</span><span class="p">(</span><span class="nv">$idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

            <span class="nd">total!</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="交换">交换</h3>

<p>交换是 d-ary 堆算法实现依赖的主要操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...     </span>

<span class="k">fn</span> <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">idx2</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">_v1</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">_v2</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k1</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx2</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k2</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">idx1</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cd">/// return insert_idx</span>
<span class="k">fn</span> <span class="nf">sift_up</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">cur</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">paren</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">paren</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cur</span>
<span class="p">}</span>

<span class="cd">/// return insert_idx</span>
<span class="k">fn</span> <span class="nf">sift_down</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.min_child</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">break</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">min_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nd">base!</span><span class="p">());</span>

    <span class="p">(</span><span class="n">start</span><span class="o">..</span><span class="n">end</span><span class="p">)</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<ol>
  <li>当插入新节点的时候，把新节点放到尾部，然后和父节点比较，如果堆的性质发生违背，就交换两个节点，递归地进行直到到达根节点；</li>
  <li>当更新已有节点的时候，如果新值比旧值大，就向下交换，如果比旧值小，就向上交换，相等就什么都不做；</li>
  <li>删除根节点的时候，把它和序列上最后一个节点交换，然后把最后一个节点向下交换</li>
</ol>

<h2 id="核心算法实现">核心算法实现</h2>

<h3 id="insert">Insert</h3>

<p>扩容的时候和一般内存上的连续结构一样，申请新的更大内存（不必要每次扩张都有下一层完全树的内存大小，算法实现也不依赖于此），然后把旧的全部复制到新内存位置，最后释放旧内存。<em>注意，这种做法看起来比不用复制旧内存的链表结构要浪费很多，但实际上不仅摊销代价很小，通常直接代价也很小，绝大多数情况在时间效率上远优于链表结构！</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.index</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.recap</span><span class="p">(</span><span class="n">E</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.recap</span><span class="p">(</span><span class="k">self</span><span class="nf">.cap</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">ent</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>

        <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">ent</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">((</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">));</span>
        <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.sift_up</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">recap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">new_cap</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.raw</span><span class="nf">.resize</span><span class="p">(</span><span class="n">new_cap</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey">DecreaseKey</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl DaryHeap ...</span>

<span class="nd">#[inline]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.index</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">),</span> <span class="s">"No {i:?}"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="k">self</span><span class="py">.index</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">oldv</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.replace</span><span class="p">((</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">newidx</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="nf">.w</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.sift_up</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="n">idx</span><span class="p">,</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.sift_down</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">self</span><span class="py">.index</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newidx</span><span class="p">);</span>

    <span class="n">oldv</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop">Pop</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.remove</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.sift_down</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="nf">Some</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// remain None, update self.len</span>
<span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.index</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="时间复杂度分析">时间复杂度分析</h2>

<p>d-ary 堆本质上当然仍是二叉堆，但当基数较大的时候，实际上原来 $\text{log} n$ 的操作就降低为常量。</p>

<p><code class="language-plaintext highlighter-rouge">insert</code>: $O(1)$</p>

<p><code class="language-plaintext highlighter-rouge">decrease-key</code>: $O(1)$</p>

<p><code class="language-plaintext highlighter-rouge">delete-min</code> (<code class="language-plaintext highlighter-rouge">pop</code>): $O(1) $</p>

<p>在 <code class="language-plaintext highlighter-rouge">pop</code> 的时候理论上还优于之前介绍过的斐波那契堆，实际上由于这是建立在连续内存上的数据，比起基于链表的结构不知道好到哪里去了！</p>

<p>**通常 d-ary 堆的基数是 32，也就是 E=5 **，这是个经验结论，在此之前，随着基数增大，时间效率呈现有意义地增加，而在此之后，时间效率几乎不增乃至减少。Clojure 自己的持久化 <code class="language-plaintext highlighter-rouge">Vector</code> 的实现里 Trie 的基数就是 $32$ 。</p>

<h2 id="引用">引用</h2>

<p>完整代码： https://github.com/minghu6/rust-minghu6/blob/master/src/collections/heap/dary.rs</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为斐波那契堆的上位替代。]]></summary></entry><entry><title type="html">速通最小生成树（MST）</title><link href="/algs/GraphMST.html" rel="alternate" type="text/html" title="速通最小生成树（MST）" /><published>2022-11-18T00:00:00+08:00</published><updated>2022-11-18T00:00:00+08:00</updated><id>/algs/GraphMST</id><content type="html" xml:base="/algs/GraphMST.html"><![CDATA[<h2 id="前言">前言</h2>

<p>介绍三种基本的最小生成树算法：</p>

<p>它们都是贪心算法</p>

<ol>
  <li>基于最小边的 Kruskal 算法</li>
  <li>基于最小距离的点（到生成树）的 Prim 算法</li>
  <li>基于连通分量最小出边的 Boruvka 算法</li>
</ol>

<p>对于它们进行简单的比较</p>

<p>实现基于<a href="/algs/GraphTheoryBasic.html">图论基础</a>里面提到的数据结构</p>

<h2 id="性质">性质</h2>

<p>介绍一下最小生成树相关的性质<sup id="fnref:mst-wiki" role="doc-noteref"><a href="#fn:mst-wiki" class="footnote" rel="footnote">1</a></sup>，可能让我们对算法的理解能拨其冗繁、摁其要务，看得更清楚一点。</p>

<h3 id="割的性质">割的性质</h3>

<p>对于连通图 $G = (V, E)$ ，如果 $U$ 为它的非平凡子图（不是空集和它自身），则存在 $U$ 的所有出边（一头在 $U$ ,一头不在 $U$ ）中权值最小的边 $e$ 一定属于某棵 $G$ 上的最小生成树。</p>

<p>记 $T$ 为 $G$ 上的一棵最小生成树，</p>

<ol>
  <li>
    <p>如果 $e$  在 $T$ 上， 性质1成立；</p>
  </li>
  <li>
    <p>如果 $e$ 不在 $T$ 上，由于 $T$ 是生成树，加入 $e$ 就会构成一个环（不妨标记这个环形路径为 $C$ ），并且一定存在C中e以外的一条U的出边 $f$ ，由于e是最小出边，那么f一定权重大于等于 $e$ 。因此 $T-f+e$ 不仅是生成树，而且由于权重小于等于 $T$ , 是最小生成树。也就是e属于一棵生成树，性质1仍然成立。</p>
  </li>
</ol>

<p>证毕。</p>

<p>进一步地，如果这条最小出边 $e$ 是唯一最小的，它一定属于所有最小生成树。</p>

<h4 id="推论1">推论1</h4>

<p>对于连通图 $G = (V, E)$ ， $U$ 是 $E$ 的子图，如果 $U$ 属于某棵 $G$ 上的最小生成树，那么在加入一条最小出边后，仍然属于某棵最小生成树。</p>

<p>设 $U$ 属于最小生成树 $T$ ，根据性质1，加入最小出边 $e$ 后，$U$ 要么仍然属于 $T$ ，要么属于 $T-f+e$ ，都仍然属于某棵最小生成树。</p>

<h4 id="推论2">推论2</h4>

<p>进一步推论，开始的时候 $G$ 中每个点构成的子图一定属于最小生成树，那么根据归纳推理，不断地加最小出边，当图中每个点都被加入后，得到一棵生成树，也就是最小生成树。这也是 Prim 算法的证明。</p>

<h3 id="环的性质">环的性质</h3>

<p>图上的环状路径 $C$ ，如果其中一条边比其它所有边都大，那么它肯定不在任何一棵最小生成树上。</p>

<p>和上面割的性质的证明是是类似的，反证如果在某棵最小生成树，则其他 $C$ 上的边可以替换产生一棵更小权重的最小生成树。</p>

<h3 id="唯一性">唯一性</h3>

<p>如果 $G$ 上每条边的权重都是唯一的，那么最小生成树也是唯一的。</p>

<p>证明也是反证，假设有两棵不同的最小生成树，二者的对称差集（symmetric difference set）里权重最小的那一条所在的环上的其他边，至少有一条边不属于这棵最小生成树，而属于另一棵最小生成树，由于边权重唯一，那条边必然大于这个最小的差边，因而可以构成去大边加小边的更小的最小生成树，矛盾，证毕。</p>

<h2 id="kruskal-算法">Kruskal 算法</h2>

<p>大概读作 /’krʌs,gol/</p>

<h3 id="描述">描述</h3>

<p>最简单的，基于最小边的贪心算法</p>

<ol>
  <li>假设开始的时候每个点都是只包括自己的连通分量；</li>
  <li>边按照权重排序，从最小边开始，若边上的两点不在同一连通分量里，就把它加入生成树，然后把两个点所在的连通分量连通为一个分量，最后就得到最小生成树；</li>
</ol>

<h3 id="实现">实现</h3>

<ol>
  <li>对边用堆或者提前排序维护从小到大的边的检查顺序；</li>
  <li>用并查集维护连通分量</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_kruskal</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cm">/* init sorted edge set */</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted_edges</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sorted_edges</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">sorted_edges</span><span class="nf">.sort_unstable_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.2</span><span class="p">);</span>

    <span class="cm">/* init disjoint set */</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ds</span> <span class="o">=</span> <span class="nn">UnionFind</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">MergeBy</span><span class="p">::</span><span class="n">SZ</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ds</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span> <span class="k">in</span> <span class="n">sorted_edges</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">ds</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ds</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ds</span><span class="nf">.cunion</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="证明">证明</h3>

<p>Kruskal 算法的证明并不像它看起来那么简单。</p>

<p>假设 $G$ 是加权连通图， $Y$ 是算法应用在 $G$ 上产生的子图</p>

<p><strong>是生成树</strong></p>

<ol>
  <li>$Y$ 不存在环， 这是由算法加边时的检查所保证的；</li>
  <li>$Y$ 是连通的，因为所有边都被检查了一遍，只要两个点不在同一分量里就加入</li>
</ol>

<p><strong>且是最小生成树</strong></p>

<p>首先提出一个<strong>假设</strong> $P$：</p>

<p>​	设 $F$（Forest）是算法在任意阶段生成的边集，则总有 $G$ 上的最小生成树包含 $F$ ，并且它（这棵生成树）里面的边之前阶段没有被算法拒绝过</p>

<p>用归纳法证明 $P$ 成立：</p>

<ol>
  <li>
    <p>在开始的时候，$F=\varnothing $ ，显然 $G$ 上任何最小生成树都包含 $F$ ，算法一开始也没有拒绝过任何边， $P$ 成立；</p>
  </li>
  <li>
    <p>假设 $P$ 在算法的某个非最终阶段成立，将这时包含 $F$ 的最小生成树记为 $T$ ，下一个要加入的边记为 $e$ ：</p>

    <ol>
      <li>如果 $e$  在 $T$ 上， $P$ 成立；</li>
      <li>如果 $e$ 不在 $T$ 上，由于 $T$ 是生成树，加入 $e$ 就会构成一个环（不妨标记这个环形路径为 $C$ ），而由于 $e$ 通过了算法检查，所以 $e$ 加入后，构不成 $F$ 上的环形结构，也就是说环形路径 $C$ 一定存在至少一条边不属于 $F$ 。不妨标记这样的一条边为 $f$ ，$f \neq e$。根据 $P$ 的定义， $T$ 上没有边之前被 $F$ 拒绝过， $f$ 如果不属于 $F$ ，则一定权重大于等于 $e$ 。因此 $T-f+e$ 不仅是生成树，而且由于权重小于等于 $T$ , 因此是最小生成树，而 $T-f+e$ 包含 $F+e$ ， $P$ 仍然成立。
因此我们证明了若 $P$ 在 $F$ 上成立，就有 $P$ 在 $F+e$ 上成立的递推关系。</li>
    </ol>
  </li>
</ol>

<p>归纳证毕，假设 $P$ 成立。</p>

<p>因此当 $F$ 是生成树的时候，一定有最小生成树包含它，也就是 $F$ 是最小生成树。</p>

<p>而之前我们已经证明了 $F$ 最终所生成的子图 $Y$ 是生成树， 于是有算法产生了一棵最小生成树，证毕。</p>

<h3 id="时间复杂度">时间复杂度</h3>

<p>假设 $n=|V|$，$m=|E|$</p>

<p>复杂度等于边排序 $O(m \text{log} m)$ + 并查集操作 $O(m \text{log} n)$ ，等于 $O(m (\text{log} m+\text{log} n))$ 。</p>

<h2 id="prime-算法">Prime 算法</h2>

<p>类似 Dijkstra 算法，从距既有生成树最短距离的点开始加</p>

<h3 id="描述-1">描述</h3>

<ol>
  <li>选取图中任意一点开始，作为生成树的根节点，把其余点到生成树的最短距离初始化为 $+\infty$ ，根节点的生成树最短距离初始化为 $0$ ，初始化每个点到生成树的最短边的对应点为 <code class="language-plaintext highlighter-rouge">None</code>，记为 $\texttt{pair}$ ，把所有点加入剩余点集 $R$；</li>
  <li>每次从 R 中取出到生成树距离最小的点记为 $u$ ，把边 $(u, \texttt{pair}(u))$ 加入边集 $E$ 中。检查它的邻居中不在生成树上的点 $v$ ，如果边的权重 $w_{\large uv}$ ，与生成树最短距离 $\texttt{dis}(v)$ ，有  $w_{\large uv} &lt; \texttt{dis}(v) $  ，更新 $\texttt{dis}(v)$ 为  $w_{\large uv}$ ，也更新 $\texttt{pair}(u)$  为 $u$ ；</li>
  <li>当$R = \varnothing$ 时，退出，得到的E即为一棵最小生成树</li>
</ol>

<h3 id="实现-1">实现</h3>

<p>关键显然在于维护生成树距离的堆的选择，这涉及两个堆操作，<code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，经典地是使用Fib堆（在<a href="/algs/FibHeap.html">斐波那契堆（Fibonacci Heap） </a> 一文中介绍过），这样有理论更好的 <code class="language-plaintext highlighter-rouge">decrease-key</code> 性能，但实际上，我们知道在有缓存的 CPU 架构下二叉堆实际表现好得多，如果把调整二叉堆的实现，把基数从 $2$ 提高，到比如 $32$ ，那么理论上可以认为 <code class="language-plaintext highlighter-rouge">pop</code> 和 <code class="language-plaintext highlighter-rouge">decrease-key</code> 都有线性表现，这是理论与实践上都最优的优化。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="证明-1">证明</h3>

<p><a href="#推论2">割的性质推论2</a></p>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>经典使用斐波那契堆： $O(\text{log}n) + O(m) = O(\text{log}n + m)$</p>

<p>使用大基数的 $k$ 叉堆： $O(1) + O(m) = O(m)$</p>

<h2 id="boruvka-算法">Boruvka 算法</h2>

<p>Borůvka (捷克语) ，大概读作 /,bros’gɑʊl/</p>

<h3 id="描述-2">描述</h3>

<p>对每个连通分量加最小出边，直到没有出边为止。</p>

<p>这本质上和 Kruskal 算法是一样的，实际上 Kruskal 算法对所有边排序是有点儿浪费比较次数了。</p>

<ol>
  <li>开始的时候，图中每个点都是一个连通分量，对所有边遍历，选取其中两头不在同一个连通分量的，用它更新两个连通分量在这一轮迭代里的最小出边；</li>
  <li>一轮结束后，把新选取的最小出边加入结果集，并连接两个分量，当没有新选任何最小出边的时候结束，否则进行下一轮遍历</li>
</ol>

<p><strong>注意：</strong></p>

<ol>
  <li>显然作为一个优化，加入结果集的边就不需要再遍历了</li>
  <li>具体的算法实现中，注意不要让权重相等的边导致结果中出现环</li>
</ol>

<h3 id="实现-2">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_boruvka</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// using lexicograph order</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dsu</span> <span class="o">=</span> <span class="nn">UnionFind</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">MergeBy</span><span class="p">::</span><span class="n">SZ</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">dsu</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// components cheapest edges: (weight, usize)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cand_edges</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">comp_min_edges</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
            <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">cand_edges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pu</span> <span class="o">=</span> <span class="n">dsu</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">pv</span> <span class="o">=</span> <span class="n">dsu</span><span class="nf">.cfind</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pu</span> <span class="o">==</span> <span class="n">pv</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">pu_min_edge</span> <span class="o">=</span> <span class="n">comp_min_edges</span>
                <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pu</span><span class="p">)</span>
                <span class="nf">.cloned</span><span class="p">()</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pu_min_edge</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pu_min_edge</span> <span class="p">{</span>
                <span class="n">comp_min_edges</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">pv_min_edge</span> <span class="o">=</span> <span class="n">comp_min_edges</span>
                <span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pv</span><span class="p">)</span>
                <span class="nf">.cloned</span><span class="p">()</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pv_min_edge</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pv_min_edge</span> <span class="p">{</span>
                <span class="n">comp_min_edges</span><span class="nf">.insert</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">continue_flag</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">opt</span><span class="p">)</span> <span class="k">in</span> <span class="n">comp_min_edges</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">opt</span> <span class="p">{</span>
                <span class="n">res</span><span class="nf">.insert</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
                <span class="n">dsu</span><span class="nf">.cunion</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
                <span class="n">cand_edges</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">));</span>

                <span class="n">continue_flag</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">continue_flag</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="利用属性的简单证明">利用属性的简单证明</h3>

<p>开始时 $G$ 中每个点都是一个连通分量，每次选取最小出边，连接两个分量。首先这两个分量分别属于某棵最小生成树，其中任一个分量加上出边仍然是最小生成树的一部分，<strong>显然</strong> （也许并没有显然）应当是这两个连通分量合起来仍然属于某棵最小生成树。</p>

<h3 id="完整证明">完整证明</h3>

<p>完整证明过于复杂，另行查阅资料，不介绍。</p>

<h3 id="时间复杂度-2">时间复杂度</h3>

<p>由于每次迭代后连通分量至少减半（每个新分量都没再连通过），所以最外层迭代次数是O(logn)，每次边的遍历是 $O(m)$  ，并查询是 $O(\text{log}n)$ ，所以时间复杂度为 $O(m\text{log}n\text{log}n)$ 。</p>

<h2 id="时间复杂度简单比较">时间复杂度简单比较</h2>

<p>时间复杂度涉及 $n$ 和 $m$ ，按照图的稀疏度分两个维度讨论（对于连通图，$m\geqslant n-1$ ）</p>

<p><br /></p>

<p>对于稀疏图，$m=n$ :</p>

<p>Kruskal:  $O(m(\text{log}m+\text{log}n)) = O(n\text{log}n)$</p>

<p>Prime:  $O(\text{log}n+m) = O(n+\text{log}n) = O(n)$</p>

<p>Boruvka: $O(m\text{log}n\text{log}n) = O(n\text{log}n\text{log}n)$</p>

<p>复杂度从优到劣， Prim &gt; Kruskal &gt; Boruvka</p>

<p><br /></p>

<p>对于稠密图，$m=n^2$</p>

<p>Kruskal: $O(m(\text{log}m+\text{log}n)) = O(n^2\text{log}n\text{log}n)$</p>

<p>Prime:  $O(\text{log}n+m) = O(n^2 + \text{log}n)$</p>

<p>Boruvka: $O(m\text{log}n\text{log}n) = O(n^2\text{log}n\text{log}n)$</p>

<p>复杂度从优到劣， Prim &gt; Kruskal = Boruvka</p>

<p><br /></p>

<p>好像仅从复杂度上，经典实现里 Prim都是各方最优。</p>

<p>从优化实现上，Prim 的优化和 Boruvka 算法的拓展都可以到 $O(m)$ 。</p>

<h2 id="后续">后续</h2>

<p>关于 Prim 进一步可以看看 <a href="/algs/DaryHeap.html">d-ary 堆的实现</a>；而基于 Boruvka 的线性算法<sup id="fnref:lt-mst" role="doc-noteref"><a href="#fn:lt-mst" class="footnote" rel="footnote">2</a></sup> 复杂的部分在于一个去重（zhong）边的最小生成树的验证算法（原始提出和 Targan 最近共同祖先同一篇论文里），没有具体实现的介绍，只有原始的算法的论文，大体看了以下，应该可以弄明白，但是要花不少时间，有点儿鸡肋，就这样吧。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:mst-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Minimum_spanning_tree <a href="#fnref:mst-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:lt-mst" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Expected_linear_time_MST_algorithm <a href="#fnref:lt-mst" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">指数提升（倍增，Binary Lifting）</title><link href="/algs/BinaryLifting.html" rel="alternate" type="text/html" title="指数提升（倍增，Binary Lifting）" /><published>2022-11-16T00:00:00+08:00</published><updated>2022-11-16T00:00:00+08:00</updated><id>/algs/BinaryLifting</id><content type="html" xml:base="/algs/BinaryLifting.html"><![CDATA[<h2 id="前言">前言</h2>

<p>我一定要狠狠地“婊扬“一下“倍增“这个翻译，这个翻译从字面上看是要翻倍、增加，可是翻倍已经包含增加的内涵（一般概念上的对象都是自然数的），结果实际上一般人看到这个词就只能理解到翻倍的意涵，为什么要翻倍？这么做的好处在哪儿？ 这到底是什么东西？我每次看到这个词总是一头雾水，看了几次算法介绍也不能抓到关键点，而使用倍增这个翻译的介绍的大多数作者也没能抓住关键点，可能他们也被倍增这个鬼翻译迷惑住，只能硬讲流程，却点不出关键点。</p>

<p>我是直到看到“倍增”对应的英文词 Binary Lifting ，才恍然大悟，明白它的想法到底是什么，什么叫“好“翻译增加学习曲线的陡峭度？！它显然是可类比 Binary Search 二分搜索，用指数级别增长取代线性增长概念，从而把线性时间复杂度降低为对数级时间复杂度。这又要讲这个鬼翻译，大哥你提升和增长哪个更形象？你不觉得增长过于抽象了吗？何况你又把增长缩写为“增“，很可能人一看到“增“首先联想到的是增加而不是增长，那增加就比增长更抽象了，最后更绝地是，翻译者觉得“倍增”就是把翻倍和增长结合在一起的意思，这完全没有语文素养，没意识到白话文双元词语义分主辅的使用习惯，比如“强力”，主要是“强”，“力”是对“强”的辅助修饰，而倍增一词，就是一个“倍“，增通常是辅助，是被忽略的！</p>

<p>这样我们分析了“倍增”如何犯了一系列模糊重点，翻译失准的问题，翻译三重标准–信达雅，翻译者可能觉得自己这种翻译简直“既达而雅”了，实际在第一步“信“的标准上就失败了（很多那些让人摸不着头脑的翻译比那些佶屈聱牙的直白翻译还不如）（这种翻译，令人血压升高的程度堪比那个 YGO DL 里面那个有同步协调不用，非要同“吊“ 还不加儿化音的鬼翻译）（按照这种翻译，二分搜索就可以翻成“半搜“了，让人看了也一头雾水）。</p>

<p>所以我自己使用了一个更到位，让人一眼就看清楚这个算法是做什么的<strong>直白</strong>翻译：<strong>指数提升</strong> ，这个翻译首先从全局上讲清楚了，就是指数级增长，然后是“提升“就比“增“具体地多，清楚得多。</p>

<h2 id="算法思想">算法思想</h2>

<p>指数提升在前言里已经提过了，就是用指数级增长取代线性增长，这里我们具体地描述一下场景：</p>

<p>假设有在同一直线上的两点 $A$ , $B$ ，在不知道 $|AB |$（$A$ 到 $B$ 的距离）的情况下，从 $A$ 跳到 $B$ ，每次跳幅是单位距离的整数倍。</p>

<p>我们有如下几个逐渐改进的方案：</p>

<h3 id="步行">步行</h3>

<p>一个单位一个单位的跳，每次检查是否到了 $B$ 点，这肯定可以，但这是最慢的方法。</p>

<h3 id="传统家用汽车">传统家用汽车</h3>

<p>一跳跳固定跳 $n$ 个单位，最后距离如果不足一跳就下车步行（改为一个单位一个单位跳）</p>

<p>比步行强多了，但控制太差，要么速度不够快，要么步行距离长。</p>

<h3 id="传统超跑">传统超跑</h3>

<p>前面两种方法本质都是 $O(n)$ 的时间复杂度，于是我们想，可以加快这一过程，用指数增长（或减少）的步幅来跳。</p>

<p>假设幂底是 $m$ ，用档位代指指数，那么 $n$ 档就是 $m^n$ 。</p>

<ol>
  <li>
    <p>这样我们从 $0$ 档起步，每跳一步，就加速一档： $1$ 档, $2$ 档, ……, $n$ 档，直到第 $n+1$ 步会超过 $B$ ；</p>
  </li>
  <li>
    <p>之后从 $n$ 档开始逐一降档，直到下一步不超过 $B$ ，然后尝试保持档位跳第 $n+2$ 步，仍然超过就继续降档，重复步骤2，直到降到 $0$ 档，然后下车步行，直到到达 $B$ 点</p>
  </li>
</ol>

<p>有了指数级变速器，这比传统家用汽车性能强多了，但显然一档一档地提速显得加速度不够理想。</p>

<h3 id="电动超跑">电动超跑</h3>

<p>假如我们知道 $|AB |$  最大不超过 $x$ ，那么我们可以起步挂在 $\lfloor \log_{m}x \rfloor$ 档，一步到位，之后直接进入步骤2。</p>

<p>在最后的电动超跑的方案下，挂在每档的次数， 对应相应位上的数字，这样从高到低，构成了 $|AB |$ 的 $m$ 进制表示。设挂在每档的次数为 $k$ , 则显然有  $0\leqslant k &lt; m$ 。</p>

<p>通常我们会设定 $m=2$ ，这有实现上的便利：</p>

<ol>
  <li>当 $m=2$ 时，$k \in [0, 1]$，这意味着不存在重复的档位，挂了 $n$ 档后，下一步直接从 $n-1$ 档开始检查，当挂完 $0$ 档之后，一定到达了目的地；</li>
  <li>可以直接通过右移（right shift）来做 $2$ 为底的对数运算</li>
</ol>

<p>所以我们还可以把“指数提升“叫做<strong>幂（指）2提升</strong>或<strong>二进制提升</strong>，无论它们哪一个名字都比<em>倍增</em> 要好得多。</p>

<h2 id="应用模板">应用模板</h2>

<h3 id="快速开对数-2为底">快速开对数 （2为底）</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">quick_log2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="开跳">开跳</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nf">quick_log2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// skip 2^i</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">斐波那契堆的实作 (for Rust)</title><link href="/algs/FibHeapImplRust.html" rel="alternate" type="text/html" title="斐波那契堆的实作 (for Rust)" /><published>2022-11-13T00:00:00+08:00</published><updated>2022-11-13T00:00:00+08:00</updated><id>/algs/FibHeapImplRust</id><content type="html" xml:base="/algs/FibHeapImplRust.html"><![CDATA[<p>算法理论部分，在上一篇论文 <strong><a href="/algs/FibHeap.html">Fibonacci Heap</a></strong> 已经讲完了，下面是干活的部分<sup id="fnref:rust-impl" role="doc-noteref"><a href="#fn:rust-impl" class="footnote" rel="footnote">1</a></sup>：</p>

<h2 id="语言特定">语言特定</h2>

<h3 id="数据共享可变性与非null对象">数据共享、可变性与非null对象</h3>

<p>Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针  <code class="language-plaintext highlighter-rouge">Rc</code> (reference counter) 代替直接的指针，使用 <code class="language-plaintext highlighter-rouge">RefCell</code> 来“作弊“地绕开可变性检查，使用 <code class="language-plaintext highlighter-rouge">Option</code> 取代传统含 <code class="language-plaintext highlighter-rouge">null</code> 对象。但是这不可避免地使代码显得冗长，按说应该有语法糖或者辅助结构来做这件事，但是没有，这也是 Rust1 诸多不完美地方中的一处，好在可以通过写一点儿宏来解决这个问题。</p>

<h3 id="计数指针的强弱引用">计数指针的强弱引用</h3>

<p>另外的问题在于双向索引的链表结构会造成计数指针的循环引用，这会造成内存泄露的问题。Rust 提供了 <code class="language-plaintext highlighter-rouge">Weak</code> 计数指针的弱引用来解决这个问题。使用弱引用有两个方案：</p>

<ol>
  <li>所有正向引用（从左到右，从上到下）是正常的强引用，而反向引用（从右到左，从下到上）是弱引用，唯一例外是根链表，这只要在释放的时候手动去掉一个强引用，打破强引用的循环就可以了。</li>
  <li>所有引用都是弱引用，只在堆的头部的索引里保留唯一的强引用。</li>
</ol>

<p>方案 2 的好处是不需要在算法里区分强弱引用和做强弱转换，省事省心；但方案 1 的好处在于不依赖外部维持的强引用，每个节点都可以分型地单独使用，更符合个人美感所以暂时选择方案 1 。</p>

<h3 id="宏机制">宏机制</h3>

<p>最后是展开说明 Rust 的宏机制，它是 Rust 集众家之长，也是目前为止综合起来，最令我满意的宏机制的实现方案，虽然也有应有未有的地方。</p>

<p>Rust 的宏分为两种 ： 预处理宏（procedure macro）和声明式宏（declare macro）。</p>

<p><strong>预处理宏</strong></p>

<p>预处理宏是顾名思义，展开在提前的、单独的一遍扫描过程里，可以做到声明式宏做不到的所有，比如创造新的 Token 节点，但是没有语义感知，需要放置在单独的 crate 里面，使用也麻烦一点。</p>

<p><strong>声明式宏</strong></p>

<p>声明式宏名字并没有那么直观，是嵌在源文件中，和普通代码在同一过程中展开，有特殊的 <code class="language-plaintext highlighter-rouge">$crate</code> 指名当前所属 Crate ，但是因此功能受限，无法创建新的 Token ，后面生成宏的宏又被限制在它定义的模块里，不能跨模块使用。</p>

<p>这里我们直接使用声明式宏在补充该有的语法糖。</p>

<h3 id="生命周期对引用的限制">生命周期对引用的限制</h3>

<p>同样不同于传统的编程模型，Rust 引入了生命周期的概念，区别于一般在安全点上动态运行的垃圾回收器，来作为一种静态的内存自动管理机制，属于从源头上解决了内存需要自动管理而传统垃圾回收器有运行期性能“毛刺“的问题。但是这又对提出了新问题：由于 <code class="language-plaintext highlighter-rouge">Rc</code> 所有权是 <code class="language-plaintext highlighter-rouge">GlobalAllocator</code> ，而不是 <code class="language-plaintext highlighter-rouge">FibHeap</code> ，因此它创建的引用，由于生命周期的限制，无法用在 <code class="language-plaintext highlighter-rouge">FibHeap</code> 返回引用的接口上。这个问题也是 <code class="language-plaintext highlighter-rouge">Rc</code> 、 <code class="language-plaintext highlighter-rouge">RefCell</code> 另一个比冗繁更要命的缺点，阅读了 Rust 和标准库内部组件的实现，看它们基本上都不使用这两个公开组件而是用 unsafe 的传统指针另写一套，功能上和这两个组件基本类似，唯一额外作用就是能绕开生命周期的限制。</p>

<p>在这里我们直接使用 <code class="language-plaintext highlighter-rouge">Box</code> 把需要导出引用的数据放到堆上而不是 <code class="language-plaintext highlighter-rouge">RefCell</code> 中，在 <code class="language-plaintext highlighter-rouge">RefCell</code> 里只保留原始指针，通过这种 unsafe 操作，绕过生命周期的限制（实际也可以绕过所有权、可变性等等所有 Rust 额外的检查）</p>

<h3 id="克隆clone与复制copy">克隆（clone）与复制（copy）</h3>

<p>这里对应的是内存模型里的<strong>值对象</strong>与<strong>引用对象</strong>，copy 针对的是值对象，clone 针对的是引用对象。二者的区别首先是概念上的、语义上的，值对象就是它本身只是内存里的一个数值，可以任意地在任何地方使用，没有任何其他语义上或物理上的外部关系；而引用对象就像广泛的用于传统面向对象语言里的普通对象，这里二者在概念上直接构成互补的关系。</p>

<p>从实现角度，copy 为了严格语义不被违反，限制了只能自动实现，基本的数值类型是可 copy 的，任何派生的可 copy 对象必须保证所有字段都是可 copy 的。从语义上讲，分配内存空间的对象都应该是不可 copy 的，什么 <code class="language-plaintext highlighter-rouge">Vec</code>，<code class="language-plaintext highlighter-rouge">array</code>， <code class="language-plaintext highlighter-rouge">String</code> … 都不行，因为分配内存本身就不能随意复制。</p>

<p>注意区别于传统上世纪 90 年代的那一批面向对象语言什么 Java、Python、Ruby、C# 等等，在这种传统编程模型里，所有对象都是引用，没有值对象的概念，更重要的是前面提到的数据共享上缺乏设计，于是在对象克隆的时候有深和浅的区别，有的也称 deep “copy” 和 swallow “copy”。</p>

<p>这种在数据共享上设计的匮乏是它们并发痛点的根源， 只熟悉那些语言的人可能会把这个东西和上面的 clone 与 copy 的概念错误地对应起来。实际上对于 Rust 而言并不常用到那些语言里常见的克隆深与浅的问题，因为 Rust 有一套新的安全编程模型，所有权、可变性、生命周期等等保证你要么转移对象所有权，要么克隆就是完全克隆。</p>

<p>但原则的城墙大门紧闭，但在总有几扇窗户是开着的，就像 <code class="language-plaintext highlighter-rouge">Rc</code>、<code class="language-plaintext highlighter-rouge">RefCell</code> 这种“怪胎“的存在，当我们不得不用它们在更高层面模拟传统编程模型的时候，就必须考虑自己有区分的实现深浅克隆的问题了。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="heap-node">Heap Node</h3>

<h4 id="structure--wrappers">Structure &amp;&amp; Wrappers</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="cd">/// Used for reverse reference to avoid circular-reference</span>
<span class="cd">///</span>
<span class="cd">/// So we can easy auto drop</span>
<span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// children number</span>

    <span class="cd">/// rev ref</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// rev ref</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Indicate that it has lost a child</span>
    <span class="n">marked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="sugar-macros">Sugar Macros</h4>

<p>谈到 Rust 的声明式宏，总是离不开 <a href="https://danielkeep.github.io/tlborm/book/index.html">黑小书</a> 和 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">基础文档</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////////////////////////////////////////</span>
<span class="c1">//// Attr macros</span>

<span class="cd">/// Clone attr</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">_unr</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">mattr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="n">mname</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">mattr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nd">attr!</span><span class="p">(</span><span class="nv">$node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">marked</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="heap-head">Heap Head</h3>

<h3 id="structure">Structure</h3>

<ol>
  <li>$\texttt{len}$ 和 $\texttt{rcnt}$ ，分别是节点数和根节点个数，它们只是额外的基本统计信息，可以省略；</li>
  <li>$\texttt{min}$ 是最小根；</li>
  <li>$\texttt{nodes}$ 是索引，这里专注主要功能的使用，所以使用 HashMap ，如果要实现 $O(1)$ 的 Union 方法就需要换成别的分型结构，比如二叉搜索树或者B-树</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">CollKey</span> <span class="o">=</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// roots count</span>
    <span class="n">rcnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// index of nodes</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sugar-macros-1">Sugar Macros</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">node!</span><span class="p">(</span><span class="nv">$i</span><span class="p">,</span> <span class="nv">$k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$rank:expr</span><span class="p">,</span> <span class="nv">$marked:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">:</span> <span class="nv">$i</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$k</span><span class="p">),</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nv">$rank</span><span class="p">,</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">marked</span><span class="p">:</span> <span class="nv">$marked</span><span class="p">,</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="算法无关的基础方法">算法无关的基础方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">WeakNode</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">node</span><span class="na">.0</span><span class="p">;</span>
        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">children</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="cd">/// replace with new val, return old val</span>
    <span class="k">fn</span> <span class="nf">replace_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">oldk</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">newk</span> <span class="o">=</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="nd">mattr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="n">newk</span><span class="p">;</span>

        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldk</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// from self.min go through all roots</span>
    <span class="k">fn</span> <span class="nf">roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sibs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sibs</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="n">sib</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sibs</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">I</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="n">k</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// break circle dependency to enable drop</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.nodes</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法相关的基础方法">算法相关的基础方法</h3>

<h4 id="摘儿子">摘儿子</h4>

<p>在 update-key 的时候，需要把违背堆性质或者失去超过一个孩子的非根节点从父结点摘除。这就是这个方法的作用，需要仔细考虑，每一步都不能忽略：</p>

<p>假设被摘的节点为 $\texttt{x}$</p>

<ol>
  <li>如果 $\texttt{x}$ 的左邻居不为空，把左邻的右邻连接到 $\texttt{x}$ 的右邻，否则 $\texttt{x}$ 就是父节点的第一个孩子，这时还需要更新父节点的孩子到 $\texttt{x}$ 的右邻；</li>
  <li>如果 $\texttt{x}$ 的右邻居不为空，还把右邻的左邻更新为 $\texttt{x}$ 的左邻；</li>
  <li>父节点的 $\texttt{rank–}$ ；</li>
  <li>摘出来的节点去头和左右邻，只保留它的孩子</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cut_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">mchild!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">mrank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">rank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="cd">/// remove paren, left and right</span>
    <span class="k">fn</span> <span class="nf">purge_as_root</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">mparen!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="锄根">锄根</h4>

<p>在执行 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候，需要把一个根节点从根链表中移除：</p>

<ol>
  <li>根数自减，如果不为 $0$ ，意味着根链表还存在，就把左邻的右邻连接到右邻，右邻的左邻连接到左邻；</li>
  <li>purge</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...    </span>
<span class="k">fn</span> <span class="nf">remove_from_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.rcnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="插苗">插苗</h4>

<p>锄根的逆过程，把一个节点 $\texttt{x}$ 插入到根链表中：</p>

<ol>
  <li>根数 $\texttt{rcnt}$ 自增，保护性地 purge 节点 $\texttt{x}$ ；</li>
  <li>如果根链表不存在，把 $\texttt{x}$ 作为根链表的唯一节点，让它成为最小根并且左右邻指向自己；</li>
  <li>否则，头插法插入 $\texttt{x}$ ， $\texttt{x}$ 的右邻链接到最小根的右邻， $\texttt{x}$ 左邻链接到最小根，然后最小根的右邻链接到 $\texttt{x}$ ， $\texttt{x}$ 的右邻的左邻链接到  $\texttt{x}$</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">fn</span> <span class="nf">push_into_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>

        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...  </span>
</code></pre></div></div>

<h2 id="高空台-atf">高空台 （ATF）</h2>

<p>欲要善其事，必先利其器</p>

<p><strong>任何有一定复杂度的实现都非一蹴而就，而越是复杂度高的实现，越是需要测试与调试的部分先行，越是由测试的全面性、彻底性与调试工具的效率决定其进程速度。</strong></p>

<h3 id="打印方法">打印方法</h3>

<p>一个全面而又简洁的打印方法是进行状态观察的基础手段。</p>

<ol>
  <li>
    <p>对于 Fib 堆，简单遍历根节点地逐树打印，表明最小根；</p>
  </li>
  <li>
    <p>树的打印遵循 BFS 顺序，每层一行，同层不同父节点的由分号分开， 并且在开头表明父节点序号；</p>
  </li>
  <li>
    <p>单个节点打印它的权重（key）和索引（idx），如果被标记还要打印标记</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="k">self</span><span class="py">.rcnt</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}  ({i:03})  {}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="c1">// writeln!(f)?;</span>
            <span class="k">if</span> <span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"M=&gt;"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">sib</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">sib</span><span class="nf">.is_some</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}&gt;&gt; end &lt;&lt;{}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"R({:?}) "</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">curq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="k">self</span><span class="nf">.children</span><span class="p">())];</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxtq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="k">in</span> <span class="n">curq</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">children</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"P({:?}) "</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">childlen</span> <span class="o">=</span> <span class="n">children</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childlen</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">nxtq</span><span class="nf">.push</span><span class="p">((</span><span class="n">child</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">child</span><span class="nf">.children</span><span class="p">()));</span>
                <span class="p">}</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">nxtq</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="n">curq</span> <span class="o">=</span> <span class="n">nxtq</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"None"</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="s">"{:?}[{:?}]{}"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.idx</span><span class="p">,</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.key</span> <span class="p">},</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.marked</span> <span class="p">{</span> <span class="s">" X"</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="s">""</span> <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="克隆方法">克隆方法</h3>

<p>测试的时候，需要验证某一个状态是否正确，而当验证过程会影响测试对象本身状态时，就需要一个克隆方法来克隆一个被测试对象来进行这种有副作用地验证。</p>

<ol>
  <li>创建新的索引目录，对根链表逐根完全克隆，每克隆完一个，就和前一个克隆的节点双向链接起来，最后把头尾相连，构成一个循环链表；</li>
  <li>对于根链表上的每棵树克隆的时候，先创建新的根节点，并把新创建的节点加入新的索引目录里，然后对它孩子递归地调用节点的完全克隆方法，创造出的孩子左右相连，每个孩子的父节点也要指向自己创建的新的根节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rcnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rcnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">min</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">roots_iter</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_min</span><span class="p">)</span> <span class="o">=</span> <span class="n">roots_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">_min</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">root</span> <span class="k">in</span> <span class="n">roots_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newroot</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newroot</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newroot</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newroot</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">,</span>
            <span class="n">min</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">overall_clone</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// overall clone node body</span>
        <span class="k">let</span> <span class="n">newx</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">rank!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="c1">// update index reference</span>
        <span class="n">nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">newx</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// recursive call it</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">childen_iter</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="n">childen_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

            <span class="nd">mchild!</span><span class="p">(</span><span class="n">newx</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mparen!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">newx</span><span class="nf">.downgrade</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">childen_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">newx</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="主要算法方法">主要算法方法</h2>

<p>Fib 堆核心的算法就是三个：</p>

<ol>
  <li>Push</li>
  <li>Pop</li>
  <li>DecreaseKey</li>
</ol>

<h3 id="push-方法">Push 方法</h3>

<p>根据算法，创建新的节点和索引后，直接插入到根链表中； 如果 $\texttt{key}$ 比最小根小，就更新最小根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop-方法">Pop 方法</h3>

<p>（这里从使用的接口上讲，实际上需要的是 <code class="language-plaintext highlighter-rouge">pop_item</code> ）</p>

<ol>
  <li>如果长度为 $0$ ，不存在最小根，直接返回 <code class="language-plaintext highlighter-rouge">None</code>；</li>
  <li>否则长度自减，从最小根的右邻开始，遍历所有邻居，找到新的最小节点，如果最小根没有邻居（除它以外），就得到一个空节点；</li>
  <li>把旧的最小根指向的节点从根链表摘除，最小根指向新的最小节点（包括可能是空节点），开启树的规整，合并同秩树；</li>
  <li>树规整：创建一个 $\texttt{rank =&gt; node}$ 的 Map，遍历根链表，对于每个根，递归地查询 Map 是否有同秩的节点已经加入，有就合并两棵树，然后更新当前根节点为合并后的树的根节点，递归查询合并结束后，就插入当前树的秩和节点到 Map 中</li>
  <li>把旧的最小根节点从索引删除，返回旧的最小根的节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.1</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* push children of oldmin into roots */</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* update min */</span>

    <span class="k">let</span> <span class="n">newmin</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">sib</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span>
    <span class="nf">.cloned</span><span class="p">()</span>
    <span class="nf">.unwrap_or_default</span><span class="p">();</span>

    <span class="cm">/* just del old min */</span>

    <span class="k">self</span><span class="nf">.remove_from_roots</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">oldmin</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.replace</span><span class="p">(</span><span class="n">newmin</span><span class="p">);</span>


    <span class="k">self</span><span class="nf">.consolidate</span><span class="p">();</span>

    <span class="nf">Some</span><span class="p">((</span>
        <span class="k">self</span><span class="nf">.remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmin</span><span class="p">),</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">oldmin</span><span class="p">)</span><span class="py">.key</span><span class="p">),</span>
    <span class="p">))</span>
<span class="p">}</span>


<span class="cd">/// merge same rank trees recusively</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">consolidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rank</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">hashmap!</span><span class="p">();</span>

    <span class="k">for</span> <span class="k">mut</span> <span class="n">sib</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">rank</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.merge_same_rank_root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">rank</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">),</span> <span class="n">sib</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey-方法">DecreaseKey 方法</h3>

<p>对节点 $\texttt{x}$ 降 $\texttt{key}$ ，首先检查一下索引（检查是否 $\texttt{x}$ 的新 $\texttt{key}$ 确实较小），检查一下是否不是根节点并且堆性质违背（比父节点的 $\texttt{key}$ 更小），如果是，标记 $\texttt{x}$ ，设置 <em>cut-meld-unmark</em> 递归的起始点为 $\texttt{x}$ ，假装 $\texttt{x}$ 本身也是符合<em>cut-meld-unmark</em> 条件的一个父节点，否则设置起始点为空节点。最后由于是降 $\texttt{key}$ ，还要检查最小根是否需要更新为 $\texttt{x}$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">oldv</span><span class="p">,</span>
                <span class="s">"decrease violated! {:?} !(&lt;) {:?}"</span><span class="p">,</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="o">&amp;</span><span class="n">oldv</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"Empty index {i:?}"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decrease_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">unmeld_ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 假装x节点本身也是一个符合条件的父节点</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">unmeld_ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>cut-meld-unmark to roots :</strong></p>

<p>如果起始节点是空节点，就退出；递归地检查当前节点是否不为根节点并且被标记，是，就取消标记，从父节点被摘出，推进根链表，然后以父节点为新的起始节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">cut_meld_unmark_to_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ent</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">while</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">strongp</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="n">strongp</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">strongp</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 定义上不标记根，但这应该是无所谓的，标记对于可能的pop导致的树规整后的树情况更精确</span>
    <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="额外算法方法">额外算法方法</h2>

<h3 id="update-方法">Update 方法</h3>

<p>从语义上可以把 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的方法拓展为完整的更新key的方法 。</p>

<ol>
  <li>如果索引不存在，就插入节点，否则替换节点；</li>
  <li>如果 $\texttt{key}$ 相等，什么都不做；</li>
  <li>如果 $\texttt{key}$ 降低，就 <code class="language-plaintext highlighter-rouge">decrease-key</code> ；</li>
  <li>如果增加，就 <code class="language-plaintext highlighter-rouge">increase-key</code></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.increase_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>increase-key</strong> :</p>

<p>注意： 由于当对最小根 <code class="language-plaintext highlighter-rouge">increase-key</code> 的时候需要重新搜索最小根，时间复杂度为 $O(\texttt{rank})$ ，在不保证严格二项堆的性质时，最坏时间复杂度为 $O(\texttt{n})$  , 会破坏了整个 <code class="language-plaintext highlighter-rouge">update</code> 其他部分的 $O(\texttt{logn})$ 的性质。</p>

<p><code class="language-plaintext highlighter-rouge">increase-key</code> 的时候，同样地，当堆性质违背的时候（新的 $\texttt{key}$ 大于孩子节点）递归地执行 <em>cut-meld-unmark</em> 操作，区别在于升 $\texttt{key}$ 的是 $\texttt{x}$ 而要扫描的是x的孩子节点，好像是 $\texttt{x}$ 的孩子们降 $\texttt{key}$ 造成的堆性质违背。统计 $\texttt{x}$ 总共因为堆违背失去的孩子数（如果 $\texttt{x}$ 已被标记，初始化为 $1$ 否则为 $0$ ）。</p>

<p>检查失去的孩子节点数，如果没有，就把启动点设置为空节点；如果恰好为 $1$ ，确认标记x，以 $\texttt{x}$ 的父节点为启动点；如果大于 $1$ ，标记 $\texttt{x}$ ，以 $\texttt{x}$ 本身为启动点。</p>

<p><em>cut-meld-unmark</em>  递归地操作完成后，如果升 $\texttt{key}$ 的节点是最小根指向的节点，还要遍历根链表，更新最小根</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">increase_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">children_lost</span> <span class="o">=</span> <span class="k">if</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="n">children_lost</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="n">children_lost</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">min_node</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">min_node</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="典例片段">典例片段</h2>

<h3 id="prim-最小生成树">Prim 最小生成树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:rust-impl" role="doc-endnote">
      <p>https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs <a href="#fnref:rust-impl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[算法理论部分，在上一篇论文 Fibonacci Heap 已经讲完了，下面是干活的部分1： https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs &#8617;]]></summary></entry><entry><title type="html">斐波那契堆（Fibonacci Heap）</title><link href="/algs/FibHeap.html" rel="alternate" type="text/html" title="斐波那契堆（Fibonacci Heap）" /><published>2022-10-27T00:00:00+08:00</published><updated>2022-10-27T00:00:00+08:00</updated><id>/algs/FibHeap</id><content type="html" xml:base="/algs/FibHeap.html"><![CDATA[<p>Fibonacci Heap<sup id="fnref:fib" role="doc-noteref"><a href="#fn:fib" class="footnote" rel="footnote">1</a></sup><sup id="fnref:fib2" role="doc-noteref"><a href="#fn:fib2" class="footnote" rel="footnote">2</a></sup> <sup id="fnref:fib-wiki" role="doc-noteref"><a href="#fn:fib-wiki" class="footnote" rel="footnote">3</a></sup>是一个基于链表结构的，理论时间复杂度很优的数据结构。</p>

<p>常用于Dijkstra最短路径、Prim最小生成树等贪心算法，使用 <code class="language-plaintext highlighter-rouge">push</code> - <code class="language-plaintext highlighter-rouge">decrease-key</code>，都是 $O(1)$ 的时间复杂度。</p>

<h2 id="前言">前言</h2>

<p>一点儿啰嗦，可以跳过。说实话本来看图例， 看着各种相比最优的时间复杂度颇为心动但仔细看下去，发现完全是典型的基于链表结构的算法，代意词是理论很好但实际性能和最好的比要差一到两个数量级。那谁是最好的？</p>

<p>其中之一就是Rust标准库里本家实现的堆–<a href="https://doc.rust-lang.org/src/alloc/collections/binary_heap.rs.html#268">BinaryHeap</a> 。这个堆不看不知道，一看我的天，整个基础结构就是一块儿连续内存，什么叫完美？！！你一看这个就知道性能比较可以不用做了，你F堆拿什么跟人家比，比都没法儿比！除非说，使用的CPU没有碗口大的高速缓存，否则你链表结构，就一个字，拉！</p>

<h2 id="预备知识">预备知识</h2>

<h3 id="二项式树-binomial-tree">二项式树 （Binomial Tree）</h3>

<h4 id="秩阶度-rankorderdegree">秩、阶、度 （rank/order/degree）</h4>

<p>$\texttt{order}$ ，通常指允许的最大孩子数量，常用于B树，二叉树的 $\texttt{order}$ 为 $2$ ；</p>

<p>$\texttt{degree}$ ，具体地某个节点的孩子的数量；</p>

<p>$\texttt{rank}$ ，一般指排名，但这里用作 $\texttt{degree}$ 的别名；</p>

<p>以下统称 $\texttt{rank}$ ，指称直接孩子的个数。</p>

<h4 id="性质与定义">性质与定义</h4>

<ol>
  <li>
    <p>二项树的节点数为 ${\large 2^{\text{rank}}}$ ；</p>
  </li>
  <li>
    <p>显然单节点树的 $\texttt{rank=0}$ ，而合并两棵单节点树可以得到 $\texttt{rank=1}$ 的树，合并两棵 $\texttt{rank=1}$ 的树可以得到 $\texttt{rank=2}$ 的树，由此可归纳得到 $\texttt{rank=k, (k&gt;0)}$ 可以由两棵 $\texttt{rank=k-1}$ 的树合并得到，这就是二项式树的构造；</p>
  </li>
  <li>
    <p>特别地，从实现上讲，每次同 $\texttt{rank}$ 的树合并，都是其中一棵作为另一棵的最左子树，这样构造出的二项式树的子树也是二项式树，假设 $\texttt{rank=k} $，而且从左到由的 $\texttt{rank}$ 分别为 $\texttt{k-1, k-2, …, 0} $ 。</p>
  </li>
</ol>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_01.svg" zoom="200%" /></div>

<p>二项式堆（Binomial Heap）就是由多棵二项式树构成，每棵树都是小顶堆（Min Heap），并且每棵子树的 $\texttt{rank}$ 独特。</p>

<p>每个二项式堆都可以这样构造出来，二项式堆的结点数 $\texttt{n}$ 的二进制表示的每一位对应一个 $\texttt{rank}$ 数值。</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_02.svg" zoom="200%" /></div>

<p><em>而二项堆里的每棵二项树的孩子构成的森林都可以理解为完全二项堆。</em></p>

<h2 id="定义">定义</h2>

<p>斐波那契堆类似于二项式堆，是一个二项式树的森林，但并不严格要求 $\texttt{rank}$ 独特。</p>

<p>执行 <code class="language-plaintext highlighter-rouge">push</code> 操作的时候新节点直接作为单节点的二项式树，插入到根链表中。只有在 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候递归合并同 $\texttt{rank}$ 的树，才得到严格的二项式堆。</p>

<h2 id="数据结构">数据结构</h2>

<p>堆的结构：一个指向森林中最小根的指针，以及其他必要元数据；</p>

<p>树根的存储结构：双头循环链表；</p>

<p>树的结构：经典带反向引用的 <code class="language-plaintext highlighter-rouge">child-sibling</code> 链表。</p>

<h2 id="push-操作">Push 操作</h2>

<h3 id="算法">算法</h3>

<p>根据定义，直接把单个节点插入到根链表中即可，必要的话更新堆指针。</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_push1.png" title="" /></div>
<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_push2.png" title="" /></div>

<h3 id="复杂度分析">复杂度分析</h3>

<p>时间复杂度显然为 $O(1)$ 。</p>

<h2 id="pop-操作">Pop 操作</h2>

<h3 id="算法-1">算法</h3>

<p><code class="language-plaintext highlighter-rouge">pop</code>算法分为几步：</p>

<ol>
  <li>
    <p>把 <code class="language-plaintext highlighter-rouge">min</code> 所指向根的树的所有孩子插入到根链表中，然后遍历根列表找到下一个最小根，最后把旧根从根链表中删除；</p>
  </li>
  <li>
    <p>从更新后的最小根出发，再次遍历根链表，在这个过程中构建 $\texttt{rank =&gt; root}$ 的 $\texttt{Map}$ ，当发现新的根的 $\texttt{rank}$ 已在 $\texttt{Map}$ 中存在时，递归地合并同 $\texttt{rank}$ 的树。<em>显然整个过程一遍扫描就可以完成，结果是规整成了一棵严格二项式树</em></p>
  </li>
</ol>

<p>举例来看：</p>

<p><em>图中黑色节点为标记节点，decrease-min 操作中使用，表示该树失去过孩子</em></p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop01.png" title="" /></div>

<p>当前最小根指向 $\texttt{node(3)}$，它的孩子有 $\texttt{node(18), node(52), node(41)}$  ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop02.png" title="" /></div>

<p>把它的 $3$ 个孩子插入到根链表中，更新最小根为 $7$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop03.png" title="" /></div>

<p>从当前最小根节点开始递归地合并同 $\texttt{rank}$ 的树；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop04.png" title="" /></div>

<p>扫描到 $\texttt{node(7)}$ ， $\texttt{rank = 1}$ ，插入当前 $\texttt{rank =&gt; root}$ 对儿到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop05.png" title="" /></div>

<p>扫描到 $\texttt{node(24)}$ ， $\texttt{rank = 2}$ ，Map中没有同 $\texttt{rank}$ 项，插入当前 $\texttt{rank =&gt; root}$ 对儿到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop06.png" title="" /></div>

<p>扫描到 $ \texttt{node(23)} $ ， $\texttt{rank = 0}$ ，Map中没有同 $\texttt{rank}$ 项，把 $\texttt{0 =&gt; node(23)}$ 插入到 $\texttt{Map}$ 中，继续向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop07.png" title="" /></div>

<p>扫描到 $\texttt{node(17)}$ ，$\texttt{rank = 0}$ ，Map中发现同 $\texttt{rank}$ 的 $\texttt{node(23)}$ ，把该项从 $\texttt{Map}$ 取出， 把较大的 $\texttt{node(23)}$ 插入到 $\texttt{node(17)}$ ，检查同 $\texttt{rank}$ 项 <em>显然这个同 rank 树的合并不影响后面没扫描过的根节点</em>；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop08.png" title="" /></div>

<p>更新后的 $\texttt{17}$ 的 $\texttt{rank += 1}$ ，为 $1$ ，与 $\texttt{node(7)}$ 相同，继续合并，较大的 $\texttt{node(17)}$ 插入到 $\texttt{node(7)}$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop09.png" title="" /></div>

<p>更新后的 $\texttt{node(7)}$ 的 $\texttt{rank += 1} $，为 $2$ ，与 $\texttt{node(24)}$ 相同，继续合并，较大的 $\texttt{rank += 1}$ 插入到 $\texttt{node(7)}$ ；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop10.png" title="" /></div>

<p>更新后的 $\texttt{node(7)}$ 的 $\texttt{rank += 1} $，为 $3$ ， 没有同 $\texttt{rank}$ 项，把 $\texttt{3 =&gt; node(7)}$ 插入到 $\texttt{Map}$ 中，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop11.png" title="" /></div>

<p>扫描到 $\texttt{node(18)}$ ，$\texttt{rank = 1}$，没有同 $\texttt{rank}$ 项，把 $\texttt{1 =&gt; node(18)}$，插入到 $\texttt{Map}$ 中，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop12.png" title="" /></div>

<p>扫描到 $\texttt{node(52)}$ ，$\texttt{rank = 0}$，没有同 $\texttt{rank}$ 项，继续向下；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop13.png" title="" /></div>

<p>扫描到 $\texttt{node(41)}$ ，$\texttt{rank = 1}$，与 $\texttt{node(18)}$ 的 $\texttt{rank}$ 相同，合并；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop14.png" title="" /></div>

<p>更新后的树 $\texttt{rank = 2}$ ，没有同 $\texttt{rank}$ 项，插入 $\texttt{Map}$ ，向下扫描；</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_pop15.png" title="" /></div>

<p>发现所有节点已被扫描完，规整结束 <em>堆的数据结构里维护一个根节点数的变量，用它来指示扫描何时结束</em> 。</p>

<h3 id="复杂度分析-1">复杂度分析</h3>

<p>由于每棵树都是二项式树， 扫描最小根孩子节点的实际花费为 $\texttt{rank(H)}$ ，$ \texttt{H} $为最小根节点的树。扫描根节点链表的实际花费为根节点数，标记为 $\texttt{trees}$ ，所以有实际花费为 $O(\texttt{trees + rank})$  。</p>

<p>而由于每次规整后的，不存在相同 $\texttt{rank}$ 的树，所以标记 $\texttt{H’}$ 为 $\texttt{rank}$ 最大的树，有 $\texttt{trees} \leqslant \texttt{rank(H’) + 1}$ 。</p>

<p>对于不涉及 <code class="language-plaintext highlighter-rouge">decrease-key</code> 操作的F堆来说，每棵树都是严格二项式树，而根据二项式树的性质，标记 $\texttt{H’}$ 的节点数为 $n’$ ， $n’ \lt n$，有 $\texttt{rank(H’) = } {\log_2 n’ \lt log_2 n}$ 。</p>

<p>所以摊销时间复杂度为 $O(\text{log n})$ 。</p>

<p>而对于 <code class="language-plaintext highlighter-rouge">decrease-key</code> 操作后的不严格二项式树，由于每棵孩子最多丢失一个孩子，应该仍然保持 $\texttt{rank(H’)}$ ~ ${O(\text{log n})}$ 的性质，后面的性质理论分析部分对此进行了证明，所以摊销时间复杂度仍为 ${O(\text{log n})}$ 。</p>

<h2 id="decreasekey-操作">DecreaseKey 操作</h2>

<h3 id="算法-2">算法</h3>

<p>实现 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，需要一个额外的编号对节点的索引目录，</p>

<p><em>同时为了在pop操作时维护这一结构并不破坏时间复杂度，还需要一个反向的节点对编号的目录，进行 O(1) 时间的反查</em></p>

<p>假设需要更新 $\texttt{key}$ 的节点为 $x$ ，首先检查情况堆的性质是否被破坏：</p>

<p>对于 <code class="language-plaintext highlighter-rouge">decrease-key</code> ，堆的性质被破坏的情况就是，节点 $x$ 的 $\texttt{key}$ 比父节点小，<em>对于increase-key，就要检查节点x的子节点的key是否有比其小的</em> 。</p>

<p>如果堆的性质被破坏：</p>

<ol>
  <li>
    <p>把 $x$ 节点从父节点的孩子中删除，然后推到堆的根的链表上，取消 $x$ 节点的标记（<em>已被规整</em>） ，然后标记父节点（<em>表明它失去过一个孩子</em>节点），姑且把这个操作称为 <em>cut-meld-unmark</em>；</p>
  </li>
  <li>
    <p>向上递归地执行 <em>cut-meld-unmark</em> ，直到一个未被标记或者是根节点的父节点，然后标记它。</p>
  </li>
</ol>

<p>最后检查最小根是否需要被更新。</p>

<p><em>decrease-key</em> 流程：</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk1.png" title="" /></div>

<p><em>cut-meld-unmark</em> 流程：</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk2.png" title="" /></div>

<p>图例是一个 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的非平凡情况</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_01.png" title="" /></div>

<p>对节点 $x$ 的 $\texttt{key}$ 从 $35$ 降到 $5$</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_03.png" title="" /></div>

<p>发现堆性质被破坏，先对 $x$ 执行 <em>cut-meld-unmark</em></p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_04.png" title="" /></div>

<p>向上递归，发现 $p$ 被标记，意味着 $p$ 之前已经失去过一个孩子，加上这次，已经失去了两个孩子，</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_05.png" title="" /></div>

<p>对 $p$ 执行 <em>cut-meld-unmark</em> ，</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_06.png" title="" /></div>

<p>递归地检查 $p$ 的父节点 $p’$ ， $p’$ 也被标记</p>

<div class="sx-center"><img src="/../assets/img/fibheap/fibheap_dk_2b_07.png" title="" /></div>

<p>对 $p’$ 执行 <em>cut-meld-unmark</em> ，到了根节点，cut-meld-unmark 整个过程停止，检查最小根，发现 $\texttt{x = 5 &lt; 7}$ ，于是把最小根更新到 $x$ 。</p>

<h3 id="复杂度分析-2">复杂度分析</h3>

<p>由于每次操作最多增加一个标记节点，那么平均每次取消的标记节点也是 $1$ ，也就是摊销复杂度是 $O(1)$ 。</p>

<h2 id="其他操作">其他操作</h2>

<h3 id="union-操作-optional">Union 操作 （Optional）</h3>

<p>直接连接两个根链表，不考虑维护索引目录的情况下，那操作就是 $O(1)$ 。</p>

<p>如果需要维护索引目录，索引目录的合并也应该是 $O(1)$ 的时间复杂度。</p>

<h3 id="remove-操作-specific">Remove 操作 （Specific）</h3>

<ol>
  <li><code class="language-plaintext highlighter-rouge">decrease-key</code> 到 $-\infty$</li>
  <li><code class="language-plaintext highlighter-rouge">pop</code></li>
</ol>

<p>复杂度显然为 $O(\text{log n})$ 。</p>

<h2 id="性质的理论分析">性质的理论分析</h2>

<p>在对斐波那契堆的性质进行分析之前，先要引入几个相关的概念。</p>

<h3 id="黄金比率-golden-ratio">黄金比率 （Golden Ratio）</h3>

<p>对于两个数 $a$ ，$b$    $a&gt;b&gt;0$ ，有</p>

\[\large\frac{a+b}{a} = \frac{a}{b} = \varphi\]

<p>则称这两个数处于黄金比率，而这个黄金比率 $\varphi$ 可以通过定义</p>

<p>$ 1 + \frac{b}{a} = \frac{a}{b} = \varphi\ $</p>

<p>$1 + \frac{1}{\large \varphi} = \varphi $</p>

<p>得到它的二次方程 $\varphi + 1 = \varphi^2$</p>

<p>解出两个根，正根 $\varphi = {\large \frac{1+\sqrt{5}}{2}} \approx 1.618$ ，以及负根 $\psi = {\large \frac{1-\sqrt{5}}{2}} \approx -0.618$</p>

<h3 id="斐波那契数-fibonacci-number">斐波那契数 （Fibonacci Number）</h3>

\[F_n =
\left\{\begin{array}{l}
\ 0&amp; &amp;(n = 0) \\
\ 1&amp; &amp;(n = 1) \\ 
\ F_{n-2} + F_{n-1}&amp; &amp;(n \ge 2) \\
\end{array}\right.\]

<table>
  <thead>
    <tr>
      <th>$i$</th>
      <th>$0$</th>
      <th>$1$</th>
      <th>$2$</th>
      <th>$3$</th>
      <th>$4$</th>
      <th>$5$</th>
      <th>$6$</th>
      <th>$7$</th>
      <th>$…$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$F_i$</td>
      <td>$0$</td>
      <td>$1$</td>
      <td>$1$</td>
      <td>$2$</td>
      <td>$3$</td>
      <td>$5$</td>
      <td>$8$</td>
      <td>$13$</td>
      <td>$…$</td>
    </tr>
  </tbody>
</table>

<p>它的封闭表达式</p>

\[F_n = \frac{\varphi^n-\psi^n}{\varphi-\psi} = \frac{\varphi^n-\psi^n}{\sqrt 5}\]

<p>显然它的增长速度也是指数级的。</p>

<h4 id="性质1">性质1</h4>

<p>基础：</p>

\[\begin{array}{l}
&amp;F_2 = 1 = 1 + \sum_{i=0}^{0} F_i\\
&amp;F_3 = 2 = 1 + \sum_{i=0}^{1} F_i
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l} 
F_{n+2} &amp;=\ F_n + F_{n+1}\\
&amp;=\ F_n + 1 + \sum_{i=0}^{n-1} F_i\\
&amp;=\ 1 + \sum_{i=0}^{n} F_i
\end{array}\]

<p>得到 $ F_{n+2} = 1 + \sum_{i=0}^{n} F_i $</p>

<h4 id="性质2">性质2</h4>

<p>基础：</p>

\[\begin{array}{l}
&amp;F_2 =\ 1 \geqslant 1 = \varphi^0\\
&amp;F_3 =\ 2 \geqslant \varphi = \varphi^1
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l}
F_{n+2} &amp;=\ F_{n+1} + F_{n}\\
&amp;\geqslant \ \varphi^{n-1} + \varphi^{n-2}\\
&amp;=\ \varphi^{n-2}(1 + \varphi)\\
&amp;=\ \varphi^{n-2}\varphi^2\\
&amp;=\ \varphi^n
\end{array}\]

<p>得到 $ F_{n+2} \geqslant \varphi^n $</p>

<h3 id="斐波那契堆的性质">斐波那契堆的性质</h3>

<h4 id="性质1-1">性质1</h4>

<p>对一个 $\texttt{rank}$ 为 $n$ 的节点 $x$ ，按照插入顺序，编号它的孩子 $y_1, y_2, …, y_n$ 。</p>

<p>那么根据二项式树的性质，有 $\texttt{rank(} y_i \texttt{)}= i-1$ 。</p>

<p>考虑到 <code class="language-plaintext highlighter-rouge">decrease-key</code> 导致 $y_i$ 最多失去一个孩子</p>

<p>于是有</p>

\[\texttt{rank}({\large y_i}) \geqslant
\ \left \{\begin{array}{l}
\ 0 &amp;(i=1)\\
\ i - 2  &amp;(i \geqslant 2)\\
\end{array}\right.\]

<h4 id="性质2-1">性质2</h4>

<p>假设 $\texttt{size(k)}$ ，为 $\texttt{rank}$ 为 $k$ 的节点的可能的最小结点数</p>

<p>基础：</p>

\[\begin{array}{l}
&amp;\texttt{size}(0) =\ 1 = F_2 \geqslant F_2 \\
&amp;\texttt{size}(1) =\ 2 = F_3 \geqslant F_3 \\
\end{array}\]

<p>归纳推理：</p>

\[\begin{array}{l}
size(k) &amp;\geqslant 1 + \sum_{i=1}^{k} \texttt{size(rank(}y_i\texttt{))}\\
&amp;= 1 + \texttt{size(rank(}y_1\texttt{))} + \sum_{i=2}^{k} \texttt{size(rank(}y_i\texttt{))}\\
&amp;\geqslant 1 + \texttt{size(0)} + \sum_{i=2}^{k} \texttt{size(rank(i-2))}\\
&amp;\geqslant 1 + 1 + \sum_{i=2}^{k} \texttt{size(} F_i \texttt{)}\\
&amp;= 1 + \sum_{i=0}^{k} \texttt{size(} F_i\texttt{)}\\
&amp;= F_{k+2}\\
&amp;\geqslant \varphi^{k}
\end{array}\]

<p>于是有</p>

\[\texttt{size(k)} \geqslant F_{k+2} \geqslant \varphi^{k}\ \ \ (k \geqslant 0)\]

<p>根据这个性质，两边取 $log$ ，得到  $ log_{\varphi}^{size(k)} \geqslant k = rank $ 。</p>

<p>回顾前面 <code class="language-plaintext highlighter-rouge">pop</code> 的时间复杂度分析，$\texttt{rank}$ ~ $O(log_{\varphi}^{\texttt{size(k)}})$ ~ $O(log\ n)$，也就是说我们在理论上证明了 <code class="language-plaintext highlighter-rouge">decrease-key</code> 导致的不严格二项式树，仍然不影响它的 $O(\text{log n})$ 的时间复杂度。</p>

<h2 id="后续斐波那契堆的具体实现rust">后续：<strong><a href="/algs/FibHeapImplRust.html">斐波那契堆的具体实现（Rust）</a></strong></h2>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fib" role="doc-endnote">
      <p>https://www.cs.princeton.edu/~wayne/teaching/fibonacci-heap.pdf <a href="#fnref:fib" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fib2" role="doc-endnote">
      <p>http://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/FibonacciHeaps.pdf <a href="#fnref:fib2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:fib-wiki" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Fibonacci_heap <a href="#fnref:fib-wiki" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[Fibonacci Heap12 3是一个基于链表结构的，理论时间复杂度很优的数据结构。 https://www.cs.princeton.edu/~wayne/teaching/fibonacci-heap.pdf &#8617; http://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/FibonacciHeaps.pdf &#8617; https://en.wikipedia.org/wiki/Fibonacci_heap &#8617;]]></summary></entry><entry><title type="html">图理论基础</title><link href="/algs/GraphTheoryBasic.html" rel="alternate" type="text/html" title="图理论基础" /><published>2022-10-09T00:00:00+08:00</published><updated>2022-10-09T00:00:00+08:00</updated><id>/algs/GraphTheoryBasic</id><content type="html" xml:base="/algs/GraphTheoryBasic.html"><![CDATA[<h2 id="概念">概念</h2>

<p>假设图 G = {V, E}， V是顶点集，E是边集</p>

<ol>
  <li>
    <p>边，无向边（edge）</p>
  </li>
  <li>
    <p>有向边（arc）
tail(起点) -&gt; head（终点）</p>
  </li>
  <li>
    <p>|V|: 点的个数，图的阶（order）</p>
  </li>
  <li>
    <p>无根树，连通无向图</p>
  </li>
  <li>
    <p><strong>简单图 (simple graph)</strong>：若一个图中没有自环和重边，它被称为简单图。具有至少两个顶点的简单无向图中一定存在度相同的结点。因为最多n-1个不同的度，而有n个点，这叫做抽屉原理或者鸽巢原理。</p>

    <p>反过来，如果一张图中有自环或重边，则称它为 <strong>多重图 (multigraph)</strong>。</p>
  </li>
</ol>

<p>参考<a href="/lang/c_trap.html">这里</a></p>

<h2 id="实现">实现</h2>

<p>本篇实现是诸多相关算法基础数据结构：</p>

<p>额外依赖<a href="https://gist.github.com/minghu6/e8b6236c745489be489317088e70e24f">EasyColl gist</a></p>

<script src="https://gist.github.com/minghu6/e8b6236c745489be489317088e70e24f.js"></script>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Adjacent link formed simple (directed) connected graph</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Graph</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">e</span><span class="p">:</span> <span class="n">MV</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">w</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">Graph</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="cd">/// The length of the shortest path between the most distanced nodes.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">diameter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">isize</span> <span class="p">{</span>
        <span class="nf">diameter_dp</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// O(|E|)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">vertexs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_w</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">vertexs</span><span class="nf">.insert</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="n">vertexs</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">vertexs</span><span class="nf">.into_iter</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">edges</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">edges</span> <span class="o">=</span> <span class="k">self</span><span class="py">.e</span><span class="na">.0</span><span class="nf">.iter</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">subedges</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">=</span> <span class="n">subedges</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">from</span><span class="p">,</span> <span class="n">tos</span><span class="p">))</span> <span class="o">=</span> <span class="n">edges</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">subedges</span> <span class="o">=</span> <span class="n">tos</span>
                        <span class="nf">.into_iter</span><span class="p">()</span>
                        <span class="nf">.cloned</span><span class="p">()</span>
                        <span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="p">(</span><span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                        <span class="nf">.rev</span><span class="p">()</span>
                        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[概念]]></summary></entry><entry><title type="html">Linux上把大文件夹移动到其他存储设备上来释放空间</title><link href="/os/mv-large-size-dir-to-another-dev.html" rel="alternate" type="text/html" title="Linux上把大文件夹移动到其他存储设备上来释放空间" /><published>2022-09-10T00:00:00+08:00</published><updated>2022-09-10T00:00:00+08:00</updated><id>/os/mv-large-size-dir-to-another-dev</id><content type="html" xml:base="/os/mv-large-size-dir-to-another-dev.html"><![CDATA[<h2 id="问题背景">问题背景</h2>

<p>一个常见的问题是发现某个文件夹比如<code class="language-plaintext highlighter-rouge">/var</code>, <code class="language-plaintext highlighter-rouge">/opt</code> 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。</p>

<h2 id="约定">约定</h2>

<p>不妨假设根系统<code class="language-plaintext highlighter-rouge">/</code>挂载在磁盘分区<code class="language-plaintext highlighter-rouge">sda4</code>，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为<code class="language-plaintext highlighter-rouge">sdb</code>。</p>

<h2 id="思路1">思路1<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2>

<p>一个体面的思路是在<code class="language-plaintext highlighter-rouge">sdb</code>上创建一个分区，假设为<code class="language-plaintext highlighter-rouge">sdb1</code>，创建LargeDir的同级根目录LargeDir2，把<code class="language-plaintext highlighter-rouge">sdb1</code>挂载到LargeDir2，把LargeDir的内容复制到LargeDir2</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>LargeDir2
mount /dev/sdb1 LargeDir2
rsync <span class="nt">-a</span> LargeDir/ LargeDir2
</code></pre></div></div>

<p>在文件系统表单<code class="language-plaintext highlighter-rouge">/etc/fstab</code>里添加对应项,比如
<code class="language-plaintext highlighter-rouge">/dev/sdb1    LargeDir    ext4    defaults      2 2</code></p>

<p>重启后生效，但是这个思路是后一个文件系统隐藏了前一个文件系统的子目录，<strong>如何删除原文件系统的子目录内容呢？</strong></p>

<p>由于<strong>Linux允许同一文件系统有多个挂载点</strong>，所以只需要把<code class="language-plaintext highlighter-rouge">sda4</code>再次挂载到一个新的目录，然后就可以找到原LargeDir，然后删除。</p>

<h2 id="思路2">思路2<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2>

<p>重启进入单用户模式，安全移动内容，然后删除，然后重新命名回来</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://askubuntu.com/questions/39536/how-can-i-store-var-on-a-separate-partition <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://www.suse.com/support/kb/doc/?id=000018399 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[问题背景]]></summary></entry><entry><title type="html">kernel crash dump</title><link href="/os/kernel-crash-dump.html" rel="alternate" type="text/html" title="kernel crash dump" /><published>2022-09-01T00:00:00+08:00</published><updated>2022-09-01T00:00:00+08:00</updated><id>/os/kernel-crash-dump</id><content type="html" xml:base="/os/kernel-crash-dump.html"><![CDATA[<h2 id="ubuntu">Ubuntu</h2>

<p><a href="https://ubuntu.com/server/docs/kernel-crash-dump">install linux-crashdump</a></p>

<h2 id="dump-output">Dump Output</h2>

<p><code class="language-plaintext highlighter-rouge">alias crash="crash /usr/lib/debug/boot/vmlinux-$(uname -r)"</code></p>

<p><code class="language-plaintext highlighter-rouge">crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;</code></p>

<p>bt: backtrace
log: kernel log</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[Ubuntu]]></summary></entry><entry><title type="html">Compile Linux Kernel</title><link href="/os/compile-linux-kernel.html" rel="alternate" type="text/html" title="Compile Linux Kernel" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/os/compile-linux-kernel</id><content type="html" xml:base="/os/compile-linux-kernel.html"><![CDATA[<p>编译实践1：
学习Linux内核模块开发，需要增加一个<code class="language-plaintext highlighter-rouge">FORCE_UNLOADING</code> feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。</p>

<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"><strong>Linux上游源代码（git地址在其页面下方）</strong></a></p>

<p><strong>默认环境</strong>
当前目录： kernel源目录</p>

<h2 id="ubuntu">Ubuntu</h2>

<p>注意源文件的下载，不要在系统目录比如<code class="language-plaintext highlighter-rouge">/usr/src</code>下进行，而要在用户空间内进行，而<code class="language-plaintext highlighter-rouge">apt source</code>，<code class="language-plaintext highlighter-rouge">apt-get source</code>, 不需要也不能使用<code class="language-plaintext highlighter-rouge">sudo</code>, 会错误得造成源文件的用户组变为root。对于&gt;= 20.04,没有官方更新的wiki讲如何使用debian/rules，直接从linux上游源代码处获取。</p>

<p>= 18.04</p>

<p>参考<a href="https://askubuntu.com/questions/1085411/unable-to-follow-kernel-buildyourownkernel">这篇文章</a></p>

<p>= 19.04</p>

<p>参考<a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">官方wiki</a></p>

<p>= 20.04 (or maybe upper than it)</p>

<p>参考<a href="https://discourse.ubuntu.com/t/how-to-compile-kernel-in-ubuntu-20-04/20268/10">这篇文章</a></p>

<ol>
  <li>
    <p>下载源代码</p>
  </li>
  <li>
    <p>安装依赖<code class="language-plaintext highlighter-rouge">sudo apt install asciidoc autoconf bc binutils-dev bison build-essential crash dkms fakeroot flex gawk gcc kernel-wedge kexec-tools libelf-dev libiberty-dev libncurses5-dev libncurses-dev libssl-dev libudev-dev makedumpfile openssl pciutils-dev</code></p>

    <p>(<code class="language-plaintext highlighter-rouge">pciutils-dev</code> is replaced by <code class="language-plaintext highlighter-rouge">libpci-dev</code> in the later version)</p>
  </li>
  <li>
    <p>配置参考下面tips</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">make -jn deb-pkg</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cd .. &amp;&amp; sudo apt ./linux-*.deb</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sudo update-grub</code></p>
  </li>
</ol>

<p><strong>Tips:</strong></p>

<ol>
  <li>
    <p>Linux 68%的代码是驱动相关代码，当然大部分的编译时间也是在编译驱动上，而这一部分也是容易出问题，往往花了几个小时编译发现，后来发现在这里出了错误，这就很难受，需要提前仔细配置。个人经验是不使用 <code class="language-plaintext highlighter-rouge">/boot/config-`uname -r` </code> 作为初始配置，而是使用<code class="language-plaintext highlighter-rouge">make localmodconfig</code> 创建初始配置:<code class="language-plaintext highlighter-rouge">.config</code>文件，使用默认的配置，确保驱动的编译不出问题。然后使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>(shell text) or <code class="language-plaintext highlighter-rouge">make xconfig</code>(qt5 gui) 配置内核其他部分。</p>
  </li>
  <li>
    <p>make 使用<code class="language-plaintext highlighter-rouge">-j</code>启用多核编译很重要，如果宿主机器在编译的同时需要运行其他任务，建议少用一个核心，避免机器down掉(然后比如当前用户直接被强制logout)。</p>
  </li>
  <li>
    <p>如果make过程中因为什么原因中途停掉了，可以再次启动，但是第一次会报错: <code class="language-plaintext highlighter-rouge">"dpkg-source: unrepresentable changes to source"</code>, 只要把相关报错文件删除掉重新运行即可。</p>
  </li>
  <li>
    <p>&gt;= 20.04, 可能需要的额外依赖包:</p>

    <p>dwarves # tmp_vmlinux.btf: pahole (pahole) is not available</p>
  </li>
</ol>

<h2 id="select-kernel">Select Kernel</h2>

<p>重启的时候按住<code class="language-plaintext highlighter-rouge">shift</code>进入grup界面，选择需要的版本内核启动。
修改默认启动内核，参考<a href="https://support.huaweicloud.com/intl/en-us/trouble-ecs/ecs_trouble_0327.html">华为云的这篇文章</a>和<a href="https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version/1393019#1393019">askubuntu的这个回答</a>
修改配置文件<code class="language-plaintext highlighter-rouge">/etc/default/grub</code>的 <code class="language-plaintext highlighter-rouge">GRUB_DEFAULT</code> 的值为启动项的序号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0，正常启动
1&gt;y， 高级启动项，y start from 0
</code></pre></div></div>

<p>查看高级启动项的序号(Ubuntu为例)：
<code class="language-plaintext highlighter-rouge">sudo grub-mkconfig | grep -iE "menuentry 'Ubuntu, with Linux" | awk '{print i++ " : "$1, $2, $3, $4, $5, $6, $7}'</code>
不要忘记最后运行<code class="language-plaintext highlighter-rouge">sudo update-grup</code>来更新配置。</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[编译实践1： 学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。]]></summary></entry><entry><title type="html">TCP Congestion Control</title><link href="/net/ietf_rfc_5681_obs2581.html" rel="alternate" type="text/html" title="TCP Congestion Control" /><published>2022-08-07T00:00:00+08:00</published><updated>2022-08-07T00:00:00+08:00</updated><id>/net/ietf_rfc_5681_obs2581</id><content type="html" xml:base="/net/ietf_rfc_5681_obs2581.html"><![CDATA[<p>This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04</p>

<h2 id="1-introduction">1. Introduction</h2>

<p>介绍TCP四种交织在一起的拥塞控制算法：</p>

<ol>
  <li>慢启动（slow start）</li>
  <li>拥塞避免（congestion avoidance）</li>
  <li>快速重传（fast retransmit）</li>
  <li>快速恢复（fast recovery）</li>
</ol>

<p>TCP链接需要做什么，在一个长时间停当后，以及确定和澄清一些TCP ACK生成的问题</p>

<h2 id="2-definition">2. Definition</h2>

<p>发送方最大分片大小（Sender Maximum Segment Size, SMSS）<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>接收方最大分片大小（Receiver Maximum Segment Size, RMSS）<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>最大段（Full Sized Segment）</p>

<p>接收方窗口（Receiver Window, rwnd）</p>

<p>拥塞窗口（Congestion Window, cwnd）<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>初始窗口（Initial Window, IW）<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>丢失窗口（Lost Window, LW）<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<p>重启窗口（Restart Window, RW）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>飞行尺寸（FlightSize）<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup></p>

<p>重复确认（Duplicate Acknowledgement）:</p>

<p>一个确认被认为是重复的如果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a. ack的接收者有未完成的（outstanding）数据

b. 到来的ack没有携带数据

c. SYN 和 FIN的标志都没有被设置

d. ack number等于链接最大的ack number

e. 到来的ack广告的窗口大小等于上一次ack广告的窗口大小

f: 使用SACKs（Selective Acknownledgements）的TCP会利用SACK信息判断ack是否重复
</code></pre></div></div>

<h2 id="3-congestion-control-algorithm">3. Congestion Control Algorithm</h2>

<p>本文提到的拥塞控制算法使用丢失或者ECN标记作为拥塞发生的信号</p>

<h3 id="31-slow-start-and-congestion-avoidance">3.1 Slow Start and Congestion Avoidance</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if SMSS &gt; 2190 (bytes):
  IW &lt;= 2*SMSS and IM &lt;= 2*SS(Segment Size)
else if 1095 &lt; SMSS &lt;= 2190:
  IW &lt;= 3*SMSS and IW &lt;= 3*SS
ekse:
  IW &lt;= 4*SMSS and IW&lt;= 4*SS
</code></pre></div></div>

<p>建立TCP链接的两个ACK不能用来增加cwnd的大小。等等IW设置详见<a href="https://datatracker.ietf.org/doc/html/rfc3390">RFC3390</a>。</p>

<p>ssthresh的初始值可以任意高<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>
慢启动算法启动标准：<code class="language-plaintext highlighter-rouge">cwnd &lt; ssthresh</code>
拥塞避免算法标准：<code class="language-plaintext highlighter-rouge">cwnd &gt; ssthresh</code>
二选一都可以：<code class="language-plaintext highlighter-rouge">cwnd = ssthresh</code></p>

<p>在慢启动的时候，每次ACK，cwnd的增加不超过SMSS bytes，当cwnd超过<code class="language-plaintext highlighter-rouge">ssthresh</code>或者拥塞重新被检测到的时候，退出慢启动。
传统TCP实现每次正好增加SMSS，但是我们推荐使用： <code class="language-plaintext highlighter-rouge">cwnd += min(N, SMSS)</code>,N是被新的ACK新确认的未确认数据的大小。<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">9</a></sup></p>

<p>在拥塞避免的时候，每过一个往返时间<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">10</a></sup>，cwnd可以增加一个full-sized segment<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup>大小；
应该（SHOULD）每一个来回的时间，增加<code class="language-plaintext highlighter-rouge">min(N, SMSS)</code>
但是不管怎样，每次cwnd不能增加超过SMSS。</p>

<p>或者每当收到一个不重复的ACK数据报，就增加一个<code class="language-plaintext highlighter-rouge">SMSS * SMSS / cwnd</code>大小<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">12</a></sup>；
还有的方法是增加新的被ACK确认的数据大小，直到cwnd增加到SMSS。<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">13</a></sup></p>

<p>同样地，当检测到拥塞发生的时候，算法终止。</p>

<p>ssthresh不应该超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>

<p>并且，一旦超时，cwnd必须被设为不超过LW，也就是1 full-sized segment。因此在重传被丢弃的包分片后，发送方使用慢启动来增加窗口的大小，从1 full-sized segment到新的ssthresh，在这时拥塞避免算法开始接管。</p>

<h3 id="32-fast-retransmitfast-recovery">3.2 Fast Retransmit/Fast Recovery</h3>

<p>当乱序的分片到达的时候，TCP接收端应该发送duplicate ack，通知发送方接收到的分片乱序以及应该收到的序列号。</p>

<p>从发送端的视角，当收到重复ack的时候，可能是几个网络原因：</p>

<ol>
  <li>分片丢失</li>
  <li>网络把数据分片重新排序</li>
  <li>ack或网络分片的复制（replication）</li>
</ol>

<p>In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in (all or part) of a gap in the sequence space.</p>

<p>TCP发送方基于到来的重复ack，使用快速重传算法来探测和修复丢包。
快速重传算法使用3个重复ack作为直接启动的信号而不需要等重传计时器过时。
在快速是重传算法发送了可能丢失的分片后，快速恢复算法接管新数据的传输，直到一个非重复ack的到来。
不执行慢启动的理由是重复ack的收到不仅表明分片丢失，也表明分片很可能已经离开了网络（在缓冲区中）</p>

<p>快速重传和快速恢复算法一起实现如下：</p>

<ol>
  <li>
    <p>在发送方收到第一个和第二个重复ack时，应该发送一个之前未发送数据的分片<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup></p>
  </li>
  <li>
    <p>当收到第三个重复的ack时，一个TCP必须把ssthresh设置为不超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>
  </li>
  <li>
    <p>开始在SND.UNA<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup>丢失的分片必须被重传，并且cwnd设置为<code class="language-plaintext highlighter-rouge">ssthresh + 3*SMSS</code>。<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup></p>
  </li>
  <li>
    <p>对于每一个额外的重复ACK（在第三个之后）cwnd必须增加SMSS。<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup></p>
  </li>
  <li>
    <p>当之前未发送的数据可用，并且cwnd新值和接收方窗口允许时，TCP应该发送<code class="language-plaintext highlighter-rouge">1*SMSS</code>bytes数据。</p>
  </li>
  <li>
    <p>当下一个ack到达并确认之前未确认的数据时，TCP必须将cwnd设置为ssthresh（set by step-2）<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup><sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup></p>
  </li>
</ol>

<p>众所周知，这个算法通常无法有效地从单个数据包飞行中的多次丢失中恢复。</p>

<h2 id="4-additional-considerations">4. Additional Considerations</h2>

<h3 id="41-restarting-idle-connections">4.1. Restarting Idle Connections</h3>

<h3 id="42-generating-acknowledgments">4.2. Generating Acknowledgments</h3>

<h3 id="43-loss-recovery-mechanisms">4.3. Loss Recovery Mechanisms</h3>

<h2 id="5--security-considerations">5.  Security Considerations</h2>

<p>这个per是什么鬼，还有这么用的，啥意思？并且TCP发送方不能改变cwnd来反映这两个分片。记住，使用SACK的发送方不能发送新数据除非到来的重复ack包含新的SACK信息</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>最大分片的负载大小，不包括TCP/IP headers。这个数值基于MTU、PMTUD、RMSS或者其他因素。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>由TCP MSS option决定，如果没有设置，则为536 bytes（TCP安全最大值） <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>限制TCP发送数据的状态变量，TCP发送数据的大小受cwnd和rwnd的双重限制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>发送方的三次握手后的拥塞窗口 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>在重传计时器发现包的丢失时的拥塞窗口的大小 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>在一个慢启动算法里，在一段停当（idle）的时间后，启动重传时的拥塞窗口大小 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>已发送，但尚未被ack确认的数据数量，也就是“飞行中“的数据包 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Slow Start Threshold <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>这么做是为了增加鲁棒性针对一些行为不端的接收方方通过同一分片的多次的ACK响应（ACK Division），每个ack仅是数据的一部分，每个ACK都会使得发送方窗口增加SMSS，结果使得发送方使用过大的发送窗口 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>round-trip time, RTT <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>包含当前允许发送的最大数据的分片，比如包含SMSS bytes的数据 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>当cwnd非常大的时候，比如比<code class="language-plaintext highlighter-rouge">SMSS*SMSS</code> 还要大的时候，应该算为至少1 byte；同时更旧实现会增加一个额外常数，但这是错误的会导致性能损失 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>缺点是需要维护一个额外的状态变量 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver’s advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Sender Unknowledge <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>这人为地夸大了cwnd已经离开网络被接收方缓存3个分片 <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>这人为地夸大了cwnd为了反映离开网络的额外分片。为了防止这一机制被接收方滥用，可以限制cwnd扩大的次数为未接收分片的数量。Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>这被叫做窗口紧缩（deflating） <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>这个ack应该是由step-3的重传引发的。除此之外，这个ack应该确认所有在丢失的分片和收到的第三个重复的分片发送的所有中间分片，如果中间没有丢失 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;net&quot;]" /><summary type="html"><![CDATA[This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04]]></summary></entry></feed>