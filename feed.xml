<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-10-26T09:40:49+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">图理论基础</title><link href="/graph/algs/2022/10/09/graph-theory-basic.html" rel="alternate" type="text/html" title="图理论基础" /><published>2022-10-09T00:00:00+08:00</published><updated>2022-10-09T00:00:00+08:00</updated><id>/graph/algs/2022/10/09/graph-theory-basic</id><content type="html" xml:base="/graph/algs/2022/10/09/graph-theory-basic.html"><![CDATA[<p>假设图 G = {V, E}， V是顶点集，E是边集</p>

<ol>
  <li>
    <p>边，无向边（edge）</p>
  </li>
  <li>
    <p>有向边（arc）
tail(起点) -&gt; head（终点）</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>|V</td>
          <td>，点的个数，图的阶（order）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>无根树，连通无向图</li>
</ol>]]></content><author><name></name></author><category term="[&quot;graph&quot;, &quot;algs&quot;]" /><summary type="html"><![CDATA[假设图 G = {V, E}， V是顶点集，E是边集]]></summary></entry><entry><title type="html">Linux上把大文件夹移动到其他存储设备上来释放空间</title><link href="/linux/fs/2022/09/10/mv-large-size-dir-to-another-dev.html" rel="alternate" type="text/html" title="Linux上把大文件夹移动到其他存储设备上来释放空间" /><published>2022-09-10T00:00:00+08:00</published><updated>2022-09-10T00:00:00+08:00</updated><id>/linux/fs/2022/09/10/mv-large-size-dir-to-another-dev</id><content type="html" xml:base="/linux/fs/2022/09/10/mv-large-size-dir-to-another-dev.html"><![CDATA[<h2 id="问题背景">问题背景</h2>

<p>一个常见的问题是发现某个文件夹比如<code class="language-plaintext highlighter-rouge">/var</code>, <code class="language-plaintext highlighter-rouge">/opt</code> 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。</p>

<h2 id="约定">约定</h2>

<p>不妨假设根系统<code class="language-plaintext highlighter-rouge">/</code>挂载在磁盘分区<code class="language-plaintext highlighter-rouge">sda4</code>，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为<code class="language-plaintext highlighter-rouge">sdb</code>。</p>

<h2 id="思路1">思路1<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2>

<p>一个体面的思路是在<code class="language-plaintext highlighter-rouge">sdb</code>上创建一个分区，假设为<code class="language-plaintext highlighter-rouge">sdb1</code>，创建LargeDir的同级根目录LargeDir2，把<code class="language-plaintext highlighter-rouge">sdb1</code>挂载到LargeDir2，把LargeDir的内容复制到LargeDir2</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>LargeDir2
mount /dev/sdb1 LargeDir2
rsync <span class="nt">-a</span> LargeDir/ LargeDir2
</code></pre></div></div>

<p>在文件系统表单<code class="language-plaintext highlighter-rouge">/etc/fstab</code>里添加对应项,比如
<code class="language-plaintext highlighter-rouge">/dev/sdb1    LargeDir    ext4    defaults      2 2</code></p>

<p>重启后生效，但是这个思路是后一个文件系统隐藏了前一个文件系统的子目录，<strong>如何删除原文件系统的子目录内容呢？</strong></p>

<p>由于<strong>Linux允许同一文件系统有多个挂载点</strong>，所以只需要把<code class="language-plaintext highlighter-rouge">sda4</code>再次挂载到一个新的目录，然后就可以找到原LargeDir，然后删除。</p>

<h2 id="思路2">思路2<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2>

<p>重启进入单用户模式，安全移动内容，然后删除，然后重新命名回来</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://askubuntu.com/questions/39536/how-can-i-store-var-on-a-separate-partition <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://www.suse.com/support/kb/doc/?id=000018399 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;Linux&quot;, &quot;FS&quot;]" /><summary type="html"><![CDATA[问题背景]]></summary></entry><entry><title type="html">kernel crash dump</title><link href="/kernel/2022/09/01/kernel-crash-dump.html" rel="alternate" type="text/html" title="kernel crash dump" /><published>2022-09-01T00:00:00+08:00</published><updated>2022-09-01T00:00:00+08:00</updated><id>/kernel/2022/09/01/kernel-crash-dump</id><content type="html" xml:base="/kernel/2022/09/01/kernel-crash-dump.html"><![CDATA[<h2 id="ubuntu">Ubuntu</h2>

<p><a href="https://ubuntu.com/server/docs/kernel-crash-dump">install linux-crashdump</a></p>

<h2 id="dump-output">Dump Output</h2>

<p><code class="language-plaintext highlighter-rouge">alias crash="crash /usr/lib/debug/boot/vmlinux-$(uname -r)"</code></p>

<p><code class="language-plaintext highlighter-rouge">crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;</code></p>

<p>bt: backtrace
log: kernel log</p>]]></content><author><name></name></author><category term="[&quot;Kernel&quot;]" /><summary type="html"><![CDATA[Ubuntu]]></summary></entry><entry><title type="html">Compile Linux Kernel</title><link href="/linux/kernel/2022/08/26/compile-linux-kernel.html" rel="alternate" type="text/html" title="Compile Linux Kernel" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/linux/kernel/2022/08/26/compile-linux-kernel</id><content type="html" xml:base="/linux/kernel/2022/08/26/compile-linux-kernel.html"><![CDATA[<p>编译实践1：
学习Linux内核模块开发，需要增加一个<code class="language-plaintext highlighter-rouge">FORCE_UNLOADING</code> feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。</p>

<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"><strong>Linux上游源代码（git地址在其页面下方）</strong></a></p>

<p><strong>默认环境</strong>
当前目录： kernel源目录</p>

<h2 id="ubuntu">Ubuntu</h2>

<p>注意源文件的下载，不要在系统目录比如<code class="language-plaintext highlighter-rouge">/usr/src</code>下进行，而要在用户空间内进行，而<code class="language-plaintext highlighter-rouge">apt source</code>，<code class="language-plaintext highlighter-rouge">apt-get source</code>, 不需要也不能使用<code class="language-plaintext highlighter-rouge">sudo</code>, 会错误得造成源文件的用户组变为root。对于&gt;= 20.04,没有官方更新的wiki讲如何使用debian/rules，直接从linux上游源代码处获取。</p>

<p>= 18.04</p>

<p>参考<a href="https://askubuntu.com/questions/1085411/unable-to-follow-kernel-buildyourownkernel">这篇文章</a></p>

<p>= 19.04</p>

<p>参考<a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">官方wiki</a></p>

<p>= 20.04 (or maybe upper than it)</p>

<p>参考<a href="https://discourse.ubuntu.com/t/how-to-compile-kernel-in-ubuntu-20-04/20268/10">这篇文章</a></p>

<ol>
  <li>
    <p>下载源代码</p>
  </li>
  <li>
    <p>安装依赖<code class="language-plaintext highlighter-rouge">sudo apt install asciidoc autoconf bc binutils-dev bison build-essential crash dkms fakeroot flex gawk gcc kernel-wedge kexec-tools libelf-dev libiberty-dev libncurses5-dev libncurses-dev libssl-dev libudev-dev makedumpfile openssl pciutils-dev</code></p>

    <p>(<code class="language-plaintext highlighter-rouge">pciutils-dev</code> is replaced by <code class="language-plaintext highlighter-rouge">libpci-dev</code> in the later version)</p>
  </li>
  <li>
    <p>配置参考下面tips</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">make -jn deb-pkg</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cd .. &amp;&amp; sudo apt ./linux-*.deb</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sudo update-grub</code></p>
  </li>
</ol>

<p><strong>Tips:</strong></p>

<ol>
  <li>
    <p>Linux 68%的代码是驱动相关代码，当然大部分的编译时间也是在编译驱动上，而这一部分也是容易出问题，往往花了几个小时编译发现，后来发现在这里出了错误，这就很难受，需要提前仔细配置。个人经验是不使用 <code class="language-plaintext highlighter-rouge">/boot/config-`uname -r` </code> 作为初始配置，而是使用<code class="language-plaintext highlighter-rouge">make localmodconfig</code> 创建初始配置:<code class="language-plaintext highlighter-rouge">.config</code>文件，使用默认的配置，确保驱动的编译不出问题。然后使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>(shell text) or <code class="language-plaintext highlighter-rouge">make xconfig</code>(qt5 gui) 配置内核其他部分。</p>
  </li>
  <li>
    <p>make 使用<code class="language-plaintext highlighter-rouge">-j</code>启用多核编译很重要，如果宿主机器在编译的同时需要运行其他任务，建议少用一个核心，避免机器down掉(然后比如当前用户直接被强制logout)。</p>
  </li>
  <li>
    <p>如果make过程中因为什么原因中途停掉了，可以再次启动，但是第一次会报错: <code class="language-plaintext highlighter-rouge">"dpkg-source: unrepresentable changes to source"</code>, 只要把相关报错文件删除掉重新运行即可。</p>
  </li>
  <li>
    <p>&gt;= 20.04, 可能需要的额外依赖包:</p>

    <p>dwarves # tmp_vmlinux.btf: pahole (pahole) is not available</p>
  </li>
</ol>

<h2 id="select-kernel">Select Kernel</h2>

<p>重启的时候按住<code class="language-plaintext highlighter-rouge">shift</code>进入grup界面，选择需要的版本内核启动。
修改默认启动内核，参考<a href="https://support.huaweicloud.com/intl/en-us/trouble-ecs/ecs_trouble_0327.html">华为云的这篇文章</a>和<a href="https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version/1393019#1393019">askubuntu的这个回答</a>
修改配置文件<code class="language-plaintext highlighter-rouge">/etc/default/grub</code>的 <code class="language-plaintext highlighter-rouge">GRUB_DEFAULT</code> 的值为启动项的序号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0，正常启动
1&gt;y， 高级启动项，y start from 0
</code></pre></div></div>

<p>查看高级启动项的序号(Ubuntu为例)：
<code class="language-plaintext highlighter-rouge">sudo grub-mkconfig | grep -iE "menuentry 'Ubuntu, with Linux" | awk '{print i++ " : "$1, $2, $3, $4, $5, $6, $7}'</code>
不要忘记最后运行<code class="language-plaintext highlighter-rouge">sudo update-grup</code>来更新配置。</p>]]></content><author><name></name></author><category term="[&quot;Linux&quot;, &quot;Kernel&quot;]" /><summary type="html"><![CDATA[编译实践1： 学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。]]></summary></entry><entry><title type="html">Packetization Layer Path MTU Discovery for Datagram Transports</title><link href="/ietf%20rfcs/2022/08/16/ietf_rfc_8899.html" rel="alternate" type="text/html" title="Packetization Layer Path MTU Discovery for Datagram Transports" /><published>2022-08-16T00:00:00+08:00</published><updated>2022-08-16T00:00:00+08:00</updated><id>/ietf%20rfcs/2022/08/16/ietf_rfc_8899</id><content type="html" xml:base="/ietf%20rfcs/2022/08/16/ietf_rfc_8899.html"><![CDATA[<h2 id="abstract">Abstract</h2>

<p>补充了在UDP上实现PMTUD的指南</p>

<h2 id="2-terminology">2. Terminology</h2>]]></content><author><name></name></author><category term="[&quot;IETF RFCs&quot;]" /><summary type="html"><![CDATA[Abstract]]></summary></entry><entry><title type="html">TCP Congestion Control</title><link href="/ietf%20rfcs/2022/08/07/ietf_rfc_5681_obs2581.html" rel="alternate" type="text/html" title="TCP Congestion Control" /><published>2022-08-07T00:00:00+08:00</published><updated>2022-08-07T00:00:00+08:00</updated><id>/ietf%20rfcs/2022/08/07/ietf_rfc_5681_obs2581</id><content type="html" xml:base="/ietf%20rfcs/2022/08/07/ietf_rfc_5681_obs2581.html"><![CDATA[<p>This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04</p>

<h2 id="1-introduction">1. Introduction</h2>

<p>介绍TCP四种交织在一起的拥塞控制算法：</p>

<ol>
  <li>慢启动（slow start）</li>
  <li>拥塞避免（congestion avoidance）</li>
  <li>快速重传（fast retransmit）</li>
  <li>快速恢复（fast recovery）</li>
</ol>

<p>TCP链接需要做什么，在一个长时间停当后，以及确定和澄清一些TCP ACK生成的问题</p>

<h2 id="2-definition">2. Definition</h2>

<p>发送方最大分片大小（Sender Maximum Segment Size, SMSS）<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>接收方最大分片大小（Receiver Maximum Segment Size, RMSS）<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>最大段（Full Sized Segment）</p>

<p>接收方窗口（Receiver Window, rwnd）</p>

<p>拥塞窗口（Congestion Window, cwnd）<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>初始窗口（Initial Window, IW）<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>丢失窗口（Lost Window, LW）<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<p>重启窗口（Restart Window, RW）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>飞行尺寸（FlightSize）<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup></p>

<p>重复确认（Duplicate Acknowledgement）:</p>

<p>一个确认被认为是重复的如果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a. ack的接收者有未完成的（outstanding）数据

b. 到来的ack没有携带数据

c. SYN 和 FIN的标志都没有被设置

d. ack number等于链接最大的ack number

e. 到来的ack广告的窗口大小等于上一次ack广告的窗口大小

f: 使用SACKs（Selective Acknownledgements）的TCP会利用SACK信息判断ack是否重复
</code></pre></div></div>

<h2 id="3-congestion-control-algorithm">3. Congestion Control Algorithm</h2>

<p>本文提到的拥塞控制算法使用丢失或者ECN标记作为拥塞发生的信号</p>

<h3 id="31-slow-start-and-congestion-avoidance">3.1 Slow Start and Congestion Avoidance</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if SMSS &gt; 2190 (bytes):
  IW &lt;= 2*SMSS and IM &lt;= 2*SS(Segment Size)
else if 1095 &lt; SMSS &lt;= 2190:
  IW &lt;= 3*SMSS and IW &lt;= 3*SS
ekse:
  IW &lt;= 4*SMSS and IW&lt;= 4*SS
</code></pre></div></div>

<p>建立TCP链接的两个ACK不能用来增加cwnd的大小。等等IW设置详见<a href="https://datatracker.ietf.org/doc/html/rfc3390">RFC3390</a>。</p>

<p>ssthresh的初始值可以任意高<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>
慢启动算法启动标准：<code class="language-plaintext highlighter-rouge">cwnd &lt; ssthresh</code>
拥塞避免算法标准：<code class="language-plaintext highlighter-rouge">cwnd &gt; ssthresh</code>
二选一都可以：<code class="language-plaintext highlighter-rouge">cwnd = ssthresh</code></p>

<p>在慢启动的时候，每次ACK，cwnd的增加不超过SMSS bytes，当cwnd超过<code class="language-plaintext highlighter-rouge">ssthresh</code>或者拥塞重新被检测到的时候，退出慢启动。
传统TCP实现每次正好增加SMSS，但是我们推荐使用： <code class="language-plaintext highlighter-rouge">cwnd += min(N, SMSS)</code>,N是被新的ACK新确认的未确认数据的大小。<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">9</a></sup></p>

<p>在拥塞避免的时候，每过一个往返时间<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">10</a></sup>，cwnd可以增加一个full-sized segment<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup>大小；
应该（SHOULD）每一个来回的时间，增加<code class="language-plaintext highlighter-rouge">min(N, SMSS)</code>
但是不管怎样，每次cwnd不能增加超过SMSS。</p>

<p>或者每当收到一个不重复的ACK数据报，就增加一个<code class="language-plaintext highlighter-rouge">SMSS * SMSS / cwnd</code>大小<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">12</a></sup>；
还有的方法是增加新的被ACK确认的数据大小，直到cwnd增加到SMSS。<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">13</a></sup></p>

<p>同样地，当检测到拥塞发生的时候，算法终止。</p>

<p>ssthresh不应该超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>

<p>并且，一旦超时，cwnd必须被设为不超过LW，也就是1 full-sized segment。因此在重传被丢弃的包分片后，发送方使用慢启动来增加窗口的大小，从1 full-sized segment到新的ssthresh，在这时拥塞避免算法开始接管。</p>

<h3 id="32-fast-retransmitfast-recovery">3.2 Fast Retransmit/Fast Recovery</h3>

<p>当乱序的分片到达的时候，TCP接收端应该发送duplicate ack，通知发送方接收到的分片乱序以及应该收到的序列号。</p>

<p>从发送端的视角，当收到重复ack的时候，可能是几个网络原因：</p>

<ol>
  <li>分片丢失</li>
  <li>网络把数据分片重新排序</li>
  <li>ack或网络分片的复制（replication）</li>
</ol>

<p>In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in (all or part) of a gap in the sequence space.</p>

<p>TCP发送方基于到来的重复ack，使用快速重传算法来探测和修复丢包。
快速重传算法使用3个重复ack作为直接启动的信号而不需要等重传计时器过时。
在快速是重传算法发送了可能丢失的分片后，快速恢复算法接管新数据的传输，直到一个非重复ack的到来。
不执行慢启动的理由是重复ack的收到不仅表明分片丢失，也表明分片很可能已经离开了网络（在缓冲区中）</p>

<p>快速重传和快速恢复算法一起实现如下：</p>

<ol>
  <li>
    <p>在发送方收到第一个和第二个重复ack时，应该发送一个之前未发送数据的分片<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup></p>
  </li>
  <li>
    <p>当收到第三个重复的ack时，一个TCP必须把ssthresh设置为不超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>
  </li>
  <li>
    <p>开始在SND.UNA<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup>丢失的分片必须被重传，并且cwnd设置为<code class="language-plaintext highlighter-rouge">ssthresh + 3*SMSS</code>。<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup></p>
  </li>
  <li>
    <p>对于每一个额外的重复ACK（在第三个之后）cwnd必须增加SMSS。<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup></p>
  </li>
  <li>
    <p>当之前未发送的数据可用，并且cwnd新值和接收方窗口允许时，TCP应该发送<code class="language-plaintext highlighter-rouge">1*SMSS</code>bytes数据。</p>
  </li>
  <li>
    <p>当下一个ack到达并确认之前未确认的数据时，TCP必须将cwnd设置为ssthresh（set by step-2）<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup><sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup></p>
  </li>
</ol>

<p>众所周知，这个算法通常无法有效地从单个数据包飞行中的多次丢失中恢复。</p>

<h2 id="4-additional-considerations">4. Additional Considerations</h2>

<h3 id="41-restarting-idle-connections">4.1. Restarting Idle Connections</h3>

<h3 id="42-generating-acknowledgments">4.2. Generating Acknowledgments</h3>

<h3 id="43-loss-recovery-mechanisms">4.3. Loss Recovery Mechanisms</h3>

<h2 id="5--security-considerations">5.  Security Considerations</h2>

<p>这个per是什么鬼，还有这么用的，啥意思？并且TCP发送方不能改变cwnd来反映这两个分片。记住，使用SACK的发送方不能发送新数据除非到来的重复ack包含新的SACK信息</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>最大分片的负载大小，不包括TCP/IP headers。这个数值基于MTU、PMTUD、RMSS或者其他因素。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>由TCP MSS option决定，如果没有设置，则为536 bytes（TCP安全最大值） <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>限制TCP发送数据的状态变量，TCP发送数据的大小受cwnd和rwnd的双重限制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>发送方的三次握手后的拥塞窗口 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>在重传计时器发现包的丢失时的拥塞窗口的大小 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>在一个慢启动算法里，在一段停当（idle）的时间后，启动重传时的拥塞窗口大小 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>已发送，但尚未被ack确认的数据数量，也就是“飞行中“的数据包 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Slow Start Threshold <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>这么做是为了增加鲁棒性针对一些行为不端的接收方方通过同一分片的多次的ACK响应（ACK Division），每个ack仅是数据的一部分，每个ACK都会使得发送方窗口增加SMSS，结果使得发送方使用过大的发送窗口 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>round-trip time, RTT <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>包含当前允许发送的最大数据的分片，比如包含SMSS bytes的数据 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>当cwnd非常大的时候，比如比<code class="language-plaintext highlighter-rouge">SMSS*SMSS</code> 还要大的时候，应该算为至少1 byte；同时更旧实现会增加一个额外常数，但这是错误的会导致性能损失 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>缺点是需要维护一个额外的状态变量 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver’s advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Sender Unknowledge <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>这人为地夸大了cwnd已经离开网络被接收方缓存3个分片 <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>这人为地夸大了cwnd为了反映离开网络的额外分片。为了防止这一机制被接收方滥用，可以限制cwnd扩大的次数为未接收分片的数量。Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>这被叫做窗口紧缩（deflating） <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>这个ack应该是由step-3的重传引发的。除此之外，这个ack应该确认所有在丢失的分片和收到的第三个重复的分片发送的所有中间分片，如果中间没有丢失 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;IETF RFCs&quot;]" /><summary type="html"><![CDATA[This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04]]></summary></entry><entry><title type="html">A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP</title><link href="/ietf%20rfcs/2022/08/07/ietf_rfc_6675_obs3517.html" rel="alternate" type="text/html" title="A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP" /><published>2022-08-07T00:00:00+08:00</published><updated>2022-08-07T00:00:00+08:00</updated><id>/ietf%20rfcs/2022/08/07/ietf_rfc_6675_obs3517</id><content type="html" xml:base="/ietf%20rfcs/2022/08/07/ietf_rfc_6675_obs3517.html"><![CDATA[<p>This RFC is release 2012.08 obsoletes RFC3517 which is released on 2003.04</p>]]></content><author><name></name></author><category term="[&quot;IETF RFCs&quot;]" /><summary type="html"><![CDATA[This RFC is release 2012.08 obsoletes RFC3517 which is released on 2003.04]]></summary></entry><entry><title type="html">Path MTU Discovery</title><link href="/ietf%20rfcs/2022/08/06/ietf_rfc_1191_obs1063.html" rel="alternate" type="text/html" title="Path MTU Discovery" /><published>2022-08-06T00:00:00+08:00</published><updated>2022-08-06T00:00:00+08:00</updated><id>/ietf%20rfcs/2022/08/06/ietf_rfc_1191_obs1063</id><content type="html" xml:base="/ietf%20rfcs/2022/08/06/ietf_rfc_1191_obs1063.html"><![CDATA[<p>This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.07</p>

<h2 id="1-protocol-overview">1. Protocol Overview</h2>

<p>通过设置IP header 的 <code class="language-plaintext highlighter-rouge">DF</code> bit 来动态发现一个路径的PMTU<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:
以第一跳<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的MTU为初始值(已知的)，如果收到ICMP code 3-4<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>由于网络拓扑会随时间改变，PMTU的减少，仍然可以通过DTB meessage得知，只要DF bit 被设置，而PMTU的增加，可以通过主机上的定期任务<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>来检测。</p>

<h2 id="2-host主机specification">2. Host（主机）specification</h2>

<p>当Host探索PMTU的减少时，速度必须尽可能地快，而探索PMTU的增加时，探索的时间间隔不能频繁（infrequent）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>。</p>

<p>更具体地，当探索PMTU的增加时，增加失败的间隔不少于5min，增加成功的间隔不小于1min，建议的间隔分别是是10min和2min。</p>

<p>Host必须向下兼容不包含next-hop MTU的旧风格的DTB message<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>。</p>

<p>Host估值的PMTU应该不低于68 octets<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup></p>

<h3 id="3-tcp-mss-option">3. TCP MSS<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup> Option</h3>

<p>除非被允许，Host进行PMTUD时发送IP包的长度不应该超过 536 + 40 = 576 octets。</p>

<p>而很多TCP实现总是设置MSS选项并且将值设为536，如果目的连接是非本地的。这种行为是对的，因为互联网上到处都是不遵守规则，发送超过576 octets<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>的的host。</p>

<p>一个host可能根据MTU设置MMS，这不应该对PMTUD造成问题，并且可以劝阻同层发送巨大的数据报</p>

<h2 id="4-router路由器-specification">4. Router（路由器） specification</h2>

<p>DTB message(ICMP code 3-4) format, 提供额外的origin header，next-hop MTU 不赘叙</p>

<h2 id="5-处理旧风格的message">5. 处理旧风格的message</h2>

<p>即如果message本身没有提供PMTU的信息。</p>

<p>最简单的方式是取当前估计的PMTU与576之间的最小值，并且取消<code class="language-plaintext highlighter-rouge">DF</code>bit。</p>

<p>更复杂的方式需要“搜索”准确的PMTU估计值。有几个可能方法，它们根据一个之前的估计值产生一个新的估计值。</p>

<p>比如乘以一个常数比如0.75，但这样收敛又慢，产生的估计值又低于实际的值。所以不推荐。</p>

<p>再比如进行二分搜索，它收敛快一点，但从FDDI<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup> MTU落到Ethernet<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup> MTU仍然需要4-5步，而有一个非常的劣势是识别数据报到达另一端的时间是一个复杂实现。因此也不推荐。</p>

<p>有一个看起来效果似乎很好方法是比起盲搜，搜索一组可能出现的值，因为设计者们倾向于用类似的方式选择MTUs,使用其中的最小值<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>。使用下表的搜索，</p>

<p>Table Common MTUs in the Internet:</p>

<table>
  <thead>
    <tr>
      <th>Plateau</th>
      <th>MTU</th>
      <th>Comments</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>65535</td>
      <td>65535</td>
      <td>Official maximum MTU</td>
      <td>RFC 791</td>
    </tr>
    <tr>
      <td>32004</td>
      <td>65535</td>
      <td>Hyperchannel</td>
      <td>RFC 1044</td>
    </tr>
    <tr>
      <td>17914</td>
      <td>17914</td>
      <td>16Mb IBM Token Ring</td>
      <td> </td>
    </tr>
    <tr>
      <td>8166</td>
      <td>8166</td>
      <td>IEEE 802.4</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>4464</td>
      <td>IEEE 802.5 (4Mb max)</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td>4352</td>
      <td>4352</td>
      <td>FDDI (Revised)</td>
      <td>RFC 1188</td>
    </tr>
    <tr>
      <td> </td>
      <td>2048</td>
      <td>Wideband Network</td>
      <td>RFC 907</td>
    </tr>
    <tr>
      <td>2002</td>
      <td>2002</td>
      <td>IEEE 802.5 (4Mb recommended)</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>1536</td>
      <td>Exp. Ethernet Nets</td>
      <td>RFC 895</td>
    </tr>
    <tr>
      <td> </td>
      <td>1500</td>
      <td>Ethernet Networks</td>
      <td>RFC 894</td>
    </tr>
    <tr>
      <td> </td>
      <td>1500</td>
      <td>Point-to-Point (default)</td>
      <td>RFC 1134</td>
    </tr>
    <tr>
      <td>1492</td>
      <td>1492</td>
      <td>IEEE 802.3</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>1006</td>
      <td>SLIP</td>
      <td>RFC 1055</td>
    </tr>
    <tr>
      <td>1006</td>
      <td>1006</td>
      <td>ARPANET</td>
      <td>BBN 1822</td>
    </tr>
    <tr>
      <td> </td>
      <td>576</td>
      <td>X.25 Networks</td>
      <td>RFC 877</td>
    </tr>
    <tr>
      <td> </td>
      <td>544</td>
      <td>DEC IP Portal</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>512</td>
      <td>NETBIOS</td>
      <td>RFC 1088</td>
    </tr>
    <tr>
      <td> </td>
      <td>508</td>
      <td>IEEE 802/Source-Rt Bridge</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td>508</td>
      <td>508</td>
      <td>ARCNET</td>
      <td>RFC 1051</td>
    </tr>
    <tr>
      <td>296</td>
      <td>296</td>
      <td>Point-to-Point (low delay)</td>
      <td>RFC 1144</td>
    </tr>
    <tr>
      <td>68</td>
      <td>68</td>
      <td>Official minimum MTU</td>
      <td>RFC 791</td>
    </tr>
  </tbody>
</table>

<p>使用这个表的收敛性最坏情况也比二分搜索相当，因为plateau几乎是2的幂，而如果值不在表中，被低估的值也不会超过2倍。</p>

<p>所有ICMP code 3 都包含源IP header，可以直接使用其中的Total Length字段的值作为输入，生成下一个估计值<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup>。</p>

<p>该表仅是建议参考，应该保持更新，添加一些2的幂加40（IP header + TCP header）的项，作为过渡，也可以包含稍微比2的幂稍小一些的项。但不管怎样，plateau的数量不应该太多，而实现者应该给无源代码客户提供一种方便的更新表值的工具<sup id="fnref:23" role="doc-noteref"><a href="#fn:23" class="footnote" rel="footnote">15</a></sup></p>

<h2 id="6-host-implementation">6. Host implementation</h2>

<p>提供一组关于PMTUD在主机软件上实现的建议。</p>

<h3 id="61-layering分层">6.1 Layering（分层）</h3>

<p>IP层应该存储PMTU信息，并且ICMP层应该处理DTB message。而分包层<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">16</a></sup>应该能反映PMTU的变化，通过改变发送数据报的大小，并且必须能指定<code class="language-plaintext highlighter-rouge">DF</code> bit。我们不希望IP层简单地为每个包设定<code class="language-plaintext highlighter-rouge">DF</code> bit，因为分包层可能无法改变它的数据报的大小<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">17</a></sup></p>

<h3 id="62-storing-pmtu-information">6.2 Storing PMTU Information</h3>

<p>存储信息的明显位置是将其作为一个字段，存储在路由表项中。一个主机不会为每一个目标地址有一个路由信息，但应该能为每个活跃目标地址缓存路由<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">18</a></sup>。</p>

<p>使用同一路径的所有的分包层都应该被通知，如果该路径PMTU减少了。这种通知应该区别于普通的包的丢失。</p>

<h3 id="63-purging-stale-pmtu-information">6.3 Purging stale PMTU information</h3>

<p>由于没有机制能实现发现当前的使用的PMTU因为它太小而过时了，所以需要一个实现能够老化缓存的值，以便有机会发现的新的更大的PMTU<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">19</a></sup>。而上层协议绝对不能因为PMTU的增加而重发，因为这没有包的丢失。</p>

<p>一个实现PMTU老化的方法是给路由表项添加时间戳字段，这个字段初始化为一个保留值，表明这个PMTU没有改变。当PMTU减少时，时间戳更新为当前时间。计时器驱动的程序扫描整个路由表，当一个表项的时间戳不是保留值时，如果超时了，则：</p>

<ol>
  <li>将估计的PMTU设置为关联的第一跳的MTU</li>
  <li>使用这个路由的分包层被通知PMTU的增加</li>
</ol>

<p>PMTU估计值可能从路由表消失,如果路由表项被移除掉<sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">20</a></sup>，一个解决方法是当ICMP 重定向消息导致路有变化或者当路由被删除的时候通知分包层</p>

<h3 id="64-tcp-layer-actions">6.4 TCP layer actions</h3>

<p>TCP数据报的大小受PMTU和MSS的双重制约。</p>

<p>当DTB message到达的时候，特定连接的特定于DTB message的数据报立刻重传，当然需要使用新的PMTU。</p>

<p>现代TCP实现包含拥塞控制和慢启动算法，DTB message不应该影响拥塞窗口，但是应该触发慢启动机制<sup id="fnref:20" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">21</a></sup>。</p>

<p>TCP的性能可能会下降，如果发送方的最大窗口大小<sup id="fnref:21" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">22</a></sup>不是精确的分片（segment）大小的几倍。如果使用了PMTUD，分片的大小发生改变，就会出现这种情况。因此应该根据新PMTU的大小调整最大窗口大小，来适应新的分片的大小，使保持一个整数倍的关系。</p>

<p>PMTUD不应该影响MSS选项的数值。</p>

<h3 id="65-issues-for-other-transport-protocols">6.5. Issues for other transport protocols</h3>

<p>像原始NFS协议这种如果有难处，还是分片传输吧。</p>

<h3 id="66-management-interface">6.6. Management interface</h3>

<p>一个PMTUD的实现应该为系统工具程序提供：</p>

<ol>
  <li>指定不在给定路由上做PMTUD<sup id="fnref:22" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">23</a></sup></li>
  <li>改变给定路由的PMTU</li>
  <li>改变PMTU老化的时间间隔</li>
</ol>

<h2 id="7-likely-values-for-path-mtus">7. Likely values for Path MTUs</h2>

<p>合并到第五章</p>

<h2 id="8-security-considerations">8. Security considerations</h2>

<p>通过发送恶意DTB message可以实现两种DOS攻击：</p>

<ol>
  <li>提供过于小的PMTU，使得连接变慢</li>
  <li>提供过于大的PMTU，这可能会造成暂时的阻塞，因为受害者的包会被路由器丢弃，在一个往返的时间里，主机会发现错误，但频繁的重复攻击会导致大量的数据报被丢弃。而一个主机<strong>永远不能</strong>根据DTB message提供的PMTU来提高估计值的上限，因为这会使得面对这种攻击变得很脆弱。</li>
</ol>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Path MTU <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>First Hop <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Fragmentation required, and DF flag set, carrying next-hop MTU and IP header and first 8 bytes of original datagram’s data <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>也就是PTB(Packet Too Big) message，或者DTB(Datagram Too Big) message <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>发送更高的PMTU假设的数据包，看是否能通过，大多数情况下PMTU不会改变，因此不应该太频繁地启用。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>因为需要发送比当前估计的PMTU更大的数据报，并且PMTU不太可能增加 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>可以通过检测next-hop MTU字段是否为0，来识别旧风格的DTB，根据ICMP的规定，未使用的字段必须为0 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>1 octect = 1 byte in CPU = 8 bit <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>Max Segment Size, IP datagram size minus IP header and TCP header (40 bytes, totally) <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>576 is safe max IP datagram size for TCP, or 536 for MSS <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Fiber Distributed Data Interface, 光纤网，用于校园网、广域网 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>比起FDDI，高带宽效率低，但延迟也低 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>as “plateau” <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>基于4.2BSD实现的路由器会发送错误的Total length，它额外加上了origin header length，而且以octets而不是4xoctets的形式表现 <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:23" role="doc-endnote">
      <p>BSD 派生的Unix内核提供<code class="language-plaintext highlighter-rouge">ioctl</code>来做这件事 <a href="#fnref:23" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>在IP结构里，发送多大的数据报是由IP上层的协议决定的，我们称这样的协议为分包层（Packetization Layer） <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>比如一个内核外的UDP应用, 比如最原始版本的NFS协议，一个跨网络管理文件的系统，这种情况下应该允许分片（fragmentation） <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>这个需求已经被处理ICMP重定向消息的需要强制满足了 <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>这个时间从上一次PMTU不减开始，以10min为标准 <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>这可能发生在ICMP重定向消息或者特定的路由守护进程几分钟后删除了旧的路由信息，还可能是在一个多网卡（multi-homed host）的主机上拓扑的变化可能导致不同网卡的使用 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:20" role="doc-endnote">
      <p>也就是只重传第一个分段，直到收到ACK <a href="#fnref:20" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:21" role="doc-endnote">
      <p>最大窗口区别于拥塞窗口，拥塞窗口的大小总是分片大小的几倍，而最大窗口（<em>send space</em>）在很多系统（比如从4.2BSD衍生出来的）通常是1024 octets的几倍，是固定的 <a href="#fnref:21" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:22" role="doc-endnote">
      <p>可以在路由项上设置一个标志位，当有这个标志位时，<code class="language-plaintext highlighter-rouge">DF</code> bit一定会被清除，不管上层请求是什么 <a href="#fnref:22" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;IETF RFCs&quot;]" /><summary type="html"><![CDATA[This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.07]]></summary></entry><entry><title type="html">C dialect options</title><link href="/c/gcc/2022/08/01/c_dialect_options.html" rel="alternate" type="text/html" title="C dialect options" /><published>2022-08-01T00:00:00+08:00</published><updated>2022-08-01T00:00:00+08:00</updated><id>/c/gcc/2022/08/01/c_dialect_options</id><content type="html" xml:base="/c/gcc/2022/08/01/c_dialect_options.html"><![CDATA[<p>Ref: <a href="https://www.acrc.bris.ac.uk/acrc/RedHat/rhel-gcc-en-4/c-dialect-options.html">1</a>, <a href="https://stackoverflow.com/questions/17206568/what-is-the-difference-between-c-c99-ansi-c-and-gnu-c">2</a></p>

<table>
  <thead>
    <tr>
      <th>ISO C90</th>
      <th>ISO C99</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-ansi, -std=c89, iso9899:1990, (ISO C90)</td>
      <td>-std=c99, iso9899:1999</td>
    </tr>
    <tr>
      <td>-std=iso9899:199409 (ISO C90 as modified in amendment 1)</td>
      <td>-std=gnu99 (iso c99 + gnu extensions, gcc default)</td>
    </tr>
    <tr>
      <td>-std=gnu89 (iso c90 + gnu extensions + some c99 features)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>ISO C11</th>
      <th>ISO C18</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-std=c11</td>
      <td>-std=c17, -std=c18</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>iso9899 (C Lang Spec Number of ISO)</li>
  <li><code class="language-plaintext highlighter-rouge">-ansi</code> for C++ mode means that remove conflics gnu extensions with ISO C++</li>
  <li>The word <code class="language-plaintext highlighter-rouge">ansi</code> means American Nation Standard Institute, c89 means ansi 89 (the first standard version), however c99 is iso 1999.The history is <code class="language-plaintext highlighter-rouge">ansi89 -&gt; iso90(same with ansi89) -&gt; iso99</code>, in other words, iso take the ownership of the C Lang standard from ansi.</li>
  <li>c18 is created on 2017 and released on 2018, so it’s called c17 or c18. It contains no new features, just corrections</li>
</ol>

<h2 id="runtime-environments">Runtime Environments</h2>

<table>
  <thead>
    <tr>
      <th>std</th>
      <th>no_std</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-fhosted (takes place in a hosted env)</td>
      <td>-fno-hosted</td>
    </tr>
    <tr>
      <td>-fno-freestanding</td>
      <td>-ffreestanding</td>
    </tr>
    <tr>
      <td>-fno-builtin, -fno-builtin-&lt;xxx&gt;</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>fno-builtin: Don’t recognize built-in functions that do not begin with <code class="language-plaintext highlighter-rouge">__builtin_</code> as prefix, <code class="language-plaintext highlighter-rouge">__built_in_xxx</code> always existed.</p>
  </li>
  <li>
    <p>fno-builtin-&lt;xxx&gt; such as <code class="language-plaintext highlighter-rouge">-fno-builtin-printf</code>.</p>
  </li>
  <li>
    <p>on <code class="language-plaintext highlighter-rouge">no_std</code> env using <code class="language-plaintext highlighter-rouge">__builtin_xxx</code> instead</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;C&quot;, &quot;GCC&quot;]" /><summary type="html"><![CDATA[Ref: 1, 2]]></summary></entry><entry><title type="html">C/C++ 陷阱</title><link href="/c/c++/2022/04/22/c_trap.html" rel="alternate" type="text/html" title="C/C++ 陷阱" /><published>2022-04-22T00:00:00+08:00</published><updated>2022-04-22T00:00:00+08:00</updated><id>/c/c++/2022/04/22/c_trap</id><content type="html" xml:base="/c/c++/2022/04/22/c_trap.html"><![CDATA[<ol>
  <li>
    <p>变量初始化</p>

    <p>在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据</p>
  </li>
  <li>
    <p>结构体初始化注意要在堆上手动分配内存，否则是栈上的会被回收， 这与Rust使用习惯又不一样</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;C&quot;, &quot;C++&quot;]" /><summary type="html"><![CDATA[变量初始化 在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据]]></summary></entry></feed>