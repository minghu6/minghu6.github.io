<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-10-27T12:30:26+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">图理论基础</title><link href="/algs/2022/10/09/graph-theory-basic.html" rel="alternate" type="text/html" title="图理论基础" /><published>2022-10-09T00:00:00+08:00</published><updated>2022-10-09T00:00:00+08:00</updated><id>/algs/2022/10/09/graph-theory-basic</id><content type="html" xml:base="/algs/2022/10/09/graph-theory-basic.html"><![CDATA[<p>假设图 G = {V, E}， V是顶点集，E是边集</p>

<ol>
  <li>
    <p>边，无向边（edge）</p>
  </li>
  <li>
    <p>有向边（arc）
tail(起点) -&gt; head（终点）</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>|V</td>
          <td>，点的个数，图的阶（order）</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>无根树，连通无向图</li>
</ol>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[假设图 G = {V, E}， V是顶点集，E是边集]]></summary></entry><entry><title type="html">Linux上把大文件夹移动到其他存储设备上来释放空间</title><link href="/os/2022/09/10/mv-large-size-dir-to-another-dev.html" rel="alternate" type="text/html" title="Linux上把大文件夹移动到其他存储设备上来释放空间" /><published>2022-09-10T00:00:00+08:00</published><updated>2022-09-10T00:00:00+08:00</updated><id>/os/2022/09/10/mv-large-size-dir-to-another-dev</id><content type="html" xml:base="/os/2022/09/10/mv-large-size-dir-to-another-dev.html"><![CDATA[<h2 id="问题背景">问题背景</h2>

<p>一个常见的问题是发现某个文件夹比如<code class="language-plaintext highlighter-rouge">/var</code>, <code class="language-plaintext highlighter-rouge">/opt</code> 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。</p>

<h2 id="约定">约定</h2>

<p>不妨假设根系统<code class="language-plaintext highlighter-rouge">/</code>挂载在磁盘分区<code class="language-plaintext highlighter-rouge">sda4</code>，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为<code class="language-plaintext highlighter-rouge">sdb</code>。</p>

<h2 id="思路1">思路1<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></h2>

<p>一个体面的思路是在<code class="language-plaintext highlighter-rouge">sdb</code>上创建一个分区，假设为<code class="language-plaintext highlighter-rouge">sdb1</code>，创建LargeDir的同级根目录LargeDir2，把<code class="language-plaintext highlighter-rouge">sdb1</code>挂载到LargeDir2，把LargeDir的内容复制到LargeDir2</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>LargeDir2
mount /dev/sdb1 LargeDir2
rsync <span class="nt">-a</span> LargeDir/ LargeDir2
</code></pre></div></div>

<p>在文件系统表单<code class="language-plaintext highlighter-rouge">/etc/fstab</code>里添加对应项,比如
<code class="language-plaintext highlighter-rouge">/dev/sdb1    LargeDir    ext4    defaults      2 2</code></p>

<p>重启后生效，但是这个思路是后一个文件系统隐藏了前一个文件系统的子目录，<strong>如何删除原文件系统的子目录内容呢？</strong></p>

<p>由于<strong>Linux允许同一文件系统有多个挂载点</strong>，所以只需要把<code class="language-plaintext highlighter-rouge">sda4</code>再次挂载到一个新的目录，然后就可以找到原LargeDir，然后删除。</p>

<h2 id="思路2">思路2<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></h2>

<p>重启进入单用户模式，安全移动内容，然后删除，然后重新命名回来</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://askubuntu.com/questions/39536/how-can-i-store-var-on-a-separate-partition <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://www.suse.com/support/kb/doc/?id=000018399 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[问题背景]]></summary></entry><entry><title type="html">kernel crash dump</title><link href="/os/2022/09/01/kernel-crash-dump.html" rel="alternate" type="text/html" title="kernel crash dump" /><published>2022-09-01T00:00:00+08:00</published><updated>2022-09-01T00:00:00+08:00</updated><id>/os/2022/09/01/kernel-crash-dump</id><content type="html" xml:base="/os/2022/09/01/kernel-crash-dump.html"><![CDATA[<h2 id="ubuntu">Ubuntu</h2>

<p><a href="https://ubuntu.com/server/docs/kernel-crash-dump">install linux-crashdump</a></p>

<h2 id="dump-output">Dump Output</h2>

<p><code class="language-plaintext highlighter-rouge">alias crash="crash /usr/lib/debug/boot/vmlinux-$(uname -r)"</code></p>

<p><code class="language-plaintext highlighter-rouge">crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;</code></p>

<p>bt: backtrace
log: kernel log</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[Ubuntu]]></summary></entry><entry><title type="html">Compile Linux Kernel</title><link href="/os/2022/08/26/compile-linux-kernel.html" rel="alternate" type="text/html" title="Compile Linux Kernel" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/os/2022/08/26/compile-linux-kernel</id><content type="html" xml:base="/os/2022/08/26/compile-linux-kernel.html"><![CDATA[<p>编译实践1：
学习Linux内核模块开发，需要增加一个<code class="language-plaintext highlighter-rouge">FORCE_UNLOADING</code> feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。</p>

<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"><strong>Linux上游源代码（git地址在其页面下方）</strong></a></p>

<p><strong>默认环境</strong>
当前目录： kernel源目录</p>

<h2 id="ubuntu">Ubuntu</h2>

<p>注意源文件的下载，不要在系统目录比如<code class="language-plaintext highlighter-rouge">/usr/src</code>下进行，而要在用户空间内进行，而<code class="language-plaintext highlighter-rouge">apt source</code>，<code class="language-plaintext highlighter-rouge">apt-get source</code>, 不需要也不能使用<code class="language-plaintext highlighter-rouge">sudo</code>, 会错误得造成源文件的用户组变为root。对于&gt;= 20.04,没有官方更新的wiki讲如何使用debian/rules，直接从linux上游源代码处获取。</p>

<p>= 18.04</p>

<p>参考<a href="https://askubuntu.com/questions/1085411/unable-to-follow-kernel-buildyourownkernel">这篇文章</a></p>

<p>= 19.04</p>

<p>参考<a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">官方wiki</a></p>

<p>= 20.04 (or maybe upper than it)</p>

<p>参考<a href="https://discourse.ubuntu.com/t/how-to-compile-kernel-in-ubuntu-20-04/20268/10">这篇文章</a></p>

<ol>
  <li>
    <p>下载源代码</p>
  </li>
  <li>
    <p>安装依赖<code class="language-plaintext highlighter-rouge">sudo apt install asciidoc autoconf bc binutils-dev bison build-essential crash dkms fakeroot flex gawk gcc kernel-wedge kexec-tools libelf-dev libiberty-dev libncurses5-dev libncurses-dev libssl-dev libudev-dev makedumpfile openssl pciutils-dev</code></p>

    <p>(<code class="language-plaintext highlighter-rouge">pciutils-dev</code> is replaced by <code class="language-plaintext highlighter-rouge">libpci-dev</code> in the later version)</p>
  </li>
  <li>
    <p>配置参考下面tips</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">make -jn deb-pkg</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cd .. &amp;&amp; sudo apt ./linux-*.deb</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sudo update-grub</code></p>
  </li>
</ol>

<p><strong>Tips:</strong></p>

<ol>
  <li>
    <p>Linux 68%的代码是驱动相关代码，当然大部分的编译时间也是在编译驱动上，而这一部分也是容易出问题，往往花了几个小时编译发现，后来发现在这里出了错误，这就很难受，需要提前仔细配置。个人经验是不使用 <code class="language-plaintext highlighter-rouge">/boot/config-`uname -r` </code> 作为初始配置，而是使用<code class="language-plaintext highlighter-rouge">make localmodconfig</code> 创建初始配置:<code class="language-plaintext highlighter-rouge">.config</code>文件，使用默认的配置，确保驱动的编译不出问题。然后使用<code class="language-plaintext highlighter-rouge">make menuconfig</code>(shell text) or <code class="language-plaintext highlighter-rouge">make xconfig</code>(qt5 gui) 配置内核其他部分。</p>
  </li>
  <li>
    <p>make 使用<code class="language-plaintext highlighter-rouge">-j</code>启用多核编译很重要，如果宿主机器在编译的同时需要运行其他任务，建议少用一个核心，避免机器down掉(然后比如当前用户直接被强制logout)。</p>
  </li>
  <li>
    <p>如果make过程中因为什么原因中途停掉了，可以再次启动，但是第一次会报错: <code class="language-plaintext highlighter-rouge">"dpkg-source: unrepresentable changes to source"</code>, 只要把相关报错文件删除掉重新运行即可。</p>
  </li>
  <li>
    <p>&gt;= 20.04, 可能需要的额外依赖包:</p>

    <p>dwarves # tmp_vmlinux.btf: pahole (pahole) is not available</p>
  </li>
</ol>

<h2 id="select-kernel">Select Kernel</h2>

<p>重启的时候按住<code class="language-plaintext highlighter-rouge">shift</code>进入grup界面，选择需要的版本内核启动。
修改默认启动内核，参考<a href="https://support.huaweicloud.com/intl/en-us/trouble-ecs/ecs_trouble_0327.html">华为云的这篇文章</a>和<a href="https://askubuntu.com/questions/82140/how-can-i-boot-with-an-older-kernel-version/1393019#1393019">askubuntu的这个回答</a>
修改配置文件<code class="language-plaintext highlighter-rouge">/etc/default/grub</code>的 <code class="language-plaintext highlighter-rouge">GRUB_DEFAULT</code> 的值为启动项的序号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0，正常启动
1&gt;y， 高级启动项，y start from 0
</code></pre></div></div>

<p>查看高级启动项的序号(Ubuntu为例)：
<code class="language-plaintext highlighter-rouge">sudo grub-mkconfig | grep -iE "menuentry 'Ubuntu, with Linux" | awk '{print i++ " : "$1, $2, $3, $4, $5, $6, $7}'</code>
不要忘记最后运行<code class="language-plaintext highlighter-rouge">sudo update-grup</code>来更新配置。</p>]]></content><author><name></name></author><category term="[&quot;os&quot;]" /><summary type="html"><![CDATA[编译实践1： 学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。]]></summary></entry><entry><title type="html">TCP Congestion Control</title><link href="/net/2022/08/07/ietf_rfc_5681_obs2581.html" rel="alternate" type="text/html" title="TCP Congestion Control" /><published>2022-08-07T00:00:00+08:00</published><updated>2022-08-07T00:00:00+08:00</updated><id>/net/2022/08/07/ietf_rfc_5681_obs2581</id><content type="html" xml:base="/net/2022/08/07/ietf_rfc_5681_obs2581.html"><![CDATA[<p>This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04</p>

<h2 id="1-introduction">1. Introduction</h2>

<p>介绍TCP四种交织在一起的拥塞控制算法：</p>

<ol>
  <li>慢启动（slow start）</li>
  <li>拥塞避免（congestion avoidance）</li>
  <li>快速重传（fast retransmit）</li>
  <li>快速恢复（fast recovery）</li>
</ol>

<p>TCP链接需要做什么，在一个长时间停当后，以及确定和澄清一些TCP ACK生成的问题</p>

<h2 id="2-definition">2. Definition</h2>

<p>发送方最大分片大小（Sender Maximum Segment Size, SMSS）<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>接收方最大分片大小（Receiver Maximum Segment Size, RMSS）<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>最大段（Full Sized Segment）</p>

<p>接收方窗口（Receiver Window, rwnd）</p>

<p>拥塞窗口（Congestion Window, cwnd）<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>初始窗口（Initial Window, IW）<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>丢失窗口（Lost Window, LW）<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<p>重启窗口（Restart Window, RW）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>飞行尺寸（FlightSize）<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup></p>

<p>重复确认（Duplicate Acknowledgement）:</p>

<p>一个确认被认为是重复的如果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a. ack的接收者有未完成的（outstanding）数据

b. 到来的ack没有携带数据

c. SYN 和 FIN的标志都没有被设置

d. ack number等于链接最大的ack number

e. 到来的ack广告的窗口大小等于上一次ack广告的窗口大小

f: 使用SACKs（Selective Acknownledgements）的TCP会利用SACK信息判断ack是否重复
</code></pre></div></div>

<h2 id="3-congestion-control-algorithm">3. Congestion Control Algorithm</h2>

<p>本文提到的拥塞控制算法使用丢失或者ECN标记作为拥塞发生的信号</p>

<h3 id="31-slow-start-and-congestion-avoidance">3.1 Slow Start and Congestion Avoidance</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if SMSS &gt; 2190 (bytes):
  IW &lt;= 2*SMSS and IM &lt;= 2*SS(Segment Size)
else if 1095 &lt; SMSS &lt;= 2190:
  IW &lt;= 3*SMSS and IW &lt;= 3*SS
ekse:
  IW &lt;= 4*SMSS and IW&lt;= 4*SS
</code></pre></div></div>

<p>建立TCP链接的两个ACK不能用来增加cwnd的大小。等等IW设置详见<a href="https://datatracker.ietf.org/doc/html/rfc3390">RFC3390</a>。</p>

<p>ssthresh的初始值可以任意高<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>
慢启动算法启动标准：<code class="language-plaintext highlighter-rouge">cwnd &lt; ssthresh</code>
拥塞避免算法标准：<code class="language-plaintext highlighter-rouge">cwnd &gt; ssthresh</code>
二选一都可以：<code class="language-plaintext highlighter-rouge">cwnd = ssthresh</code></p>

<p>在慢启动的时候，每次ACK，cwnd的增加不超过SMSS bytes，当cwnd超过<code class="language-plaintext highlighter-rouge">ssthresh</code>或者拥塞重新被检测到的时候，退出慢启动。
传统TCP实现每次正好增加SMSS，但是我们推荐使用： <code class="language-plaintext highlighter-rouge">cwnd += min(N, SMSS)</code>,N是被新的ACK新确认的未确认数据的大小。<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">9</a></sup></p>

<p>在拥塞避免的时候，每过一个往返时间<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">10</a></sup>，cwnd可以增加一个full-sized segment<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">11</a></sup>大小；
应该（SHOULD）每一个来回的时间，增加<code class="language-plaintext highlighter-rouge">min(N, SMSS)</code>
但是不管怎样，每次cwnd不能增加超过SMSS。</p>

<p>或者每当收到一个不重复的ACK数据报，就增加一个<code class="language-plaintext highlighter-rouge">SMSS * SMSS / cwnd</code>大小<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">12</a></sup>；
还有的方法是增加新的被ACK确认的数据大小，直到cwnd增加到SMSS。<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">13</a></sup></p>

<p>同样地，当检测到拥塞发生的时候，算法终止。</p>

<p>ssthresh不应该超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>

<p>并且，一旦超时，cwnd必须被设为不超过LW，也就是1 full-sized segment。因此在重传被丢弃的包分片后，发送方使用慢启动来增加窗口的大小，从1 full-sized segment到新的ssthresh，在这时拥塞避免算法开始接管。</p>

<h3 id="32-fast-retransmitfast-recovery">3.2 Fast Retransmit/Fast Recovery</h3>

<p>当乱序的分片到达的时候，TCP接收端应该发送duplicate ack，通知发送方接收到的分片乱序以及应该收到的序列号。</p>

<p>从发送端的视角，当收到重复ack的时候，可能是几个网络原因：</p>

<ol>
  <li>分片丢失</li>
  <li>网络把数据分片重新排序</li>
  <li>ack或网络分片的复制（replication）</li>
</ol>

<p>In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in (all or part) of a gap in the sequence space.</p>

<p>TCP发送方基于到来的重复ack，使用快速重传算法来探测和修复丢包。
快速重传算法使用3个重复ack作为直接启动的信号而不需要等重传计时器过时。
在快速是重传算法发送了可能丢失的分片后，快速恢复算法接管新数据的传输，直到一个非重复ack的到来。
不执行慢启动的理由是重复ack的收到不仅表明分片丢失，也表明分片很可能已经离开了网络（在缓冲区中）</p>

<p>快速重传和快速恢复算法一起实现如下：</p>

<ol>
  <li>
    <p>在发送方收到第一个和第二个重复ack时，应该发送一个之前未发送数据的分片<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup></p>
  </li>
  <li>
    <p>当收到第三个重复的ack时，一个TCP必须把ssthresh设置为不超过<code class="language-plaintext highlighter-rouge">max(FlightSize/2, 2*SMSS)</code></p>
  </li>
  <li>
    <p>开始在SND.UNA<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">15</a></sup>丢失的分片必须被重传，并且cwnd设置为<code class="language-plaintext highlighter-rouge">ssthresh + 3*SMSS</code>。<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">16</a></sup></p>
  </li>
  <li>
    <p>对于每一个额外的重复ACK（在第三个之后）cwnd必须增加SMSS。<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">17</a></sup></p>
  </li>
  <li>
    <p>当之前未发送的数据可用，并且cwnd新值和接收方窗口允许时，TCP应该发送<code class="language-plaintext highlighter-rouge">1*SMSS</code>bytes数据。</p>
  </li>
  <li>
    <p>当下一个ack到达并确认之前未确认的数据时，TCP必须将cwnd设置为ssthresh（set by step-2）<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">18</a></sup><sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">19</a></sup></p>
  </li>
</ol>

<p>众所周知，这个算法通常无法有效地从单个数据包飞行中的多次丢失中恢复。</p>

<h2 id="4-additional-considerations">4. Additional Considerations</h2>

<h3 id="41-restarting-idle-connections">4.1. Restarting Idle Connections</h3>

<h3 id="42-generating-acknowledgments">4.2. Generating Acknowledgments</h3>

<h3 id="43-loss-recovery-mechanisms">4.3. Loss Recovery Mechanisms</h3>

<h2 id="5--security-considerations">5.  Security Considerations</h2>

<p>这个per是什么鬼，还有这么用的，啥意思？并且TCP发送方不能改变cwnd来反映这两个分片。记住，使用SACK的发送方不能发送新数据除非到来的重复ack包含新的SACK信息</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>最大分片的负载大小，不包括TCP/IP headers。这个数值基于MTU、PMTUD、RMSS或者其他因素。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>由TCP MSS option决定，如果没有设置，则为536 bytes（TCP安全最大值） <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>限制TCP发送数据的状态变量，TCP发送数据的大小受cwnd和rwnd的双重限制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>发送方的三次握手后的拥塞窗口 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>在重传计时器发现包的丢失时的拥塞窗口的大小 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>在一个慢启动算法里，在一段停当（idle）的时间后，启动重传时的拥塞窗口大小 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>已发送，但尚未被ack确认的数据数量，也就是“飞行中“的数据包 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Slow Start Threshold <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>这么做是为了增加鲁棒性针对一些行为不端的接收方方通过同一分片的多次的ACK响应（ACK Division），每个ack仅是数据的一部分，每个ACK都会使得发送方窗口增加SMSS，结果使得发送方使用过大的发送窗口 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>round-trip time, RTT <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>包含当前允许发送的最大数据的分片，比如包含SMSS bytes的数据 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>当cwnd非常大的时候，比如比<code class="language-plaintext highlighter-rouge">SMSS*SMSS</code> 还要大的时候，应该算为至少1 byte；同时更旧实现会增加一个额外常数，但这是错误的会导致性能损失 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>缺点是需要维护一个额外的状态变量 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver’s advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Sender Unknowledge <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>这人为地夸大了cwnd已经离开网络被接收方缓存3个分片 <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>这人为地夸大了cwnd为了反映离开网络的额外分片。为了防止这一机制被接收方滥用，可以限制cwnd扩大的次数为未接收分片的数量。Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize. <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>这被叫做窗口紧缩（deflating） <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>这个ack应该是由step-3的重传引发的。除此之外，这个ack应该确认所有在丢失的分片和收到的第三个重复的分片发送的所有中间分片，如果中间没有丢失 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;net&quot;]" /><summary type="html"><![CDATA[This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.04]]></summary></entry><entry><title type="html">Path MTU Discovery</title><link href="/net/2022/08/06/ietf_rfc_1191_obs1063.html" rel="alternate" type="text/html" title="Path MTU Discovery" /><published>2022-08-06T00:00:00+08:00</published><updated>2022-08-06T00:00:00+08:00</updated><id>/net/2022/08/06/ietf_rfc_1191_obs1063</id><content type="html" xml:base="/net/2022/08/06/ietf_rfc_1191_obs1063.html"><![CDATA[<p>This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.07</p>

<h2 id="1-protocol-overview">1. Protocol Overview</h2>

<p>通过设置IP header 的 <code class="language-plaintext highlighter-rouge">DF</code> bit 来动态发现一个路径的PMTU<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:
以第一跳<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>的MTU为初始值(已知的)，如果收到ICMP code 3-4<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>由于网络拓扑会随时间改变，PMTU的减少，仍然可以通过DTB meessage得知，只要DF bit 被设置，而PMTU的增加，可以通过主机上的定期任务<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>来检测。</p>

<h2 id="2-host主机specification">2. Host（主机）specification</h2>

<p>当Host探索PMTU的减少时，速度必须尽可能地快，而探索PMTU的增加时，探索的时间间隔不能频繁（infrequent）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>。</p>

<p>更具体地，当探索PMTU的增加时，增加失败的间隔不少于5min，增加成功的间隔不小于1min，建议的间隔分别是是10min和2min。</p>

<p>Host必须向下兼容不包含next-hop MTU的旧风格的DTB message<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>。</p>

<p>Host估值的PMTU应该不低于68 octets<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup></p>

<h3 id="3-tcp-mss-option">3. TCP MSS<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup> Option</h3>

<p>除非被允许，Host进行PMTUD时发送IP包的长度不应该超过 536 + 40 = 576 octets。</p>

<p>而很多TCP实现总是设置MSS选项并且将值设为536，如果目的连接是非本地的。这种行为是对的，因为互联网上到处都是不遵守规则，发送超过576 octets<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>的的host。</p>

<p>一个host可能根据MTU设置MMS，这不应该对PMTUD造成问题，并且可以劝阻同层发送巨大的数据报</p>

<h2 id="4-router路由器-specification">4. Router（路由器） specification</h2>

<p>DTB message(ICMP code 3-4) format, 提供额外的origin header，next-hop MTU 不赘叙</p>

<h2 id="5-处理旧风格的message">5. 处理旧风格的message</h2>

<p>即如果message本身没有提供PMTU的信息。</p>

<p>最简单的方式是取当前估计的PMTU与576之间的最小值，并且取消<code class="language-plaintext highlighter-rouge">DF</code>bit。</p>

<p>更复杂的方式需要“搜索”准确的PMTU估计值。有几个可能方法，它们根据一个之前的估计值产生一个新的估计值。</p>

<p>比如乘以一个常数比如0.75，但这样收敛又慢，产生的估计值又低于实际的值。所以不推荐。</p>

<p>再比如进行二分搜索，它收敛快一点，但从FDDI<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup> MTU落到Ethernet<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup> MTU仍然需要4-5步，而有一个非常的劣势是识别数据报到达另一端的时间是一个复杂实现。因此也不推荐。</p>

<p>有一个看起来效果似乎很好方法是比起盲搜，搜索一组可能出现的值，因为设计者们倾向于用类似的方式选择MTUs,使用其中的最小值<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>。使用下表的搜索，</p>

<p>Table Common MTUs in the Internet:</p>

<table>
  <thead>
    <tr>
      <th>Plateau</th>
      <th>MTU</th>
      <th>Comments</th>
      <th>Reference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>65535</td>
      <td>65535</td>
      <td>Official maximum MTU</td>
      <td>RFC 791</td>
    </tr>
    <tr>
      <td>32004</td>
      <td>65535</td>
      <td>Hyperchannel</td>
      <td>RFC 1044</td>
    </tr>
    <tr>
      <td>17914</td>
      <td>17914</td>
      <td>16Mb IBM Token Ring</td>
      <td> </td>
    </tr>
    <tr>
      <td>8166</td>
      <td>8166</td>
      <td>IEEE 802.4</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>4464</td>
      <td>IEEE 802.5 (4Mb max)</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td>4352</td>
      <td>4352</td>
      <td>FDDI (Revised)</td>
      <td>RFC 1188</td>
    </tr>
    <tr>
      <td> </td>
      <td>2048</td>
      <td>Wideband Network</td>
      <td>RFC 907</td>
    </tr>
    <tr>
      <td>2002</td>
      <td>2002</td>
      <td>IEEE 802.5 (4Mb recommended)</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>1536</td>
      <td>Exp. Ethernet Nets</td>
      <td>RFC 895</td>
    </tr>
    <tr>
      <td> </td>
      <td>1500</td>
      <td>Ethernet Networks</td>
      <td>RFC 894</td>
    </tr>
    <tr>
      <td> </td>
      <td>1500</td>
      <td>Point-to-Point (default)</td>
      <td>RFC 1134</td>
    </tr>
    <tr>
      <td>1492</td>
      <td>1492</td>
      <td>IEEE 802.3</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td> </td>
      <td>1006</td>
      <td>SLIP</td>
      <td>RFC 1055</td>
    </tr>
    <tr>
      <td>1006</td>
      <td>1006</td>
      <td>ARPANET</td>
      <td>BBN 1822</td>
    </tr>
    <tr>
      <td> </td>
      <td>576</td>
      <td>X.25 Networks</td>
      <td>RFC 877</td>
    </tr>
    <tr>
      <td> </td>
      <td>544</td>
      <td>DEC IP Portal</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>512</td>
      <td>NETBIOS</td>
      <td>RFC 1088</td>
    </tr>
    <tr>
      <td> </td>
      <td>508</td>
      <td>IEEE 802/Source-Rt Bridge</td>
      <td>RFC 1042</td>
    </tr>
    <tr>
      <td>508</td>
      <td>508</td>
      <td>ARCNET</td>
      <td>RFC 1051</td>
    </tr>
    <tr>
      <td>296</td>
      <td>296</td>
      <td>Point-to-Point (low delay)</td>
      <td>RFC 1144</td>
    </tr>
    <tr>
      <td>68</td>
      <td>68</td>
      <td>Official minimum MTU</td>
      <td>RFC 791</td>
    </tr>
  </tbody>
</table>

<p>使用这个表的收敛性最坏情况也比二分搜索相当，因为plateau几乎是2的幂，而如果值不在表中，被低估的值也不会超过2倍。</p>

<p>所有ICMP code 3 都包含源IP header，可以直接使用其中的Total Length字段的值作为输入，生成下一个估计值<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">14</a></sup>。</p>

<p>该表仅是建议参考，应该保持更新，添加一些2的幂加40（IP header + TCP header）的项，作为过渡，也可以包含稍微比2的幂稍小一些的项。但不管怎样，plateau的数量不应该太多，而实现者应该给无源代码客户提供一种方便的更新表值的工具<sup id="fnref:23" role="doc-noteref"><a href="#fn:23" class="footnote" rel="footnote">15</a></sup></p>

<h2 id="6-host-implementation">6. Host implementation</h2>

<p>提供一组关于PMTUD在主机软件上实现的建议。</p>

<h3 id="61-layering分层">6.1 Layering（分层）</h3>

<p>IP层应该存储PMTU信息，并且ICMP层应该处理DTB message。而分包层<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">16</a></sup>应该能反映PMTU的变化，通过改变发送数据报的大小，并且必须能指定<code class="language-plaintext highlighter-rouge">DF</code> bit。我们不希望IP层简单地为每个包设定<code class="language-plaintext highlighter-rouge">DF</code> bit，因为分包层可能无法改变它的数据报的大小<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">17</a></sup></p>

<h3 id="62-storing-pmtu-information">6.2 Storing PMTU Information</h3>

<p>存储信息的明显位置是将其作为一个字段，存储在路由表项中。一个主机不会为每一个目标地址有一个路由信息，但应该能为每个活跃目标地址缓存路由<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">18</a></sup>。</p>

<p>使用同一路径的所有的分包层都应该被通知，如果该路径PMTU减少了。这种通知应该区别于普通的包的丢失。</p>

<h3 id="63-purging-stale-pmtu-information">6.3 Purging stale PMTU information</h3>

<p>由于没有机制能实现发现当前的使用的PMTU因为它太小而过时了，所以需要一个实现能够老化缓存的值，以便有机会发现的新的更大的PMTU<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">19</a></sup>。而上层协议绝对不能因为PMTU的增加而重发，因为这没有包的丢失。</p>

<p>一个实现PMTU老化的方法是给路由表项添加时间戳字段，这个字段初始化为一个保留值，表明这个PMTU没有改变。当PMTU减少时，时间戳更新为当前时间。计时器驱动的程序扫描整个路由表，当一个表项的时间戳不是保留值时，如果超时了，则：</p>

<ol>
  <li>将估计的PMTU设置为关联的第一跳的MTU</li>
  <li>使用这个路由的分包层被通知PMTU的增加</li>
</ol>

<p>PMTU估计值可能从路由表消失,如果路由表项被移除掉<sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">20</a></sup>，一个解决方法是当ICMP 重定向消息导致路有变化或者当路由被删除的时候通知分包层</p>

<h3 id="64-tcp-layer-actions">6.4 TCP layer actions</h3>

<p>TCP数据报的大小受PMTU和MSS的双重制约。</p>

<p>当DTB message到达的时候，特定连接的特定于DTB message的数据报立刻重传，当然需要使用新的PMTU。</p>

<p>现代TCP实现包含拥塞控制和慢启动算法，DTB message不应该影响拥塞窗口，但是应该触发慢启动机制<sup id="fnref:20" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">21</a></sup>。</p>

<p>TCP的性能可能会下降，如果发送方的最大窗口大小<sup id="fnref:21" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">22</a></sup>不是精确的分片（segment）大小的几倍。如果使用了PMTUD，分片的大小发生改变，就会出现这种情况。因此应该根据新PMTU的大小调整最大窗口大小，来适应新的分片的大小，使保持一个整数倍的关系。</p>

<p>PMTUD不应该影响MSS选项的数值。</p>

<h3 id="65-issues-for-other-transport-protocols">6.5. Issues for other transport protocols</h3>

<p>像原始NFS协议这种如果有难处，还是分片传输吧。</p>

<h3 id="66-management-interface">6.6. Management interface</h3>

<p>一个PMTUD的实现应该为系统工具程序提供：</p>

<ol>
  <li>指定不在给定路由上做PMTUD<sup id="fnref:22" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">23</a></sup></li>
  <li>改变给定路由的PMTU</li>
  <li>改变PMTU老化的时间间隔</li>
</ol>

<h2 id="7-likely-values-for-path-mtus">7. Likely values for Path MTUs</h2>

<p>合并到第五章</p>

<h2 id="8-security-considerations">8. Security considerations</h2>

<p>通过发送恶意DTB message可以实现两种DOS攻击：</p>

<ol>
  <li>提供过于小的PMTU，使得连接变慢</li>
  <li>提供过于大的PMTU，这可能会造成暂时的阻塞，因为受害者的包会被路由器丢弃，在一个往返的时间里，主机会发现错误，但频繁的重复攻击会导致大量的数据报被丢弃。而一个主机<strong>永远不能</strong>根据DTB message提供的PMTU来提高估计值的上限，因为这会使得面对这种攻击变得很脆弱。</li>
</ol>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Path MTU <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>First Hop <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Fragmentation required, and DF flag set, carrying next-hop MTU and IP header and first 8 bytes of original datagram’s data <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>也就是PTB(Packet Too Big) message，或者DTB(Datagram Too Big) message <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>发送更高的PMTU假设的数据包，看是否能通过，大多数情况下PMTU不会改变，因此不应该太频繁地启用。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>因为需要发送比当前估计的PMTU更大的数据报，并且PMTU不太可能增加 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>可以通过检测next-hop MTU字段是否为0，来识别旧风格的DTB，根据ICMP的规定，未使用的字段必须为0 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>1 octect = 1 byte in CPU = 8 bit <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>Max Segment Size, IP datagram size minus IP header and TCP header (40 bytes, totally) <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>576 is safe max IP datagram size for TCP, or 536 for MSS <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>Fiber Distributed Data Interface, 光纤网，用于校园网、广域网 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>比起FDDI，高带宽效率低，但延迟也低 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>as “plateau” <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>基于4.2BSD实现的路由器会发送错误的Total length，它额外加上了origin header length，而且以octets而不是4xoctets的形式表现 <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:23" role="doc-endnote">
      <p>BSD 派生的Unix内核提供<code class="language-plaintext highlighter-rouge">ioctl</code>来做这件事 <a href="#fnref:23" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>在IP结构里，发送多大的数据报是由IP上层的协议决定的，我们称这样的协议为分包层（Packetization Layer） <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>比如一个内核外的UDP应用, 比如最原始版本的NFS协议，一个跨网络管理文件的系统，这种情况下应该允许分片（fragmentation） <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>这个需求已经被处理ICMP重定向消息的需要强制满足了 <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>这个时间从上一次PMTU不减开始，以10min为标准 <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>这可能发生在ICMP重定向消息或者特定的路由守护进程几分钟后删除了旧的路由信息，还可能是在一个多网卡（multi-homed host）的主机上拓扑的变化可能导致不同网卡的使用 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:20" role="doc-endnote">
      <p>也就是只重传第一个分段，直到收到ACK <a href="#fnref:20" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:21" role="doc-endnote">
      <p>最大窗口区别于拥塞窗口，拥塞窗口的大小总是分片大小的几倍，而最大窗口（<em>send space</em>）在很多系统（比如从4.2BSD衍生出来的）通常是1024 octets的几倍，是固定的 <a href="#fnref:21" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:22" role="doc-endnote">
      <p>可以在路由项上设置一个标志位，当有这个标志位时，<code class="language-plaintext highlighter-rouge">DF</code> bit一定会被清除，不管上层请求是什么 <a href="#fnref:22" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;net&quot;]" /><summary type="html"><![CDATA[This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.07]]></summary></entry><entry><title type="html">C dialect options</title><link href="/lang/2022/08/01/c_dialect_options.html" rel="alternate" type="text/html" title="C dialect options" /><published>2022-08-01T00:00:00+08:00</published><updated>2022-08-01T00:00:00+08:00</updated><id>/lang/2022/08/01/c_dialect_options</id><content type="html" xml:base="/lang/2022/08/01/c_dialect_options.html"><![CDATA[<p>Ref: <a href="https://www.acrc.bris.ac.uk/acrc/RedHat/rhel-gcc-en-4/c-dialect-options.html">1</a>, <a href="https://stackoverflow.com/questions/17206568/what-is-the-difference-between-c-c99-ansi-c-and-gnu-c">2</a></p>

<table>
  <thead>
    <tr>
      <th>ISO C90</th>
      <th>ISO C99</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-ansi, -std=c89, iso9899:1990, (ISO C90)</td>
      <td>-std=c99, iso9899:1999</td>
    </tr>
    <tr>
      <td>-std=iso9899:199409 (ISO C90 as modified in amendment 1)</td>
      <td>-std=gnu99 (iso c99 + gnu extensions, gcc default)</td>
    </tr>
    <tr>
      <td>-std=gnu89 (iso c90 + gnu extensions + some c99 features)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>ISO C11</th>
      <th>ISO C18</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-std=c11</td>
      <td>-std=c17, -std=c18</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>iso9899 (C Lang Spec Number of ISO)</li>
  <li><code class="language-plaintext highlighter-rouge">-ansi</code> for C++ mode means that remove conflics gnu extensions with ISO C++</li>
  <li>The word <code class="language-plaintext highlighter-rouge">ansi</code> means American Nation Standard Institute, c89 means ansi 89 (the first standard version), however c99 is iso 1999.The history is <code class="language-plaintext highlighter-rouge">ansi89 -&gt; iso90(same with ansi89) -&gt; iso99</code>, in other words, iso take the ownership of the C Lang standard from ansi.</li>
  <li>c18 is created on 2017 and released on 2018, so it’s called c17 or c18. It contains no new features, just corrections</li>
</ol>

<h2 id="runtime-environments">Runtime Environments</h2>

<table>
  <thead>
    <tr>
      <th>std</th>
      <th>no_std</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-fhosted (takes place in a hosted env)</td>
      <td>-fno-hosted</td>
    </tr>
    <tr>
      <td>-fno-freestanding</td>
      <td>-ffreestanding</td>
    </tr>
    <tr>
      <td>-fno-builtin, -fno-builtin-&lt;xxx&gt;</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>fno-builtin: Don’t recognize built-in functions that do not begin with <code class="language-plaintext highlighter-rouge">__builtin_</code> as prefix, <code class="language-plaintext highlighter-rouge">__built_in_xxx</code> always existed.</p>
  </li>
  <li>
    <p>fno-builtin-&lt;xxx&gt; such as <code class="language-plaintext highlighter-rouge">-fno-builtin-printf</code>.</p>
  </li>
  <li>
    <p>on <code class="language-plaintext highlighter-rouge">no_std</code> env using <code class="language-plaintext highlighter-rouge">__builtin_xxx</code> instead</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[Ref: 1, 2]]></summary></entry><entry><title type="html">C/C++ 陷阱</title><link href="/lang/2022/04/22/c_trap.html" rel="alternate" type="text/html" title="C/C++ 陷阱" /><published>2022-04-22T00:00:00+08:00</published><updated>2022-04-22T00:00:00+08:00</updated><id>/lang/2022/04/22/c_trap</id><content type="html" xml:base="/lang/2022/04/22/c_trap.html"><![CDATA[<ol>
  <li>
    <p>变量初始化</p>

    <p>在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据</p>
  </li>
  <li>
    <p>结构体初始化注意要在堆上手动分配内存，否则是栈上的会被回收， 这与Rust使用习惯又不一样</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[变量初始化 在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据]]></summary></entry><entry><title type="html">Zero Cost Exception Mechanism</title><link href="/lang/2022/03/30/zero_cost_exception.html" rel="alternate" type="text/html" title="Zero Cost Exception Mechanism" /><published>2022-03-30T00:00:00+08:00</published><updated>2022-03-30T00:00:00+08:00</updated><id>/lang/2022/03/30/zero_cost_exception</id><content type="html" xml:base="/lang/2022/03/30/zero_cost_exception.html"><![CDATA[<h2 id="related-header-definition">Related Header Definition</h2>

<p>依赖于 <em>unwinding library</em> 提供的至少如下的接口:</p>

<pre><code class="language-txt">  _Unwind_RaiseException,
  _Unwind_Resume,
  _Unwind_DeleteException,
  _Unwind_GetGR,
  _Unwind_SetGR,
  _Unwind_GetIP,
  _Unwind_SetIP,
  _Unwind_GetRegionStart,
  _Unwind_GetLanguageSpecificData,
  _Unwind_ForcedUnwind
</code></pre>

<h3 id="personality-routine">Personality Routine</h3>

<p>语言特定的函数(以下也称为routine, 名字用<code class="language-plaintext highlighter-rouge">__personality_routine</code>指代), 用于和<strong>unwinding library</strong> 配合做语言特定的异常处理</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_Unwind_Reason_Code</span> <span class="p">(</span><span class="o">*</span><span class="n">__personality_routine</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
    <span class="n">_Unwind_Action</span> <span class="n">actions</span><span class="p">,</span>
    <span class="n">uint64</span> <span class="n">exceptionClass</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">_Unwind_Exception</span> <span class="o">*</span><span class="n">exceptionObject</span><span class="p">,</span>
    <span class="k">struct</span> <span class="nc">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>返回值类型:</li>
</ul>

<p><strong>_Unwind_Reason_Code</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">_URC_NO_REASON</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">_URC_FOREIGN_EXCEPTION_CAUGHT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">_URC_FATAL_PHASE2_ERROR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">_URC_FATAL_PHASE1_ERROR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">_URC_NORMAL_STOP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">_URC_END_OF_STACK</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">_URC_HANDLER_FOUND</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">_URC_INSTALL_CONTEXT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">_URC_CONTINUE_UNWIND</span> <span class="o">=</span> <span class="mi">8</span>
<span class="p">}</span> <span class="n">_Unwind_Reason_Code</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>参数1 <code class="language-plaintext highlighter-rouge">version</code>: 个性例程假设的 unwinding runtime 的版本号, 比如 1</p>
  </li>
  <li>
    <p>参数2 <code class="language-plaintext highlighter-rouge">actions</code>: Personality Routine Actions:</p>
  </li>
</ul>

<p><strong>_Unwind_Action</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">_Unwind_Action</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">_Unwind_Action</span> <span class="n">_UA_SEARCH_PHASE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 0b0001</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">_Unwind_Action</span> <span class="n">_UA_CLEANUP_PHASE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0b0010</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">_Unwind_Action</span> <span class="n">_UA_HANDLER_FRAME</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 0b0100</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">_Unwind_Action</span> <span class="n">_UA_FORCE_UNWIND</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1">// 0b1000</span>
</code></pre></div></div>

<p>action flag可以在不违反语义情况下(比如搜索和清除阶段不能被同时设置)叠加</p>

<ul>
  <li>
    <p>参数3 <code class="language-plaintext highlighter-rouge">exception class</code>:</p>

    <p>By convention, the high 4 bytes indicate the vendor (for instance <code class="language-plaintext highlighter-rouge">HP\0\0</code>), and the low 4 bytes indicate the language. (for instance <code class="language-plaintext highlighter-rouge">C++\0</code>)</p>
  </li>
  <li>
    <p>参数4 <code class="language-plaintext highlighter-rouge">exceptionObject</code>: <code class="language-plaintext highlighter-rouge">_Unwind_Exception</code>的指针类型</p>
  </li>
</ul>

<p><strong>_Unwind_Exception</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="p">{</span>
    <span class="n">uint64</span>    <span class="n">exception_class</span><span class="p">;</span>  <span class="c1">// 同上exception_class</span>
    <span class="n">_Unwind_Exception_Cleanup_Fn</span> <span class="n">exception_cleanup</span><span class="p">;</span>
    <span class="n">uint64</span>    <span class="n">private_1</span><span class="p">;</span>
    <span class="n">uint64</span>    <span class="n">private_2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>_Unwind_Exception_Cleanup_Fn</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">_Unwind_Exception_Cleanup_Fn</span><span class="p">)</span>
    <span class="p">(</span><span class="n">_Unwind_Reason_Code</span> <span class="n">reason</span><span class="p">,</span>
     <span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exc</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">exception_cleanup</code> routine一定会在异常对象被不同运行时销毁时被调用, 比如Java异常被C++捕获.</p>

<p>这种情况下会返回reason code来表明异常对象被删除的原因:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">_URC_FOREIGN_EXCEPTION_CAUGHT</code>: 这表明不同的运行时捕获了异常, 嵌套的外部异常或者重抛外部异常会导致UB (undefined behaviour)</li>
  <li><code class="language-plaintext highlighter-rouge">_URC_FATAL_PHASE1_ERROR</code>: 个性例程在 <em>Phase-1</em> 遇到了未被特定错误码定义的错误</li>
  <li><code class="language-plaintext highlighter-rouge">_URC_FATAL_PHASE2_ERROR</code>: 个性例程在 <em>Phase-2</em> 遇到了错误,比如栈损坏</li>
</ol>

<ul>
  <li>参数5 <code class="language-plaintext highlighter-rouge">context</code>: <code class="language-plaintext highlighter-rouge">_Unwind_Context</code>的指针</li>
</ul>

<p><strong>_Unwind_Context</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_Unwind_Context</span>
</code></pre></div></div>

<p>由 <em>unwinder library</em> 定义的不透明结构.  由其创建和销毁, 在unwinding的时候传给个性例程.</p>

<h2 id="the-stack-unwind-process">The Stack Unwind Process</h2>

<p>(begins with the raising of an exception)</p>

<p><strong>两阶段处理</strong>:</p>

<p><em>Phase-1</em>:  search,  action is set <code class="language-plaintext highlighter-rouge">_UA_SEARCH_PHASE</code>.</p>

<p>从当前PC和(其他)寄存器状态开始, 逐帧展开(函数不断向上退出), 直到个性例程报告成功(在某一帧找到handler) 然后进入<code class="language-plaintext highlighter-rouge">Phase-2</code></p>

<p>或者失败(所有帧中找不到handler) 调用<code class="language-plaintext highlighter-rouge">terminate()</code></p>

<p><em>Phase-2</em>:  cleanup, action is set <code class="language-plaintext highlighter-rouge">_UA_CLEANUP_PHASE</code>.</p>

<p>框架重启,再次重复调用个性例程,找到被标志的帧, 然后把控制权转给landing pad代码 (<code class="language-plaintext highlighter-rouge">goto label xxx</code>)</p>

<p>两阶段处理的提供了一些好处, 比如可以在<em>Phase-1</em> dismiss 异常, 这允许通过修复异常的情况, 从而实现可恢复性的异常的处理.</p>

<p>对于一个异常只要多次抛出(by re-throwing), 就可以多次执行两阶段.</p>

<p><strong>_Unwind_Action 解释</strong></p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_UA_SEARCH_PHASE</code>:
成功返回 <code class="language-plaintext highlighter-rouge">_URC_HANDLER_FOUND</code>, 失败返回 <code class="language-plaintext highlighter-rouge">_URC_CONTINUE_UNWIND</code> (上文所示, 个性例程返回值是<code class="language-plaintext highlighter-rouge">_Unwind_Reason_Code</code>).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_UA_CLEANUP_PHASE</code>:
个性例程可以通过调用嵌套过程来自己执行清理,然后返回<code class="language-plaintext highlighter-rouge">_URC_CONTINUE_UNWIND</code>;
或者准备寄存器环境把控制转移给“landing pad“, 然后返回<code class="language-plaintext highlighter-rouge">_URC_INSTALL_CONTEXT</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_UA_HANDLER_FRAME</code>
在 <em>Phase 2</em>, 表明当前帧就是要找的有被标记的handler的帧. The personality routine is not allowed to change its mind between phase 1 and phase 2, i.e. it must handle the exception in this frame in phase 2.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_UA_FORCE_UNWIND</code>
在 <em>Phase 2</em>, 表明, 表示异常不允许被捕获. This flag is set while unwinding the stack for <code class="language-plaintext highlighter-rouge">longjmp</code> or during thread cancellation. User-defined code in a catch clause may still be executed, but the catch clause must resume unwinding with a call to _Unwind_Resume when finished.</p>
  </li>
</ol>

<p>转移控制权给landing pad,返回<code class="language-plaintext highlighter-rouge">_URC_INSTALL_CONTEXT</code>, 在这之前 <strong>unwind library</strong> 使用上下文管理例程和上下文记录<code class="language-plaintext highlighter-rouge">_Unwind_Context</code>来恢复寄存器环境.</p>

<h3 id="上下文管理例程">上下文管理例程</h3>

<p><strong>_Unwind_GetGR</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint64</span> <span class="nf">_Unwind_GetGR</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
</code></pre></div></div>

<p>函数返回给定寄存器的64bit的值 (64位的系统). 寄存器按照它的索引编号进行标识.</p>

<p>对于Itanium实现:</p>

<p>0-31 是固定寄存器, 32-127 是栈寄存器. During the two phases of unwinding, only GR1 has a guaranteed value, which is the Global Pointer (GP) of the frame referenced by the unwind context. If the register has its NAT bit set, the behaviour is unspecified.</p>

<p><strong>_Unwind_SetGR</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">_Unwind_SetGR</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">new_value</span><span class="p">);</span>
</code></pre></div></div>

<p>This function sets the 64-bit value of the given register, identified by its index as for <code class="language-plaintext highlighter-rouge">_Unwind_GetGR</code>. The NAT bit of the given register is reset.</p>

<p>The behaviour is guaranteed only if the function is called during phase 2 of unwinding, and applied to an unwind context representing a handler frame, for which the personality routine will return <code class="language-plaintext highlighter-rouge">_URC_INSTALL_CONTEXT</code>. In that case, only registers GR15, GR16, GR17, GR18 should be used. These scratch registers are reserved for passing arguments between the personality routine and the landing pads.</p>

<p><strong>_Unwind_GetIP</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint64</span> <span class="nf">_Unwind_GetIP</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
</code></pre></div></div>

<p>This function returns the 64-bit value of the instruction pointer (IP) 也就是PC.</p>

<p>During unwinding, the value is guaranteed to be the address of the bundle immediately following the call site in the function identified by the unwind context. This value may be outside of the procedure fragment for a function call that is known to not return (such as <code class="language-plaintext highlighter-rouge">_Unwind_Resume</code>).</p>

<p><strong>_Unwind_SetIP</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">_Unwind_SetIP</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">new_value</span><span class="p">);</span>
</code></pre></div></div>

<p>This function sets the value of the instruction pointer (IP) for the routine identified by the unwind context.</p>

<p>The behaviour is guaranteed only when this function is called for an unwind context representing a handler frame, for which the personality routine will return <code class="language-plaintext highlighter-rouge">_URC_INSTALL_CONTEXT</code>. In this case, control will be transferred to the given address, which should be the address of a landing pad.</p>

<p><strong>_Unwind_GetLanguageSpecificData</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint64</span> <span class="nf">_Unwind_GetLanguageSpecificData</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
</code></pre></div></div>

<p>This routine returns the address of the language-specific data area for the current stack frame.</p>

<p><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:" /> <em>This routine is not stricly required: it could be accessed through <code class="language-plaintext highlighter-rouge">_Unwind_GetIP</code> using the documented format of the <code class="language-plaintext highlighter-rouge">UnwindInfoBlock</code>, but since this work has been done for finding the personality routine in the first place, it makes sense to cache the result in the context. We could also pass it as an argument to the personality routine.</em></p>

<p><strong>_Unwind_GetRegionStart</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint64</span> <span class="nf">_Unwind_GetRegionStart</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>
</code></pre></div></div>

<p>This routine returns the address of the beginning of the procedure or code fragment described by the current unwind descriptor block.</p>

<p>This information is required to access any data stored relative to the beginning of the procedure fragment. For instance, a call site table might be stored relative to the beginning of the procedure fragment that contains the calls. During unwinding, the function returns the start of the procedure fragment containing the call site in the current stack frame.</p>

<h3 id="抛出异常">抛出异常</h3>

<p><strong>_Unwind_RaiseException</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_Unwind_Reason_Code</span> <span class="nf">_Unwind_RaiseException</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exception_object</span> <span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">_Unwind_RaiseException</code> 实际并不返回, 除非发生了错误的情况 (such as no handler for the exception, bad stack format, etc.). 可能的返回值:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">_URC_END_OF_STACK</code>
The unwinder encountered the end of the stack during phase 1, without finding a handler.</li>
  <li><code class="language-plaintext highlighter-rouge">_URC_FATAL_PHASE1_ERROR</code>: The unwinder encountered an unexpected error during phase 1, e.g. stack corruption.</li>
</ol>

<p><em><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:" /> The unwind runtime will likely have modified the stack (e.g. popped frames from it) or register context, or landing pad code may have corrupted them. As a result, the the caller of <code class="language-plaintext highlighter-rouge">_Unwind_RaiseException</code> can make no assumptions about the state of its stack or registers.</em></p>

<p><strong>_Unwind_ForcedUnwind</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_Unwind_Reason_Code</span> <span class="nf">_Unwind_ForcedUnwind</span> <span class="p">(</span>
    <span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exception_object</span><span class="p">,</span>
    <span class="n">_Unwind_Stop_Fn</span> <span class="n">stop</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stop_parameter</span> <span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>参数1 <code class="language-plaintext highlighter-rouge">stop</code>: <code class="language-plaintext highlighter-rouge">_Unwind_Stop_Fn</code> 特定函数指针类型</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">_Unwind_Reason_Code</span> <span class="p">(</span><span class="o">*</span><span class="n">_Unwind_Stop_Fn</span><span class="p">)</span> <span class="p">(</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">,</span>
    <span class="n">_Unwind_Action</span> <span class="n">actions</span><span class="p">,</span>
    <span class="n">uint64</span> <span class="n">exceptionClass</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exceptionObject</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">_Unwind_Context</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">stop_parameter</span> <span class="p">);</span>
</code></pre></div></div>

<p>Forced unwinding 是 <em>Phase-2</em> 中的过程. 对每一个展开帧, 都调用<code class="language-plaintext highlighter-rouge">stop</code> 函数 and 加上一个额外的<code class="language-plaintext highlighter-rouge">stop parameter</code>.</p>

<p>如果<code class="language-plaintext highlighter-rouge">stop</code> 函数标识了目标帧, 它就会把控制权转给landing pad, 而不是返回(通常是在调用了 <code class="language-plaintext highlighter-rouge">_Unwind_DeleteException</code>之后).</p>

<p>反之, 没有找到目标帧时就会返回:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_URC_NO_REASON</code>:
这不是目标帧, unwind运行时会再次调用个性例程, 使用<code class="language-plaintext highlighter-rouge">_UA_FORCE_UNWIND</code> and <code class="language-plaintext highlighter-rouge">_UA_CLEANUP_PHASE</code> 的action参数, 展开下一帧,并再次调用<code class="language-plaintext highlighter-rouge">stop</code>例程</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_URC_END_OF_STACK</code>:
In order to allow <code class="language-plaintext highlighter-rouge">_Unwind_ForcedUnwind</code>to perform special processing when it reaches the end of the stack, the unwind runtime will call it after the last frame is rejected, with a NULL stack pointer in the context, and the <code class="language-plaintext highlighter-rouge">stop</code> function must catch this condition (i.e. by noticing the NULL stack pointer). <strong>It may return this reason code if it cannot handle end-of-stack.</strong></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_URC_FATAL_PHASE2_ERROR</code>: 这个<code class="language-plaintext highlighter-rouge">stop</code> 函数应该在其他致命错误的情况下返回, e.g. stack corruption.</p>
  </li>
</ol>

<p>如果<code class="language-plaintext highlighter-rouge">stop</code>函数返回了任何<code class="language-plaintext highlighter-rouge">_URC_NO_REASON</code>意外的reason code, 从 <code class="language-plaintext highlighter-rouge">_Unwind_ForcedUnwind</code>的调用者的角度讲, 栈的状态是不确定的. 因此, unwind library 应该返回 <code class="language-plaintext highlighter-rouge">_URC_FATAL_PHASE2_ERROR</code> 给它的调用者.</p>

<p><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:" /> <em>Example: <code class="language-plaintext highlighter-rouge">longjmp_unwind()</code></em></p>

<p><em>期望的<code class="language-plaintext highlighter-rouge">longjmp_unwind()</code>的实现是这样的. <code class="language-plaintext highlighter-rouge">setjmp()</code> 保存了状态后 (包括帧的指针).  <code class="language-plaintext highlighter-rouge">longjmp_unwind()</code>将会调用<code class="language-plaintext highlighter-rouge">_Unwind_ForcedUnwind</code>,用context里记录的帧地址和当前保存的帧地址进行比较. 如果相等就调用 <code class="language-plaintext highlighter-rouge">setjmp()</code> 进行恢复, 否则返回 <code class="language-plaintext highlighter-rouge">_URC_NO_REASON</code> 或者 <code class="language-plaintext highlighter-rouge">_URC_END_OF_STACK</code>.</em></p>

<p><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE&lt;/b&gt;:" /> <em>如果未来对 两阶段的foced unwinding 有新的需求, 可以定义另外的例程和新的<code class="language-plaintext highlighter-rouge">actions</code> 参数类型来进行支持</em></p>

<p><strong>_Unwind_Resume</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">_Unwind_Resume</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exception_object</span><span class="p">);</span>
</code></pre></div></div>

<p>恢复异常的传播 e.g. 在部分展开的栈中执行清理代码(clean-up code)后如果不能恢复程序的正常执行, 就会恢复该异常的传播. 具体地就是在执行清理任务的landing pad结尾调用它(<code class="language-plaintext highlighter-rouge">_Unwind_Resume</code>).</p>

<p><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE 1&lt;/b&gt;:" /><em><code class="language-plaintext highlighter-rouge">_Unwind_Resume</code>不能用来实现重抛(re-throwing). 这是一个两阶段模型, 之前的unwind session会被关闭. 重抛需要使用<code class="language-plaintext highlighter-rouge">_Unwind_RaiseException</code>.</em></p>

<p><img src="/assets/img/warning.gif" alt="&lt;b&gt;NOTE 2&lt;/b&gt;:" /> This is the only routine in the unwind library which is expected to be called directly by generated code: it will be called at the end of a landing pad in a “landing-pad” model.</p>

<h3 id="异常对象的管理">异常对象的管理</h3>

<p><strong>_Unwind_DeleteException</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">_Unwind_DeleteException</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_Unwind_Exception</span> <span class="o">*</span><span class="n">exception_object</span><span class="p">);</span>
</code></pre></div></div>

<p>删除给定的异常对象. 当程序捕获了外部异常后仍可以恢复正常运行时, 由于并不清楚如何删除这个外部的异常对象, 这时就需要调用这个例程.</p>

<p>它实际上是个方便函数, 会调用异常对象头(header)里面的<code class="language-plaintext highlighter-rouge">exception_cleanup</code>字段所带的<code class="language-plaintext highlighter-rouge">_Unwind_Exception_Cleanup_Fn</code>类型的函数指针</p>

<h2 id="互操作的约定规则">互操作的约定规则</h2>

<p>对于C++, 在forced unwinding的时候, 一个 catch-all 块也会执行. 比如, a longjmp may execute code in a catch(…) during stack unwinding. However, if this happens, unwinding will proceed at the end of the catch-all block, whether or not there is an explicit rethrow.</p>

<h2 id="reference">Reference</h2>

<ol>
  <li><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html</a></li>
</ol>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[Related Header Definition]]></summary></entry><entry><title type="html">C++ ABI 笔记 1</title><link href="/oth/2022/03/27/cxx-abi-node-0.html" rel="alternate" type="text/html" title="C++ ABI 笔记 1" /><published>2022-03-27T00:00:00+08:00</published><updated>2022-03-27T00:00:00+08:00</updated><id>/oth/2022/03/27/cxx-abi-node-0</id><content type="html" xml:base="/oth/2022/03/27/cxx-abi-node-0.html"><![CDATA[<p>Ref: <a href="1">https://itanium-cxx-abi.github.io/cxx-abi/abi.html</a></p>

<h2 id="member-pointer">Member Pointer</h2>

<ol>
  <li>
    <p>数据成员指针类型的基本ABI属性是 <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>, 表示数据成员到所属基类的字节偏移量.</p>

    <p>空数据成员指针表示为<code class="language-plaintext highlighter-rouge">-1</code> (但是通过显式派生到基类的转换,生成偏移量为<code class="language-plaintext highlighter-rouge">-1</code>的数据成员指针)</p>
  </li>
  <li>
    <p>一个非空的数据成员指针的基到派生和派生到基的转换, 可以通过分别加或减掉二者静态偏移量(C++标准保证可知这个静态偏移量)实现</p>
  </li>
  <li>
    <p>建议更好的空数据指针实现: (x &lt;&lt; 1) + 1 表示非空数据</p>
  </li>
</ol>

<h3 id="member-function-pointers">Member Function Pointers</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
  <span class="n">fnptr_t</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="kt">ptrdiff_t</span> <span class="n">adj</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">fnptr_t</code> : 1 + offset(function’s vtable entry offset in bytes)</p>

    <p>null 表示空的函数指针</p>
  </li>
</ol>

<p>调用过程:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adj_this = `this` + `adj`

if ptr != null { 从vtable中加载对应项 } else { 调用存储的函数指针 }
</code></pre></div></div>

<h2 id="virtual-table-layout">Virtual Table Layout</h2>

<p>Virtual call (vcall) offsets are used to perform pointer adjustment for virtual functions that are declared in a virtual base class or its subobjects and overridden in a class derived from it.</p>

<p>These entries are allocated in the virtual table for the virtual base class that is most immediately derived from the base class containing the overridden virtual function declaration.</p>

<p>They are used to find the necessary adjustment from the virtual base to the derived class containing the overrider, if any.</p>

<p>When a virtual function is invoked via a virtual base, but has been overridden in a derived class,</p>

<p>the overriding function first adds a fixed offset to adjust the this pointer to the virtual base,</p>

<p>and then adds the value contained at the vcall offset in the virtual base to its this pointer to get the address of the derived object where the function was overridden.</p>

<p>These values may be positive or negative.</p>

<p>Virtual Base (vbase) offsets are used to access the virtual bases of an object.</p>

<p>Such an entry is added to the derived class object address (i.e. the address of its virtual table pointer) to get the address of a virtual base class subobject.</p>

<p>Such an entry is required for each virtual base class. The values can be positive or negative.</p>

<p>However, in classes sharing a virtual table with a primary base class,</p>

<p>the vcall and vbase offsets added by the derived class all come before the vcall and vbase offsets required by the base class,</p>

<p>so that the latter may be laid out as required by the base class without regard to additions from the derived class(es).</p>

<p>The offset to top holds the displacement to the top of the object from the location within the object of the virtual table pointer that addresses this virtual table, as a  ptrdiff_t.</p>

<p>It is always present. The offset provides a way to find the top of the object from any base subobject with a virtual table pointer. This is necessary for dynamic_cast&lt;void*&gt; in particular.</p>

<p><b>NOTE</b>: In a complete object virtual table, and therefore in all of its primary base virtual tables, the value of this offset will be zero. For the secondary virtual tables of other non-virtual bases, and of many virtual bases, it will be negative. Only in some construction virtual tables will some virtual base virtual tables have positive offsets, due to a different ordering of the virtual bases in the full object than in the subobject’s standalone layout.
The typeinfo pointer points to the typeinfo object used for RTTI. It is always present. All entries in each of the virtual tables for a given class must point to the same typeinfo object. A correct implementation of typeinfo equality is to check pointer equality, except for pointers (directly or indirectly) to incomplete types. The typeinfo pointer is a valid pointer for polymorphic classes, i.e. those with virtual functions, and is zero for non-polymorphic classes.
The virtual table address point points here, i.e. this is the virtual table address contained in an object’s virtual pointer. This address must have the alignment required for pointers.
Virtual function pointers are used for virtual function dispatch. Each pointer holds either the address of a virtual function of the class, or the address of a secondary entry point that performs certain adjustments before transferring control to a virtual function.
The form of a virtual function pointer is specified by the processor-specific C++ ABI for the implementation. In the specific case of 64-bit Itanium shared library builds, a virtual function pointer entry contains a pair of components (each 64 bits): the value of the target GP value and the actual function address. That is, rather than being a normal function pointer, which points to such a two-component descriptor, a virtual function pointer entry is the descriptor.</p>

<p>The order of the virtual function pointers in a virtual table is the order of declaration of the corresponding member functions in the class. If an implicitly-declared copy assignment operator, move assignment operator, or destructor is virtual, it is treated as if it were declared at the end of the class, in that order. (Implicitly-declared assignment operators may be virtual if a base class declares a virtual assignment operator taking a reference to a derived class type.)</p>

<p>An entry is added for every virtual function in a class, including deleted functions, unless:</p>

<p>the function is consteval or
the function overrides a function from the primary base and that override does not require a return-type adjustment.
An override requires a return-type adjustment if the return types are different and have potentially incompatible representations. C++ permits an override to differ in return type from the overridden function only if both types are pointer-to-class or reference-to-class types and the class type B in the overridden function is an unambiguous base class of the class type D in the override. For the purposes of vtable layout, these types are considered to have potentially incompatible representations if:</p>

<p>B is a morally virtual base of D (even if D is final and the offset of B within D is known to be zero) or
the (static) offset of B within D is non-zero.
When a derived class and its primary base share a virtual table, the virtual function entries introduced by the derived class follow those for the primary base, so that the layout of the primary base’s embedded virtual table is the same as that of its standalone virtual table. In particular, if the derived class overrides a base class virtual function with a different (covariant) return type, the entry for the derived class comes after the primary base’s embedded virtual table in declaration order, and is the entry used for calls from the derived class without adjustment. The entry in the embedded primary virtual table points to a routine that adjusts the result pointer before returning.</p>

<p>The entries for virtual destructors are actually pairs of entries. The first destructor, called the complete object destructor, performs the destruction without calling delete() on the object. The second destructor, called the deleting destructor, calls delete() after destroying the object. Both destroy any virtual bases; a separate, non-virtual function, called the base object destructor, performs destruction of the object but not its virtual base subobjects, and does not call delete().</p>

<p>Following the primary virtual table of a derived class are secondary virtual tables for each of its proper base classes, except any primary base(s) with which it shares its primary virtual table. These are copies of the virtual tables for the respective base classes (copies in the sense that they have the same layout, though the fields may have different values). We call the collection consisting of a primary virtual table along with all of its secondary virtual tables a virtual table group. The order in which they occur is the same as the order in which the base class subobjects are considered for allocation in the derived object:</p>

<p>First are the virtual tables of direct non-primary, non-virtual proper bases, in the order declared, including their secondary virtual tables for non-virtual bases in the order they appear in the standalone virtual table group for the base. (Thus the effect is that these virtual tables occur in inheritance graph order, excluding primary bases and virtual bases.)
Then come the virtual base virtual tables, also in inheritance graph order, and again excluding primary bases (which share virtual tables with the classes for which they are primary).
This ABI does not make guarantees about the layout of other virtual tables in a virtual table group relative to a virtual table pointer in an object or a VTT. It guarantees only the layout of the global symbol for that virtual table group. It does not guarantee that the virtual table pointers actually installed in an object or a VTT will point into that global symbol.</p>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[Ref: https://itanium-cxx-abi.github.io/cxx-abi/abi.html]]></summary></entry></feed>