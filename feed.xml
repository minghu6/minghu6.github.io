<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-07-29T23:45:34+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">算法复杂度分析的标记符号</title><link href="/algs/ComplexityNotations.html" rel="alternate" type="text/html" title="算法复杂度分析的标记符号" /><published>2024-07-28T00:00:00+08:00</published><updated>2024-07-28T00:00:00+08:00</updated><id>/algs/ComplexityNotations</id><content type="html" xml:base="/algs/ComplexityNotations.html"><![CDATA[<p>介绍下在分析算法复杂度时用到的标记符号，及其数学来源。</p>

<p>这些标记符号开始源于德国数学家 <a href="https://en.wikipedia.org/wiki/Paul_Gustav_Heinrich_Bachmann">Paul Bachmann</a> 和 <a href="https://en.wikipedia.org/wiki/Edmund_Landau">Edmund Landau</a> 的发明，后经 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a> 的整理，形成了现在熟悉的这些渐进符号（<strong>asymptotic notation</strong>）。</p>

<h2 id="o-记号">$O$ 记号</h2>

<p>开始叫做 big-O<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，后经过 Knuth 整理，也可以表示为 big Omicron 。</p>

<h3 id="形式化描述">形式化描述</h3>

<p>$f(x) = O(g(x)),\quad x\to \infty $</p>

<p>等价于：</p>

<p>$\exists (M\gt0, x_0)$ ，使得所有 $x \geqslant x_0$ ，都有 $|f(x)| \leqslant M g(x)$ ， 其中函数 $g(x)$ 对于足够大的 $x$ 来说总是正数。</p>

<h2 id="o-记号-1">$o$ 记号</h2>

<p>叫做 little-o ，也可以叫做 little omicron 。相比于 big-O ，little-o 的限制更加严格。</p>

<h3 id="形式化描述-1">形式化描述</h3>

<p>$f(x) = o(g(x)),\quad x\to \infty $</p>

<p>等价于：</p>

<p>$\forall \epsilon \gt 0,\ \exists x_0$ ，使得所有 $x \geqslant x_0$ ，都有 $|f(x)| \leqslant \epsilon g(x)$ ， 其中函数 $g(x)$ 对于足够大的 $x$ 来说总是正数。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>这个定义形式上就类似微分里面的上极限的定义。</p>

<h3 id="另一种形式">另一种形式</h3>

<p>按照定义高阶无穷小的方式，它还可以写作：</p>

<p>$\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = 0$</p>

<p>也就是说，$g(x)$ 是更高阶的一个函数，是 $f(x)$ 的严格上限。这种 little-o 的记号在泰勒展开式里作为余项也用到过。</p>

<h3 id="与-o-的关系">与 $O$ 的关系</h3>

<p>记号描述得其实是一种集合成员与集合的概念，这样我们就清楚了 big-O 实际上就是同阶函数和更高阶函数 $o$ 两个不相交集合的并集 <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<h2 id="omega--omega-记号">$\Omega$ &amp; $\omega$ 记号</h2>

<p>分别叫做 big Omega 和 little omega ，根据 Knuth 的归纳调整，big Omega 成为了：</p>

<p>$f(x) = \Omega(g(x)) \Leftrightarrow g(x) = O(f(x))$</p>

<p>而 little omega 则对应了：</p>

<p>$f(x) = \omega(g(x)) \Leftrightarrow g(x) = o(f(x))$</p>

<p>但是按照函数阶的集合的观点更直观，big Omega 代表小于或等于这个阶的函数集合，而 little omega 则代表了；严格小于这个阶的函数集合。</p>

<h2 id="theta-记号">$\Theta$ 记号</h2>

<p>叫做 big Theta。根据 Knuth 的定义：</p>

<p>$f(x) = \Theta(g(x)) \Leftrightarrow f(x) = O(g(x)) = \Omega(g(x))$</p>

<p>是说给出的 $g(x)$ 同时满足了 big-O 和 big Omega 这两个集合的定义。</p>

<h2 id="总结">总结</h2>

<p>可以按照如下表对复杂度记号进行理解：</p>

<table>
  <thead>
    <tr>
      <th>记号</th>
      <th>逻辑关系</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$O$</td>
      <td>$\leqslant$</td>
    </tr>
    <tr>
      <td>$o$</td>
      <td>$\lt$</td>
    </tr>
    <tr>
      <td>$\Theta$</td>
      <td>$\simeq$</td>
    </tr>
    <tr>
      <td>$\Omega$</td>
      <td>$\geqslant$</td>
    </tr>
    <tr>
      <td>$\omega$</td>
      <td>$\gt$</td>
    </tr>
  </tbody>
</table>

<p><a href="https://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities">备查时间复杂度表</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>根据 <a href="https://en.wikipedia.org/wiki/Big_O_notation#History_(Bachmann%E2%80%93Landau,_Hardy,_and_Vinogradov_notations)">wiki</a> 的说法， big-O 来源于德语 “Ordnung”，用来表示近似阶的意思。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>显然这里的 $\epsilon$ 和 big-O 形式化定义里面的 $M$ 是一样的，只是作为一种对使用传统的尊重，大写英文字母用作某个常数而 $\epsilon$ 用作任意（小）的数字。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>很容易搞混得是 $f(x)\sim g(x)$ 描述得是等价关系 $\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = 1$ 而不是同阶关系 $\displaystyle \lim_{x\to\infty}{\frac{f(x)}{g(x)}} = C \gt 0 $，缺少一个描述同阶关系的记号有点儿别扭。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[介绍下在分析算法复杂度时用到的标记符号，及其数学来源。]]></summary></entry><entry><title type="html">质数基础</title><link href="/algs/Prime0.html" rel="alternate" type="text/html" title="质数基础" /><published>2023-12-29T00:00:00+08:00</published><updated>2023-12-29T00:00:00+08:00</updated><id>/algs/Prime0</id><content type="html" xml:base="/algs/Prime0.html"><![CDATA[<p><em>本文主要参考：</em></p>

<p><em>1. en-wiki 相关页面</em></p>

<p><em>2.Jonason Sorenson:《An Introduction to Prime Number Sieves》</em></p>

<p>*3. *</p>

<h2 id="定义">定义</h2>

<p>质数（prime），指大于 $1$ 的自然数里，不能拆解为比它严格更小两个的自然数乘积的数。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>互质（co-prime），两个整数 $a$，$b$ 没有除了 $1$ 以外的作为正整数的共同除数（divisor），则说 $a$ 质于 $b$ ，或者 $a,b$ 互质<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">2</a></sup>。<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">3</a></sup></p>

<h2 id="性质">性质</h2>

<h3 id="欧几里得引理">欧几里得引理<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">4</a></sup></h3>

<p><del><strong>原始版本</strong>：如果质数 $p$ 能够除 $a\cdot b$ <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">5</a></sup>，并且 $p$ 不能除 $a$ ，则 $p$ 能够除 $b$ 。</del></p>

<p><strong>现代版本</strong>：如果一个整数 $n$ 能够除 $a\cdot b$ ，并且 $n$ 与 $a$ 互质，则 $n$ 能够除 $b$ 。</p>

<h4 id="证明">证明</h4>

<p>现代版是对把原始欧几里得引理推广到一般整数上，我们直接对此进行证明。</p>

<p>不妨假设 $n$ 是非负数：</p>

<h5 id="证初始条件">证初始条件</h5>

<p>对于初始情况，比如 $ab = 0$ ，此时 $a=0$ 或 $b=0$ 。</p>

<p>假设 $a=0$ ，因为 $n\perp a$ ，那么显然有 $n = 1$ ，而 $1$ 可以除任何数，当然能够除 $b$ ，结论成立；</p>

<p>假设 $b=0$，$b$ 能够被任何数整除，当然能被 $n$ 整除，条件成立。</p>

<h5 id="证递推关系">证递推关系</h5>

<p>假设结论对于所有积在 $[0, ab)$ 的情况结论都成立：</p>

<p>因为 $n | a\cdot b$ ，不妨令</p>

\[n\cdot q=ab \qquad\qquad \texttt{(1)}\]

<p>如果 $n=a$ ，因为 $n\perp a$ ，那么显然有 $|n| = 1$ ，那么 $n$ 一定可以除 $b$ ；</p>

<p>如果 $n\lt a$ ，两边减去 $n\cdot b$ ，得到 $nq - nb = ab - nb$ ，也就是 $n(q-b) = (a-n)b$ 。又因为 $n\perp a$ ，所以有 $n\perp a-n$ <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">6</a></sup> ，而 $0 \leqslant (a-n)b \lt ab$ ，按照假设，有 $n | b$ ；</p>

<p>否则 $n \gt a$，两边减去 $a\cdot q$ ，得到 $nq-aq = ab-aq$ ，也即</p>

\[(n-a)q=a(b-q) \qquad\qquad \texttt{(2)}\]

<p>类似地， 因为 $n-a\perp a$ ，而 $0 \leqslant a(b-q) \lt ab$ ，所以有 $n-a | b-q $ 。不妨令 $b-q = r(n-a)$ ，代回式 $\texttt{(2)}$ 得到 $(n-a)q=(n-a)ar$ ，于是有 $q=ar$ ，代回式 $\texttt{(1)}$ 有 $nar=ab$，$b=nr$ ，也就是 $n|b$ 。</p>

<p>于是我们证明了递归关系的成立。</p>

<p>欧几里得引理证毕。</p>

<h3 id="算式基本定理">算式基本定理<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup></h3>

<p>每一个大于 $1$ 的正整数都可以，而且唯一地分解为一组质数的乘积。</p>

<h4 id="证明-1">证明</h4>

<h5 id="存在性证明">存在性证明</h5>

<p>这很容易理解，假如一个大于 $1$ 的正整数的因式分解不是质数就是合数，因式分解后，如果存在合数，那么合数本身也一定可以继续分解，直到只剩下质数为止。</p>

<h5 id="唯一性证明">唯一性证明</h5>

<p>反证法，假设 $s$ 是最小的、至少有两个质数分解组合的正整数：$s = \prod p_m = \prod q_n$ 。</p>

<p>既然 $p_1 \perp q_k$ ，根据上文欧式引理，有 $p_1 |\prod_{1}^{n-1} q$；同理，$p_1 \perp p_{k=n-1}$ ，可得 $p_1 | \prod_{1}^{n-2} q$ ；直到 $p_1 | q_1$ 。又因为 $p_1 \perp q_1$ ，所以只能是 $p_1 = q_1$ ，这样就得到了比 $s$ 更小的能分解为至少两个质数组合的正整数 $\prod_{2}^{m} p = \prod_{2}^{n} q$ ，与前提假设相悖，于是反证成立。</p>

<h5 id="唯一性证明独立">唯一性证明（独立）</h5>

<p>这里通过不依赖欧几里得引理来独立证明。</p>

<p>仍然通过反证法，假设 $s$ 是最小的、至少有两个质数分解组合的正整数 $s = \prod p_m = \prod q_n$ 。</p>

<p>如果两个组合里存在一对儿相等的质数 $p_i = q_j$ ，则两边约掉相等的数后会出现一个比 $s$ 更小的多质数分解的整数，与前提相悖。</p>

<p>因此不妨可以假设 $p_1 \lt q_1$ ，令 $P=\prod_{2}^{m} p$ ，$Q=\prod_{2}^{n} q$ ，则有 $s=p_1P=q_1Q$ 。</p>

<p>又有 $p_1 \lt q_1$ ，所以 $P \gt Q$ ，不妨令 $s’$ 等于 $s$ 减去 $p_1Q$ ，得到 $s’ = p_1(P-Q) = Q(q_1-p_1)$ 。因为 $ s’ \lt s$ ，所以 $s’$ 只有唯一的质因数分解，那么 $p_1$ 要么在 $q_1 - p_1$ 的部分，要么在 $Q$ 的部分。</p>

<p>如果 $p_1$ 在 $q_1-p_1$ 的部分，则有 $p_1 | q_1$ ，与 $p_1$ 、$q_1$ 都是质数相悖；</p>

<p>如果 $p_1$ 在 $Q$ 的部分，由于前面的结论，$p_1 \not\in \lbrace q \rbrace$ ，因此就有两对儿质因数分解，这样就发现了比 $s$ 更小的多组质因数分解的正整数 $Q$ ，与假设相悖。</p>

<p>反证证毕。</p>

<h2 id="质性测试">质性测试</h2>

<p>这里将介绍简单的测试方法<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">8</a></sup> – 试除法（trial division），其中使用的技巧将在后面查找范围内所有质数的方法里得到进一步的拓展。</p>

<p>被测试的整数记为 $n$ ，试除法，顾名思义就是检查所有 $2\dots n-1$ 的值能否除 $n$ ，也就是根据原始定义进行测试。这里主要介绍常见的优化技巧：</p>

<p>首先，因数测试的上限不需要到 $n-1$ ，而只需要到 $\lfloor \sqrt{n} \rfloor$ <sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">9</a></sup> ，因为因数如果存在，一定是一大一小或者相等大小，只需要检查所有较小或者相等的数就行。</p>

<p>其次，可以先检测大多数情况下最常见的质因数：$2, 3$ 来快速失败。</p>

<p>更进一步地，可以排除所有与 $2,3$ 不互质的数，实质上我们是在尝试寻找 $n$ 的质因数，可以用 $3\sharp\cdot k+i = 6k+i$ <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup>的形式表示后面的数字，其中 $k \in N^+, 0\leqslant i \lt 3\sharp$ 。之所以选择 $3\sharp$ 作为周期长度，是因为它是这些质因子的最小公倍数，在此基础上排除那些与 $2$ 或 $3$ 不互质的 $i$ ，比如 $i=0, 2, 4$ ，也就是只需要检查 $6k+1, 6k+5$ 。如果从数字 $5$ <sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>开始检查是否能除 $n$ ，那么为了方便起见，周期内的这两个位置 $x$ 可以表示为 $x \mod{6} \equiv \pm1$ 。</p>

<p>有了这样三个主要地优化，现在就可以写下试除法的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">is_prime</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n:expr</span><span class="p">;</span> <span class="nv">$ty:ty</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

            <span class="nv">'ret</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="kc">false</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">5</span><span class="o">..=&lt;</span><span class="nv">$ty</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">isqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">break</span> <span class="nv">'ret</span> <span class="kc">false</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">break</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里使用宏只是因为 Rust 缺乏统一描述常见基本数字类型的 Trait ，而使用 <code class="language-plaintext highlighter-rouge">loop</code> 是为了在宏里模拟函数体行为。</p>

<h2 id="查找质数">查找质数</h2>

<p>具体来说，是这样一个问题：给定一个正整数 $n$ ，查找所有质数 $p\leqslant n$ 。<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">12</a></sup></p>

<p>方法是通过各种“筛子算法” （Sives）来缩减问题规模，这也是数学上对此类问题的通解。</p>

<h3 id="e-筛子">E-筛子</h3>

<p>Eratosthenes 筛子，简称作E-筛子，属于是非常古老、简单的一种筛子算法。</p>

<p>E-筛子是一种求解合数的思路，最后是通过它的补集获得需要的质数。</p>

<ol>
  <li>在对整个范围一遍扫描的过程中，开始先逐个数检查质性；</li>
  <li>当发现一个质数 $p$ 时，就把它的乘积 $2p, 3p, \dots , \lfloor n/p\rfloor p$ 都标记为合数；</li>
  <li>这样在继续扫描的过程中发现被标记为合数的就直接跳过，直到发现下一个质数，然后重复步骤2直到 $n$</li>
</ol>

<p>实际上我们标记合数的方法是追踪所有小于它的质数，因为根据上面所讲的<a href="#算式基本定理">正整数唯一分解定理</a>，也就是所有的合数都可以做质因数分解，一定存在一个严格比它小的质数可以除它。这样地话，如果我们是从第一个质数开始，那么实际上：</p>

<ol>
  <li>标记合数的过程不需要从 $2p$ 开始，而是直接从 $p\cdot p$ 开始，因为所有 $\lt p$ 的合数已经被更小的质数标记过了；</li>
  <li>最外轮的扫描只到 $\lfloor \sqrt{n} \rfloor$ 即可，因为作为合数的因子对，只需要通过那些较小的就可以完成合数的标记了</li>
</ol>

<h4 id="样例代码">样例代码</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">bit_vec</span><span class="p">::</span><span class="n">BitVec</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_sive</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">BitVec</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">bits</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="复杂度分析">复杂度分析</h4>

<p>每查找到一个质数，就需要 $n/p$ 的操作次数，因此总的操作数为 $\displaystyle \sum_{ p\leqslant \sqrt{n}}  n/p $ 。而根据已知的结论，来自<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">13</a></sup>  chapter 22 的：$\displaystyle \sum_{p \leqslant x} \frac{1}{p} = \log\log x + O(1)$ ，可以得到算法的最坏时间复杂度为 $O(n\log\log n)$ 。</p>

<p>时间复杂度近乎是线性的，但这个算法的问题不在时间上，而在空间上，因为要对每个数字进行标记，就需要 $O(n)$ bit 的空间，这个空间使用在一般问题上不算很糟糕，但在数论相关问题上就让人受不了，这就引出了下面“分段”处理的方法。</p>

<h4 id="分段处理">分段处理</h4>

<p>分段处理可以把空间占用从 $O(n)$ 降到 $O(\sqrt{n})$ ，这可以大大缓解算法对空间的占用。</p>

<p>方法是可以预计算出所有到 $\sqrt{n}$ 为止的质数，根据前面已知，所有 $\leqslant n$ 范围内的合数都可以由预计算出的质数构造出，只需要知到这些质数的乘积落在每个分段上的第一个数，就可以标记完所有这个分段的合数。</p>

<p>而如何知道质数 $p$ 落在某个分段区间的第一个数呢？只需要知道分段的左边缘 $l$ ，那么易知落点为 $l+p-(l\mod{p})$ 。</p>

<h5 id="样例代码-1">样例代码</h5>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_seg_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nf">e_sive</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">delta</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">seg</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">delta</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">i</span><span class="o">..=</span><span class="n">delta</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">seg</span><span class="nf">.set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">delta</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">yield</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">seg</span><span class="nf">.set_all</span><span class="p">();</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="复杂度分析-1">复杂度分析</h5>

<p>这样主要辅助空间是两个 $\sqrt{n}$ bit 的数组，因此空间复杂度为 $O(\sqrt{n})$ 。而当分段大小为 $\sqrt{n}$ 时，总的时间复杂度仍然是 $O(n\log\log n)$ ，实际上分段筛选和原始算法的区别就像 BFS 和 DFS 。</p>

<h4 id="增量生成">增量生成</h4>

<p>事实上我们应用在分段代码上的方法也可以直接用来无限生成质数，当已知 $\leqslant n$  的质数时，一轮最多可以计算到 $\leqslant n^2$ 范围的质数。</p>

<h3 id="轮筛">轮筛<sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">14</a></sup></h3>

<p>比起 E-筛子通过求合数然后通过补集来获得质数，<strong>轮筛</strong>则是通过使用一个合适的轮子来直接获得质数。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>或者另一种说法，只能被 $1$ 和 它自己整除的数字。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>记作 $a \perp b$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>$1$ 和 $-1$ 是唯一的两个和所有数都互质的数，也是唯一和 $0$ 互质的数；除了 $1$ 以外，自己与自己不互质。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Euclid’s lemma，以下简称欧式引理 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>除，divide， $p$ 能被除 $a\cdot b$ 也即 $a\cdot b$ 能被 $p$ 整除，记作 $p| a\cdot b$ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>反证法，若 $n\not\perp a-n$ ，则 $n \not\perp a-n + n$ ，与前提条件相悖。 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Fundamental theorem of arithmetic，也可以形象地叫做正整数唯一分解定理，某种程度我更倾向于这个名字，因为这个名字一点儿都不故弄玄虚，是自解释的，但是作为章节标题它有点儿长了 :(，其他名字还有 Unique factorization theorem、 Prime factorization theorem etc. 。 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>还有更复杂的经验算法、概率测试算法、快速确定性测试算法等一系列计算较为复杂的方法 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>在现代编程语言里应该有名字诸如 <code class="language-plaintext highlighter-rouge">isqrt</code> 的数学函数来实现向下取整的平分根计算。 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>$c\sharp$ 指得是质数的阶乘（primorial），它可以指所有小于等于正整数 $c$ 的质数的乘积。对它的估算是 $c\sharp \leqslant 4^n$ ；不过还存在另一个模糊易混淆的定义：$p_n\sharp$ ，指得是到第 $n$ 个质数为止（包含 $p_n$ ）的质数乘积。 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>$2, 3$ 前面在前面作为快速失败的优化已经提前测过，$4$ 是 $2$ 的倍数直接跳过，于是从 $5$ 开始检测。 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>实质上是查找 $[2\dots n]$ 范围内的所有质数。 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>G. H. Hardy and E. M. Wright. An Introduction to the Theory of Numbers. Oxford University Press, 5th edition, 1979 <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>Wheel Sieve <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[本文主要参考：]]></summary></entry><entry><title type="html">LeetCode Packet 2</title><link href="/oth/LeetCodePacket2.html" rel="alternate" type="text/html" title="LeetCode Packet 2" /><published>2023-12-25T00:00:00+08:00</published><updated>2023-12-25T00:00:00+08:00</updated><id>/oth/LeetCodePacket2</id><content type="html" xml:base="/oth/LeetCodePacket2.html"><![CDATA[]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">0174 - Dungeon Game</title><link href="/oth/LeetCode0174.html" rel="alternate" type="text/html" title="0174 - Dungeon Game" /><published>2023-12-11T00:00:00+08:00</published><updated>2023-12-11T00:00:00+08:00</updated><id>/oth/LeetCode0174</id><content type="html" xml:base="/oth/LeetCode0174.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/dungeon-game/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>绝对标准地 <em>Hard</em> 难度的问题。</p>

<p>给一个二维的地图，从左上角走到右下角，看起来非常像之前做过的譬如 <a href="/oth/LeetCode0085.html">0085 - Maximal Rectangle</a> 这样的题目，只需要从上到下地逐行扫描，计算从起点到每一行的每个位置的子问题的解，直到最后一行的最后一个位置。</p>

<p>但是对于本题这样做是不行的，因为一般到某个位置的路线有两条，一条是从上到下的，一条是从左到右的，而有两个指标用来选择最小生命值的路线，一个是到当前位置为止整个路径上出现过的路径和的最小值，另一个是到当前位置的路径和。这两个指标可能是矛盾的，比如有一条路线的最小值较大但是路径和较小，导致选择该路线最终在后面得到了较小的最小值，从而得到了不正确的结果。</p>

<p>换句话说，前面的子问题的路线选择受后面位置数值的影响，这个 DP 的解法存在<strong>后效性</strong>，因此这个解法是不能成立的。</p>

<p>这样问题就陷入了困局，实际上我花了几天的时间去考虑这个题，终于发现我们可以从终点开始做 DP 这样就避开了后效性的问题，于是引入了新的 DP 思路：<strong>后效翻转</strong> 。</p>

<p>对于这道题来说，子问题变成从前面的位置到终点的最小生命值，这样从后向前找，路线的选择是确定的，只需要比较两条路线：下方和右方对应的解，选较大的即可，而当前位置子问题的解则是比较</p>

<ol>
  <li>后面的解加上当前位置值；</li>
  <li>当前位置的值，取这两个的最小值</li>
</ol>

<p>顺带一讲，这个解应该是路径上的最小值，而路径的选择是让这个路径最小值取到最大，这样才可以付出最小生命。最后的最小生命就是把这个最小值取反，比较它与零的大小，取一个最大值，把结果加上 1 ，这样保证最后至少有一点生命值。</p>

<h2 id="解迭代版本">解①迭代版本：</h2>

<p>或者说 BFS，比起递归版本，这个版本通常有更多地细节去深入。</p>

<p>这个解法的复杂之处在于需要考虑下受地图矩形的长度和宽度两个因素限制的坐标位置，特别是如果我们想要用一维数组来存储子问题解的话。</p>

<p>计算的整个过程是从终点倒退回起点，计算每一步可到位置的子问题解，就如下图所示：</p>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map1.svg" style="zoom:150%;" /></div>

<p>灰色线连起来的区域就是每一步可能到达的位置，这里用步数作为控制流程的变量，并为了方便以终点为原点建立坐标系，等到访问 <code class="language-plaintext highlighter-rouge">dungeon</code> 数组（以下简写作 $D$ ）时再把坐标转换为以左上角为原点的坐标系。</p>

<p>这样地话，对于 $m$ 行 $n$ 列的 $D$ 数组 假设当前步数是 $l$ ，那么</p>

<p>能够到达的最大的高度 $h=\min(m,l)$ ，最大宽度 $w=\min(n,l)$ 。</p>

<p>因此在当前步数的从左下到右上的可达范围里</p>

<p>左下位置 $(x_0,y_0): (l-w+1,w)$ ，右上位置 $(x_1,y_1): (h, l-h+1)$ 。</p>

<p>这样的话，每一步的位置范围就是从 $x_0 \rightarrow x_1$ ，记录下它的差 $d_\text{max} = x_1-x_0$ ，可以用来指示当前步数最后一个位置的在一维数组里的下标。</p>

<p>由于每步的位置数并不相同，因此交替使用两个一维的数组（$\text{low}_1$ 和 $\text{low}_0$）来存储当前步数和之前步数的子问题解，而解的计算要根据所处位置分为三个阶段、四种情况。三个阶段是随着步数的增加会出现的，矩形长宽都没有限制的<strong>前场</strong>、较短一维限制而较长一维没有限制的<strong>中场</strong>，以及两个维度都被限制的<strong>后场</strong>。</p>

<h3 id="1-矩形前场">1. 矩形前场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map5.svg" style="zoom:120%;" /></div>
<p><br /></p>

<p>矩形前场就是在从终点开始的扫描过程中，随着步数增加，$h$ 和 $w$ 增加的情况。此时最左下角只能从它的右方得到，右上角只能从它的下方得到，其余位置都可以从两边得到。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\lt d_\text{max})
\end{array}
\right.\]

<h3 id="2-宽矩形中场">2. 宽矩形中场</h3>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map2.svg" style="zoom:120%;" /></div>
</p>
<p>所谓中场，就是随着步数增加，$d_\text{max}$ 却保持不变的阶段，是在步数超过较短一维的长度时进入而在步数达到较长一维的长度时退出的一个阶段。
\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l} 
\text{low}_0[0]&amp; (i=0) \\
\left 
\{\begin{array}{l}
\text{low}_0[d-1]\\ \text{low}_0[d]
\end{array}
\right. &amp;(0\lt i\leqslant d_\text{max})
\end{array}
\right.\)</p>

<h3 id="3-高矩形中场">3. 高矩形中场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map3.svg" style="zoom:120%;" /></div>
<p>\(\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d_\text{max}-1] &amp;(i=d_\text{max})\\
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\lt d_\text{max})
\end{array}
\right.\)</p>

<h3 id="4-矩形后场">4. 矩形后场</h3>

<div class="sx-center">
<img src="/assets/img/leetcode0174/rec_map4.svg" style="zoom:120%;" /></div>

<p>后场就是当中场结束时，也就是步长超过较长一维时进入的阶段。</p>

\[\text{low}_1[i] \leftarrow 
\left 
\{\begin{array}{l}
\text{low}_0[d]\\ \text{low}_0[d+1]
\end{array}
\right. &amp;(0\leqslant i\leqslant d_\text{max})\]

<p>于是我们便得到了代码。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">low0</span> <span class="o">=</span> <span class="p">[</span><span class="n">dungeon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">low1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">tot</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">l</span><span class="o">-</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">d_max</span> <span class="o">=</span> <span class="n">x1</span><span class="o">-</span><span class="n">x0</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 矩形前半场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 宽矩形中间场
</span>            <span class="n">low1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">y1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 高矩形中间场 (x0 != 1)
</span>            <span class="n">low1</span><span class="p">[</span><span class="n">d_max</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> <span class="n">low0</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 矩形后半场
</span>            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">y0</span><span class="o">-</span><span class="n">d</span>

                <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">low0</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low1</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="n">x</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="p">]</span>

        <span class="n">low0</span><span class="p">,</span> <span class="n">low1</span> <span class="o">=</span> <span class="n">low1</span><span class="p">,</span> <span class="n">low0</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">low0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：69 ms (beats 81.50%, ~100%, 55 ms)，内存占用：17.5 MB (beats 63.73%, ~100%)。</p>

<h2 id="解">解②：</h2>

<p>或者说 DFS。</p>

<p>在上面的迭代版本或者BFS版本里，不管是分析还是代码都显得有些冗长，这主要是因为我们不愿意直接把判断放在循环里，而要弄清楚所有的过程细节，而对于递归版本，可以很简单地实现。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">dungeon</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dungeon</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dungeon</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：78 ms (beats 39.60%, ~100%)，内存占用：20.21 MB (beats 5.06%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0152 - Maximum Product Subarray</title><link href="/algs/LeetCode0152.html" rel="alternate" type="text/html" title="0152 - Maximum Product Subarray" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/LeetCode0152</id><content type="html" xml:base="/algs/LeetCode0152.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-product-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p>经典 <em>Medium</em> 但是 <em>Hard</em> ，这道题单独看可以算作 Medium 类型的题目，但是作为 DP 标签就显得很 Hard，因为题目和一般的 DP 思路好像有关系，实质是没有关系，如果再类比 <a href="/algs/LeetCode0053.html">0053 - Maximum Subarray</a> 的思路那就更困难了，难就难在干扰项。</p>

<p>同样也是正、负、零三种整数，而累积和累和的区别在于累积的符号会翻转而且幅度越来越大，最大数可以由正数乘积得到，或者负数的乘积遇到负数翻而来。</p>

<h2 id="解常规">解①常规：</h2>

<p>用 $0$ 把数组分段，按照负数的数量分情况讨论：</p>

<p>$=0$：直接累乘</p>

<p>$=1$：比较两边的正数的累积结果，</p>

<p>$=2$：直接累积</p>

<p>$\geqslant$ 3：</p>

<p>​	3.1. 奇数，比较从第一个负数后的正数开始乘到尾和从头开始乘到最后一个负数前的正数；</p>

<p>​	3.2. 偶数，累乘</p>

<p>这样只需要记录负数的坐标（不需要记全，对于超过了两个的，只需要记录第一个和最后一个负数的坐标即可）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neg</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">-</span><span class="n">zero</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#  i-zero &gt; 2
</span>                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand1</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cand2</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cand1</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">zero</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">neg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="n">cand2</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">neg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

            <span class="n">zero</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">neg</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">cand</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">cand</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：76 ms (beats 78.56%, ~100%)，内存占用：16.2 MB (beats 99.98%)。</p>

<h2 id="解正负值">解②正负值：</h2>

<p>可以在一遍的过程中计算这些数，只需要两个变量来存储状态，pos 表示最大的正数，neg 表示最小的负数（或者绝对值最大的负数。</p>

<p>这两个变量代表的子数组拥有相同的后缀，也就是扫描到的位置。</p>

<p>在开始或者遇到 $0$ 时，pos 和 neg 都设为 None，如果在 None 的时候遇到同符号的数值时，赋值给它们，否则就继续累乘；如果不为 None 则当遇到反符号的时候，就给反符号赋值（注意保存被覆盖的值，这时分组赋值就很合适）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">*=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">neg</span> <span class="o">*=</span> <span class="n">v</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">neg</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">v</span>

                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：73 ms (beats 88.24%, ~100%), 内存占用：16.95 MB (~100%)。</p>

<h2 id="解前后缀">解③前后缀：</h2>

<p>由于实际上的差异只是由，也可以不考虑正负值的变化情况，直接从前缀和后缀两个方向计算累乘，当发现累积归为 0 时，就改乘为赋值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">postfix</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">postfix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">postfix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：80 ms (beats 54.67%, ~100%)，内存占用：16.76 MB (~100%)。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">最大子数组</title><link href="/algs/MaxSubArr.html" rel="alternate" type="text/html" title="最大子数组" /><published>2023-11-17T00:00:00+08:00</published><updated>2023-11-17T00:00:00+08:00</updated><id>/algs/MaxSubArr</id><content type="html" xml:base="/algs/MaxSubArr.html"><![CDATA[<p>收集一系列有关最大子数组的问题。</p>

<h2 id="最大子数组和"><a href="/algs/LeetCode0053.html">最大子数组和</a></h2>

<h2 id="最大子数组积"><a href="./LeetCode0152">最大子数组积</a></h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[收集一系列有关最大子数组的问题。]]></summary></entry><entry><title type="html">1458 - Max Dot Product of Two Subsequences</title><link href="/algs/LeetCode1458.html" rel="alternate" type="text/html" title="1458 - Max Dot Product of Two Subsequences" /><published>2023-10-17T00:00:00+08:00</published><updated>2023-10-17T00:00:00+08:00</updated><id>/algs/LeetCode1458</id><content type="html" xml:base="/algs/LeetCode1458.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.20/1458_max_dot_prod_of_two_seq/py1458">源代码</a></p>

<p>一般地<a href="/algs/TwoStrDP.html">两串上的DP</a>是从两个前缀子串开始的更小规模的问题扩展到全串，从而直接解决题目要求的问题，而本题特殊的地方是子序列并不是完整的前缀子串。</p>

<p>不妨把前缀子串视为 border，而譬如子序列则是  content ，它和 border之间有 padding ，其他普通的问题可以通过 border 就可以直接计算出来，而对于子序列这样的问题，需要额外考虑是否需要“填充” padding。</p>

<p>“padding” 的引入让问题稍微复杂了一点，但主要还是干扰了我们破题的思路，如果我们能把保持一个清晰的思路，解题还是很容易的。</p>

<h2 id="第一版">第一版：</h2>

<p>因为乘积存在负数，并且不允许空的点积序列，因此先排除乘积全是负数的情况。</p>

<p>之后在 DP 过程中只需要考虑是否把非负的乘积加进来即可，这也暗示了“padding”的判断方法：只有正的乘积会被加进来，负的会被视为“padding”跳过。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\
    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
        <span class="k">return</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nums2</span><span class="p">))</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>282 ms (beats 82.09%), 19.02 MB (beats 66.24%)</p>

<h2 id="改进">改进：</h2>

<ol>
  <li>采用了一个稍微更好一点的对于乘积全是负数的情况的判断方法，取两个极值进行比较，但是因此要分两种情况进行判断；</li>
  <li>按照前面滚动数组的思路讲空间占用压缩到一维；</li>
  <li>合并了 DP 核心算法里的分支判断</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">nums1_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_max</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_max</span> <span class="o">*</span> <span class="n">nums2_min</span>

    <span class="n">nums1_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">nums2_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nums1_min</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums2_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nums1_min</span> <span class="o">*</span> <span class="n">nums2_max</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>183 ms (beats 95.32%), 16.34 MB (beats 92.92%, ~100%)</p>

<h2 id="另版">另版：</h2>

<p>还有一点稍稍不同思路的是把全负乘积考虑进一般情况，但是对于压缩的 DP 数组来说，需要额外处理初始值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
        <span class="n">nums1</span><span class="p">,</span> <span class="n">nums2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
    <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">pre0</span><span class="p">,</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">pre1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>189 ms (beats 95.32%), 16.29 MB (beats 97.06%, ~100%)</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Best Time to Buy and Sell Stock</title><link href="/oth/LeetCodeBuySellStock.html" rel="alternate" type="text/html" title="LeetCode Best Time to Buy and Sell Stock" /><published>2023-10-01T00:00:00+08:00</published><updated>2023-10-01T00:00:00+08:00</updated><id>/oth/LeetCodeBuySellStock</id><content type="html" xml:base="/oth/LeetCodeBuySellStock.html"><![CDATA[<h2 id="0121-best-time-to-buy-and-sell-stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">0121. Best Time to Buy and Sell Stock</a></h2>

<p><em>Easy</em></p>

<p>单次交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0122-best-time-to-buy-and-sell-stock-ii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">0122. Best Time to Buy and Sell Stock II</a></h2>

<p><em>Medium</em></p>

<p>不限次数交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0123-best-time-to-buy-and-sell-stock-iii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">0123. Best Time to Buy and Sell Stock III</a></h2>

<p><em>Hard</em></p>

<p>限制两次交易</p>

<h3 id="破题">破题</h3>

<p>题目的复杂程度终于提升到了有点儿意思的程度，这里的关键是搞清楚“最多两次”交易的限制条件到底对我们的模型意味着什么？</p>

<p>可以认为，做两次交易的收益总是不差于一次交易，只要在计算模型上把一次交易视为两次交易的边缘值。</p>

<h3 id="解两遍扫描">解①两遍扫描</h3>

<p>把价格表分为两部分，左边用于第一次交易，右边用于第二次交易，这样只需要检查每个位置的两次交易之和，求一个最大值即可。可以让左边分割的串从空串开始，这样就包含了一次交易的情况。</p>

<p>每次分割的左边串的最大收益可以依靠前面 <a href="#0121-best-time-to-buy-and-sell-stock">0121. Best Time to Buy and Sell Stock</a> 来计算，而分割的右边串则可以预先运用同样的算法反向扫描，保存个位置的计算结果，在从左开始扫描的时候查询表即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


    <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：760 ms (beats 98.06%)，内存占用：30.5 MB (beats 72.56%, ~100%)</p>

<h3 id="解规范解">解②规范解</h3>

<p>在上一个解的时候，我们通过组合单次求解的方法来计算两次交易得到的最大收益，而这个单次求解的方法好像扫描一个个位置就可以进行该位置的更新，（因为当天交易收益总是零，因此是否允许当天交易都不重要），这暗示我们很可能有一个扫描每个位置就可以计算出两次交易的最大收益的模型。</p>

<p>这才引出对股票买卖问题的统一模型：</p>

<p>累积计算每次买或卖的收益，买的收益是 $-\text{price}$ ，卖的收益是买的收益加上 $\text{price}$ ，下次交易的收益基础是之前的收益。</p>

<p>对于两次买卖就有：</p>

\[\begin{align}
\text{buy}_1 &amp;= \max(\text{buy}_1',\text{-price})\\
\text{sell}_1 &amp;= \max(\text{buy}_1',\text{price})\\
\text{buy}_2 &amp;= \max(\text{sell}_1',\text{-price})\\
\text{sell}_2 &amp;= \max(\text{buy}_2',\text{price})\\
\end{align}\]

<p>也就是：$\text{buy}_1 \rightarrow \text{sell}_1 \rightarrow \text{buy}_2 \rightarrow \text{sell}_2$</p>

<p>有必要解释下，按照自然流程，两次交易至少应该是第一天 $\text{buy}_1$ ，第二天 $\text{sell}_1$ ，第三天 $\text{buy}_2$，第四天 $\text{sell}_2$，是一个 $4$ 天的窗口，但是这需要额外检查下数据长度，而把这些操作压缩到一天，并不影响结果，而且可以适应长度不足 $4$ 的情况。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy1
</span>    <span class="n">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy2
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">buy1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell1</span> <span class="o">&lt;</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell1</span> <span class="o">=</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span>
        <span class="k">if</span> <span class="n">buy2</span> <span class="o">&lt;</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy2</span> <span class="o">=</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell2</span> <span class="o">&lt;</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell2</span> <span class="o">=</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell2</span>
</code></pre></div></div>

<p>运行时间：670 ms (beats 99.76%)，内存占用：30.5 MB (beats 88.72%, ~100%) 。</p>

<p>这个统一模型在一遍扫描就解决了问题，并且省掉了前面的 $O(n)$ 的内存占用<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> 。</p>

<h2 id="0188-best-time-to-buy-and-sell-stock-iv"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">0188. Best Time to Buy and Sell Stock IV</a></h2>

<p><em>Hard</em></p>

<p>上面问题的一般化，不是限制两次交易，而是给定的参数 $k$ 次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># buy[i] - sell[i+1]
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
                <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span>
            <span class="k">elif</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
                <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：59 ms (Beats 99.16%, ~100%)，内存占用：16.36MB (Beats 82.07%，~100%)。</p>

<h2 id="0309-best-time-to-buy-and-sell-stock-with-cooldown"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">0309. Best Time to Buy and Sell Stock with Cooldown</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有冷冻期</p>

<h3 id="破题-1">破题</h3>

<p>购买冷冻期机制的引入改变了整个的模型，使得我们不能像前面的那个无限次数交易那样简单统计所有增量，就可以得到答案。</p>

<p>如果遵循股票买卖整个系列的顺序来做题，题解可能格外困难，因为很容易受到前面解题思路的影响，而重构整个模型并没有那么直观，因此我认为应该把这道题标记为 Hard 难度。</p>

<p>因此，让我们先从最简单地、最基本地方法开始：一个基于递归，使用记忆化优化的，穷举所有可能的解决方法。</p>

<h3 id="解递归记忆化">解①递归记忆化</h3>

<p>逐个读取价格表，分两个模式：等待购入和等待卖出。下面分别用 $\text{Buy}$ 和 $\text{Sell}$ 表示这两个模式，在 $\text{Buy}$ 模式下有两种选择：在当前价格日卖出和下一天再说，同样地 $\text{Sell}$ 模式也有两种选择，以当前价格卖出和下一天再说。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">Buy</span> <span class="o">=</span> <span class="n">auto</span><span class="p">(),</span>
    <span class="n">Sell</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">recur</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：52 ms (beats 44.28%, ~100%)，内存占用：21.06 MB (beats 31.05%)。</p>

<h3 id="解迭代dp">解②迭代DP</h3>

<p>上面的递归实现，可以帮助我们理清普通 DP 版本的实现思路。</p>

<p>对于交易有限次数的股票模型，可以穷举所有所有轮次买和卖的状态，但是对于不限次数的模型，则不能这样穷举，只能区分买和卖，不能辨别轮次。</p>

<p>尝试从正面看这个问题，分别用 <code class="language-plaintext highlighter-rouge">buy</code> 和 <code class="language-plaintext highlighter-rouge">sell</code> 两个数组代表一个前缀价格串上的最后操作是买或卖带来的最大收益。</p>

<p>这样，</p>

<ol>
  <li>
    <p>买的最大收益是要比较前一天买的最大收益（意味着当前没有买卖）以及包含冷冻期在内的卖的最大收益加上当前价格；</p>
  </li>
  <li>
    <p>卖的最大收益则是前一天卖的最大收益（意味着当前没有买卖）或者前一天买的最大收益加上当前价格（当前卖出）</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：36 ms (beats 98.07%, ~100%)，内存占用：16.39 MB (beats 99.34%) 。</p>

<p>当然，仔细观察代码，会发现 $O(n)$ 的内存占用是不必要的，实际上只需要维护三个持久变量：$\text{buy}_0$, $\text{buy}_1$ 和 $\text{sell}_0$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">buy0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy0</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sell0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy1</span><span class="p">,</span> <span class="n">sell0</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell0</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">sell0</span> <span class="o">=</span> <span class="n">sell1</span>
        <span class="n">buy1</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">=</span> <span class="n">buy2</span><span class="p">,</span> <span class="n">buy1</span>

    <span class="k">return</span> <span class="n">sell0</span>
</code></pre></div></div>

<p>运行时间：45 ms (beats 79.16%, ~100%)，内存占用：16.56 MB (beats 87.33%. ~100%) 。</p>

<h2 id="0714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">0714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有交易费</p>

<h3 id="解状态dp">解①状态DP</h3>

<p>直接按照前面交易冻结日的股票交易模型，易得</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">,</span> <span class="n">sell</span><span class="o">-</span><span class="n">price</span><span class="p">)</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">,</span> <span class="n">buy</span><span class="o">+</span><span class="n">price</span><span class="o">-</span><span class="n">fee</span><span class="p">)</span>

        <span class="n">buy</span> <span class="o">=</span> <span class="n">buy1</span>
        <span class="n">sell</span> <span class="o">=</span> <span class="n">sell1</span>

    <span class="k">return</span> <span class="n">sell</span>
</code></pre></div></div>

<p>运行时间：566 ms (beats 77%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h3 id="解贪心">解②贪心</h3>

<p>但是还是有方法利用像 <a href="#0122-best-time-to-buy-and-sell-stock-ii">0122. Best Time to Buy and Sell Stock</a> 问题那样直接地算法来解决。</p>

<p>只需要把交易费用加在购入价格上即可。</p>

<p>注意这里的 $\text{buy}$ 区别于分状态 DP 问题里面的  $\text{buy}$ ，它表示得不是购入的最大收益，而是最低价格。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">fee</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span> <span class="o">+</span> <span class="n">fee</span>
        <span class="k">elif</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="n">buy</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">price</span><span class="o">-</span><span class="n">buy</span>
            <span class="n">buy</span> <span class="o">=</span> <span class="n">price</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：495 ms (beats 99.5%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>虽然形式上压缩到了一天，但是我们的计算公式也暗示，实际上不可能同时更新，实质上全部更新还是至少需要四天，对于一次交易也至少需要两天 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>虽然在测试上也看不这个内存节省的区别来，但毕竟是 Python 嘛，内存模型并不节省 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[0121. Best Time to Buy and Sell Stock]]></summary></entry><entry><title type="html">0115 - Distinct Subsequences</title><link href="/oth/LeetCode0115.html" rel="alternate" type="text/html" title="0115 - Distinct Subsequences" /><published>2023-09-30T00:00:00+08:00</published><updated>2023-09-30T00:00:00+08:00</updated><id>/oth/LeetCode0115</id><content type="html" xml:base="/oth/LeetCode0115.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/distinct-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.18/0115_distinct_subseq/py0115">源代码</a></p>

<p>判断一个串的所有（非连续）子序列里，等于目标串的数量。</p>

<p>这里要特别关注<strong>解3：子序列的窗口范式</strong></p>

<h2 id="解正解">解①正解：</h2>

<p>这个是最直接的推导思路，考虑 $s$ 的前缀从 $s[..0]$ 逐个增加字符直到 $s[..n]$ ，观察对样本串 $t$ 它的前缀随之的变化。</p>

<p>假设增加了一个字符 $x$ ，那么对于样本串 $t$ ，所有出现 $x$ 的位置的前缀都会因此受到影响。</p>

<p>假设 $x$ 出现在 $t$ 的所有位置是 P，则有 $\text{dp}[P] := \text{dp}[P] + \text{dp}[P-1]$，也就是 $x$ 前面的前缀会因为 $x$ 的加入，而使得包含 $x$ 的前缀数量增加。特别地，当 $t$ 的前缀是空串的时候，设定值总是为 $1$ ，这样可以方便统一地计算。</p>

<p>那么该如何计算出 $x$ 出现在 $t$ 的所有位置呢，正好字符集很小（大小写字母），直接用列表保存最节省内存，可以在对 $t$ 的一遍扫描过程中把坐标加进对应字符的坐标列表里。</p>

<p>于是得到了下面的实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>
        <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">pre_v</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pre_i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">c_i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">pre_i</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre_v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">pre_v</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">pre_i</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>有几点需要特别说明的：</p>

<h4 id="1-快速失败地优化">1. 快速失败地优化</h4>

<p>譬如</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>这样的代码，几乎总是可以明显提高我们的运行表现，为一些应该很优，但由于 Python 匮乏地运行时优化而表现一般地实现挽尊：—— 。</p>

<h4 id="2-dp-数组的特异处">2. DP 数组的特异处</h4>

<p>从代码上乍看起来，这里的 $\text{dp}$ 数组和之前那些一般的 $\text{dp}$ 数组是一样的，我们只是照样把二维压缩到一维。</p>

<p>但这里特别地是，从计算过程上看，每一行并不是所有的数据都会被更新，没有被计算的数据应该继承自上一行，而不是被置为一个固定的初始值。</p>

<p>这样使用二维不仅浪费空间，而且并不方便，使用一维的空间，总是更好的选择。</p>

<h4 id="3-一维地实现">3. 一维地实现</h4>

<p>同样地，在使用压缩地 $\text{dp}$ 数组时，为了避免数据被覆盖，需要提前保存上一行的前一个位置的数据，但是我们预计算的位置并不一定是连续的，因此需要进行判断。对于不连续的位置，就不会存在数据覆盖的问题。</p>

<p>运行时间 94 ms (beats 92.81%)，内存占用：16.46 MB (beats 96.82%, ~100%) 。</p>

<h2 id="解递归迭代">解②递归+迭代：</h2>

<p>实际上如果我们理解了解①，那么可以把它转换成我们更熟悉地 $\text{dp}$ 实现。</p>

<p>只要考虑：</p>

<ol>
  <li>要么当 $s$ 的前缀拓展一个字符时，$t$ 也拓展一个字符，这只当 s 和 t 拓展的字符相等时才可以；</li>
  <li>要么无条件地跳过当前字符，也就是 $s$ 拓展字符，但是 $t$ 不拓展</li>
</ol>

<p>这样当：</p>

<ol>
  <li>$s$ 的长度小于 $t$ 时，当然返回 $0$；</li>
  <li>而当 $s$ 长度等于 $t$ 时，进行比较，返回 $1$ 或者 $0$；</li>
  <li>当 $m$ 长度为 $0$ 时，也就是递归的一般返回点，或者说初试情况，返回 $1$</li>
</ol>

<p>递归地版本最简洁，表现也最好：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p>运行时间：70 ms (beats 93.39%)，内存占用：34.2 MB (beats 72.33%) 。</p>

<p>迭代的版本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：95 ms (beats 92.78%)，内存占用：16.5 MB (beats 96.74%) 。</p>

<h2 id="解另一个范式">解③另一个范式：</h2>

<p>这里要介绍得是规模递增的另一个范式，很少提到，但是由于有更好地迭代次数，是最快的实现。</p>

<p>对于上面的一般思路来说，是增加 $s$ 的前缀的字符，把问题规模一步步拓展到全局，而对于子序列地匹配，还可以这样考虑：</p>

<p>每一个文本串 $s$ 上面可以匹配目标串 $t$ 的子序列都可以看做，由某些在 $s$ 上的 $t$ 长度模式的对应位置字符构成。</p>

<p>这些构成 $t$ 的子序列的字符可以是连续的，也就是在同一个模式上，也可以不连续，那就是在不同的模式上。</p>

<p>这看起来就像是一个固定窗口在 $s$ 上滑动，探寻窗口对应位置的字符与 $t$ 上对应字符是否相等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="tips">Tips：</h3>

<ol>
  <li>由于在外循环固定减少了 $m$ 长度的轮次，因此是相比上述更快的一个实现；</li>
  <li>同时快速失败地优化也被省略掉了，因为已经不能提升它的表现了</li>
</ol>

<p>运行时间：44 ms (beats 99.44%, ~100%)，内存占用：16.29 MB (beats 99.85%, ~100%) 。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0087 - Scramble String</title><link href="/oth/LeetCode0087.html" rel="alternate" type="text/html" title="0087 - Scramble String" /><published>2023-09-19T00:00:00+08:00</published><updated>2023-09-19T00:00:00+08:00</updated><id>/oth/LeetCode0087</id><content type="html" xml:base="/oth/LeetCode0087.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/scramble-string/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.17/0087_scramble_str/py0087">源代码</a></p>

<p>因为这道题是 3k点赞，1k点踩， 于是看了下评论，结果为我的解题带来了非常大的负面影响：有一个评论里讲什么这道题的题解非常困难，但是用4套嵌套循环实现非常简单，这一直影响我的思路。</p>

<p>然而实际上这只是一道普通的 Top-down DP，或者说，记忆化搜索就可以通过的题目。</p>

<p>另外让人不爽地是这个文本：“<strong>Randomly</strong> decide to swap the two substrings……” ，随机地决定这种说法就很误导，让人搞不清问题到底是个什么类型的问题。</p>

<p>实际上这个问题很简单，把串按位置划分，从 $1\dots n-1 $，确保得到的两个子串的长度至少为 $1$；</p>

<p>而这两个子串有两种可能：保持原序或者颠倒顺序；</p>

<p>然后试着对子串继续应用这个划分，直到子串的长度为 $1$ 。</p>

<p>最终目的是检查 $s_1$ 能否变换到 $s_2$ 。</p>

<h2 id="解">解①：</h2>

<p>这个问题天然地适合利用递归解决，只不过可以通过保存一些中间结果来进行优化。</p>

<p>具体说就是遍历每一个划分子串的位置，然后对划分后的两种情况：原序和反序，分别进行判断。</p>

<p>对于原序，就是检查较小规模地同一问题 $s_1[0..i-1]$ 能够变换到 $s_2[0..i-1]$ ；以及 $s_1[i..n-1]$ 能够变换到 $s_2[i..n-1]$ ；</p>

<p>对于反序，就是检查$s_1[0..i-1]$ 能够变换到 $s_2[n-i..n-1]$；以及 $s_1[i..n-1]$ 能够变换到 $s_2[0..n-i-1]$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="p">:])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[:</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>特别地，这里检查了字符集合是否相等，作为一个快速失败地（预测）优化<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<p>运行时间：58 ms (beats 78.15%, ~100%)，内存占用：17.9 MB (beats 36.12%, ~100%)。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>而用 <code class="language-plaintext highlighter-rouge">sorted</code> 比 <code class="language-plaintext highlighter-rouge">set</code> 明显要快，对于本题的最终结果的影响是差了 20 ms 。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry></feed>