<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-09-10T10:37:43+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">Rust 包内资源管理</title><link href="/lang/RustResourceCode.html" rel="alternate" type="text/html" title="Rust 包内资源管理" /><published>2024-12-10T00:00:00+08:00</published><updated>2024-12-10T00:00:00+08:00</updated><id>/lang/RustResourceCode</id><content type="html" xml:base="/lang/RustResourceCode.html"><![CDATA[<h2 id="问题引入">问题引入</h2>

<p>有时候在一个 Cargo package/workspace 需要放一些供内部使用的非代码文件，这些文件往往是从硬编码的代码里分离出来的，变成可配置的文件，比如测试数据。</p>

<p>这时候就需要这些资源文件进行管理，传统的方法是把每一个从目录到文件的名字作为常量（<code class="language-plaintext highlighter-rouge">&amp;'static str</code>）写到一个专门定义常量的文件里，但这样至少有三个缺点：</p>

<ol>
  <li>没有目录层次，如果在名字上加目录前缀，就会让名字特别长，严重影响人机交互，不加目录前缀就会让人用起来一头雾水，还会导致命名冲突；</li>
  <li>虽然单个目录或文件的名字是常量，但它们之间的层次关系仍然需要手动组合，这根本不能说是一种完备的资源管理方法，而且本身的这种组合字符串变成 <code class="language-plaintext highlighter-rouge">Path</code> ，然后在进行文件读取的冗余代码实在令人恶心，破坏了美感；</li>
  <li>代码和资源文件之间缺乏耦合，如果资源文件发生了改变，那么拼接常量字符串的一端根本就无从得到。</li>
</ol>

<p>从这些缺点里总结出我们对资源管理“工具”的需求：它应该是结构化的、具有语义感知功能的一个“东西”。</p>

<h2 id="分析和设计">分析和设计</h2>

<p>从设计哲学的角度我们考虑，这个“东西”应该是代码与数据之间的“粘合剂”，它不应该是纯粹的代码，也不可能是纯粹的数据，它应该有“二相性”，而 Rust 本身是高度类型化的语言，任何结构化的信息都可以通过一个 Structure / Enum 来表现，那么首先我们考虑使用一个动态定义的结构体来表现一个目录或者文件；进一步地，对于表示目录的结构体应该是嵌套定义的，然后通过 <code class="language-plaintext highlighter-rouge">.</code> 访问层级目录。</p>

<p>这样的话显然手写这样的结构体太反人体工学了，需要一个宏来辅助工作，而且这个宏应该是以一种配置语言比如 Json 的形式使用，才能尽可能直观、简单和便于维护。</p>

<p><em>当然递归定义给宏的实现带来了麻烦，但我们相信总是能实现的，所以先不管这些。</em></p>

<h2 id="配置和使用">配置和使用</h2>

<h3 id="配置示例">配置示例</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">resources!</span> <span class="p">{</span>
    <span class="n">graph</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">sp</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">sp_5_csv</span><span class="p">:</span> <span class="s">"sp5.csv"</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="n">test_suites</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">mutable_mapping_toml</span><span class="p">:</span> <span class="s">"mutable_mapping.toml"</span><span class="p">,</span>
        <span class="n">bpt_toml</span><span class="p">:</span> <span class="s">"bpt.toml"</span>
    <span class="p">},</span>
    <span class="n">zh_en_poems_txt</span><span class="p">:</span> <span class="s">"zh_en_poems.txt"</span>
<span class="p">}</span>

<span class="nd">lazy_static!</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">RES</span><span class="p">:</span> <span class="n">Res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nn">Res</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="使用示例">使用示例</h3>

<h4 id="case-1">case-1</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 加载 Toml (String) </span>
  
  <span class="k">let</span> <span class="n">toml_str</span> <span class="o">=</span> <span class="n">RES</span><span class="nf">.test_suites</span><span class="p">()</span><span class="nf">.mutable_mapping_toml</span><span class="p">()</span><span class="nf">.load_to_string</span><span class="p">();</span>
  
  <span class="k">match</span> <span class="nn">TestDataTable</span><span class="p">::</span><span class="nf">deserialize</span><span class="p">(</span><span class="nn">toml</span><span class="p">::</span><span class="nn">Deserializer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toml_str</span><span class="p">))</span> <span class="p">{</span>
      <span class="nf">Ok</span><span class="p">(</span><span class="n">tbl</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">tbl</span><span class="p">,</span>
      <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"{err}"</span><span class="p">),</span>
  <span class="p">}</span>
</code></pre></div></div>

<h4 id="case-2">case-2</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 打开一个 CSV (File)</span>
  
  <span class="k">let</span> <span class="k">mut</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Graph</span><span class="p">::</span><span class="nf">read_from_csv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">RES</span><span class="nf">.graph</span><span class="p">()</span><span class="nf">.sp</span><span class="p">()</span><span class="nf">.sp_5_csv</span><span class="p">()</span><span class="nf">.open</span><span class="p">())</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<h4 id="case-3">case-3</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 读取原始字节 (Vec&lt;u8&gt;)</span>
  
  <span class="k">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">RES</span><span class="nf">.zh_en_poems_txt</span><span class="p">()</span><span class="nf">.load</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="实现预处理宏">实现（预处理宏）</h2>

<h3 id="依赖">依赖</h3>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">proc-macro2</span> <span class="p">=</span> <span class="s">"1"</span>
<span class="py">quote</span> <span class="p">=</span> <span class="s">"1"</span>
<span class="nn">syn</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2"</span> <span class="p">}</span>
<span class="py">derive-syn-parse</span> <span class="p">=</span> <span class="s">"0.2.0"</span>
<span class="py">paste</span> <span class="p">=</span> <span class="s">"1"</span>
<span class="py">derive-quote-to-tokens</span> <span class="p">=</span> <span class="s">"0.1.1"</span>
<span class="py">either</span> <span class="p">=</span> <span class="s">"1.13"</span>
<span class="py">convert_case</span> <span class="p">=</span> <span class="s">"0.6"</span>
</code></pre></div></div>

<h3 id="代码">代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">convert_case</span><span class="p">::{</span><span class="n">Case</span><span class="p">,</span> <span class="n">Casing</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">either</span><span class="p">::{</span><span class="nb">Left</span><span class="p">,</span> <span class="nb">Right</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">proc_macro2</span><span class="p">::{</span><span class="n">Span</span><span class="p">,</span> <span class="n">TokenStream</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">quote</span><span class="p">::{</span><span class="n">quote</span><span class="p">,</span> <span class="n">ToTokens</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">syn</span><span class="p">::{</span><span class="n">Ident</span><span class="p">,</span> <span class="n">LitStr</span><span class="p">};</span>

<span class="k">use</span> <span class="k">crate</span><span class="p">::{</span>
    <span class="n">EitherResourceFileOrResourceDir</span><span class="p">,</span> <span class="n">ResourceDir</span><span class="p">,</span> <span class="n">ResourceFile</span><span class="p">,</span> <span class="n">Resources</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">#[proc_macro]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">resources</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">resources</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">Resources</span><span class="p">);</span>

    <span class="nn">TokenStream</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">quote!</span> <span class="p">{</span> #<span class="n">resources</span> <span class="p">})</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Resources</span> <span class="p">{</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">Punctuated</span><span class="o">&lt;</span><span class="n">EitherResourceFileOrResourceDir</span><span class="p">,</span> <span class="nd">Token!</span><span class="p">[,]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">ResourceDir</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
    <span class="n">colon_token</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[:]</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">brace_token</span><span class="p">:</span> <span class="n">Brace</span><span class="p">,</span>
    <span class="n">fields</span><span class="p">:</span> <span class="n">Punctuated</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">EitherResourceFileOrResourceDir</span><span class="o">&gt;</span><span class="p">,</span> <span class="nd">Token!</span><span class="p">[,]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Parse,</span> <span class="nd">Clone)]</span>
<span class="k">struct</span> <span class="n">ResourceFile</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
    <span class="n">maybe_colon_token</span><span class="p">:</span> <span class="nd">Token!</span><span class="p">[:],</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">LitStr</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">either_wrapper!</span><span class="p">(</span><span class="n">ResourceFile</span><span class="p">,</span> <span class="n">ResourceDir</span><span class="p">);</span>

<span class="nd">macro_rules!</span> <span class="n">ident</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$name:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Ident</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$name</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="nn">Span</span><span class="p">::</span><span class="nf">call_site</span><span class="p">())</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">litstr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$name:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">LitStr</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nn">Span</span><span class="p">::</span><span class="nf">call_site</span><span class="p">())</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">either_wrapper</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$left:ident</span><span class="p">,</span> <span class="nv">$right:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">paste</span><span class="p">::</span><span class="nd">paste!</span> <span class="p">{</span>
            <span class="nd">#[derive(Clone)]</span>
            <span class="nd">#[repr(transparent)]</span>
            <span class="k">struct</span> <span class="p">[</span><span class="o">&lt;</span><span class="nb">Either</span> <span class="nv">$left</span> <span class="n">Or</span> <span class="nv">$right</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">value</span><span class="p">:</span> <span class="nb">Either</span><span class="o">&lt;</span><span class="nv">$left</span><span class="p">,</span> <span class="nv">$right</span><span class="o">&gt;</span>
            <span class="p">}</span>

            <span class="k">impl</span> <span class="n">Parse</span> <span class="k">for</span> <span class="p">[</span><span class="o">&lt;</span><span class="nb">Either</span> <span class="nv">$left</span> <span class="n">Or</span> <span class="nv">$right</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">ParseStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">forked</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.fork</span><span class="p">();</span>

                    <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span>
                        <span class="n">value</span><span class="p">:</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">=</span> <span class="n">forked</span><span class="nf">.parse</span><span class="p">()</span> <span class="p">{</span>
                            <span class="n">input</span><span class="nf">.advance_to</span><span class="p">(</span><span class="o">&amp;</span><span class="n">forked</span><span class="p">);</span>

                            <span class="nf">Left</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="p">{</span>
                            <span class="nf">Right</span><span class="p">(</span><span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">)</span>
                        <span class="p">}</span>
                    <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$left:ident</span><span class="p">,</span> <span class="nv">$right:ident</span> <span class="nv">$</span><span class="p">(,)</span><span class="o">?</span> <span class="o">+</span><span class="n">ToTokens</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">either_wrapper!</span><span class="p">(</span><span class="nv">$left</span><span class="p">,</span> <span class="nv">$right</span><span class="p">);</span>

        <span class="nn">paste</span><span class="p">::</span><span class="nd">paste!</span> <span class="p">{</span>
            <span class="k">impl</span> <span class="n">ToTokens</span> <span class="k">for</span> <span class="p">[</span><span class="o">&lt;</span><span class="nb">Either</span> <span class="nv">$left</span> <span class="n">Or</span> <span class="nv">$right</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">fn</span> <span class="nf">to_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">proc_macro2</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="k">match</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.value</span> <span class="p">{</span>
                        <span class="nf">Left</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">quote!</span> <span class="p">{</span>
                            #<span class="n">left</span>
                        <span class="p">},</span>
                        <span class="nf">Right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">quote!</span> <span class="p">{</span>
                            #<span class="n">right</span>
                        <span class="p">}</span>
                    <span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ToTokens</span> <span class="k">for</span> <span class="n">Resources</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">to_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">braced_content</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{};</span>
        <span class="k">let</span> <span class="n">prefix_name</span> <span class="o">=</span> <span class="s">"Res"</span><span class="nf">.to_string</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">either_file_or_dir</span> <span class="k">in</span> <span class="k">self</span><span class="py">.items</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">def_method</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">either_file_or_dir</span><span class="py">.value</span> <span class="p">{</span>
                <span class="nf">Left</span><span class="p">(</span><span class="n">resfile</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">resource_file</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resfile</span><span class="p">));</span>
                    <span class="nf">def_resource_file_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resfile</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nf">Right</span><span class="p">(</span><span class="n">resdir</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">resource_dir</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resdir</span><span class="p">));</span>
                    <span class="nf">def_resource_dir_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resdir</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="n">braced_content</span><span class="nf">.extend</span><span class="p">(</span><span class="n">def_method</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">quote!</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">struct</span> <span class="n">Res</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span>
            <span class="p">}</span>

            <span class="k">impl</span> <span class="n">Res</span> <span class="p">{</span>
                <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">config_dir</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">env!</span><span class="p">(</span><span class="s">"CARGO_MANIFEST_DIR"</span><span class="p">));</span>

                    <span class="k">Self</span> <span class="p">{</span>
                        <span class="n">path</span><span class="p">:</span> <span class="n">config_dir</span><span class="nf">.with_file_name</span><span class="p">(</span><span class="s">"res"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                #<span class="n">braced_content</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">resource_dir</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">resdir</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResourceDir</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tokens</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">braced_content</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{};</span>

    <span class="k">for</span> <span class="n">either_file_or_dir</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">resdir</span><span class="py">.fields</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">def_method</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">either_file_or_dir</span><span class="py">.value</span> <span class="p">{</span>
            <span class="nf">Left</span><span class="p">(</span><span class="n">resfile</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">resource_file</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resfile</span><span class="p">));</span>
                <span class="nf">def_resource_file_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resfile</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nf">Right</span><span class="p">(</span><span class="n">resdir</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">resource_dir</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resdir</span><span class="p">));</span>
                <span class="nf">def_resource_dir_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">resdir</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">braced_content</span><span class="nf">.extend</span><span class="p">(</span><span class="n">def_method</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ResourceDir</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">resdir</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">long_name_ident</span><span class="p">,</span> <span class="o">..</span> <span class="p">)</span><span class="o">=</span> <span class="nf">assemble_name</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="n">tokens</span><span class="nf">.extend</span><span class="p">(</span><span class="nd">quote!</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">struct</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span>
        <span class="p">}</span>

        <span class="k">impl</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            #<span class="n">braced_content</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="n">tokens</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">resource_file</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">resfile</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResourceFile</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ResourceFile</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">resfile</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">long_name_ident</span><span class="p">,</span> <span class="o">..</span> <span class="p">)</span><span class="o">=</span> <span class="nf">assemble_name</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="nd">quote!</span><span class="p">{</span>
        <span class="k">pub</span> <span class="k">struct</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span>
        <span class="p">}</span>

        <span class="k">impl</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">path</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">Path</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.path</span><span class="nf">.as_path</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.path</span><span class="nf">.is_file</span><span class="p">(),</span> <span class="s">"{:#?}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.path</span><span class="p">);</span>

                <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.path</span><span class="nf">.is_file</span><span class="p">(),</span> <span class="s">"{:#?}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.path</span><span class="p">);</span>

                <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">load_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
                <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.path</span><span class="nf">.is_file</span><span class="p">(),</span> <span class="s">"{:#?}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.path</span><span class="p">);</span>

                <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nf">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.path</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">def_resource_dir_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">resdir</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResourceDir</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ResourceDir</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">resdir</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">long_name_ident</span><span class="p">,</span> <span class="n">name_litstr</span><span class="p">,</span> <span class="o">..</span> <span class="p">)</span><span class="o">=</span> <span class="nf">assemble_name</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="nd">quote!</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> #<span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            #<span class="n">long_name_ident</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">:</span> <span class="k">self</span><span class="py">.path</span><span class="nf">.join</span><span class="p">(</span>#<span class="n">name_litstr</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">def_resource_file_method</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">resfile</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">ResourceFile</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ResourceFile</span> <span class="p">{</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">resfile</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">long_name_ident</span><span class="p">,</span> <span class="o">..</span> <span class="p">)</span><span class="o">=</span> <span class="nf">assemble_name</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="nd">quote!</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> #<span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> #<span class="n">long_name_ident</span> <span class="p">{</span>
            #<span class="n">long_name_ident</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">:</span> <span class="k">self</span><span class="py">.path</span><span class="nf">.join</span><span class="p">(</span>#<span class="n">path</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// (long_name_ident, name_litstr, next_prefix_name = long_name_str)</span>
<span class="k">fn</span> <span class="nf">assemble_name</span><span class="p">(</span><span class="k">mut</span> <span class="n">prefix_name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Ident</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Ident</span><span class="p">,</span> <span class="n">LitStr</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// snake style name</span>
    <span class="k">let</span> <span class="n">name_str</span> <span class="o">=</span> <span class="n">name</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">name_str</span><span class="p">,</span> <span class="n">name_str</span><span class="nf">.to_case</span><span class="p">(</span><span class="nn">Case</span><span class="p">::</span><span class="n">Snake</span><span class="p">));</span>

    <span class="c1">// upper camel style prefix name</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">prefix_name</span><span class="p">,</span> <span class="n">prefix_name</span><span class="nf">.to_case</span><span class="p">(</span><span class="nn">Case</span><span class="p">::</span><span class="n">UpperCamel</span><span class="p">));</span>
    <span class="n">prefix_name</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name_str</span><span class="nf">.to_case</span><span class="p">(</span><span class="nn">Case</span><span class="p">::</span><span class="n">UpperCamel</span><span class="p">));</span>

    <span class="p">(</span><span class="nd">ident!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefix_name</span><span class="p">),</span> <span class="nd">litstr!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name_str</span><span class="p">),</span> <span class="n">prefix_name</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>还可以，比如在一个 Cargo workspace 里面可以专门用一个 Crate 来持有资源文件的配置（看起来就像 Micro Service 框架一样）。</p>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[问题引入]]></summary></entry><entry><title type="html">探讨 Rust 实现自引用结构</title><link href="/lang/BT-3-Extra-FlatBPT.html" rel="alternate" type="text/html" title="探讨 Rust 实现自引用结构" /><published>2024-12-05T00:00:00+08:00</published><updated>2024-12-05T00:00:00+08:00</updated><id>/lang/BT-3-Extra-FlatBPT</id><content type="html" xml:base="/lang/BT-3-Extra-FlatBPT.html"><![CDATA[<p><strong>别名：BT(3-extra) - Flat B+树（Vec like）</strong></p>

<p><strong>– 探索 Rust 编程模型下传统自引用数据结构的最佳实现</strong></p>

<p><strong>– 实验一种基于数组的扁平化节点和键值分离的 B+ 树实现</strong></p>

<h2 id="问题引入">问题引入</h2>

<p><strong>自引用数据结构（Self Referential Structures）</strong>，指存在递归定义的结构体，最简单的比如链表里的节点，</p>

<p>在 C 里使用<em>指针（Pointer）</em>实现这种定义</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
    <span class="p">..</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在传统的面向对象的语言比如 Java 里，直接使用<em>引用（Reference）</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但对于 Rust 而言，引入 <em>指针</em> 就破坏了内存安全（Memory safety），使用 <em>引用</em> 就面临可变性检查。</p>

<p>实在是进退失据，不知如何是好；或者说，按照 Rust 哲学自引用数据结构是一种反模式，事实上它也确实存在内存安全或并发编程方面的脆弱性。</p>

<p>但不管怎样，因为有大量的历史算法沉淀在自引用的结构里（树和图），无论如何都要找到一个在 Rust 里应付这种数据结构的办法，因为缺乏来自语言机制上的大力支持，这并不容易，实际变成了一个考验对 Rust 熟悉程度的一个门槛，像我自己用了 Rust 好几年了，到今天才算找到一点儿感觉，在此写下一个总结性的心得体会。</p>

<h2 id="两种常规方法">两种常规方法</h2>

<p>一般地讲，有两种常规的方法来实现自引用结构，一种是使用<strong>“官方指定”</strong>的“作弊器”，另一种是使用<strong>“官方使用”</strong>的“作弊器”。</p>

<h3 id="官方指定">官方指定</h3>

<p><strong>“官方指定”</strong>的作弊器指的是官方文档里推荐的 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;T&gt;&gt;</code> 套装。</p>

<p>这个套装的两个组件 <code class="language-plaintext highlighter-rouge">RefCell</code> 和 <code class="language-plaintext highlighter-rouge">Rc</code> 的设计可谓“卧龙凤雏”、“一时瑜亮”。</p>

<h4 id="refcell"><code class="language-plaintext highlighter-rouge">RefCell</code></h4>

<p><code class="language-plaintext highlighter-rouge">RefCell</code> 提供了一种通过不可变引用进行可变修改的办法，原理是直接跳过可变性检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">borrow</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="n">BorrowFlag</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">// Stores the location of the earliest currently active borrow.</span>
    <span class="c1">// This gets updated whenever we go from having zero borrows</span>
    <span class="c1">// to having a single borrow. When a borrow occurs, this gets included</span>
    <span class="c1">// in the generated `BorrowError`/`BorrowMutError`</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"debug_refcell"</span><span class="nd">)]</span>
    <span class="n">borrowed_at</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">crate</span><span class="p">::</span><span class="nn">panic</span><span class="p">::</span><span class="n">Location</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[rustc_never_returns_null_ptr]</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="c1">// We can just cast the pointer from `UnsafeCell&lt;T&gt;` to `T` because of</span>
        <span class="c1">// #[repr(transparent)]. This exploits std's special status, there is</span>
        <span class="c1">// no guarantee for user code that this will work in future versions of the compiler!</span>
        <span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="c1">// Positive values represent the number of `Ref` active. Negative values</span>
<span class="c1">// represent the number of `RefMut` active. Multiple `RefMut`s can only be</span>
<span class="c1">// active at a time if they refer to distinct, nonoverlapping components of a</span>
<span class="c1">// `RefCell` (e.g., different ranges of a slice).</span>
<span class="c1">//</span>
<span class="c1">// `Ref` and `RefMut` are both two words in size, and so there will likely never</span>
<span class="c1">// be enough `Ref`s or `RefMut`s in existence to overflow half of the `usize`</span>
<span class="c1">// range. Thus, a `BorrowFlag` will probably never overflow or underflow.</span>
<span class="c1">// However, this is not a guarantee, as a pathological program could repeatedly</span>
<span class="c1">// create and then mem::forget `Ref`s or `RefMut`s. Thus, all code must</span>
<span class="c1">// explicitly check for overflow and underflow in order to avoid unsafety, or at</span>
<span class="c1">// least behave correctly in the event that overflow or underflow happens (e.g.,</span>
<span class="c1">// see BorrowRef::new).</span>
<span class="k">type</span> <span class="n">BorrowFlag</span> <span class="o">=</span> <span class="nb">isize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">UNUSED</span><span class="p">:</span> <span class="n">BorrowFlag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Location</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个成系列的 <code class="language-plaintext highlighter-rouge">XXCell</code> 结构体的设计质量很糟，本来像这样既不能 <code class="language-plaintext highlighter-rouge">Send</code> 也不能 <code class="language-plaintext highlighter-rouge">Sync</code> ，只是为了绕过可变性检查而设计的结构体根本就没有计划外的使用风险，也不知道它在外部接口的设计上抠抠搜搜些什么 😅，还要分好几个结构体，像这个 <code class="language-plaintext highlighter-rouge">Cell</code> 和 <code class="language-plaintext highlighter-rouge">RefCell</code> 唯一区别就是 <code class="language-plaintext highlighter-rouge">RefCell</code> 可以 Borrow（而 <code class="language-plaintext highlighter-rouge">Cell</code> 只能 <code class="language-plaintext highlighter-rouge">replace</code> ）。</p>

<p>再说这个 <code class="language-plaintext highlighter-rouge">BorrowFlag</code> ，可能就是为了这点儿醋才包的饺子，简直昏了头， 本身设计的目的就是为了绕过可变性检查，结果又在这里做 Borrow check ，不是你检查些什么呀 😓？</p>

<p>特别地，为了简短篇幅而没在代码里列出来的 <code class="language-plaintext highlighter-rouge">RefCell</code> 的 Borrow 实现也有“巧思”，我一直以为 Borrow 的返回值是 <code class="language-plaintext highlighter-rouge">&amp;T</code> 或 <code class="language-plaintext highlighter-rouge">&amp;mut T</code> ，结果发现是一层包装： <code class="language-plaintext highlighter-rouge">Ref</code> 和 <code class="language-plaintext highlighter-rouge">RefMut</code> ，当然标准库的实现一贯如此，这也罢了，那么 <code class="language-plaintext highlighter-rouge">Rc</code>，<code class="language-plaintext highlighter-rouge">Ref</code>，<code class="language-plaintext highlighter-rouge">RefMut</code> 都实现了自动解包（<code class="language-plaintext highlighter-rouge">Deref</code> 和 <code class="language-plaintext highlighter-rouge">DerefMut</code> ），偏偏 <code class="language-plaintext highlighter-rouge">RefCell</code> 不实现又是什么原因呢，喜欢多写一个 <code class="language-plaintext highlighter-rouge">.borrow()</code> ，表明显式 Borrow 🤓？</p>

<p>整个标准库里没有任何地方使用 <code class="language-plaintext highlighter-rouge">RefCell</code> ，相反其他地方还要为适配它写额外的代码。</p>

<h4 id="rc"><code class="language-plaintext highlighter-rouge">Rc</code></h4>

<p><code class="language-plaintext highlighter-rouge">Rc</code> 是引用计数器（Reference counter）。</p>

<p>其中 <code class="language-plaintext highlighter-rouge">NonNull</code> 技术上的意义是为非 <code class="language-plaintext highlighter-rouge">null</code> 指针提供普通对象的语义，比如<a href="https://doc.rust-lang.org/reference/subtyping.html#variance">协变性</a>，比如派生 trait。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This is a `NonNull` to allow optimizing the size of this type in enums,</span>
    <span class="c1">// but it is not necessarily a valid pointer.</span>
    <span class="c1">// `Weak::new` sets this to `usize::MAX` so that it doesn’t need</span>
    <span class="c1">// to allocate space on the heap. That's not a value a real pointer</span>
    <span class="c1">// will ever have because RcInner has alignment at least 2.</span>
    <span class="c1">// This is only possible when `T: Sized`; unsized `T` never dangle.</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pointer</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This is repr(C) to future-proof against possible field-reordering, which</span>
<span class="c1">// would interfere with otherwise safe [into|from]_raw() of transmutable</span>
<span class="c1">// inner types.</span>
<span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">strong</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">weak</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[cfg(not(no_global_oom_handling))]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// There is an implicit weak pointer owned by all the strong</span>
        <span class="c1">// pointers, which ensures that the weak destructor never frees</span>
        <span class="c1">// the allocation while the strong destructor is running, even</span>
        <span class="c1">// if the weak pointer is stored inside the strong one.</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">from_inner</span><span class="p">(</span>
                <span class="c1">// get 'static lifetimes raw pointer</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">leak</span><span class="p">(</span>
                    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                        <span class="n">RcInner</span> <span class="p">{</span> <span class="n">strong</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">weak</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">value</span> <span class="p">}))</span>
                    <span class="nf">.into</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.inc_weak</span><span class="p">();</span>
        <span class="n">Weak</span> <span class="p">{</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">this</span><span class="py">.ptr</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
   
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline]</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_inner</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">ptr</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.dec_strong</span><span class="p">();</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.strong</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">(</span><span class="o">*</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.as_ptr</span><span class="p">())</span><span class="py">.value</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span> <span class="p">{</span> <span class="n">inner</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">};</span>

        <span class="n">inner</span><span class="nf">.dec_weak</span><span class="p">();</span>
        <span class="c1">// the weak count starts at 1, and will only go to zero if all</span>
        <span class="c1">// the strong pointers have disappeared.</span>
        <span class="k">if</span> <span class="n">inner</span><span class="nf">.weak</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.alloc</span><span class="nf">.deallocate</span><span class="p">(</span>
                    <span class="k">self</span><span class="py">.ptr</span><span class="nf">.cast</span><span class="p">(),</span> 
                    <span class="nn">Layout</span><span class="p">::</span><span class="nf">for_value_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.as_ptr</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>看代码的时候我就在思考一个问题，为什么要单独搞一个 <code class="language-plaintext highlighter-rouge">Weak</code> ，它不就是不“拥有”对象所有权的普通指针吗，怎么机制搞那么复杂，先让 <code class="language-plaintext highlighter-rouge">Rc</code> 持有数据 <code class="language-plaintext highlighter-rouge">T</code>，再让 <code class="language-plaintext highlighter-rouge">Weak</code> 持有<code class="language-plaintext highlighter-rouge">T</code> 的容器 <code class="language-plaintext highlighter-rouge">RcInner</code> ？</p>

<p>其次，这个引用计数器到底有什么用，计数的机制本身还是生命周期，那直接用生命周期的机制不就行了？要知道引用计数器，是破坏了单一所有权原则的，并且为了给循环引用打补丁，才引入弱引用的机制（补丁还不能从根本上解决问题）。</p>

<p>把这个问题延展开，因为 Rust 是单一所有权，所以可以静态分析生命周期，所以实际既不需要 Tracing 方式的 GC ，也不需要引用计数器这种方式的 GC 。</p>

<p>标准库在 ThreadLocal 的实现里仅此一处的使用了 <code class="language-plaintext highlighter-rouge">Rc</code> 。</p>

<h3 id="官方使用">官方使用</h3>

<p>标准库里的自引用数据结构都是特化类型的指针，比如以下是标准库 <code class="language-plaintext highlighter-rouge">BTreeMap</code> 里的“树节点”类型</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// We want to be covariant in `K` and `V`.</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">InternalNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>

    <span class="cd">/// This node's index into the parent node's `edges` array.</span>
    <span class="cd">/// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.</span>
    <span class="cd">/// This is only guaranteed to be initialized when `parent` is non-null.</span>
    <span class="n">parent_idx</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// The number of keys and values this node stores.</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>

    <span class="cd">/// The arrays storing the actual data of the node. Only the first `len` elements of each</span>
    <span class="cd">/// array are initialized and valid.</span>
    <span class="n">keys</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">CAPACITY</span><span class="p">],</span>
    <span class="n">vals</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">CAPACITY</span><span class="p">],</span>
<span class="p">}</span>

<span class="nd">#[repr(C)]</span>
<span class="c1">// gdb_providers.py uses this type name for introspection.</span>
<span class="k">struct</span> <span class="n">InternalNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// The pointers to the children of this node. `len + 1` of these are considered</span>
    <span class="cd">/// initialized and valid, except that near the end, while the tree is held</span>
    <span class="cd">/// through borrow type `Dying`, some of these pointers are dangling.</span>
    <span class="n">edges</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更好的方法">更好的方法</h3>

<p>可以合并 <code class="language-plaintext highlighter-rouge">Rc</code> 和 <code class="language-plaintext highlighter-rouge">RefCell</code> 的功能，并且去掉对于 Rust 来说莫名奇妙的计数指针，改为单一所有权的指针和由它衍生出的普通指针。</p>

<p>这种设计和实现优化了人机交互，重新确立了单一所有权原则，从根本上消除了循环引用带来的内存泄漏的可能性。[^5]</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Hash)]</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Hash)]</span>
<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">value</span><span class="p">:</span> <span class="nn">NonNull</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_box</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">value</span><span class="p">:</span> <span class="nn">NonNull</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nb">Ptr</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="k">self</span><span class="py">.value</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_ref</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMut</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_ref</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">BorrowMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">ptr_eq</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">eq</span><span class="p">(</span><span class="n">this</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="n">other</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="k">self</span><span class="py">.value</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Copy</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_ref</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">DerefMut</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_ref</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">BorrowMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.as_mut</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>其中有几点需要解释：</p>

<ol>
  <li>自动派生的那些 trait 实际上就是 <code class="language-plaintext highlighter-rouge">NonNull</code> 自动实现的 trait ，也是最常用的几个用于只读属性的 trait ；</li>
  <li>为 <code class="language-plaintext highlighter-rouge">Ptr</code> 实现了 <code class="language-plaintext highlighter-rouge">Copy</code> trait ，因为它并不拥有数据，我们把它当一个既不为 NULL 也不悬空的有效指针一样使用，反过来 <code class="language-plaintext highlighter-rouge">OwnedPtr</code> 连 <code class="language-plaintext highlighter-rouge">Clong</code> trait 都没有实现，它应该像一个暴露出指针接口的 <code class="language-plaintext highlighter-rouge">Unique</code> 指针，即使实现克隆也应该是是在克隆一个新的值放到堆上；</li>
  <li>为 <code class="language-plaintext highlighter-rouge">Ptr&lt;T&gt;</code> 和 <code class="language-plaintext highlighter-rouge">OwnedPtr&lt;T&gt;</code> 实现了 <code class="language-plaintext highlighter-rouge">Deref</code> 和 <code class="language-plaintext highlighter-rouge">DerefMut</code> ，这样使用它们就好像直接在 <code class="language-plaintext highlighter-rouge">T</code> 上使用一样；</li>
  <li>为 <code class="language-plaintext highlighter-rouge">Ptr&lt;T&gt;</code> 实现了 <code class="language-plaintext highlighter-rouge">Borrow</code> 和 <code class="language-plaintext highlighter-rouge">BorrowMut</code> ，因为标准库的数据结构的 <code class="language-plaintext highlighter-rouge">get</code> 类方法需要实现这类 trait；</li>
  <li>我们没有实现 <code class="language-plaintext highlighter-rouge">Send</code> 和 <code class="language-plaintext highlighter-rouge">Sync</code>，这意味着它们不会被跨线程的使用。</li>
</ol>

<h4 id="使用示例">使用示例</h4>

<p>这样我们自己实现的 B+ 树可能就是如下这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">_marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">[();</span> <span class="n">M</span><span class="p">]</span><span class="o">&gt;</span>
    <span class="p">},</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">_marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">[();</span> <span class="n">M</span><span class="p">]</span><span class="o">&gt;</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="第三种方法放弃指针">第三种方法：放弃指针</h2>

<p>在现行编程框架下仍然可以避免使用指针来实现自引用结构，方法是在根部持有所有节点，使用索引（比如下标）作为传统指针的替代，不过这样有一个限制，就是节点的索引不能变。</p>

<p>首先如果索引是一个 Map ，比如 HashMap 里 Key，那么这是一个方便解决的问题，但是使用 Map 就引入了额外的依赖，这是我们很多时候想要避免的事情，同时也会损失一些性能；</p>

<p>这样的话，考虑一个简单的基于向量的实现，用它的下标作为索引，得到一个惰性删除向量，这样当删除节点的时候不会改变既有节点的位置，而当插入新数据时可以复用被标记为删除的位置。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">deleted</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="k">self</span><span class="py">.deleted</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span>
            <span class="n">deleted</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_parts</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">deleted</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.deleted</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="n">idx</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
            <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"{idx} &gt; len {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">old</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.deleted</span><span class="nf">.push</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样的实现虽然多了一层间接访问，但在一个综合了插入、删除和查询的综合测试看，这样结构的一个 B+ 树实现与标准库里的 <code class="language-plaintext highlighter-rouge">BTreeMap</code> 的性能几乎一致。</p>

<p><strong>测试的配置</strong></p>

<p><em>元组第一个数字是概率权重，第二个是操作名</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">roller</span> <span class="o">=</span> <span class="nn">RandomRoller</span><span class="p">::</span><span class="nf">with_candicates</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
    <span class="c1">// get</span>
    <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
    <span class="c1">// range</span>
    <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="nf">R</span><span class="p">(</span><span class="n">Unbounded</span><span class="p">,</span> <span class="n">Unbounded</span><span class="p">)),</span>
    <span class="c1">// insert</span>
    <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="c1">// remove </span>
    <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nf">D</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
<span class="p">]);</span>
</code></pre></div></div>

<p><strong>示例片段</strong></p>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.12/coll_st/src/bt/flatbpt.rs">完整代码</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="cd">/// (key, dataid)</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// *NOTE:* For root node, `paren` is nonsense.</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="cd">/// (min-key of child, nodeid)</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FlatBPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// uncouple data manage (avoid unnecessary mutability check)</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// nodes[0] would be root and should always not to be deleted</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">C</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[别名：BT(3-extra) - Flat B+树（Vec like）]]></summary></entry><entry><title type="html">0264 - Ugly Number II</title><link href="/oth/LeetCode0264.html" rel="alternate" type="text/html" title="0264 - Ugly Number II" /><published>2024-10-28T00:00:00+08:00</published><updated>2024-10-28T00:00:00+08:00</updated><id>/oth/LeetCode0264</id><content type="html" xml:base="/oth/LeetCode0264.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/ugly-number-ii/description">问题描述</a></p>

<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, and <code class="language-plaintext highlighter-rouge">5</code>.</p>

<p>Given an integer <code class="language-plaintext highlighter-rouge">n</code>, return <em>the</em> <code class="language-plaintext highlighter-rouge">nth</code> <strong><em>ugly number</em></strong>.</p>

<h2 id="破题">破题</h2>

<p>Medium 题目通常比 Hard 要棘手，因为干扰项多，很容易误入歧途，而 Hard 题目反而思路明确。</p>

<h3 id="轮筛陷阱">轮筛陷阱</h3>

<p>这个题真是“坑”我不浅，首先 “ prime factors ” 和 Top 3 个质数 2, 3, 5 直接把我引到了“轮筛”这个概念里<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，然后发现 <a href="https://en.wikipedia.org/wiki/Wheel_factorization">轮筛 wiki</a> 里有些概念讲得一带而过、很不清楚<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，于是去查一些介绍质数筛子的教学材料，了解了一些质数筛子，但是轮筛还是不知道，又追到了 Pritchard 的原始论文，最后把他 80s-90s 所有质数筛子论文都看完了，内容详见 <a href="/algs/Prime0.html">质数基础</a>、 <a href="/algs/Prime1.html">质数筛子</a> 和 <a href="/algs/Prime2.html">质数筛子拓展</a> ，回来发现本题和轮筛、和质数筛子、甚至和质数本身就没什么关系，真是一种幽默了。</p>

<h3 id="gpf-陷阱">GPF 陷阱</h3>

<p>虽然但是， 可以发现丑数并不是按照 2, 3, 5 的某个固定顺序增长，感觉需要对既往丑数进行一个 $\log n$ 级别的回溯，才能准确找到大小顺序排在下一个的丑数。</p>

<p>这好像暗示可以计算每个数的最大质因子，这样快速检查一个数是否是符合条件（最大质因子（GPF） $\leqslant 5$）的丑数，而 GPF 增量筛算法恰好提供了一个 $O(n)$ 时间复杂度下计算 $\text{gpf}$ 数组的方法，看起来是个思路。</p>

<p>但问题是丑数增长是指数级的，在计算到需求的第 1680 个丑数前，且不说超时的问题，光内存就已经被消耗完了。</p>

<h2 id="解-堆">解① 堆：</h2>

<p>找不到固定的变化规律，也应用不了既有算法，只能从头开始考虑，按照规律上讲，对于无法直接解决的问题，应该从答案入手、寻找规律，反推过程。这也是诱导推理或者动态规划思想的核心思路。</p>

<p>那么回到这个题目，$n$ th 丑数应该也是由某 $i$ th 丑数 x2, x3, x5 得到，而显然 $i \lt n$，也就是这个丑数是之前计算过的。</p>

<p>那么似乎为每个丑数 $a$ 计算 $2a$ , $3a$ , $5a$ 三个数，把它们加入候选集里，那么下一个丑数就可以在这个候选集里搜索，这是一个线性的复杂度，而选取其中的最小值，可以使用小顶堆，这就可以解决问题。</p>

<p><em>注意这样计算的候选项会有重复值。</em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">1690</span>

<span class="k">def</span> <span class="nf">gen_ugly_numbers</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">""" n &gt;= 1 """</span>

    <span class="n">ugly_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">probheap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ugly_numbers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">ugly_numbers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">heappushpop</span><span class="p">(</span><span class="n">probheap</span><span class="p">,</span> <span class="n">last</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">last</span><span class="p">:</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">probheap</span><span class="p">)</span>

        <span class="n">heappush</span><span class="p">(</span><span class="n">probheap</span><span class="p">,</span> <span class="n">last</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">probheap</span><span class="p">,</span> <span class="n">last</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>

        <span class="n">ugly_numbers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ugly_numbers</span>


<span class="n">UGLY_NUMBERS</span> <span class="o">=</span> <span class="n">gen_ugly_numbers</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">UGLY_NUMBERS</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>因为堆的维护需要 $O(n\log n)$ ，因此总的时间复杂度也降低到了 $O(n\log n)$ ，空间复杂度 $O(n)$ 。</p>

<p>时间性能 0 ms (beats 100%)，空间性能 16.8 MB (beats 11.8%)。</p>

<p><em>这个 0 ms 是因为缓存了全部结果，其他提交大家好像都是动态计算结果</em></p>

<h2 id="解-dp">解② DP：</h2>

<p><em>经验上大多数能用优先级队列解决的题目，也可以使用 DP 在 $O(n)$ 时间复杂度上解决。</em></p>

<p>仔细考虑下其实根本不用保存所有的候选值，只需要追踪前三个最小的丑数，设为 $a_1\lt a_2\lt a_3$ ，使得 $a_i=\min\lbrace a_i\vert a_i\cdot T[i] \gt \text{last ugly number} \rbrace, T= \lbrace 2, 3, 5\rbrace $，当前的丑数就是 $\min \lbrace 5a_1,3a_2,2a_3\rbrace$ 。</p>

<p>如果某个候选值被发现为最小，那么把它作为丑数添加后，需要更新 $a_i=\min\lbrace u\vert u \gt a_i, u\in \text{ugly nmubers} \rbrace$ 。</p>

<p>同样地，三个候选值 $5a_1,3a_2,2a_3$ 可能产生相同的值，需要全部检查一遍</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">1690</span>


<span class="k">def</span> <span class="nf">gen_ugly_numbers</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="s">""" n &gt;= 1 """</span>

    <span class="n">ugly_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">i_m5</span> <span class="o">=</span> <span class="n">i_m3</span> <span class="o">=</span> <span class="n">i_m2</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">nxt_m2</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">nxt_m3</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">nxt_m5</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ugly_numbers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nxt_m2</span><span class="p">,</span> <span class="n">nxt_m3</span><span class="p">,</span> <span class="n">nxt_m5</span><span class="p">)</span>
        <span class="n">ugly_numbers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">nxt_m2</span><span class="p">:</span>
            <span class="n">i_m2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nxt_m2</span> <span class="o">=</span> <span class="n">ugly_numbers</span><span class="p">[</span><span class="n">i_m2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">nxt_m3</span><span class="p">:</span>
            <span class="n">i_m3</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nxt_m3</span> <span class="o">=</span> <span class="n">ugly_numbers</span><span class="p">[</span><span class="n">i_m3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">nxt_m5</span><span class="p">:</span>
            <span class="n">i_m5</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nxt_m5</span> <span class="o">=</span> <span class="n">ugly_numbers</span><span class="p">[</span><span class="n">i_m5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>


    <span class="k">return</span> <span class="n">ugly_numbers</span>


<span class="n">UGLY_NUMBERS</span> <span class="o">=</span> <span class="n">gen_ugly_numbers</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">UGLY_NUMBERS</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p>

<p>时间性能：0 ms (beats 100%)，空间性能：16.59 MB (beats 80.55%)。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>如果题目的质因数限制在 2, 3, 5 以外，而不是以内，就可以用轮筛的方法解决 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>因为根本就有内在问题，没法儿实用；现在看了那么多论文我也学乖了，凡是有用的一定有具体实现，没有给具体实现的大概率是水论文 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">Python Cleanup</title><link href="/lang/PythonCleanup.html" rel="alternate" type="text/html" title="Python Cleanup" /><published>2024-10-16T00:00:00+08:00</published><updated>2024-10-16T00:00:00+08:00</updated><id>/lang/PythonCleanup</id><content type="html" xml:base="/lang/PythonCleanup.html"><![CDATA[<p><em>截止于 Python 3.13</em></p>

<h2 id="前言">前言</h2>

<p>Python 资源自动释放的机制就是四种：<code class="language-plaintext highlighter-rouge">with</code>,  <code class="language-plaintext highlighter-rouge">__del__</code>, <code class="language-plaintext highlighter-rouge">atexit</code> , <code class="language-plaintext highlighter-rouge">weakref.finalize</code></p>

<h2 id="with"><code class="language-plaintext highlighter-rouge">with</code></h2>

<p>适用于局部资源管理，是主流的资源自动释放手段，还有方便编写的 <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"><code class="language-plaintext highlighter-rouge">contextlib.contextmanager</code></a> 装饰器。</p>

<p>但是对于经典的单例、全局资源类不适用。</p>

<h2 id="__del__"><code class="language-plaintext highlighter-rouge">__del__</code></h2>

<p>即编写对象的<a href="https://docs.python.org/3/reference/datamodel.html#object.__del__">钩子函数 <code class="language-plaintext highlighter-rouge">__del__</code></a> ，但是 Python 没有为它提供任何有力的保证，语义实现的机制非常脆弱，是一种早期失败的设计。</p>

<p>它有以下几个特点：</p>

<h3 id="苏生-ub">苏生 UB</h3>

<p>在方法内部创建新的对象，从而为它的指针计数器加一，这个做法称为苏生（resurrection），但当这个新的对象被销毁时 <code class="language-plaintext highlighter-rouge">__del__</code> 是否会被调用是 Implement Dependent 。</p>

<h3 id="非确定性执行">非确定性执行</h3>

<p>不保证解释器退出的时候会被执行。</p>

<h3 id="用户负责">用户负责</h3>

<p>用户代码里注意不要申请可能会造成死锁的资源。</p>

<p>用户自己注意不要引用可能已被销毁的全局变量。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="结论">结论</h3>

<p>总之就是失败设计，不如不不用。</p>

<h2 id="atexit"><code class="language-plaintext highlighter-rouge">atexit</code></h2>

<p>确定在解释器退出时会被调用，是静态生命周期、全局资源类选项。</p>

<p><code class="language-plaintext highlighter-rouge">atexit.register(Callable[[], Any])</code></p>

<p>没有提供针对资源类的方法装饰器，只能在 <code class="language-plaintext highlighter-rouge">__init___</code> 里手动加上一行类似 <code class="language-plaintext highlighter-rouge">register(self.cleanup)</code>  的代码。</p>

<p>而注册了类方法之后，相当于让这个资源类永远有一个引用在那里，导致它永远不会被回收，相当于把资源类的生命周期提高到了 <code class="language-plaintext highlighter-rouge">static</code> 。</p>

<h2 id="weakreffinalize"><code class="language-plaintext highlighter-rouge">weakref.finalize</code></h2>

<p>作为 <code class="language-plaintext highlighter-rouge">__del__</code> 的上位替代，在资源回收（gc）的时候调用，解决了  <code class="language-plaintext highlighter-rouge">__del__</code> 的在解释器退出时不确定执行的问题，但几乎也就仅此而已。</p>

<h2 id="尾声">尾声</h2>

<p><strong>从编程角度，资源管理只有两个模式，一个是在局部上下文里使用-释放；另一个是使用全局单例模式。</strong></p>

<p>前者是最推荐的设计模式， <code class="language-plaintext highlighter-rouge">with</code> 机制已经处理很好了；而后者里是设计上的反模式，是传统上的 tradeoff 的做法，需要自己实现一个机制。</p>

<p>这样全局资源类的资源释放，实际上应该在单例模式的机制里顺便实现。</p>

<p>如下展示如何通过标记 cleanup 方法和使用 atexit.register ，在一个单例模式里实现资源自动释放。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[截止于 Python 3.13]]></summary></entry><entry><title type="html">微观基准测试</title><link href="/lang/Bench.html" rel="alternate" type="text/html" title="微观基准测试" /><published>2024-10-10T00:00:00+08:00</published><updated>2024-10-10T00:00:00+08:00</updated><id>/lang/Bench</id><content type="html" xml:base="/lang/Bench.html"><![CDATA[<h2 id="前言">前言</h2>

<p>这里讨论的是微观基准测试（micro-benchmarking）的实现，关心的主要问题是：</p>

<p><strong>在一次测试里到底要重复运行几次目标函数？</strong></p>

<p>我们希望在尽可能少的运行次数下，得到一个相对稳定、准确的测量统计。</p>

<h2 id="前车之辙">前车之辙</h2>

<p>不妨来看一下几个语言内置的微观测试框架做了什么。</p>

<h3 id="python-timeit">Python <code class="language-plaintext highlighter-rouge">timeit</code></h3>

<p><em>这个模块就是一个连同命令行接口和文档注解都不超过 400 代码的单文件。</em></p>

<p><em>从语法上看，就有将近 10 年的未被修改过<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>，而从 API 的设计理念上<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup>，核心逻辑可能写在上个世纪。</em></p>

<p>它的命令行接口让用户指定作为时间观测次数的大轮次次数 <code class="language-plaintext highlighter-rouge">repeat</code> 和作为每次观测时运行的小轮次次数 <code class="language-plaintext highlighter-rouge">number</code> ，分别提供了 <code class="language-plaintext highlighter-rouge">default_repeat = 5</code> 和<code class="language-plaintext highlighter-rouge">default_number = 1000_000</code> 的默认值。</p>

<p>这种指定一个固定轮次的做法非常原始、根本就没有意义。</p>

<p>唯一值得一提的是 <code class="language-plaintext highlighter-rouge">class Timer</code> 里面提供的 <code class="language-plaintext highlighter-rouge">autorange</code> 方法，这个方法也仍然简单：</p>

<p>从 $1$ 开始，累积交替地以 $\times 2,\ \times 5$ 的次数运行测试目标，直到总运行时间超过 $0.2$ s 。</p>

<p><em>另外在测试开始运行的时候 opt-in 地禁止 GC。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup></em></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In class Timer
</span>
<span class="k">def</span> <span class="nf">autorange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">"""Return the number of loops and time taken so that total time &gt;= 0.2.

	Calls the timeit method with increasing numbers from the sequence
    1, 2, 5, 10, 20, 50, ... until the time taken is at least 0.2
    second.  Returns (number, time_taken).

    If *callback* is given and is not None, it will be called after
    each trial with two arguments: ``callback(number, time_taken)``.
    """</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span>
            <span class="n">time_taken</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">time_taken</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">time_taken</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">time_taken</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">*=</span> <span class="mi">10</span>
</code></pre></div></div>

<h3 id="rust-test">Rust <code class="language-plaintext highlighter-rouge">test</code></h3>

<p>相比之下，Rust 内置的 <code class="language-plaintext highlighter-rouge">test</code> crate 实现的 micro-benchmarking 逻辑就体面得多。</p>

<p><strong>首先确定初始的每轮运行次数 <code class="language-plaintext highlighter-rouge">n</code><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">4</a></sup>：</strong></p>

<ol>
  <li>运行一次目标，得到测量时间 <code class="language-plaintext highlighter-rouge">ns_single</code> ns ，如果 $\lt 1$ 就补足为 $1$ ；<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></li>
  <li><code class="language-plaintext highlighter-rouge">n = 1000_000 / ns_single</code> 得到 $1$ ms 内的运行次数，如果 $\lt 1$ 就补足为 $1$ 。</li>
</ol>

<p><strong>然后逐步统计学取样，直到稳定地得到相对稳定的<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>观测统计或者超时<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">7</a></sup>：</strong></p>

<p>以 $50$ 为一轮的取样数，<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup></p>

<p>每一轮的迭代的运行次数仍然遵循交替 $\times 2,\ \times 5$ 的规律，</p>

<p>每次取样完后，通过 <code class="language-plaintext highlighter-rouge">stats::winsorize(samples, 5.0)</code> 去掉前 5% 和后 5%的取样结果<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup> ，</p>

<p>这样如果相邻两轮的观测统计 <code class="language-plaintext highlighter-rouge">summ</code> 和 <code class="language-plaintext highlighter-rouge">summ5</code> 满足以下条件：</p>

<ol>
  <li>前一轮 <code class="language-plaintext highlighter-rouge">summ</code> 的绝对偏差的中位数<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">10</a></sup> 占这个中位数本身的百分比 $\lt 1\%$ ；</li>
  <li>前一轮 <code class="language-plaintext highlighter-rouge">summ</code> 和这一轮 <code class="language-plaintext highlighter-rouge">summ5</code> 的两个中位数的差小于 <code class="language-plaintext highlighter-rouge">summ5</code> 的绝对偏差的中位数</li>
</ol>

<p>则可以返回最新一轮 <code class="language-plaintext highlighter-rouge">summ5</code> 的统计结果，</p>

<p>否则检测总运行时间是否超时，超时也返回统计结果，</p>

<p>否则进行下一轮<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">iter</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inner</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">stats</span><span class="p">::</span><span class="n">Summary</span>
<span class="k">where</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
<span class="p">{</span>
    <span class="c1">// Initial bench run to get ballpark figure.</span>
    <span class="k">let</span> <span class="n">ns_single</span> <span class="o">=</span> <span class="nf">ns_iter_inner</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Try to estimate iter count for 1ms falling back to 1m</span>
    <span class="c1">// iterations if first run took &lt; 1ns.</span>
    <span class="k">let</span> <span class="n">ns_target_total</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="p">;</span> <span class="c1">// 1ms</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">n</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="n">ns_target_total</span> <span class="o">/</span> <span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ns_single</span><span class="p">);</span>

    <span class="c1">// if the first run took more than 1ms we don't want to just</span>
    <span class="c1">// be left doing 0 iterations on every loop. The unfortunate</span>
    <span class="c1">// side effect of not being able to do as many runs is</span>
    <span class="c1">// automatically handled by the statistical analysis below</span>
    <span class="c1">// (i.e., larger error bars).</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total_run</span> <span class="o">=</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">f64</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="mf">0.0_f64</span><span class="p">;</span> <span class="mi">50</span><span class="p">];</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">loop_start</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">samples</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">ns_iter_inner</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="n">n</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">stats</span><span class="p">::</span><span class="nf">winsorize</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">summ</span> <span class="o">=</span> <span class="nn">stats</span><span class="p">::</span><span class="nn">Summary</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">samples</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="nf">ns_iter_inner</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
            <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ns</span> <span class="k">as</span> <span class="nb">f64</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">stats</span><span class="p">::</span><span class="nf">winsorize</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">summ5</span> <span class="o">=</span> <span class="nn">stats</span><span class="p">::</span><span class="nn">Summary</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">loop_run</span> <span class="o">=</span> <span class="n">loop_start</span><span class="nf">.elapsed</span><span class="p">();</span>

        <span class="c1">// If we've run for 100ms and seem to have converged to a</span>
        <span class="c1">// stable median.</span>
        <span class="k">if</span> <span class="n">loop_run</span> <span class="o">&gt;</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="n">summ</span><span class="py">.median_abs_dev_pct</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
            <span class="o">&amp;&amp;</span> <span class="n">summ</span><span class="py">.median</span> <span class="o">-</span> <span class="n">summ5</span><span class="py">.median</span> <span class="o">&lt;</span> <span class="n">summ5</span><span class="py">.median_abs_dev</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">summ5</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">total_run</span> <span class="o">+=</span> <span class="n">loop_run</span><span class="p">;</span>
        <span class="c1">// Longest we ever run for is 3s.</span>
        <span class="k">if</span> <span class="n">total_run</span> <span class="o">&gt;</span> <span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">summ5</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If we overflow here just return the results so far. We check a</span>
        <span class="c1">// multiplier of 10 because we're about to multiply by 2 and the</span>
        <span class="c1">// next iteration of the loop will also multiply by 5 (to calculate</span>
        <span class="c1">// the summ5 result)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="k">match</span> <span class="n">n</span><span class="nf">.checked_mul</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">summ5</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="重新发明-python">重新发明 [Python]</h2>

<h3 id="发明动机">发明动机</h3>

<p>一谈起为 Python Code 做基准测试，有人洋洋洒洒能列出很多种方法，什么使用 <code class="language-plaintext highlighter-rouge">time</code> 模块，使用 <code class="language-plaintext highlighter-rouge">timeit</code> 模块，使用 <code class="language-plaintext highlighter-rouge">profile</code> 或 <code class="language-plaintext highlighter-rouge">cProfile</code> ，甚至使用 Unix-like 系统上的 <code class="language-plaintext highlighter-rouge">time</code> 命令，但是真正能用的还是 <code class="language-plaintext highlighter-rouge">timeit</code> 。</p>

<p>可正如前面所讲，“你什么 <code class="language-plaintext highlighter-rouge">timeit</code> 都在做基准测试，它能做吗，做不了，没那个能力知道吧”。</p>

<p>又找不到一个主流的、大小合适的、做微观基准测试的 Python 第三方库，因此有必要为 Python 写一个可用的微观基准测试框架，这个动机也是本文的起源。</p>

<h3 id="实操">实操</h3>

<p>直接参照 Rust <code class="language-plaintext highlighter-rouge">test</code> 里的实现做一个 Python 的版本<sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">12</a></sup>。</p>

<p>好消息是 Python 内置的 <code class="language-plaintext highlighter-rouge">statistics</code> 模块把 Rust <code class="language-plaintext highlighter-rouge">test</code> 里面花两百行代码实现的统计方法<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>都实现了，这为我们省去了很多功夫。</p>

<p><em>这里只列举核心的方法，完整框架参考<a href="https://github.com/minghu6/py-minghu6">项目所在仓库</a>  。</em></p>

<h3 id="数据结构">数据结构</h3>

<p>首先定义一个测试方法应该返回的基本数据结构 <code class="language-plaintext highlighter-rouge">CaseStats</code> ：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CaseStats</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="s">"""case -&gt; module -&gt; benchmark -(archiving)&gt; records"""</span>

    <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">ave</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">iters</span><span class="p">:</span> <span class="nb">int</span>
    <span class="c1"># diviation in nanos
</span>    <span class="n">dev</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">raw_samples</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Number</span><span class="p">]</span>
</code></pre></div></div>

<p>一个被测试的目标函数函数应该是 <code class="language-plaintext highlighter-rouge">type BenchCase = Callable[[], None]</code> ，</p>

<p>这样测试方法的类型就是 <code class="language-plaintext highlighter-rouge">Callable[[BenchCase], CaseStats]</code> 。</p>

<h3 id="辅助方法">辅助方法</h3>

<p>首先是需要的一系列统计方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">StatisticsError</span>


<span class="k">class</span> <span class="nc">SampleStats</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">median_abs_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">median_abs_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">median_abs_dev_pct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
        <span class="s">""" 0.01 stand for 1% """</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">median_abs_dev</span> <span class="o">/</span> <span class="bp">self</span><span class="p">.</span><span class="n">median</span>

<span class="k">def</span> <span class="nf">winsoring</span><span class="p">(</span><span class="n">samples</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" [Winsoring](https://en.wikipedia.org/wiki/Winsorizing) high e/n and low e/n

    in-place
    """</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">StatisticsError</span><span class="p">(</span><span class="s">'must satisfy 2 * e &lt; n'</span><span class="p">)</span>

    <span class="c1"># percentiles
</span>    <span class="n">pcts</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="n">lo</span> <span class="o">=</span> <span class="n">pcts</span><span class="p">[</span><span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">pcts</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span>

        <span class="k">elif</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lo</span>


<span class="k">def</span> <span class="nf">median_abs_dev</span><span class="p">(</span><span class="n">samples</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Number</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Number</span><span class="p">:</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">median</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">),</span> <span class="n">samples</span><span class="p">)))</span>
</code></pre></div></div>

<p>一个便于观测时间的方法，利用了 Python 上文管理器的 <code class="language-plaintext highlighter-rouge">with</code> 语法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Watch</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">".2f"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""
        :fmt: format float number of (s/ms/us)
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter_ns</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter_ns</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_nanos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">start</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">nanos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_nanos</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">micros</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_nanos</span> <span class="o">/</span> <span class="mi">1000</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">millis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_nanos</span> <span class="o">/</span> <span class="mi">1000_000</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">secs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_nanos</span> <span class="o">/</span> <span class="mi">1000_000_000</span>
</code></pre></div></div>

<p>然后我们可以写性能统计取样的方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SAMPLE_SIZE</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">WINSORING_PERCENTILE</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">'n'</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s">'e'</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">sampling</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">BenchCase</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleStats</span><span class="p">:</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">SAMPLE_SIZE</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">SAMPLE_SIZE</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Watch</span><span class="p">()</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">f</span><span class="p">()</span>

        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="n">nanos</span> <span class="o">//</span> <span class="n">n</span>

    <span class="n">winsoring</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="o">**</span><span class="n">WINSORING_PERCENTILE</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SampleStats</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="主过程">主过程</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_a_benchmark</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">BenchCase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampleStats</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Watch</span><span class="p">()</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
        <span class="n">f</span><span class="p">()</span>

    <span class="n">tot</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="n">nanos</span>

    <span class="k">if</span> <span class="n">w</span><span class="p">.</span><span class="n">nanos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">RuntimeError</span><span class="p">(</span><span class="s">"It's just impossible for CPython"</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1000_000</span> <span class="o">/</span> <span class="n">w</span><span class="p">.</span><span class="n">nanos</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">Watch</span><span class="p">()</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">summ</span> <span class="o">=</span> <span class="n">sampling</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">summ5</span> <span class="o">=</span> <span class="n">sampling</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">millis</span> <span class="o">&gt;</span> <span class="mi">200</span>
            <span class="ow">and</span> <span class="n">summ</span><span class="p">.</span><span class="n">median_abs_dev_pct</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
            <span class="ow">and</span> <span class="n">summ</span><span class="p">.</span><span class="n">median</span> <span class="o">-</span> <span class="n">summ5</span><span class="p">.</span><span class="n">median</span> <span class="o">&lt;</span> <span class="n">summ5</span><span class="p">.</span><span class="n">median_abs_dev</span>
           <span class="p">):</span>

            <span class="k">return</span> <span class="n">summ5</span>

        <span class="n">tot</span> <span class="o">+=</span> <span class="n">w</span><span class="p">.</span><span class="n">nanos</span>

        <span class="k">if</span> <span class="n">tot</span> <span class="o">&gt;</span> <span class="mi">3_000_000_000</span><span class="p">:</span>  <span class="c1"># 3 seconds
</span>            <span class="k">return</span> <span class="n">summ5</span>

        <span class="n">n</span> <span class="o">*=</span> <span class="mi">10</span>  <span class="c1"># x2 x5
</span></code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>PEP484 Was accepted in Python 3.5 which was released in <strong>September 2015</strong> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>居然是传一个代码片段的字符串，和一个上下文环境的字典，非常地不正规，完全是 Python 2 那个时代的流行时尚 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>禁止 GC 可以排除由于 GC 带来的观测指标的波动，但长时间不 GC 会降低本身就很有限的性能。基本上这种操作仍然没有太大意义，外部的干扰因素有很多，应该通过统计学办法来排除干扰。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>相当于 <code class="language-plaintext highlighter-rouge">timeit</code> 里的 <code class="language-plaintext highlighter-rouge">number</code> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>这是 CPython 永远不用担心的问题。 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>这不是中文语法错误，“稳定地”指相邻迭代的两轮观测统计的“平均值”相近，“稳定的”指一轮观测统计内部的“方差”小。 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>3 s <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>相当于 <code class="language-plaintext highlighter-rouge">timeit</code> 里 <code class="language-plaintext highlighter-rouge">repeat=50</code> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>通过分别把 $\lt 5\%$ 和 $\gt 95\%$ 的样本值修改为 $=5\%$ 和 $= 95\%$ 的样本值 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>绝对偏差的中位数，<a href="https://en.wikipedia.org/wiki/Median_absolute_deviation">Median absolute deviation</a> ，$\texttt{MAD} = \texttt{median}(\vert X_i-\texttt{median}(X) \vert)$，方法分类上属于 <a href="https://en.wikipedia.org/wiki/Average_absolute_deviation">Average absolute deviation</a> ，是一种被认为比样本方差和标准差更有鲁棒性的估算标量。 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>这里还细心检查了 <code class="language-plaintext highlighter-rouge">loop</code> 代码的下一次执行，也就是 <code class="language-plaintext highlighter-rouge">n * 2 * 5</code> 后是否会溢出，如果会溢出也提前返回。 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>假设环境是 Python 3.12 <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>Rust 的问题，或者说这是个组织结构问题，在于我们知道它的源代码结构非常地迭床架屋，里面充斥着形形色色重新发明的轮子和仅限内部使用的范用工具，从 DRY 的角度看这是双重的折磨，一方面轮子不应该重新发明，而应该使用一个范用库；另一方面，发明的范用工具，应该开放为范用库。而这二百多行代码就属于前者–重新造的轮子。 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">数字类型 - 表示和编码</title><link href="/algs/NumberTypes-0.html" rel="alternate" type="text/html" title="数字类型 - 表示和编码" /><published>2024-10-09T00:00:00+08:00</published><updated>2024-10-09T00:00:00+08:00</updated><id>/algs/NumberTypes%20-%200</id><content type="html" xml:base="/algs/NumberTypes-0.html"><![CDATA[<p><em>时间有限，草稿版本，以后深入研究再修。</em></p>

<h2 id="前言">前言</h2>

<p>一般地讲，数字类型的存储可以分为两层抽象，<strong>表示形式</strong>和<strong>（对表示形式）的编码方式</strong>。</p>

<h2 id="整型integer">整型（Integer）</h2>

<h3 id="表示形式">表示形式</h3>

<p>整型数字的表示形式没有什么特别的，就是它的自然二进制表示。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="编码方式">编码方式</h3>

<p>对于无符号整数和有符号的正整数来说，编码方式就是自然的二进制表示，只有对于有符号的负整数（包括负零）要考虑特别的编码方式。</p>

<p>有几种对于负整数的编码方式：</p>

<h4 id="幅值编码signmagnitude">幅值编码（Sign–magnitude）</h4>

<p>除了在最高有效位标记外，其他部分和正整数或无符号整数一样。</p>

<h4 id="1-的补码ones-complement">1 的补码（Ones’ complement）</h4>

<p>对负整数的每一位都取反。</p>

<h4 id="2-的补码two-complement">2 的补码（Two’ complement）</h4>

<p>对负整数的每一位都取反，再加 1 。</p>

<p>主流编码方式。</p>

<h4 id="偏移二进制offset-binary">偏移二进制（Offset binary）</h4>

<p>也称为 <em>excess-K</em> ，就是加一个 K ，使得负数变为正数。</p>

<p>IEEE-754 规范的浮点数的指数部分就采用了这个方法的一个变种。</p>

<h4 id="-2-基数">-2 基数</h4>

<p><a href="https://en.wikipedia.org/wiki/Signed_number_representations#Base_%E2%88%922">参考</a></p>

<h2 id="浮点数float">浮点数（Float）</h2>

<p>这里讲的是 IEEE-754 标准的浮点数。</p>

<h3 id="表示形式-1">表示形式</h3>

<p>二进制形式的科学记数法。</p>

\[( s ) \ 1.( t ) \times 2^{( e )}\]

<h4 id="十进制与二进制转换">十进制与二进制转换</h4>

<p>使用过程中，隐含一个对于十进制与二进制转换的问题。</p>

<p>对于整数部分，没有任何问题，但是对于小数部分，很多常见的十进制数字是不能由 $2^{-1} + 2^{-2} + \dots 2^{-n}$ ，所精确表示的，实际存储的是一个近似的数学上的积分表示。</p>

<h4 id="精度取舍">精度取舍</h4>

<p>在向低精度舍入时，可以允许配置多种舍入策略，标准实现应该提供 <code class="language-plaintext highlighter-rouge">roundTiesToEven</code> 策略和 <code class="language-plaintext highlighter-rouge">roundTowardPositive</code> ， <code class="language-plaintext highlighter-rouge">roundTowardNegative</code> 和 <code class="language-plaintext highlighter-rouge">roundTowardZero</code> 这三种有特定舍入方向的策略。</p>

<p>其中 <code class="language-plaintext highlighter-rouge">roundTiesToEven</code> 应该把它作为二进制表示数字的默认策略，十进制的表示数字的舍入策略虽然是语言特定的，但也应当采取该策略。</p>

<h5 id="roundtiestoeven"><code class="language-plaintext highlighter-rouge">roundTiesToEven</code></h5>

<p>首先选择距离最近的那个数，</p>

<p>否则如果存在两个等距离候选，就选择那个最低有效位是偶数的，</p>

<p>否则就选精度部分数字（magnitude）最大的。</p>

<h3 id="编码方式-1">编码方式</h3>

<p>按照最高有效位（MSB）的顺序具体如下：<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/number_types/ieee754-binary-encoding.jpg" /></div>
</p>

<h4 id="s">S</h4>

<p>符号位，没什么好说的，最高有效位标记表示负数。</p>

<h4 id="e">E</h4>

<p>由于指数部分实际上是一个有符号整数，这里采取了 <em>excess-K</em> 的编码方案，$K=2^{e-1}-1$ ，这样距离零最远的负数加上 $K$ 后恰好为 $0$。</p>

<h4 id="t">T</h4>

<p>精度部分，省略了小数点前面固定的 $1$ 。</p>

<h4 id="特殊值">特殊值</h4>

<p>当精度部分为 $0$ ，指数部分最小（偏移后为 $0$ ），此时存在当前精度无法表示的小数，也就是发生了 underflow ，此时的状态称为 subnormal。</p>

<p>反过来，如果指数部分最大（偏移后全为 $1$），则可能成为 $\pm\ \infty$ ，或者 NaN 。</p>

<p>规定精度部分全为 $0$ 则是 $\pm\ \infty$，否则为 NAN ，特别地 IEEE-754-2008 之后规定了精度部分最高有效位 $d_1$ 为 $0$ 表示 signaling NAN ，而其他属于默认的 quiet NAN。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>整型和整型运算本身就是 CPU 原始概念的一部分，从哲学意义上讲，是先有的合成实践，后分离出它的独立原型。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>完整说明 :<img src="/assets/img/number_types/ieee-754-2019-p19.jpg" alt="" /> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[时间有限，草稿版本，以后深入研究再修。]]></summary></entry><entry><title type="html">质数筛子拓展</title><link href="/algs/Prime2.html" rel="alternate" type="text/html" title="质数筛子拓展" /><published>2024-09-23T00:00:00+08:00</published><updated>2024-09-23T00:00:00+08:00</updated><id>/algs/Prime2</id><content type="html" xml:base="/algs/Prime2.html"><![CDATA[<h2 id="前言">前言</h2>

<p>介绍一种特殊形式的筛子–增量筛子以及给出使用分段技术的筛子的并行化版本的实现代码。</p>

<h3 id="增量筛子">增量筛子</h3>

<p>增量筛子（incremental sieve），就是一种可以无限（内存空间限制内）获取质数的筛子，在不确定质数范围的情境下，配合函数式编程的风格，有它独特的作用。</p>

<h2 id="e-筛增量筛">E. 筛增量筛（√）</h2>

<p>可以预先计算 $k$ 个质数，用前 $k$ 个质数筛完 $[0, p_k^2]$ 范围内的质数，如果还要继续筛选，就以 $k=p_k^2$，进行下一轮筛选。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="c1">// ~p0^2</span>
                <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">round</span> <span class="o">=</span> <span class="nf">e_seg_sieve_0</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="n">pris</span><span class="p">,</span>
                    <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span><span class="p">,</span>
                    <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span>
                <span class="p">)</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">round</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">round</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">pris</span><span class="nf">.extend</span><span class="p">(</span><span class="n">round</span><span class="p">);</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法评价">算法评价</h3>

<p>性能在增量筛里勉强还算可用。</p>

<p>这只是把普通筛子算法在接口上改造成增量筛子的一个实例，理论上所有依赖预先计算开头一部分质数的一般筛子算法都可以仿照这种方式进行改造。</p>

<p>但是这种方式改造出的增量筛，它的性能曲线并不好看，充满一个个峰值，而好的增量筛子应该（随着质数个数增加），在性能（需求）上呈现平缓增长，贴合质数本身的增长曲线 $\frac{n}{\ln n}$ 。</p>

<p>下面会介绍几个专门的增量筛算法。</p>

<h2 id="bengelloun-增量筛">Bengelloun 增量筛（√√√）</h2>

<p>Bengelloun 增量筛<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，也可以称为 LPF 增量筛，基于最小质因数分解 $c = \texttt{lpf}(c)\cdot f$ ，使用固定 $f$ 而在 $p$ 上遍历的思路。<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">4</a></sup></p>

<h4 id="思路分析">思路分析</h4>

<p><em>和 <a href="#gpf-增量筛">GPF 增量筛</a> 思路类似，但是简单很多，<strong>强烈建议</strong>先看 <a href="#gpf-增量筛">GPF 增量筛</a> 再回过来看本章节。</em></p>

<p>每个合数 $c$ 由同一个 $f$ 而更小的一个质数 $p’ \lt p,\ (p’ \leqslant \texttt{lpf}(f))$ 的 $c’ = p’\cdot f$ 标记。</p>

<p>而且简单地只要 $\texttt{lpf}(c)\gt 2$ ，上述标记就成立，只需特别处理偶数的情况。</p>

<h3 id="样例代码">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">bengelloun_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lastp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lpf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">5</span><span class="p">];</span> <span class="c1">// +1 cap for index start from 1.</span>

            <span class="k">yield</span> <span class="n">lastp</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">3</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">lpf</span><span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">n</span><span class="p">;</span>

                    <span class="n">lpf</span><span class="p">[</span><span class="n">lastp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="c1">// lpf[n] = n;</span>
                    <span class="n">lastp</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

                    <span class="c1">// =&gt; p_next &lt; 2n</span>
                    <span class="c1">// =&gt; p1 / p0 &lt; 2</span>
                    <span class="c1">// =&gt; (p1 / p0) * p_next &lt; 4n - 2</span>
                    <span class="n">lpf</span><span class="nf">.resize</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">// lp0 &gt; 2</span>
                    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>

                    <span class="c1">// min(f, lpf[f]) = truly lpf[f]</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="nf">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lpf</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">lpf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>  <span class="c1">// next prime after p</span>

                        <span class="n">lpf</span><span class="p">[</span><span class="n">p1</span> <span class="o">*</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果按照 GPF 增量筛的风味，可以把 <code class="language-plaintext highlighter-rouge">lpf[n / 2 * 3] = 3;</code> 放到 <code class="language-plaintext highlighter-rouge">else</code> 的代码块里。</p>

<h4 id="textttlpf-扩容">$\texttt{lpf}$ 扩容</h4>

<p>同样类似于 GPF 增量筛，下一个质数 $\lt 2n$ ，在此过程中最大的合数 $c \lt 2n-1 \lt 2n$ ：</p>

<ol>
  <li>$c$ 是偶数，扩张 $3 \div 2 = 1.5 \lt 2$ 倍；</li>
  <li>$c$ 不是偶数，扩张 相邻两个质数之比，$\lt 2$ 倍。</li>
</ol>

<p>因此在产生新的质数 $n$ 后扩容到 $4n$ 即可。</p>

<h4 id="储存-textttnext">储存 $\texttt{next}$</h4>

<p>利用和 GPF 增量筛同样的方式在 <code class="language-plaintext highlighter-rouge">lpf</code> 数组上存储 $\texttt{next}(p)$ 。</p>

<p>可以通过 <code class="language-plaintext highlighter-rouge">min(f, lpf[f])</code> 来比较简洁地得到真正的 $\texttt{lpf}(f)$ 。</p>

<h3 id="算法评价-1">算法评价</h3>

<p>目前最快的一档增量筛。</p>

<h2 id="gpf-增量筛">GPF 增量筛（√√√）</h2>

<p>GPF 增量筛<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，和<a href="/algs/Prime1.html#gpf-筛子">普通 GPF 筛子</a>一样基于最大质因数分解 $c = f\cdot\texttt{gpf}(c)$，但主要以 $f$ 为常量，以 $p \geqslant \texttt{gpf}(f)$ 为增量。</p>

<h4 id="思路分析-1">思路分析</h4>

<p>回顾下普通的 GPF 筛子，是以 $p$ 为常量，遍历所有 $f\in \lbrace f\ \vert\ \texttt{gpf}(f) \leqslant p ,\ p\cdot f\leqslant N \rbrace$ 。</p>

<p>但是增量筛子并不能一次性求取一个预先确定范围的质数，而是按照大小的顺序逐个求取，如果仍然固定 $p$ ，由于不等式 $\texttt{gpf}(f) \leqslant p$ ，必须考虑最大质因数 $\leqslant p$ 范围内的每个级别的 $f$ ，或者说因为并不知道这些级别的 $f$ 之间的大小关系， 所以没办法快速得到 $\texttt{next}(f)$ 。</p>

<p>于是我们考虑固定 $f$ ，那么显然 $p$ 有一个确定的值的顺序，开始值是 $p=\texttt{gpf}(f)$ ，按照求解出的质数顺序逐步增加即可。</p>

<p>但是 $c = f\cdot\texttt{gpf}(f)$ 本身又该如何标记呢？这下只能重新固定 $p$ ，由前一个满足 $\texttt{gpf}(f) = p $ 的 $f$ <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup> 来标记，而满足条件的最小的 $f=p$ ，需要我们手动进行标记。</p>

<p>让我们把问题总结一下：</p>

<p>一个合数 $c = f \cdot p,\ (\texttt{gpf}(f) \leqslant p)$ ，</p>

<p>如果 $\texttt{gpf}(f) = p$ ，</p>

<p>           那么如果 $f=p$ ，那它是在发现某个数 $n=p^2$ 时被手动标记；</p>

<p>           否则，它是在前一个 $g\cdot p,\ (\texttt{gpf}(g) = p)$ 时被标记。</p>

<p>否则 $\texttt{gpf}(f) \lt p$ ，它是在前一个 $f\cdot q,\ (q \lt p)$ 时被标记。</p>

<h3 id="样例代码-1">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// *LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE:* Algorithm 4.4.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">gpf_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lastp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">sqrtp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// minimal (for square) prime &gt;= n</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">gpf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// (p, f)</span>

            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">3</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">sqrtp</span> <span class="o">*</span> <span class="n">sqrtp</span> <span class="p">{</span>
                    <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrtp</span><span class="p">;</span> <span class="c1">// add starter</span>
                    <span class="n">sqrtp</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">sqrtp</span><span class="p">];</span> <span class="c1">// point to next prime after sqrtp</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">n</span><span class="p">;</span>

                    <span class="c1">// gpf[n] = n;</span>
                    <span class="c1">// C_max &lt; p_next &lt; 2n =&gt; (p1/p0 or 2) * C_max &lt; 4n</span>
                    <span class="n">gpf</span><span class="p">[</span><span class="n">lastp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// point to next prime</span>
                    <span class="n">lastp</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="n">gpf</span><span class="nf">.resize</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
                    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>
                    <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="c1">// next prime</span>

                    <span class="n">gpf</span><span class="p">[</span><span class="n">p1</span> <span class="o">*</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>

                    <span class="c1">// min(f, gpf[f]) is truly gpf[f]</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="nf">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">gpf</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">f0</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">while</span> <span class="nf">min</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">gpf</span><span class="p">[</span><span class="n">f0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span>
                            <span class="n">f0</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="n">gpf</span><span class="p">[</span><span class="n">f0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有几个实现的细节问题需要结合代码进行解释。</p>

<h4 id="textttgpf-扩容">$\texttt{gpf}$ 扩容</h4>

<p>根据增量筛的语义，应当在生成一个质数后，在下一个质数生成时对数组 <code class="language-plaintext highlighter-rouge">gpf</code> 进行扩容。</p>

<p>扩容大小做如下分析，如果当前生成的质数是 $n$ ，那么下一个质数 $\lt 2n$ <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup> 。</p>

<p>而且可以发现，每个数字标记的合数不超过自身的 $2$ 倍，分析如下：</p>

<ol>
  <li>
    <p>如果是 $p$ 增加的标记，那么相邻质数之比不超过 $2$；</p>
  </li>
  <li>
    <p>如果是 $f$ 增加的标记，虽然有 $\texttt{gpf}(f) = p$ 的限制，但因为 $2$ 是最小的质数，$2f$ 一定在下一个 $f$ 的序列里。</p>
  </li>
</ol>

<p>因此，到达下一个质数过程中最大的合数 $c\lt 2n$ ，那么最大标记的数为 $2c \lt 4n$ ，因此直接将数组 <code class="language-plaintext highlighter-rouge">gpf</code> 扩容到 $4n$ 即可。</p>

<h4 id="检查平方质数">检查平方质数</h4>

<p>根据算法，我们需要手动检测当前值是否是某个质数的平方。</p>

<p>这乍看上去是个棘手的任务，好在质数也是按照增序的方式产生，实际上只需要追踪当前 $\gt n$ 的最小质数，代码里我们使用 <code class="language-plaintext highlighter-rouge">sqrtp</code> 这个变量来做这个事情。</p>

<h4 id="储存-textttnext-1">储存 $\texttt{next}$</h4>

<p>原文构想使用一个大小为 $2n$ 的数组去为每个质数存储 $\texttt{next}(f)$ 和 $\texttt{next}(p)$ ，但实际并无特别的必要。</p>

<p>$\texttt{next}(f)$ 可以延迟到需要时再计算，而 $\texttt{next}(p)$ 的存储可以仿照 <a href="#bengelloun-增量筛">Bengelloun 增量筛</a> 一样利用 <code class="language-plaintext highlighter-rouge">gpf</code> 既有的空间：</p>

<p>对已发现的质数 $p$，<code class="language-plaintext highlighter-rouge">gpf[p]</code> 的空间实际是没有用的（代码里 <code class="language-plaintext highlighter-rouge">gpf[n] = n</code> 这行代码直接被注释掉了），可以利用它来存储  $\texttt{next}(p)$ 。</p>

<p>于是代码里使用了 <code class="language-plaintext highlighter-rouge">lastp</code> 来保存最后发现的质数，当发现新质数时就令 <code class="language-plaintext highlighter-rouge">gpf[lastp]</code> 指向这个新质数。</p>

<p>只不过这样的改动会稍微影响计算 $\texttt{next}(f)$ ，所以需要把 $f=p$ 的情况单独拿出来讨论，可以通过 <code class="language-plaintext highlighter-rouge">min(f, gpf[f])</code> 来比较简洁地得到真正的 $\texttt{gpf}(f)$ 。</p>

<h3 id="算法评价-2">算法评价</h3>

<p>目前最快的一档增量筛。</p>

<h2 id="并行化实现">并行化实现</h2>

<p>可以发现支持分片技术的筛子也意味着支持并行化处理。</p>

<h3 id="分段-e-筛">分段 E. 筛</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// set amount of cpu cores used in parallel tasks</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_seg_sieve_p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">fn</span> <span class="n">sieve_subtask</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
        <span class="n">l0</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">seg</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">l</span> <span class="k">in</span> <span class="p">(</span><span class="n">l0</span><span class="o">..=</span><span class="n">l1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>  <span class="p">{</span>
            <span class="k">let</span> <span class="n">actual_delta</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>

            <span class="k">for</span> <span class="o">&amp;</span><span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">p</span><span class="o">..=</span><span class="n">actual_delta</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">seg</span><span class="nf">.set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">actual_delta</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">seg</span><span class="nf">.set_all</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">ans</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pris_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pris</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">k_dekta</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">delta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">k_dekta</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">USED_CPU_CORES_NUM</span> <span class="p">{</span>
            <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">scope</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="nf">sieve_subtask</span><span class="p">(</span><span class="n">pris_ref</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
            <span class="p">}));</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">handles</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">});</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="分段固定轮筛">分段固定轮筛</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fixed_wheel_seg_sieve_p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">WStruct</span> <span class="p">{</span> <span class="n">wheel_gap</span><span class="p">:</span> <span class="n">wg</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">empty</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_seg_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">np</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// v = p_{k+1}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">np</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="p">{</span>
        <span class="c1">// Just rolling to n</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">sieve_subtask</span><span class="p">(</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
        <span class="n">np</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l0</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">WStruct</span> <span class="p">{</span>
            <span class="n">wheel</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span>
            <span class="n">wheel_gap</span><span class="p">:</span> <span class="n">wg</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
            <span class="c1">// ipm,</span>
            <span class="o">..</span>
        <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="cm">/* Init v, vi */</span>

        <span class="k">let</span> <span class="n">v_raw</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">l0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">v</span><span class="p">,</span> <span class="k">mut</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="nf">locate_in_wheel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">prod</span><span class="p">,</span> <span class="n">v_raw</span><span class="p">);</span>

        <span class="cm">/* Init factors */</span>
        <span class="c1">// absolute value</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">factors</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">f_raw</span> <span class="o">=</span> <span class="n">l0</span> <span class="o">/</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">factors</span><span class="nf">.push</span><span class="p">(</span><span class="nf">locate_in_wheel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">prod</span><span class="p">,</span> <span class="n">f_raw</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/* Run the algorithm */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">l</span> <span class="k">in</span> <span class="p">(</span><span class="n">l0</span><span class="o">..=</span><span class="n">l1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">l1</span><span class="p">);</span>

            <span class="cm">/* sift for p_k..p_np */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
                <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">f</span><span class="p">,</span> <span class="k">mut</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="p">{</span>
                    <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

                    <span class="n">f</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="cm">/* accumulate primes */</span>

            <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="cm">/* reset for next segment */</span>

            <span class="n">bits</span><span class="nf">.set_all</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">ans</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pris_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pris</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">np</span> <span class="o">=</span> <span class="n">pris</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.rev</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(</span>
            <span class="p">|(</span><span class="n">_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)|</span>  <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span>
        <span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">k_dekta</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">delta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">k_dekta</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">USED_CPU_CORES_NUM</span> <span class="p">{</span>
            <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">scope</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="nf">sieve_subtask</span><span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">pris_ref</span><span class="p">,</span>
                    <span class="n">np</span><span class="p">,</span>
                    <span class="n">l</span><span class="p">,</span>
                    <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                    <span class="n">delta</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">}));</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">handles</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">});</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="尾声">尾声</h2>

<p><em>源代码：<a href="https://github.com/minghu6/rust-minghu6/blob/master/math/src/number.rs">Rust</a> 和 <a href="https://github.com/minghu6/py-minghu6/blob/develop/minghu6/number/prime.py">Python</a></em></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>S.A. Bengelloun. An Incremental Primal Sieve. 1986. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Paul Pritchard. LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE. 1987. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>不知道为什么，在 Pritchard 的论文引用里，Bengelloun 一律被写作 Bengalloun <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>对于增量筛子，固定 $f$ 而在 $p$ 上遍历的算法设计本身就有天然优势 ，所以后面 GPF 增量筛子也采用了这种设计，原因的具体分析二者也是相似的，所以这里省略了，直接参考 GPF 增量筛子即可。 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>寻找 $f$ 这一步的复杂度分析本质上还要研究邻近质数的相关规律，但现在数学上好像还不能把这个规律搞得很清楚，不过根据经验判断，这一步的时间复杂度近似常量。同时这一步，只发生在遇到 $n = f’\cdot p^2,\ \texttt{gpf}(f’) = p$ 的时候。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>根据前文介绍过<a href="/algs/Prime0.html#伯特兰-切比雪夫定理">伯特兰-切比雪夫定理</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">代数结构</title><link href="/algs/AbstractAlgebraic.html" rel="alternate" type="text/html" title="代数结构" /><published>2024-09-16T00:00:00+08:00</published><updated>2024-09-16T00:00:00+08:00</updated><id>/algs/AbstractAlgebraic</id><content type="html" xml:base="/algs/AbstractAlgebraic.html"><![CDATA[<p><em>我们介绍得是抽象代数（abstract algebraic, modern algebraic）的结构，相对的我们熟悉的初等代数（elementary algebraic）就是研究代数方程，而我们抽象代数，显然就是更抽象了，但还有在它之上抽象的存在，那就是范畴论（category theory），是从哲学系那边转学过来的。</em></p>

<p><em>如果说初等代数是实参函数，抽象代数就是类接口，范畴论就是元类。</em></p>

<h2 id="群group">群（Group）</h2>

<p><strong>群，是一个集合和一个（二元）操作<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">1</a></sup>。</strong></p>

<p>并且：</p>

<p><em>以整数集合 $\mathbb Z$ 和操作 $\cdot$为例</em></p>

<ol>
  <li>操作有结合性（associativity），$(a\cdot b) \cdot c = a\cdot (b \cdot c)$</li>
  <li>有单位元（identity element） $e$<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">2</a></sup>，使得 $a \cdot e = e \cdot a = a$</li>
  <li>每个元素 $a$ 都有逆元 $b$ ，使得 $ a\cdot b = b \cdot a = e$ ，$b$ 也被称为 $a^{-1}$</li>
</ol>

<h4 id="子群subgroup">子群（Subgroup）</h4>

<p>对于群 $\langle G,\cdot \rangle$，如果有集合 $H\subseteq G$，并且 $\langle H,\cdot \rangle$ 也构成群，那么 $H$ 就是 $G$ 的子群<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">3</a></sup> ，记作 $H \leq G$。</p>

<p>显然，任何群的都有一个平凡子群 $\lbrace e \rbrace$ 。</p>

<h3 id="超群结构">超群结构</h3>

<h4 id="阿贝尔群abelian-group">阿贝尔群（Abelian Group）</h4>

<p>操作额外满足交换律 $a \cdot b = b \cdot a$ 的群<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<h3 id="类群结构">类群结构</h3>

<p>但是还有部分满足群条件的类群结构。</p>

<h4 id="幺半群monoid">幺半群（Monoid）</h4>

<p>如果没有逆元，那它就是幺半群<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">5</a></sup>。</p>

<p>比如 $\langle\mathbb N,\cdot\rangle$ ，相对于  $\langle\mathbb Z,\cdot\rangle$ 只有正整数那半边，没有负整数一边，所以没有逆元。</p>

<h4 id="半群semigroup">半群（Semigroup）</h4>

<p>如果连单位元都没有，那它就是半群。</p>

<p>比如 $\langle \lbrace x \vert x \gt 1, x \in {\mathbb Z} \rbrace,\cdot \rangle$ 。</p>

<h4 id="原群magma">原群（Magma）</h4>

<p>如果连结合性都没有，就一个集合和操作，那它就是原群。</p>

<p><a href="https://en.wikipedia.org/wiki/Semigroup">英文维基百科</a>上有个图把这个类群关系总结的非常好 ：</p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/abs_alge/Magma_to_group4.svg" style="zoom:100%;" /></div>
</p>

<h2 id="环ring">环（Ring）</h2>

<p><strong>环，是一个集合，两个（二元）操作</strong></p>

<p>并且 $\langle R,+,\cdot \rangle$ ：</p>

<ol>
  <li>
    <p>$\langle R,+\rangle$ 是阿贝尔群</p>
  </li>
  <li>
    <p>$\langle R,\cdot\rangle$ 是幺半群</p>
  </li>
  <li>
    <p>满足 $\cdot$ 在 $+$ 上的分配律（distributive）<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup></p>

    <p>3.1.  $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$ （左分配，left distributivity）</p>

    <p>3.2. $(b + c)\cdot a = (b \cdot a) + (c \cdot a)$  （右分配，right distributivity）</p>
  </li>
</ol>

<h4 id="零环">零环</h4>

<p>零环（Zero Ring）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup> ，就是只含有“乘法”上的 “零元” 和 加法上的“幺元” 的<strong>单元素</strong>环，记作 $\lbrace 0 \rbrace$ ，或 $\mathbf 0$ 。</p>

<h3 id="超环结构">超环结构</h3>

<h4 id="domain">Domain</h4>

<p>Domain<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>，就是非零环。</p>

<h4 id="交换环commutative-ring">交换环（Commutative Ring）</h4>

<p>交换环，就是“乘法”满足交换律的环。</p>

<h4 id="整环integral-domain">整环（Integral Domain）</h4>

<p>整环<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">9</a></sup>，就是<a href="#Domain">非零的</a>、交换环。</p>

<h3 id="类环结构">类环结构</h3>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3" role="doc-endnote">
      <p>操作在集合上是闭合的，也就是操作的结果也都在集合里。 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>又叫“幺元”，相对于乘法里的 “$1$” 。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>反过来说 $G$ 是 $H$ 的超群（overgroup） <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>因此也叫做交换群（commutative group） <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>又叫单群、亚群、独异点、四分之三群（搁这儿开起名大会呢😅） <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>因为 $\langle R,\cdot\rangle$ 并不满足交换律 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>又叫平凡环（trivial ring） <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>此域（domain）非彼域（field） <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>又叫整域 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[我们介绍得是抽象代数（abstract algebraic, modern algebraic）的结构，相对的我们熟悉的初等代数（elementary algebraic）就是研究代数方程，而我们抽象代数，显然就是更抽象了，但还有在它之上抽象的存在，那就是范畴论（category theory），是从哲学系那边转学过来的。]]></summary></entry><entry><title type="html">Haskell 学习小记</title><link href="/lang/Haskell%E5%AD%A6%E4%B9%A0.html" rel="alternate" type="text/html" title="Haskell 学习小记" /><published>2024-09-08T00:00:00+08:00</published><updated>2024-09-08T00:00:00+08:00</updated><id>/lang/Haskell%E5%AD%A6%E4%B9%A0</id><content type="html" xml:base="/lang/Haskell%E5%AD%A6%E4%B9%A0.html"><![CDATA[<p><em>origin written at 2020-11-01</em></p>

<h2 id="纯函数">纯函数</h2>

<p>Haskell 是 <strong>纯函数</strong> 语言，语义实现的全过程都在于形式演算，而非传统的值计算。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="形式化简">形式化简</h3>

<h4 id="阿尔法化简-alpha-conversion">阿尔法化简 （$\alpha$-conversion）</h4>

<p>通过变量名重命名来做等价变换:<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

\[\lambda x \rightarrow \lambda y \rightarrow x + y \equiv \lambda a \rightarrow \lambda y \rightarrow a + y\]

<h4 id="贝塔化简-beta-reduction">贝塔化简 （$\beta$-reduction）</h4>

<p>用实际的函数体替换掉参数。</p>

<h4 id="伊塔化简-eta-reduction">伊塔化简 （$\eta$-reduction）</h4>

<p>冗余简化:</p>

\[\lambda x \rightarrow f(x) \equiv f\]

<h3 id="柯里化currying">柯里化（currying）</h3>

<p>函数都是单参数的，多参函数，是通过柯里化方式转换成单参数：</p>

<p><code class="language-plaintext highlighter-rouge">\x1 x2 ... xn -&gt; f(x1 x2 ... xn)</code> 的实际形式是 <code class="language-plaintext highlighter-rouge">\x1 -&gt; \x2 -&gt;...xn -&gt; f(x1 x2 ... xn)</code>。</p>

<p>或者说，函数参数是右结合的。</p>

<p>举个例子:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">add</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">add'</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">&gt;</span> <span class="n">add'</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span>
</code></pre></div></div>

<h3 id="不动点fixed-point">不动点（fixed point）</h3>

<p>本身的概念是满足 $f(x) = x$ 的 $x$ ，这里用作递归的形式演算 <code class="language-plaintext highlighter-rouge">fix f = f (fix f)</code> 。</p>

<p>比如牛顿法开方：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 迭代次数 -&gt; 根值 -&gt; 结果</span>
<span class="c1">-- Normal Bad Version</span>
<span class="n">sqrtNB</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">sqrtNB</span> <span class="n">n</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtNB</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">/</span> <span class="n">sqrtNB</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1">-- 性能很差</span>
<span class="o">&gt;</span> <span class="n">sqrtNB</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="mf">2.23606797749979</span>
<span class="p">(</span><span class="mf">1.81</span> <span class="n">secs</span><span class="p">,</span> <span class="mi">914</span><span class="p">,</span><span class="mi">438</span><span class="p">,</span><span class="mi">408</span> <span class="n">bytes</span><span class="p">)</span>
</code></pre></div></div>

<p>使用不动点为：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqrtFix</span> <span class="n">n</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fix</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">n</span> <span class="n">t</span> <span class="o">-&gt;</span>
    <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>
        <span class="kr">then</span> <span class="n">t</span>
        <span class="kr">else</span> <span class="n">f</span>  <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">((</span><span class="n">t</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">n</span> <span class="n">x</span>

<span class="o">&gt;</span> <span class="n">sqrtFix</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="mf">2.23606797749979</span>
<span class="p">(</span><span class="mf">0.01</span> <span class="n">secs</span><span class="p">,</span> <span class="mi">93</span><span class="p">,</span><span class="mi">688</span> <span class="n">bytes</span><span class="p">)</span>
</code></pre></div></div>

<p>` fix` 实际实现里：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fix</span> <span class="n">f</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">x</span>  <span class="c1">-- `in` 限制了 `let` 绑定的作用域</span>
</code></pre></div></div>

<h2 id="函子">函子</h2>

<p><em>在这里我们不讨论这些接口的范畴论（category theory）相应概念的起源，也许有一天我研究了范畴论后，可以在函数式语言的进阶讨论中讨论这些概念，而现在这至少与我们理解这些接口的实际工作无关。</em></p>

<p><em>另一方面范畴论属于哲学数学，可以这么地在抽象的抽象上看问题，但这样有特别的意义吗，它好像还缺乏一个能特别证明它价值的领域。</em></p>

<h3 id="所谓函子functor">所谓函子（Functor）</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span>        <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    
    <span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span>        <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span>        <span class="o">=</span>  <span class="n">fmap</span> <span class="o">.</span> <span class="n">const</span>
</code></pre></div></div>

<p>函子提供了一种在上下文 <code class="language-plaintext highlighter-rouge">f</code> <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">3</a></sup><sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">4</a></sup>里进行函数操作的方式。</p>

<p>从名字上它叫函子不叫函数，就是暗示它支持把一般函数作为一个组件，带入上下文里（进行函数操作）。</p>

<p><code class="language-plaintext highlighter-rouge">class Functor</code>  只有一个必须实现的接口函数 <code class="language-plaintext highlighter-rouge">fmap</code> ，它的签名也很好地反映了函子的本质：接受一个函数 <code class="language-plaintext highlighter-rouge">a-&gt;b</code> ，把它应用在上下文 <code class="language-plaintext highlighter-rouge">f</code> 里，使得 <code class="language-plaintext highlighter-rouge">f a</code> 变为 <code class="language-plaintext highlighter-rouge">f b</code> 。</p>

<p>（标准库）还为函子的 <code class="language-plaintext highlighter-rouge">fmap</code> 导出了等价的中缀操作符 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;$&gt;</span>

<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmap</span>
</code></pre></div></div>

<p>此外，<code class="language-plaintext highlighter-rouge">class Functor</code> 提供了一个有默认实现<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>的 <code class="language-plaintext highlighter-rouge">(&lt;$)</code> <sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup>。</p>

<p>其中，<code class="language-plaintext highlighter-rouge">.</code> 有 <code class="language-plaintext highlighter-rouge">(.) f g = \x -&gt; f (g x)</code> ，<code class="language-plaintext highlighter-rouge">const</code> 有</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">const</span>                   <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">const</span> <span class="n">x</span> <span class="kr">_</span>               <span class="o">=</span>  <span class="n">x</span>
</code></pre></div></div>

<p>可以手工（形式演算）推出 <code class="language-plaintext highlighter-rouge">(&lt;$)</code> 的类型签名：</p>

<p><code class="language-plaintext highlighter-rouge">fmap . const = a -&gt; f1 (g a)</code> ，展开 <code class="language-plaintext highlighter-rouge">.</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">g = a-&gt;b-&gt;a</code> =&gt; <code class="language-plaintext highlighter-rouge">(g a) = (b-&gt;a)</code>，展开 <code class="language-plaintext highlighter-rouge">const</code></li>
  <li><code class="language-plaintext highlighter-rouge">f1 = (a -&gt; b) -&gt; f2 a -&gt; f2 b</code> ， 展开 <code class="language-plaintext highlighter-rouge">fmap</code></li>
  <li><code class="language-plaintext highlighter-rouge">f1 (g a) = f1 (b-&gt;a) = f1 b -&gt; f1 a</code> ，规约替换 <code class="language-plaintext highlighter-rouge">(g a)</code>  和 <code class="language-plaintext highlighter-rouge">f1</code></li>
  <li><code class="language-plaintext highlighter-rouge">a -&gt; f1 (g a) = a -&gt; f1 b -&gt; f1 a</code> ，规约替换 <code class="language-plaintext highlighter-rouge">f1 (g a)</code></li>
  <li><code class="language-plaintext highlighter-rouge">fmap . const = a -&gt; f b -&gt; f a</code> ，重命名 <code class="language-plaintext highlighter-rouge">f1 = f</code></li>
</ul>

<h3 id="应用函子applicative">应用函子（Applicative）</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="cp">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>

    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>

    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">id</span>

    <span class="n">liftA2</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
    <span class="n">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>

    <span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
    <span class="n">a1</span> <span class="o">*&gt;</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;$</span> <span class="n">a1</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">a2</span>

    <span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">const</span>
    
<span class="c1">-- ...</span>

<span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;$</span>
<span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;*&gt;</span>
</code></pre></div></div>

<p>应用函子的设计是在上下文里为同一个函数连接多个参数。</p>

<p><code class="language-plaintext highlighter-rouge">class Applicative</code> 最小实现需要实现 1.  <code class="language-plaintext highlighter-rouge">pure</code> ，2.  <code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code> 与 <code class="language-plaintext highlighter-rouge">liftA2</code> 中任意一个 <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>。</p>

<h4 id="pure"><code class="language-plaintext highlighter-rouge">pure</code></h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>把一个参数装进上下文 <code class="language-plaintext highlighter-rouge">f</code> 中 。<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup><sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup></p>

<h4 id="-和-lifta2"><code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 和 <code class="language-plaintext highlighter-rouge">liftA2</code></h4>

<p><code class="language-plaintext highlighter-rouge">Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code></p>

<p>因为 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 与 <code class="language-plaintext highlighter-rouge">liftA2</code> 分别有以对方为基础的默认实现，所以接口只需实现其中任意一个，让我们看下它们的函数签名和默认实现。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">id</span>

<span class="n">liftA2</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="n">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>相比于前面的 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> ， <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 是说把 <code class="language-plaintext highlighter-rouge">a -&gt; b</code> 也放进上下文 <code class="language-plaintext highlighter-rouge">f</code> 里，<strong>这样做的好处是可以利用函数柯里化，在上下文里连接多个参数，这也是应用函子的本质。</strong></p>

<p>比如有一个多参函数 <code class="language-plaintext highlighter-rouge">a -&gt; b -&gt; c -&gt; d</code> ，那么可以结合 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 操作符，用 <code class="language-plaintext highlighter-rouge">(a -&gt; b -&gt; c -&gt; d) &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; f c</code> 的形式在上下文里传参。<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup></p>

<p>而 <code class="language-plaintext highlighter-rouge">liftA2</code> 则像是多一个参数的 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 。</p>

<p>再来看看  <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 的默认实现，按照形参实参一一对应的原则有：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="n">liftA2</span> <span class="n">id</span> 
<span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">))</span>      <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="o">=&gt;</span> <span class="p">((</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
                        <span class="o">=&gt;</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 的默认实现就有点儿隐晦了，至于 <code class="language-plaintext highlighter-rouge">liftA2</code> 的默认实现，那更是神中神，直接不演了，表明定义的实质就是模式匹配：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftA2</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span>  <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="n">fmap</span>   <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>

            <span class="n">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>
<span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">((</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
             <span class="n">fb</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">f</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
                     <span class="kr">_</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
</code></pre></div></div>

<p>注意函数实现里的实参是单独的，而函数签名里的形参则与它所在的 <code class="language-plaintext highlighter-rouge">class</code> 同名对应。</p>

<h4 id="-和-"><code class="language-plaintext highlighter-rouge">&lt;*</code> 和 <code class="language-plaintext highlighter-rouge">*&gt;</code></h4>

<p>在上下文的环境里 ，分别只保留左边参数和只保留右边参数</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixl</span> <span class="mi">4</span> <span class="o">&lt;*</span><span class="p">,</span> <span class="o">*&gt;</span><span class="p">,</span>

<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="n">const</span>

<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="n">a1</span> <span class="o">*&gt;</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;$</span> <span class="n">a1</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">a2</span>

<span class="n">const</span>                   <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">const</span> <span class="n">x</span> <span class="kr">_</span>               <span class="o">=</span>  <span class="n">x</span>
</code></pre></div></div>

<h4 id="applicative-实例">Applicative 实例</h4>

<p><strong><code class="language-plaintext highlighter-rouge">[]</code></strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span>    <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="o">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
    <span class="n">liftA2</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="p">]</span>
    <span class="n">xs</span> <span class="o">*&gt;</span> <span class="n">ys</span>  <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="kr">_</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="p">]</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">Maybe</code></strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>  
    <span class="n">pure</span> <span class="o">=</span> <span class="kt">Just</span>  
    <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>  
    <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">something</span>

<span class="o">&gt;</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>

<span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span>
<span class="o">&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<h4 id="alternative">Alternative</h4>

<p>应用函子的一个继承</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixl</span> <span class="mi">3</span> <span class="o">&lt;|&gt;</span>
<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Alternative</span> <span class="n">f</span> <span class="kr">where</span>
	<span class="n">empty</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>下面举一个最常见的例子：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Alternative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">empty</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">empty</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">l</span>       <span class="o">&lt;|&gt;</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">l</span>

<span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">1</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="单子应用monad">单子应用（Monad）</h3>

<p>醋来了，可以说整篇学习笔记就是为了搞明白 Monad 是什么而包的饺子。</p>

<p>经常地，在某个新生的编程语言的相关论坛上，当提到函数式特别是纯函数式的编程语言范式的时候，总会有一些人，不问自答、不清自来地问：“ xx（该编程语言）能从 Haskell 的 Monad 里学到什么？”，每次看到这儿我就会想，这个 Monad 到底是什么，怎么来不来的就要从它那儿学什么东西。</p>

<p>而找的一般教程总是把 Monad 搞得玄而又玄，并不清楚明白，于是有了这个学习笔记， 于是来到了这里。</p>

<p><code class="language-plaintext highlighter-rouge">Monad</code> <sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">12</a></sup> 和  <code class="language-plaintext highlighter-rouge">Alternative</code> 一样，它也是对应用函子的一个继承。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>       <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span>        <span class="o">::</span> <span class="n">forall</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
    <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">k</span>

    <span class="n">return</span>      <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
    <span class="n">return</span>      <span class="o">=</span> <span class="n">pure</span>
    
<span class="kr">infixl</span> <span class="mi">1</span>  <span class="o">&gt;&gt;</span><span class="p">,</span> <span class="o">&gt;&gt;=</span>
</code></pre></div></div>

<p>从定义上也看出来了，<code class="language-plaintext highlighter-rouge">class Monad</code> 主要就是 <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 的实现，是从一个上下文里的值 <code class="language-plaintext highlighter-rouge">m a</code>，传一个从内部值变换到另一个内部值并把它包装回上下文的函数 <code class="language-plaintext highlighter-rouge">a -&gt; m b</code>，最后得到一个上下文的值 <code class="language-plaintext highlighter-rouge">m b</code>。</p>

<p>从 <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 的函数签名上很容易发现，它的返回类型和首参类型是一样，这必然意味着必然可以有 <code class="language-plaintext highlighter-rouge">M a &gt;&gt;= f1 &gt;&gt;= f2 &gt;&gt;= 2 ... &gt;&gt;= fn</code> 这样的形式。</p>

<p><strong>如果说 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 是在上下文环境里连接多个参数，那么 Monad 提供的 <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 就是在上下文里连接多个操作。</strong></p>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 也有个 Haskell 里的名字叫 “bind” ，相对地 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> 是忽略之前上下文的值。</p>

<p>Haskell 里有个特殊语法 <code class="language-plaintext highlighter-rouge">do</code> 用来简化这种 <code class="language-plaintext highlighter-rouge">Monad</code> 上下文的函数连接。</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
	<span class="n">m</span> <span class="n">a</span>
	<span class="n">f1</span>
	<span class="n">f2</span>
	<span class="n">f3</span>
</code></pre></div></div>

<p>还可以用特殊语法 <code class="language-plaintext highlighter-rouge">x &lt;- f1</code> 来从某一步的上下文里取值。</p>

<p>还有一个常用的工具 <code class="language-plaintext highlighter-rouge">guard</code> ， 功能如其名：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">guard</span>           <span class="o">::</span> <span class="p">(</span><span class="kt">Alternative</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="nb">()</span>
<span class="n">guard</span> <span class="kt">True</span>      <span class="o">=</span>  <span class="n">pure</span> <span class="nb">()</span>
<span class="n">guard</span> <span class="kt">False</span>     <span class="o">=</span>  <span class="n">empty</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">empty</code> 是 <code class="language-plaintext highlighter-rouge">Alternative</code> 实现时定义的，是一个明确的表示失败的值。</p>

<h4 id="从-monad-里学到什么">从 <code class="language-plaintext highlighter-rouge">Monad</code> 里学到什么</h4>

<p>与其说从 <code class="language-plaintext highlighter-rouge">Monad</code> 里学到什么，不如说从 <code class="language-plaintext highlighter-rouge">Functor</code> 里学到什么，这一系列都是在探讨在某个上下文环境里做操作的语义。</p>

<p>对于纯函数式语言来说，有其在具体实现上的普遍意义。</p>

<p>而我关心的是非纯函数式语言（的设计）能从中获得什么意义？</p>

<p>应该是提供一种在非确定性上下文里操作的语义。</p>

<p>首先，明确下非确定性上下文的特征，它应该有成功的，可以继续执行下去的结果；和一种或多种失败的，没有继续执行下去意义的结果。就像经典的 IO 操作，如果前面操作没有成功，那么后面继续也就没有意义；或者连续查询的操作，如果前面是空的，后面在空集上继续查询也没有意义。</p>

<p>这么看来 Rust 的 <code class="language-plaintext highlighter-rouge">Result</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 机制已经把这个语义利用得到位了，也不能指望更多了。</p>

<p>在编写编译器的 parser 部分，就大量使用到这种语义，使得我们的代码只需要呈现主要的逻辑，也为程序员节省宝贵的精力。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">parse_fn</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Fn</span><span class="p">,</span> <span class="n">SomeError</span><span class="o">&gt;</span> <span class="p">{</span>    
    <span class="nf">Ok</span><span class="p">(</span><span class="nb">Fn</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="nf">parse_fn_name</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nf">parse_fn_params</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
        <span class="n">ret</span><span class="p">:</span> <span class="nf">parse_fn_ret</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
        <span class="n">body</span><span class="p">:</span> <span class="nf">parse_fn_body</span><span class="p">()</span><span class="o">?</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而普通程序就要写如下</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">parse_fn</span><span class="p">()</span> <span class="p">(</span><span class="n">Fn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">name_err</span> <span class="o">=</span> <span class="n">parse_fn_name</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">name_err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">..</span><span class="p">,</span> <span class="n">name_err</span>
    <span class="p">}</span>
    
    <span class="n">params</span><span class="p">,</span> <span class="n">params_err</span> <span class="o">=</span> <span class="n">parse_params</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">params_err</span> <span class="o">!=</span> <span class="n">nill</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">..</span><span class="p">,</span> <span class="n">params_err</span>
    <span class="p">}</span>
    
    <span class="n">ret</span><span class="p">,</span> <span class="n">ret_error</span> <span class="o">=</span> <span class="n">parse_ret</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">ret_err</span> <span class="o">!=</span> <span class="n">nill</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">..</span><span class="p">,</span> <span class="n">ret_err</span>
    <span class="p">}</span>
    
    <span class="n">body</span><span class="p">,</span> <span class="n">body_err</span> <span class="o">=</span> <span class="n">parse_body</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">body_err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">..</span><span class="p">,</span> <span class="n">body_err</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">Fn</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">ret</span><span class="p">,</span>
        <span class="n">body</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>还有一个关于<a href="https://langdev.stackexchange.com/questions/2675/why-does-haskell-use-the-bind-operation-instead-of-kleisli-composition">Haskell使用 bind 而不是 kleisli-构成</a> 的进阶讨论，回答很深入，但只是标记在这里，不做进一步讨论。</em></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>相比之下，作为函数式语言的另一个分支，Lisp家族，以 CommonLisp 为例，实际上广泛地使用可变的数据结构和有副作用的函数。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>当然前提是不能有命名冲突。 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">f</code> 是单参的类型构造器（一种特殊的函数），不过正如前面讲的，Haskell 多参函数的本质都是柯里化的单参函数 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>按照官方文档的说法，  <code class="language-plaintext highlighter-rouge">f a</code> 也可以叫做 action <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">infixl</code> 关键字规定中缀操作符是（向）左结合的，并指定它的优先级，给的数字越大优先级越高，类似地还有指定右结合的 <code class="language-plaintext highlighter-rouge">infixl</code> 和不指定结合性的 <code class="language-plaintext highlighter-rouge">infix</code> （此时， <a href="https://stackoverflow.com/questions/27770118/how-does-the-infix-work">只能通过括号显式指定结合性</a>）；并且不显式指定结合性和优先级，<a href="https://www.haskell.org/onlinereport/decls.html#fixity">那么默认是左结合，优先级为最高（最高为 $9$ ）</a> 。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>文档里也支持自己实现更高效的版本 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>从命名规律上讲，不妨称之为：“左偏刀”，还有 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> ，可以称之为 “全刀”，后面还有一些特殊符号的运算符：<code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> ，<code class="language-plaintext highlighter-rouge">&lt;*</code> 和<code class="language-plaintext highlighter-rouge">*&gt;</code>可以依次称之为 “全星”，“左偏星” 和“右偏星” <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>或者两个都实现，只要二者不发生矛盾 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">=&gt;</code> 前面是类型约束 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>在非纯函的语言看来，这个函数签名简直莫名其妙，这个 <code class="language-plaintext highlighter-rouge">f</code> 它从哪儿来的，怎么绑定的？这都不知道，唯一好像可以类比得是闭包里捕获的自由变量，但完全没有类比意义，基本上在 Haskell 里需要完全抛弃基于值的非纯函的编程模型，只考虑形式演算的问题，在这种前提下，我们就知道 <code class="language-plaintext highlighter-rouge">f</code> 会在形式演算的过程中根据签名匹配出来。 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 和 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 虽然优先级相同，但都是左结合 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>注意和名字相近的 <code class="language-plaintext highlighter-rouge">Monoid</code> 的区别，二者只是在范畴论上有单子可以作为 Monoid 的范化概念的关系，但从编程实际来看，二者没什么直接关系，只是名称有点儿容易搞混。<code class="language-plaintext highlighter-rouge">Monoid</code> 本身是一个经典代数结构，指的是有“幺元”的半群，在 Haskell 里也是一个接口（<code class="language-plaintext highlighter-rouge">class</code>），继承了另一个接口 <code class="language-plaintext highlighter-rouge">semigroup</code> 。 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;lang&quot;]" /><summary type="html"><![CDATA[origin written at 2020-11-01]]></summary></entry><entry><title type="html">质数筛子</title><link href="/algs/Prime1.html" rel="alternate" type="text/html" title="质数筛子" /><published>2024-08-27T00:00:00+08:00</published><updated>2024-08-27T00:00:00+08:00</updated><id>/algs/Prime1</id><content type="html" xml:base="/algs/Prime1.html"><![CDATA[<p><em>质数筛子的原理是质因数分解</em>。</p>

<h2 id="前言">前言</h2>

<p>有几个关于质数筛子的总结性观察：</p>

<h3 id="观察-1">观察 1</h3>

<p>不使用分段技术的（可用的）质数筛子，不管它的<strong>时间复杂度</strong>和<strong>空间复杂度</strong>在理论上是超线性、线性还是亚线性，在实践上都可以视为线性。</p>

<p>这是因为，</p>

<ol>
  <li>它们的区别往往只在于 $ N\log\log N$,  $N$ 和 $\large\frac{N}{\log\log N}$ ，而 $\log\log N$ 对于一个 64 位机的指针宽度的最大数字也就是 $\log\log64 = 8$ ，很可能还不如一个常数大；</li>
  <li>在实现上，超线性和线性算法有数据结构简单的优势，而亚线性算法则有规定时间复杂度内实际实现不了或者常数很大的劣势。</li>
</ol>

<h3 id="观察-2">观察 2</h3>

<p>质数筛子的时间复杂度和空间复杂度不可能同时为亚线性。</p>

<h3 id="观察-3">观察 3</h3>

<p>能否应用分段技术是筛子算法先进与否的分水岭。</p>

<p>能运用分段技术，实质就是可以进行独立任务分解，这样一方面可以将空间占用降为 $O(\sqrt N)$ ，而通常算法的瓶颈在于空间占用；另一方面也可以在多核架构下进行并行化处理。</p>

<p><em>以下介绍的筛子按照发明的时间顺序进行排列， 标题括号里的是对其总体评价。</em></p>

<h2 id="eratosthenes-筛子">Eratosthenes 筛子（√√√）</h2>

<p>Eratosthenes 筛子，简称作E-筛子，属于是非常古老、简单的一种筛子算法：</p>

<ol>
  <li>在对整个范围一遍扫描的过程中，开始先逐个数检查质性；</li>
  <li>当发现一个质数 $p$ 时，就把它的乘积： $2p, 3p, \dots , \lfloor n/p\rfloor p$ ，都标记为合数；</li>
  <li>这样在继续扫描的过程中发现被标记为合数的就直接跳过，直到发现下一个质数，然后重复步骤2直到 $n$</li>
</ol>

<p>实际上我们标记合数的方法是追踪所有小于它的质数，因为根据之前所讲的<a href="/algs/Prime0.html#算式基本定理">正整数唯一分解定理</a>，也就是所有的合数都可以做质因数分解，一定存在一个严格比它小的质数可以除它。这样的话，如果我们是从第一个质数开始，那么实际上：</p>

<ol>
  <li>标记合数的过程不需要从 $2p$ 开始，而是直接从 $p\cdot p$ 开始，因为所有 $\lt p$ 的合数已经被更小的质数标记过了；</li>
  <li>最外轮的扫描只到 $\lfloor \sqrt{n} \rfloor$ 即可，因为作为合数的因子对，只需要通过那些较小的就可以完成合数的标记了</li>
</ol>

<h3 id="样例代码">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">bit_vec</span><span class="p">::</span><span class="n">BitVec</span><span class="p">;</span>

<span class="nd">macro_rules!</span> <span class="n">sieve_spec_case</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">empty</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$n</span><span class="p">:</span> <span class="n">ident</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>

        <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="nv">$n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析">复杂度分析</h3>

<p>每查找到一个质数 $p$ ，就需要 $N/p$ 的操作次数，因此总的操作数为 $\displaystyle \sum_{ p\leqslant \sqrt{N}}  N/p $ 。而根据已知的结论，来自<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>  chapter 22 的：$\displaystyle \sum_{p \leqslant x} \frac{1}{p} = \log\log x + O(1)$ ，可以得到算法的最坏时间复杂度为 $O(N\log\log N)$ 。</p>

<h3 id="算法评价">算法评价</h3>

<p>是次快的算法，而且非常简单，虽然空间占用 $O(N)$，但常数非常小（等效 $O(\large\frac{N}{\log\log N})$ 说是）。</p>

<h2 id="分段-eratosthenes-筛">分段 Eratosthenes 筛（√√√）</h2>

<p>分段处理可以把空间占用从 $O(N)$ 降到 $O(\sqrt{N})$ ，指数级地缓解算法的空间占用。</p>

<p>方法是可以预计算出所有到 $\sqrt{N}$ 为止的质数，根据前面已知，所有 $\leqslant N$ 范围内的合数都可以由预计算出的质数构造出，只需要知到这些质数的乘积落在每个分段上的第一个数，就可以标记完所有这个分段的合数。</p>

<p>而如何知道质数 $p$ （的乘积）落在某个分段区间的第一个数呢？只需要知道分段的左边缘 $l$ ，那么易知落点为 $l+p-(l\mod{p})$ 。</p>

<h3 id="样例代码-1">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Space: O(\sqrt{n})</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_seg_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">acc</span><span class="nf">.extend</span><span class="p">(</span><span class="nf">e_seg_sieve_0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pris</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">l</span><span class="p">)));</span>

        <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">acc</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>

<span class="cd">/// 0. p^2 &gt;= l+delta</span>
<span class="cd">/// 1. pris from 0..x, no empty.</span>
<span class="cd">/// 2. return (l, l+delta]</span>
<span class="k">fn</span> <span class="n">e_seg_sieve_0</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
    <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">pris</span><span class="nf">.is_empty</span><span class="p">());</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">seg</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

            <span class="k">for</span> <span class="o">&amp;</span><span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">p</span><span class="o">..=</span><span class="n">delta</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">seg</span><span class="nf">.set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="k">in</span> <span class="n">seg</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析-1">复杂度分析</h3>

<p>这样主要辅助空间是两个 $\sqrt{N}$ bit 的数组，因此空间复杂度为 $O(\sqrt{N})$ 。而当分段大小为 $\sqrt{N}$ 时，总的时间复杂度仍然是 $O(N\log\log N)$ 。</p>

<h3 id="算法评价-1">算法评价</h3>

<p>速度排名属于第三档，但仍然简单而且足够快，重要的是使用了分片技术！</p>

<h2 id="sundaram-筛子">Sundaram 筛子（√√√）</h2>

<p>Sundaram 筛子<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">2</a></sup> ，是基于奇数因子分解 $2k+1$ 的筛子。</p>

<p>方法是检查所有 $i + j + 2ij\quad (1\leqslant i \leqslant j)$ 形式的数字，筛掉所有奇数里的合数。</p>

<p>原理如下：</p>

\[\begin{array}{ll}
2k+1&amp;= 2\cdot(i+j+2ij) + 1 \\
&amp;= 2i + 2j + 4ij + 1  \\
&amp;= (2i+1)(2j+1) 
\end{array}\]

<p>也就是说所有由 $k=i + j + 2ij$ 构成的奇数都是合数；反过来，一个奇数合数也只能是分解为两个奇数之积。</p>

<h3 id="样例代码-2">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">sundaram_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="nf">once</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.filter_map</span><span class="p">(</span>
            <span class="p">|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">},</span>
        <span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法改进">算法改进</h3>

<p>但是与其去构造奇数，不如直接检测所有奇数，这样还避免了很多 $i + j + 2ij \gt k$ 时的空转。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">sundaram_sieve_improved</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">odd1</span> <span class="k">in</span> <span class="p">(</span><span class="mi">3</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">())</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// for c in (odd1 * odd1..=n).step_by(2 * odd1) {</span>
        <span class="c1">//     bits.set((c - 1) / 2, false);</span>
        <span class="c1">// }</span>

        <span class="k">for</span> <span class="n">odd2</span> <span class="k">in</span> <span class="p">(</span><span class="n">odd1</span><span class="o">..</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">odd1</span> <span class="o">*</span> <span class="n">odd2</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">bits</span><span class="nf">.set</span><span class="p">((</span><span class="n">odd1</span> <span class="o">*</span> <span class="n">odd2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="nf">once</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.filter_map</span><span class="p">(</span>
            <span class="p">|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">},</span>
        <span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里注解了一段乘法改加法的代码，在一些经典算法论文，通常是上世纪九十年代以前的那些，很喜欢搞乘法变加法的优化，但现在应该被视为过早优化，因为乘法很容易，也很普遍地在更低层次的软件和硬件上做优化，在应用端算法上做加法替代实现反而构成了一种明显的反优化。<sup id="fnref:21" role="doc-noteref"><a href="#fn:21" class="footnote" rel="footnote">3</a></sup></p>

<p>另一方面，除法倒是还有算法上优化的必要。</p>

<h3 id="复杂度分析-2">复杂度分析</h3>

<p>时间复杂度 $O(N\log\log N)$ ，空间复杂度 $O(N)$ 。</p>

<h3 id="算法评价-2">算法评价</h3>

<p>实践时间性能非常好，是最快的一档，特别是改进的版本，甚至比 SFWS 还要快一点点。</p>

<h2 id="mairson-筛子">Mairson 筛子（√）</h2>

<p>仔细考虑下，前面E-筛子的计算过程还有重复的操作，就是有一些合数比如 $C = p_m^i\cdot p_n^j\cdot p_q^k,\ (p_m\neq p_n\neq p_q)$ 它会被不同的质数 $p_m, p_n, p_q$ 重复标记，这也是它超线性时间复杂的原因。</p>

<p>Mairson 筛子<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">4</a></sup>的实质是取消这些重复标记的过程，把问题转化为线性，为此每用一个质数 $p$ 标记完一些合数后，就要把这些合数排除在后续的标记范围里。</p>

<p>道理都懂，问题是怎么排除，Mairson 很实在地给出了具体的数据结构，也是大家根据这个具体情况自然而然能想到的，即，一个基于数组的双向链表：</p>

<ol>
  <li>一般情况下，既然是集合的操作，那么就可以考虑哈希集合，但从冗余度上讲空间占用会是所需的几倍；而质数的情况是值空间有限，实际上都是连续的自然数，完全可以放进一个数组里，用数组的下标作为索引的键；</li>
  <li>再考虑到从集合删除元素的操作需要是常数级 $O(1)$ ，那么就需要是一个链表，而且是双向链表；</li>
  <li>数组每个位置存储下一个节点的索引坐标，这样在标记某个数被删除时，只需要修改它的左右节点，就可以跳过这个节点；</li>
  <li>这个链表的头可以就是数组头，而它的尾部只需要靠存储值为零进行标记，同时这种设计使得这个链表在首尾连成了一个环，头部也形成了一个自环，体现了一种优雅。</li>
</ol>

<p>于是我们构造这个结构如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// n &gt; 0</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
</code></pre></div></div>

<p>用 <code class="language-plaintext highlighter-rouge">forward</code> 数组记录前向链接、<code class="language-plaintext highlighter-rouge">backward</code> 数组记录后向链接，开始时它们应该初始化为：</p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/forward.svg" style="zoom:100%;" /></div>
</p>
<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/backward.svg" style="zoom:100%;" /></div>
</p>

<p>这样当从集合里删除某个数 $i$ 时，只需要：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div></div>

<p>这样整个算法过程的其他部分和之前的 E-筛子一样。</p>

<h3 id="样例代码-3">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// lpf (least prime factor)</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2usize</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="cm">/* collected andthen remove all number which lpf is p from S. */</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                    <span class="c1">// remove p*f from S</span>
                    <span class="n">c</span><span class="nf">.push</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span><span class="p">);</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">c</span> <span class="p">{</span>
                    <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="n">i</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意得是，不能标记一个合数 $f$ 就立刻把它删除，因为还需要依靠它去标记 $p\cdot f$ 以及其它后续的合数。所以必须要先收集一个质数 $p$ 标记的所有合数，然后再把它们删除。</p>

<h3 id="算法改进-1">算法改进</h3>

<p>如果可以从由 $p$ 组成的最大的那个合数开始逆序标记，那么就可以立刻删除 $p\cdot f$ 而不需要先收集起来。<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">5</a></sup></p>

<p>这可以带来一些性能的提升和空间的节省。</p>

<p>那么问题就变成如何找到最大待标记数对应的 $f$ ，或者如何追踪它。</p>

<p>我们一步步地考虑这个问题，开始时 $p_1 = 2$ ，那么 $f_{\text{max}} = \large\lfloor \frac{n}{2} \rfloor$ ，在用 $p_1$ 标记完一轮后，再从 $f_{\text{max}}$  开始逐个向下检查，直到找到一个还在链表上的数，然后从它开始沿着链表倒序查找，找到一个满足  $p_2 \cdot f \leqslant n$ 的值作为第二轮 $p_2$ 对应的 $f_{\text{max}}$ 。</p>

<p>这样的话在从链表上删除某个数的时候，还需要在对应下标的某个数组上额外标记它，以便于能在 $O(1)$ 的时间里检查某个数是否在链表上。<code class="language-plaintext highlighter-rouge">backward</code> 还需要用来向前查找，可以用 <code class="language-plaintext highlighter-rouge">forward[i] = n+1</code> ，表示 $i$ 被删除。</p>

<p>这样的话标记结束的条件也可以用 $f_{\text{max}} \geqslant p$ 来代替。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">while</span> <span class="n">f_max</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f_max</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
        <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>
        <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>

        <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag it</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">forward</span><span class="p">[</span><span class="n">f_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">while</span> <span class="n">f_max</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//...</span>
</code></pre></div></div>

<p>有一个观察，但是还无法证明，链表上相邻的两个数不会被同一个 $p$ 标记<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">6</a></sup>，那么下一轮的 <code class="language-plaintext highlighter-rouge">f_max = backward[f_max]</code> 。</p>

<p>这样改进后的完整算法如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">forward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">backward</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">once</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.chain</span><span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// lpf (least prime factor)</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2usize</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">f_max</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f_max</span><span class="p">;</span>

                <span class="k">while</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">p</span> <span class="p">{</span>
                    <span class="n">forward</span><span class="p">[</span><span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>
                    <span class="n">backward</span><span class="p">[</span><span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]]</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">];</span>

                    <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag it</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">p</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
                <span class="k">if</span> <span class="n">forward</span><span class="p">[</span><span class="n">f_max</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
                <span class="k">while</span> <span class="n">f_max</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> <span class="n">f_max</span> <span class="o">=</span> <span class="n">backward</span><span class="p">[</span><span class="n">f_max</span><span class="p">];</span> <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="n">i</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="复杂度分析-3">复杂度分析</h3>

<p>显然，时间复杂度和空间复杂度均为 $O(N)$ 。</p>

<h3 id="算法评价-3">算法评价</h3>

<p>一般，跑得不快，内存占用在线性算法里也属于常数比较大的。</p>

<h2 id="轮子与轮筛-">轮子与轮筛（-）</h2>

<p>（纯）轮筛<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">7</a></sup><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">8</a></sup> 是假的，<strong>但轮子（族）是真的</strong>。</p>

<h3 id="定义轮子">定义轮子</h3>

<p><strong>轮子（wheel）</strong>是由头几个质数的乘积构成的一个空间，空间里的数都与这些质数互质。</p>

<p>这头几个质数的乘积叫做质数阶乘，记作 $p_k\sharp = \displaystyle\prod_{i=1}^{k}{p_i} = p_1\times  p_2 \ \times ..\ p_k$ <sup id="fnref:14" role="doc-noteref"><a href="#fn:14" class="footnote" rel="footnote">9</a></sup>，在前面<a href="/algs/Prime0.html">质数基础</a>的<a href="/algs/Prime0.html#质性测试">质性测试</a>一节已经接触过这个概念，于是有轮子 $W_k$（第 $k$ 个轮子）：</p>

\[W_k = \lbrace x\vert\  x \bot p_k\sharp,\ (1\leqslant x \leqslant p_k\sharp)  \rbrace\]

<p>和 $W_k$ 的模 $p_k\sharp$ 的同余数集 $W_k^*$ ：</p>

\[W_k^* = \lbrace x\vert\ x \pmod {p_k\sharp} \in W_k \rbrace\]

<p>显然，任何一个 $x \in W_k^*$ 都和 $p_1,\ p_2\ ..,\ p_k$ 互质，这可以用来把很多非质数提前筛出去，并且如果 $x \lt p_{k+1}^2$ ，那么 $x$ 一定是个质数。</p>

<p>自然可以想到，如果能构造一个更大的轮子，那么显然可以更有效地筛选质数，可以在更大范围内直接确保 $x$ 就是个质数。</p>

<h3 id="构造轮子">构造轮子</h3>

<p>首先，我们知道 $W_1 = \lbrace 1 \rbrace$；</p>

<p>其次，Pritchard 给出了一个非常形象的示意图来演示如何通过“滚动”和删除一些点，从 $W_k$ 构造出 $W_{k+1}$<sup id="fnref:5:1" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">8</a></sup></p>

<h4 id="图-轮子" align="center">图-轮子</h4>
<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/wheel.png" style="zoom:50%;" /></div>
</p>

<p>直接看图有些不明所以，让我们慢慢解释。</p>

<p>可以定义周长为 $p_k \sharp$ 的圆圈 $C_k$，$x \in W_k$ 则是它上面沿顺时针标记的点。</p>

<p>从 $W_k$ 构造出 $W_{k+1}$：</p>

<ol>
  <li>
    <p>$W_k$ “滚动” $p_{k+1}$ 圈就可以得到下一个轮子 $W_{k+1}$ 轮廓；</p>
  </li>
  <li>
    <p>再根据 $W_{k+1}$ 定义，删除满足 $x’ = p_{k+1}\cdot x,\ (x\in W_k)$ 的“同辐条点”，因为 $x’ \vert p_{k+1}$</p>
  </li>
</ol>

<h3 id="轮子性质">轮子性质</h3>

<h4 id="性质-1">性质 1</h4>

<p>如上图所示，通过 $C_k$ 滚动构建 $C_{k+1}$ 后根据 $W_{k+1}$ 定义需要删除的点 $x’$，与原先 $C_k$ 上的点在同一根辐条上，或者说它们弧度相同。</p>

<p><em>因为 $x’ = p_{k+1}\cdot x$ 。</em></p>

<h5 id="性质-11">性质 1.1</h5>

<p>这样我们知道 $\vert W_{k+1}\vert = (p_{k+1}-1)\cdot \vert W_k \vert$。</p>

<p>而我们知道 $\vert W_1\vert = 1$  ，通过递推，可以得到 $\vert W_k\vert = \displaystyle\prod_{i=1}^{k} (p_{i+1}-1)$ 。</p>

<h5 id="性质-12">性质 1.2</h5>

<p>进一步地，我们也可以得到轮子的筛选效率 $E_k =\large \frac{\vert W_k\vert}{p_k\sharp} = 1 - \displaystyle\prod_{i=0}^{k} \frac{p_{i+1}-1}{p_{i+1}}$</p>

<p>下图即为轮子筛选效率的曲线图。</p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/wheel_eff.svg" style="zoom:100%;" /></div>
</p>

<p>虽然总体趋势是存在边际效用，但前几个轮子的“费效比”都很好，这启发我们可以用一个比较小的轮子先做粗筛，然后用其他方法做进一步检测。</p>

<p><em>前面“试除法”检测质数实际就用了 $W_2$ 轮子。</em></p>

<h4 id="性质-2">性质 2</h4>

<p>轮子上第一个点是 $1$。</p>

<p><em>从 <strong>性质 1</strong> 也可以推出，因为在构建新轮子过程中它永远不会被删除；或者根据轮子的定义，$1$ 与任何数互质，所以永远在轮子里。</em></p>

<h4 id="性质-3">性质 3</h4>

<p>轮子 $W_k$ 上的第二个点是 $p_{k+1}$ 。</p>

<p><em>首先根据质数分布规律，我们可以确定 $p_{k+1} \lt p_k\sharp$ ，也就是 $p_{k+1} \in W_k$；其次，如果有任何 $x \in W_k$，满足 $1\lt x \lt p_{k+1}$， 那么它就是最小的 $\gt p_k$ 的质数，这就与 $p_{k+1}$ 的定义矛盾了。</em></p>

<h4 id="性质-4">性质 4</h4>

<p>轮子上的点具有对称性。</p>

<p>如<a href="#图-轮子">图-轮子</a>所示，轮子上点沿着 $0\degree-180\degree$ 中心轴几何对称。</p>

<p>证明如下：</p>

<p>使用诱导推理，</p>

<ol>
  <li>对于 $W_1$ 只有一个 $1$ 在周长为 $p_1=2$ 的圆圈上，对称性成立；</li>
  <li>假设 $W_k$ 对称性成立，那么由于 $C_{k+1}$ 由 $C_k$ 滚动而成，原来 $C_k$ 上标记的点滚动出的“印记”也因为 $C_k$ 的对称性而对称，而之后删除的“辐条点”也是对称的，所以剩下的“印记”仍然保持对称性，因此 $W_{k+1}$ 对称性也成立。</li>
</ol>

<p>证毕。</p>

<p><em>利用对称性，可以构造更节省空间的半轮（semi-wheel），但连 Pritchard 都指出这么做有失优雅、高效。</em></p>

<h5 id="性质-41">性质 4.1</h5>

<p>每个轮子上最后一个点是 $\vert W \vert - 1$ 。</p>

<p>因为 <strong>性质 2</strong> ，每个轮子上第一个点都是 $1$ ，根据对称性有最后一个点是 $\vert W \vert - 1$ 。</p>

<h3 id="轮筛骗局">轮筛骗局（×）</h3>

<p>Pritchard 可能为他的轮筛小发现高兴坏了，竟然昏了头，提出了一个纯轮筛的算法。</p>

<p>他的想法是这样的，既然 $W_k$ 可以直接发现 $\lt p_{k+1}^2$ 范围内的所有质数，那么只要造一个足够大的轮子，使得 $N \lt p_{k+1}^2$，然后让它滚起来，滚到 $N$，是不是就可以解决问题了。<sup id="fnref:16" role="doc-noteref"><a href="#fn:16" class="footnote" rel="footnote">10</a></sup></p>

<p>Pritchard 还引用了他心爱的 $p\cdot f$  的“乘法改加法”（下面会讲）的算法（负）优化，指出在结合了此等优化的前提下，算法操作的平均时间复杂度可以达到 $\Theta(\frac{N}{\log\log N}) $ 。</p>

<h4 id="样例代码-4">样例代码</h4>

<p>因为要应付更多的功能，使用了一个比前面 Mairson 筛子更复杂的基于数组的紧凑型双头列表。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Sublinear additive sieve by Paul Pritchard</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">wheel_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// saving 1/3 time compared with vector (each turn create new vector).</span>
    <span class="cd">///</span>
    <span class="cd">/// space cost about 3/5 N.</span>
    <span class="k">struct</span> <span class="n">CompactDoubleArrayList</span> <span class="p">{</span>
        <span class="cd">/// 0 for nil</span>
        <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="cd">/// [value, forward, backward]</span>
        <span class="n">arr</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Meta</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Default)]</span>
    <span class="k">struct</span> <span class="n">Meta</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">left</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="nb">usize</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">CompactDoubleArrayList</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Meta</span><span class="p">::</span><span class="nf">default</span><span class="p">()];</span>

            <span class="k">Self</span> <span class="p">{</span> <span class="n">tail</span><span class="p">,</span> <span class="n">arr</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="k">self</span><span class="py">.tail</span><span class="p">]</span><span class="py">.right</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">Meta</span> <span class="p">{</span>
                <span class="n">value</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span>
                <span class="n">left</span><span class="p">:</span> <span class="k">self</span><span class="py">.tail</span><span class="p">,</span>
                <span class="n">right</span><span class="p">:</span> <span class="mi">0</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.tail</span> <span class="o">==</span> <span class="k">self</span><span class="py">.arr</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.arr</span><span class="nf">.push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>  <span class="c1">// dynamic extend for saving some memory</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="py">.tail</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="n">filtering</span><span class="o">&lt;</span><span class="n">P</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="nf">pred</span><span class="p">(</span><span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.value</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.left</span><span class="p">;</span>
                    <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>

                    <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="py">.right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                    <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="py">.left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">index</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.value</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"{index} &gt; {c}"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
                <span class="nd">#[coroutine]</span>
                <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>

                    <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.value</span><span class="p">;</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">rolling</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

            <span class="k">while</span> <span class="n">l</span> <span class="o">+</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.value</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.value</span><span class="p">);</span>
                <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="py">.right</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">delete_multiple_p</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.filtering</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span> <span class="o">%</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">3usize</span><span class="p">;</span>
            <span class="c1">// let mut w = vec![1];  // w_1</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">w</span> <span class="o">=</span> <span class="nn">CompactDoubleArrayList</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="n">w</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">p</span><span class="nf">.pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="n">w</span><span class="nf">.rolling</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
                <span class="n">w</span><span class="nf">.delete_multiple_p</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

                <span class="k">yield</span> <span class="n">p</span><span class="p">;</span>

                <span class="c1">// prevent multiple overflow</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">w</span><span class="nf">.nth</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">w</span><span class="nf">.rolling</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">w</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="滚动加法构造轮子">滚动加法构造轮子</h4>

<p>尽管算法本身没有意义，但 <code class="language-plaintext highlighter-rouge">rolling</code> 作为 Pritchard 心爱的“乘法改加法”的优化之一还要讲一下。</p>

<p>按照<a href="#图-轮子">图-轮子</a>的思路，把轮子从 $W_k$ 滚动到 $W_{k+1}$ ，可以直接通过 $x = a\cdot p_k\sharp + b,\ a\in 1..(p_{k+1}-1),\ b\in W_k $ 以乘法的形式构建；</p>

<p>但是也可以通过 $x = p_k\sharp + (a-1)\cdot p_k\sharp + b$ 以滚动加法的形式构建。</p>

<p><code class="language-plaintext highlighter-rouge">rolling</code> 实现就是后者，保证选择的值和待插入元素总是差一个 $p_k\sharp$ 身位。</p>

<p>简化的伪代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">rolling</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">while</span> <span class="n">l</span> <span class="o">+</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">W</span><span class="nf">.push</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="nf">next</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="骗局所在">骗局所在</h4>

<p>如果了解轮子<strong>性质 1.2</strong> ，那我们可能觉得这种无限制地造大轮子地做法可能有点儿问题；</p>

<p>或者如果了解质数分布规律，并具有一些基本代数的常识，也可能敏锐地察觉出其中的问题。</p>

<p>没错，Pritchard 的纯轮筛隐含了一个假设，那就是 $p_{k+1}^2 \gt p_k\sharp$ ，这才有构造大轮子，再用大轮子滚一些圈，滚到 $N$ 的使用场景。</p>

<p>而实际情况是 $p_{n+1}^2 \sim \frac{(n+1)^2}{\log^2(n+1)}$ 而 $n\sharp = e^{n(1+o(1))} \sim e^n$ ，根据微分知识有</p>

\[\lim_{n\rightarrow\infty} \frac{p_{n+1}^2}{n\sharp} = 0\\\]

<p>也就是说，长远看  $p_{k+1}^2$ 是绝对跑不过 $p_k\sharp$ 的，下图是二者的变化曲线</p>

<p align="center">
  <div class="sx-center">
<img src="/assets/img/prime_sieves/p2_psharp_diff.svg" style="zoom:100%;" /></div>
</p>

<p><em>为了方便可视化地比较，图上曲线只取到了 $k=5$ ，事实上后面 $p_{k+1}^2$ 的函数曲线相比于 $p_k\sharp$ 已经近乎为水平线了。</em></p>

<p>图上可以看出，只在 $k\leqslant 3$ 时才有轮子周长小于它有效筛选范围，之后一个轮子的有效筛选范围远远小于它自身的周长，单就这一点算法就不成立。</p>

<p>更不用说，这种 $e^n$ 的增长速度使得根本没有空间去储存一个完整的轮子。</p>

<h2 id="分段固定轮筛">分段固定轮筛（√√√√）</h2>

<p>分段固定轮筛（SFWS，Segmented Fixed-Wheel Sieve）<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">11</a></sup>顾名思义，是在一个固定大小的轮子粗筛后的结果上再做第二步筛选，过程使用了分段技术。</p>

<h4 id="具体思路">具体思路</h4>

<p>设定给定正整数 $N$ ，求取 $\leqslant N$ 范围内所有质数。</p>

<p>首先定义 $p_{np} = \max(\lbrace p \vert\ p^2 \leqslant N \rbrace)$ ，也就说 $\leqslant N$ 范围内的合数最大质因子是第 $np$ 个质数。</p>

<p>假设使用了一个 $W_k$ 的轮筛，那么显然只需要再筛除从第 $k+1$ 到第 $np$ 个质因子构成的合数就可以完成质数筛选。</p>

<p>令 $c = p \cdot f \leqslant N,\ (p\in p_{k+1}..p_{np})$ ，在“粗筛”的结果上选取 $f \in W_k^*$ （这一步过程仍然利用粗筛的结果），将这些 $c$ 标记为非质数。</p>

<p>过程采取分段技术并没有让任何东西变得复杂。</p>

<h4 id="计算-np">计算 $np$</h4>

<p>假如取分片大小 $\Delta = \lfloor\sqrt {N}\rfloor $ ，计算 $ \leqslant \Delta$ 的所有质数，于是有 $\max^2 \lbrace p \leqslant \Delta \rbrace \leqslant \Delta^2 \leqslant N $ 。</p>

<p>显然有 $\max \lbrace p \leqslant \Delta \rbrace = p_{np}$ ，即 $np = \vert \lbrace p \leqslant \Delta \rbrace \vert$ 。</p>

<p>反证法证明，如果存在 $p_{np} \gt \Delta$ ，那么 $\lfloor\sqrt {N}\rfloor \geqslant p_{np} \gt \Delta$ ，这就与 $\Delta$ 的定义自相矛盾了。</p>

<h4 id="预备轮子">预备轮子</h4>

<p>一个 $W_7$ 的固定轮子就够大了，$\vert W_7 \vert = \displaystyle\prod_{i=1}^{7} p_i = 510,510$ ，光空间占用就已经有 4 MB 了。</p>

<p>轮子的计算可以参考前面章节<a href="#滚动加法构造轮子">滚动加法构造轮子</a>，过程中可以顺便构造轮子 $W$ 的增量表示 $\textit{WG}$</p>

\[\textit{WG}[i] = W^*[i+1] - W^*[i], \quad 0 \leqslant i \leqslant |W|-1\]

<h4 id="引导程序">引导程序</h4>

<p>如上所述，SFWS 需要先计算一个$ \Delta$ 范围内的质数，推荐直接使用简单的 <a href="#eratosthenes-筛子">Eratosthenes 筛子</a> 。</p>

<p>当然也可以“自举”，只是效能差一点点。</p>

<p>递归调用就要设置结束条件，可以设置当 $N \lt p_{k+1}^2$ 时，直接通过滚动轮子计算出所有目标质数。</p>

<p>但是轮子无法计算 $0..(p_{k+1}-1)$ 范围内的质数，仍然需要预先计算 $p_1 .. p_k$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bootstrapping</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">yield</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">vi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="n">v</span><span class="p">;</span>

        <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
        <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>
<span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">fixed_wheel_seg_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="样例代码-5">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fixed_wheel_seg_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">WStruct</span> <span class="p">{</span>
        <span class="n">wheel</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span>
        <span class="n">wheel_gap</span><span class="p">:</span> <span class="n">wg</span><span class="p">,</span>
        <span class="n">prod</span><span class="p">,</span>
        <span class="c1">// ipm,</span>
        <span class="o">..</span>
    <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">np</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.len</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">vi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">np</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="p">{</span>
                <span class="c1">// Just rolling to n</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">yield</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">v</span><span class="p">;</span>

                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">pris</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">yield</span> <span class="n">pris</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="cm">/* Init v0, vi */</span>

            <span class="k">let</span> <span class="n">v_raw</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">v</span><span class="p">,</span> <span class="k">mut</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="nf">locate_in_wheel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">prod</span><span class="p">,</span> <span class="n">v_raw</span><span class="p">);</span>

            <span class="cm">/* Init factors */</span>
            <span class="c1">// absolute value</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">factors</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
                <span class="c1">// (delta + p - delta % p) + 1</span>
                <span class="k">let</span> <span class="n">f_raw</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">/</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="n">factors</span><span class="nf">.push</span><span class="p">(</span><span class="nf">locate_in_wheel</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">*</span><span class="n">prod</span><span class="p">,</span> <span class="n">f_raw</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="cm">/* Run the algorithm */</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">l</span> <span class="k">in</span> <span class="p">(</span><span class="n">delta</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

                <span class="cm">/* sift for p_k..p_np */</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
                    <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">f</span><span class="p">,</span> <span class="k">mut</span> <span class="n">fi</span><span class="p">)</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="c1">// let (mut c, mut j) = factors[i];</span>

                    <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="p">{</span>
                        <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

                        <span class="n">f</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">fi</span><span class="p">];</span>
                        <span class="c1">// c += pms[i][wg[j] / 2];</span>
                        <span class="n">fi</span> <span class="o">=</span> <span class="p">(</span><span class="n">fi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
                    <span class="p">}</span>

                    <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
                    <span class="c1">// factors[i] = (c, j);</span>
                <span class="p">}</span>

                <span class="cm">/* accumulate primes */</span>

                <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="p">{</span>
                        <span class="k">yield</span> <span class="n">v</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="cm">/* reset for next segment */</span>

                <span class="n">bits</span><span class="nf">.set_all</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">locate_in_wheel</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">prod</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">raw</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">prod_rem</span> <span class="o">=</span> <span class="n">raw</span> <span class="o">%</span> <span class="n">prod</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">prod_base</span> <span class="o">=</span> <span class="n">raw</span> <span class="o">-</span> <span class="n">prod_rem</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prod_rem</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="n">prod_base</span> <span class="o">+</span> <span class="n">v0</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="在-w-上的定位-v-和-f">在 $W^*$ 上的定位 $v$ 和 $f$</h4>

<p>$v \in W^*$ 是轮子滚到每个分段上时第一个点的位置，$vi$ 是 $v \mod p_k\sharp$ 在 $W$ 上的编号。</p>

<p>$f_{p_i}$ 是轮子滚在每个分段上时第一个 $c = p \cdot f$ ，对应 $p_i$ 的 $f$，$fi$ 是 $f \mod p_k\sharp$ 在 $W$ 上的编号。</p>

<p>在 $W^*$ 上的定位 $v$ 和 $f$ 的原理是一样的，不妨就以 $v$ 为例做介绍：</p>

<p>先计算了模 $\vert W \vert$ 的余数 $\textit{prod_rem}$ 和轮子周长整数倍的轨迹长度 $\textit{prod_base}$ ：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">v_raw</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">let</span> <span class="n">prod_rem</span> <span class="o">=</span> <span class="n">v_raw</span> <span class="o">%</span> <span class="n">prod</span><span class="p">;</span>
<span class="k">let</span> <span class="n">prod_base</span> <span class="o">=</span> <span class="n">v_raw</span> <span class="o">-</span> <span class="n">prod_rem</span><span class="p">;</span>
</code></pre></div></div>

<p>然后直接在 $W$ 上做二分查找，找到第一个 $ \geqslant \textit{prod_rem}$ 的值作为 $v$ 的初始值（$模\vert W \vert$ ）：</p>

<p><em>因为 $1, \vert W \vert-1 \in W$ ，所以不存在余数 $ \textit{prod_rem}$ 落在轮子外的情况</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prod_rem</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span> <span class="c1">// prod-1 is prime</span>
<span class="p">};</span>
</code></pre></div></div>

<p>补上轨迹长度 $\textit{prod_base}$ 得到 $v$ 完整初始值：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="n">prod_base</span> <span class="o">+</span> <span class="n">v0</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="对计算-pcdot-f-的优化">对计算 $p\cdot f$ 的“优化”</h4>

<p>来了，Pritchard 心爱的“乘法改加法”的优化之二，$p\cdot f$ 的“乘法改加法”。</p>

<p>原理是轮子上两个点的距离 $\textit{WG}[i] = \Delta f$ 的值域比较小，可以为轮子计算一个 $\lbrace \textit{WG}[i] \rbrace$ ，这样对于每个 $p$ 也可以预计算一个 $p\cdot \Delta f =  \Delta (p\cdot f)$ 。</p>

<p>这样 $p\cdot f = (p\cdot f)’ + \Delta (p\cdot f)$ ，就可以实现乘法改加法。</p>

<p>除此之外，可以观察到 $\textit{WG}[i]$ 总是偶数，利用这个性质可以节约一半的预计算值的存储空间。</p>

<p><em>但是显见地在代码里我们没用这个优化，因为在付出了代码复杂化、空间占用地代价后，得到了一个更慢的时间性能上的表现。<sup id="fnref:20" role="doc-noteref"><a href="#fn:20" class="footnote" rel="footnote">12</a></sup></em></p>

<h3 id="复杂度分析-4">复杂度分析</h3>

<p>时间复杂度 $O(N)$ ，空间复杂度 $O(\sqrt{N})$ 。</p>

<h3 id="算法评价-4">算法评价</h3>

<p>虽然经常吐槽 Pritchard ，但他搞的 SFWS 思路还是对的，是我目前为止最推崇的一款筛子，是时间性能和空间性能的双料冠军！</p>

<h3 id="算法外延">算法外延</h3>

<p>按照分段固定轮筛的模式，抽象出 $(\Delta,k)$ 的参数二元组，可以把很多筛子算法归类进来。</p>

<p><em>详见原文</em></p>

<h2 id="mairson-对偶筛">Mairson 对偶筛（√√√）</h2>

<p>Mairson 对偶筛<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">13</a></sup>，对偶（dual）意指把原来算法外层对 $p$ 的遍历和内层对 $f$ 的遍历对调，变成外层对 $f$ 遍历内层对 $p$ 遍历。<sup id="fnref:17" role="doc-noteref"><a href="#fn:17" class="footnote" rel="footnote">14</a></sup></p>

<p>基于最小质因数分解，$c = \texttt{lpf}(c) \cdot f$  做筛选。</p>

<p>外层 $f$ 是连续的正整数，在 $2..\lfloor\frac{N}{2}\rfloor $ 上迭代；</p>

<p>内层 $p$ 是质数，在 $p_1 .. \texttt{lpf}(f)$ 上迭代 。</p>

<h3 id="样例代码-6">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_dual_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span> <span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="n">f</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">pris</span><span class="nf">.push</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

            <span class="c1">// if f % p == 0 {</span>
            <span class="c1">//     break;</span>
            <span class="c1">// }</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span>
            <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.flat_map</span><span class="p">(</span>
                <span class="p">|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nb">None</span>
                    <span class="p">}</span>
                <span class="p">},</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="边缘情况">边缘情况</h4>

<p>因为外循环 $f$ 从 $2$ 开始，因此 $N \lt 2$ 的情况需要特别处理。</p>

<h4 id="质数判断">质数判断</h4>

<p>如果发现 $f$ 未被标记，则它一定是质数。</p>

<p>使用反证法，假如它不是质数，那么它一定可以表示为 $f = p \cdot f’$ ，而 $f’ \lt f$ ，那么 $f$ 一定会被标记，这就与前提矛盾了。</p>

<h4 id="质数迭代">质数迭代</h4>

<p>如果从最小的质数开始增序迭代，直到第一个能整除 $f$ 的质数，这就是所有 $\leqslant \texttt{lpf}(f)$ 的质数。</p>

<p>但是另一方面我们其实注解了检测整除的代码，这是因为相对于乘法和加法，除法还是一种代价较高的算术运算，提前跳出的好处比不上一直做取余检测的代价，注掉代码不影响正确性却会使得性能获得可察觉的改善。<sup id="fnref:18" role="doc-noteref"><a href="#fn:18" class="footnote" rel="footnote">15</a></sup></p>

<h3 id="算法变种">算法变种</h3>

<p>这个算法更大的价值可能在于它的副产品，最小质因子数组 $\texttt{lpf}$，以用来做质因数分解。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// 一鱼两吃，既返回值质数列表，也返回质因数分解列表 (lpf)</span>
<span class="cd">/// 这种 API 风格倒也正好是 Rust 推荐的风格</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">mairson_dual_sieve_factorization</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lpf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pris</span><span class="p">,</span> <span class="n">lpf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">f</span> <span class="k">in</span> <span class="mi">2</span><span class="o">..=</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">lpf</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">lpf</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
            <span class="n">pris</span><span class="nf">.push</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">lpf</span><span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">lpf</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">lpf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">lpf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">pris</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">(</span><span class="n">pris</span><span class="p">,</span> <span class="n">lpf</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此时为了 $\texttt{lpf}$ 的正确性，必须严格限制 $p$ 在超过 $f$ 的最小质因子时退出，不过有了 $\texttt{lpf}$ 也省去了取余的代价。</p>

<h3 id="复杂度分析-5">复杂度分析</h3>

<p>显见内外层的时间复杂度均为 $O(\sqrt N)$ ，因此总时间复杂度为 $O(N)$ 。</p>

<p>空间复杂度 $O(N)$ 。</p>

<h3 id="算法评价-5">算法评价</h3>

<p>原始算法时间性能也非常好，比 Eratosthenes 筛子快一点，比 Sundram 筛子慢一点。</p>

<p>变种算法也即 <a href="https://cp-algorithms.com/algebra/prime-sieve-linear.html">cp-algorithms</a> 里介绍的线性筛子算法，在算法比较的结论上没有变化，但比原始算法要快。<sup id="fnref:19" role="doc-noteref"><a href="#fn:19" class="footnote" rel="footnote">16</a></sup></p>

<h2 id="gpf-筛子">GPF 筛子（√√）</h2>

<p>GPF 筛子<sup id="fnref:8:1" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">13</a></sup>，是基于最大质因数分解， $c = f\cdot \texttt{gpf(c)}$ 的质数筛子。</p>

<p>从最小的质数 $p = 2$ 开始，收集所有使得 $ f \cdot p \leqslant N$ ，并且 $\texttt{gpf}(f) \leqslant p$ 的 $f$ ，划掉对应的 $c = f \cdot p$ ，最后得到质数。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">gpf_sieve</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">factors</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">while</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="n">pris</span><span class="nf">.push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="n">factors</span><span class="nf">.push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">f_stack</span> <span class="o">=</span> <span class="n">factors</span><span class="p">;</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="n">f_stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

                <span class="n">f_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span><span class="p">);</span>
                <span class="n">factors</span><span class="nf">.push</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
        <span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span>
            <span class="n">bits</span><span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.skip</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">flag</span><span class="p">)|</span> <span class="k">if</span> <span class="n">flag</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}),</span>
        <span class="p">),</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="边缘情况-1">边缘情况</h4>

<p>因为外循环从 $p=2\leqslant \lfloor \frac{N}{2}\rfloor$ 开始， ，因此 $N \lt 4$ 的情况需要特别处理。</p>

<h3 id="复杂度分析-6">复杂度分析</h3>

<p>由于每个 $c$ 只会被计算一次，因此时间复杂度可被认为是 $O(N)$ 。</p>

<p>空间复杂度为 $O(N)$ 。</p>

<h3 id="算法评价-6">算法评价</h3>

<p>时间性能还算可以，比分段 Eratosthenes 筛慢一点。</p>

<h2 id="atkin-筛子">Atkin 筛子（?）</h2>

<p>Atkin 筛子<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">17</a></sup>，是一种二元二次型筛子。</p>

<p>它的思路还是挺先进的，先用一个 2-3-5 筛子在模 60 的余数上，得到</p>

\[\lbrace 1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59 \rbrace\]

<p>然后在这些余数上，可以分别应用三个二元二次方程，通过解数量的奇偶性做进一步筛选（要求奇数个解）；</p>

<p>最后做质数平方因子的检查（确保 squarefree）完成质数确认。</p>

<h4 id="方程-1">方程-1</h4>

<p>对于  $\delta \in \lbrace 1, 13, 17, 29, 37, 41, 49, 53 \rbrace$ ，执行 $ 4x^2 + y^2 = 60k + \delta \equiv 1 \mod 4$ 。</p>

<h4 id="方程-2">方程-2</h4>

<p>对于  $\delta \in \lbrace 1, 7, 13, 19, 31, 37, 43, 49 \rbrace$ ，执行 $ 3x^2 + y^2 = 60k + \delta \equiv 1 \mod 6$ 。</p>

<p>为了不和<strong>方程-1</strong>检查的范围重叠，可以只检查在 $\delta \in \lbrace 7,19,31,43 \rbrace$ ，也就是 $7 \mod 12$ 。</p>

<h4 id="方程-3">方程-3</h4>

<p>对于  $\delta \in \lbrace 11, 23, 47, 59 \rbrace$ ，执行 $ 3x^2 - y^2 = 60k + \delta \equiv 11 \mod 12$ 。</p>

<h4 id="一点解释">一点解释</h4>

<p>首先，这三个方程里的 $(x, y)$ ，就像 <a href="#sundaram-筛子">Sundaram 筛子</a> 一样，都是实在的正整数；</p>

<p>其次，为什么是这三个方程，为什么是奇数个解，为什么<strong>方程-3</strong>要求 $x \gt y$，为什么还要校验不含质数平方因子，原文里有解释<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">18</a></sup> 。</p>

<h3 id="原始实现">原始实现（×）</h3>

<p>原始论文的主要价值在于（宣称）突破了 Pritchard 的<em>质数筛子算法空间复杂度和时间复杂度不能同时为亚线性</em>的猜想，提出了一种理论分析在时间复杂度为 $O(\large\frac{N}{\log\log N})$ ，而空间复杂度为 $O(\sqrt N)$ 的新算法。</p>

<p>但这是一种诈骗，因为：</p>

<ol>
  <li>实际上根本不可能在规定时间复杂度内枚举完任意一个方程的解，而且按照论文里对<strong>方程-3</strong>解的枚举算法根本就是错的，不能枚举全部符合条件的解；</li>
  <li>检查质数平方因子也无法同时满足亚线性的时间和空间复杂度。</li>
</ol>

<p>但无论如何，我们试着按照原文的思路实现了一版出来。</p>

<h4 id="样例代码-7">样例代码</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">atkin</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">min</span><span class="p">;</span>

    <span class="k">use</span> <span class="nn">lazy_static</span><span class="p">::</span><span class="n">lazy_static</span><span class="p">;</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">algs1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">4</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
    <span class="p">}</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">algs2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
    <span class="p">}</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">enable_algs3</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
    <span class="p">}</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">algs3</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
    <span class="p">}</span>

    <span class="nd">lazy_static!</span> <span class="p">{</span>
        <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">DELTA16</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">16</span><span class="p">]</span> <span class="o">=</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">];</span>

        <span class="c1">// {1,13,17,29,37,41,49,53}</span>
        <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">DELTA16_ALGS1</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">];</span>

        <span class="c1">// trim duplicated delta number campared with 1</span>
        <span class="c1">// {7,19,31,43}</span>
        <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">DELTA16_ALGS2</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">];</span>

        <span class="c1">// {11, 23, 47, 59}</span>
        <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">DELTA16_ALGS3</span><span class="p">:</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">];</span>

        <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">static</span> <span class="k">ref</span> <span class="n">DELTA16_GRPS</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">delta16_grps</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[];</span> <span class="mi">16</span><span class="p">];</span>

            <span class="cm">/* algorithm 1. 4x^2 + y^2 = n */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS1</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">f</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">15</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">30</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nf">algs1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                            <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">if</span> <span class="p">(</span><span class="nf">algs1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">60</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="n">delta16_grps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* algorithm 2. 3x^2 + y^2 = n */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS2</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">f</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">15</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">30</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nf">algs2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                            <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">if</span> <span class="p">(</span><span class="nf">algs2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">60</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="n">delta16_grps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* algorithm 3. 3x^2 - y^2 = 60k + delta */</span>
            <span class="c1">// FIXME: incorrect algoriuthm</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS3</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">f</span> <span class="k">in</span> <span class="mi">3</span><span class="o">..=</span><span class="mi">10</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="nf">min</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nf">algs3</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                            <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">if</span> <span class="p">(</span><span class="nf">algs3</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">60</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="n">delta16_grps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">delta16_grps</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">atkin_sieve_enum_lattice</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">atkin</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="c1">// P[17] = 59</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">17</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">yield</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">59</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">n_k</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.div_ceil</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">delta_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.isqrt</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">delta_k</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">bits_k</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta_k</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">pri_square</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="mi">17</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">r</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">pri_square</span><span class="nf">.insert</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">l_k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
                <span class="cm">/* algorithm 1 4x^2 + y^2 = n */</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS1</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">in</span> <span class="n">DELTA16_GRPS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">k0</span> <span class="o">=</span> <span class="p">(</span><span class="nf">algs1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>

                        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                            <span class="n">k0</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
                            <span class="n">x</span> <span class="o">+=</span> <span class="mi">15</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
                            <span class="n">x</span> <span class="o">-=</span> <span class="mi">15</span><span class="p">;</span>
                            <span class="n">k0</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>

                            <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="p">{</span>
                                <span class="n">k0</span> <span class="o">+=</span> <span class="n">y0</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
                                <span class="n">y0</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>
                            <span class="p">}</span>

                            <span class="k">let</span> <span class="k">mut</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k0</span><span class="p">;</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>

                            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="n">pairs</span><span class="nf">.insert</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                                    <span class="k">let</span> <span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l_k</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

                                    <span class="n">bits_k</span><span class="nf">.set</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="o">!</span><span class="n">bits_k</span><span class="nf">.get</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
                                <span class="p">}</span>

                                <span class="n">k</span> <span class="o">+=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
                                <span class="n">y</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="cm">/* algorithm 2 3x^2 + y^2 = n */</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS2</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">in</span> <span class="n">DELTA16_GRPS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">k0</span> <span class="o">=</span>
                            <span class="p">((</span><span class="nf">algs2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>

                        <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="p">(</span><span class="n">k0</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                            <span class="n">k0</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
                            <span class="n">x</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
                            <span class="n">x</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
                            <span class="n">k0</span> <span class="o">-=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>

                            <span class="k">while</span> <span class="n">k0</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="p">(</span><span class="n">k0</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="p">{</span>
                                <span class="n">k0</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
                                <span class="n">y0</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>
                            <span class="p">}</span>

                            <span class="k">let</span> <span class="k">mut</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k0</span><span class="p">;</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span><span class="p">;</span>

                            <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="n">pairs</span><span class="nf">.insert</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                                    <span class="k">let</span> <span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="n">l_k</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

                                    <span class="n">bits_k</span><span class="nf">.set</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="o">!</span><span class="n">bits_k</span><span class="nf">.get</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
                                <span class="p">}</span>

                                <span class="n">k</span> <span class="o">+=</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
                                <span class="n">y</span> <span class="o">+=</span> <span class="mi">30</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="cm">/* algorithm 3 3x^2 - y^2 = 60k + delta */</span>
                <span class="cm">/* NOTE: There is a bug for origin formula-3
                enumerate lattice point */</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">DELTA16_ALGS3</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
                    <span class="c1">// let mut pairs = HashSet::&lt;(usize, usize)&gt;::new();</span>

                    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="n">l_k</span><span class="o">..</span><span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="nd">isqrt_ceil!</span><span class="p">((</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
                            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span><span class="nf">.isqrt</span><span class="p">();</span>

                            <span class="k">if</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y2</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="p">{</span>
                                <span class="k">let</span> <span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="n">l_k</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

                                <span class="n">bits_k</span><span class="nf">.set</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="o">!</span><span class="n">bits_k</span><span class="nf">.get</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="cm">/* remove p^2 */</span>

                <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="n">l_k</span><span class="o">..</span><span class="n">l_k</span> <span class="o">+</span> <span class="n">delta_k</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">16</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">bits_k</span><span class="p">[(</span><span class="n">k</span> <span class="o">-</span> <span class="n">l_k</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">DELTA16</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                            <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>

                            <span class="k">if</span> <span class="o">!</span><span class="n">pri_square</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">yield</span> <span class="n">c</span><span class="p">;</span>

                                <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>

                                <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">r</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                                    <span class="n">pri_square</span><span class="nf">.insert</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
                                <span class="p">}</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="cm">/* update */</span>

                <span class="n">bits_k</span><span class="nf">.clear</span><span class="p">();</span>

                <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
                <span class="n">l_k</span> <span class="o">+=</span> <span class="n">delta_k</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法评价-7">算法评价</h4>

<p>仅正确，性能上实际不可用。</p>

<h3 id="简单实现">简单实现（√√）</h3>

<p>除了原始版本外，还有一个不知道为何在网上广泛流传的简单实现版本，它直接遍历了所有二元组，先为三个方程计算值，反过来通过余数进行筛选。</p>

<p>相对于原始实现，它是一个可以接受的算法（实现），但这样时间复杂度和空间复杂度都成了 $O(N)$ 。</p>

<h4 id="样例代码-8">样例代码</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">atkin_sieve_simple</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">atkin</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">c1</span> <span class="o">=</span> <span class="nf">algs1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

                    <span class="c1">// not using 2-3-5 wheel sieve for efficiency</span>
                    <span class="k">if</span> <span class="n">c1</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">||</span> <span class="n">c1</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="o">!</span><span class="n">bits</span><span class="p">[</span><span class="n">c1</span><span class="p">]);</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="n">c2</span> <span class="o">=</span> <span class="nf">algs2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

                    <span class="c1">// 1 mod 6 =&gt; 7 mod 12</span>
                    <span class="c1">// trim duplicate element with algs1</span>
                    <span class="k">if</span> <span class="n">c2</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">c2</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">==</span> <span class="mi">7</span> <span class="p">{</span>
                        <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="o">!</span><span class="n">bits</span><span class="p">[</span><span class="n">c2</span><span class="p">]);</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="nf">enable_algs3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">c3</span> <span class="o">=</span> <span class="nf">algs3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

                        <span class="k">if</span> <span class="n">c3</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">c3</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">==</span> <span class="mi">11</span> <span class="p">{</span>
                            <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">c3</span><span class="p">,</span> <span class="o">!</span><span class="n">bits</span><span class="p">[</span><span class="n">c3</span><span class="p">]);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cm">/* trim p^2 */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">5</span><span class="o">..=</span><span class="n">n</span><span class="nf">.isqrt</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>

                    <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="p">(</span><span class="n">r</span><span class="o">..=</span><span class="n">n</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="算法评价-8">算法评价</h4>

<p>速度很快算是第二档，但本身既无法分片又不如 Eratosthenes 筛子那么简单直观，这就使得它实际没有任何可提之处，权列在此，以为参考。<sup id="fnref:22" role="doc-noteref"><a href="#fn:22" class="footnote" rel="footnote">19</a></sup></p>

<h2 id="尾声">尾声</h2>

<p><em>源代码：<a href="https://github.com/minghu6/rust-minghu6/blob/master/math/src/number.rs">Rust</a> 和 <a href="https://github.com/minghu6/py-minghu6/blob/develop/minghu6/number/prime.py">Python</a></em></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>G. H. Hardy and E. M. Wright. An Introduction to the Theory of Numbers. 1962. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:12" role="doc-endnote">
      <p>好家伙，论文都到二战前了，原始作者是印度学生 Sundaram ，找不到电子版，实际参考的是 <a href="https://en.wikipedia.org/wiki/Sieve_of_Sundaram">wiki</a> 。 <a href="#fnref:12" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:21" role="doc-endnote">
      <p>从另一方面说，在 CPython 上的实现倒还能体现这种优化的作用 <a href="#fnref:21" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Harry G. Mairson. Some new upper bounds on the generation of prime numbers. 1977. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>J.Misra. An Exercise in Program Explanation.  1979. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>形式地说，任意两个相邻的最小质因数为 $p_i$ 的自然数之间，至少存在一个最小质因数为 $p_j \gt p_i$ 的自然数。 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Paul Pritchard. A Sublinear Additive Sieve for Finding Prime Numbers. 1981. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Paul Pritchard. Explaining the Wheel Sieve. 1982. <sup id="fnref:15" role="doc-noteref"><a href="#fn:15" class="footnote" rel="footnote">20</a></sup> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:5:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:14" role="doc-endnote">
      <p>这里使用 量词 $k$ 而不是上下文惯用的 $n$ 有两方面考虑，一方面是和 <em>Explaining the Wheel Sieve</em> 原文的用法保持一致；另一方面 有些终结的意味的 $n$ ，$k$ 是更能暗示处于中间过程的一个“量词”，在轮子上和质数阶乘上使用更合适。 <a href="#fnref:14" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:16" role="doc-endnote">
      <p>这简直就是经典科幻小说家会干的事 <a href="#fnref:16" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>Paul Pritchard. Fast Compact Prime Number Sieves (among Others). 1983. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:20" role="doc-endnote">
      <p>在 CPython 上的实现只在很大的轮子上和很大的输入数据的规模上有微弱优势 <a href="#fnref:20" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Paul Pritchard. LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE. 1987. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:8:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:17" role="doc-endnote">
      <p>原文作者会为每个既有算法考虑它的对偶算法 <a href="#fnref:17" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:18" role="doc-endnote">
      <p>在 CPython 上的实现如果留着这段代码反而会带来显著的性能提升，这几乎反向明示了 CPython 并没有对乘法有什么优化 <a href="#fnref:18" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:19" role="doc-endnote">
      <p>在 CPython 上的实现也同意这个结论 <a href="#fnref:19" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>A. O. L. Atkin and D. J. Bernstein. Prime Sieves Using Binary Quadratic Forms. 2003. <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:13" role="doc-endnote">
      <p>但它使用了我不熟悉的数学工具（抽象代数等），所不了解的数学知识（数论），而且写得看起来也并不打算真的想让人了解。 <a href="#fnref:13" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:22" role="doc-endnote">
      <p>并且因为包含过多的算术运算，在 CPython 上的实现非常低效 <a href="#fnref:22" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:15" role="doc-endnote">
      <p>这个论文里数学符号的排版字体真的抽象，首先这个字符 <img src="/assets/img/prime_sieves/charR.png" alt="" /> 是什么？ 版上打眼一看都缩缩成一团了，还以为是个花体 $A$ 呢，仔细看不是，难道是什么大写希腊字母的花体么，因为拜占庭作为中世纪西方数学教育翻译的主要材料来源地之一，使得作为传统，西方人写数学符号都好整个希腊字母，但仔细对了一遍也不像，后来通过谷歌识图对比类似结果，算是确认这是个 $R$ 。 如果提前知道它是个 $R$ ，那它看起来还挺像个 $R$ 的，可这个字符<img src="/assets/img/prime_sieves/charS.png" alt="" />又是什么？它看起来像 $y$ 又像 $g$ ，这下谷歌识图也识不出来了，只能在专门的字体网站做 AI 识图，然后发现这居然是个 $S$ ，S 它是你么，它说它舅（就) 是我。这个字体名叫 <em>OriginalScriptStd</em> ，英文草书说是。 <a href="#fnref:15" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[质数筛子的原理是质因数分解。]]></summary></entry></feed>