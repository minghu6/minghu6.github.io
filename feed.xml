<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-02-07T00:15:06+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">BST(5) - 树堆（Treep）</title><link href="/algs/BST-5-Treep.html" rel="alternate" type="text/html" title="BST(5) - 树堆（Treep）" /><published>2023-02-02T00:00:00+08:00</published><updated>2023-02-02T00:00:00+08:00</updated><id>/algs/BST%20-%205%20-%20Treep</id><content type="html" xml:base="/algs/BST-5-Treep.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>树堆的概念首次是由 <a href="https://en.wikipedia.org/wiki/Raimund_Seidel">Raimund Seidel</a> and <a href="https://en.wikipedia.org/wiki/Cecilia_R._Aragon">Cecilia R. Aragon</a> 在 1989 年提出，它意思是节点用两个属性分别维护了二叉搜索树的性质和堆的性质。从二叉搜索树的角度看，可以类比前面的 <code class="language-plaintext highlighter-rouge">Splay树</code>，<code class="language-plaintext highlighter-rouge">Splay</code> 平衡性好要依赖于输入的数据具有随机性，而树堆干脆利用随机生成的权重来手动制造这种随机性。实质上都是通过随机化的输入来达到树结构的平衡。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span> <span class="p">});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Treap</span> <span class="p">{</span> <span class="n">improve_search</span><span class="p">:</span> <span class="nb">bool</span> <span class="p">});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="堆校验">堆校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">Treap</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Validate MaxHeap</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">));</span>
            <span class="n">left</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">w!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">));</span>
            <span class="n">right</span><span class="nf">.balance_validation</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基本操作">基本操作</h2>

<p>树堆基本操作有两种方式，就像讲到一般二叉搜索树的基础方法时，一种是展开型，一种是递归型 。在常见的树堆的文章里介绍得是递归型的方法，依靠 <code class="language-plaintext highlighter-rouge">Split</code> 和 <code class="language-plaintext highlighter-rouge">Join</code> 这两个基础型方法（这两个方法本身也是递归实现的）。</p>

<p>我们这里介绍展开型的实现方法，而这种方法就像一般堆的实现一样，依赖 <code class="language-plaintext highlighter-rouge">Sift-up</code> 和 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作来维护堆修改后的性质 ，而这两个操作背后又通过树的旋转实现。树的旋转不仅保持了二叉搜索树的性质，也保留了既有的堆的权重大小关系 。</p>

<h3 id="sift-up">Sift-up</h3>

<p>把一个权重较大的节点试着向上提升，直到符合堆的性质。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">fn</span> <span class="nf">siftup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="sift-down">Sift-down</h3>

<p>把权重较小的节点向下沉，直到符合堆的性质。选择左右孩子中权重最大的那一个，把它旋转到根，如此反复直到堆的性质得到维护。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="cd">/// rotate down if MaxHeap violation</span>
<span class="k">fn</span> <span class="nf">siftdown</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">max_child</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_w</span> <span class="o">=</span> <span class="nd">w!</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Left</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_w</span> <span class="p">{</span>
            <span class="n">max_child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nb">Right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_dir</span><span class="p">)</span> <span class="o">=</span> <span class="n">max_child</span> <span class="p">{</span>
            <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">child_dir</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="搜索">搜索</h3>

<p>和一般的二叉搜索树的搜索方法没什么不同。唯一特别的是两位原作者建议可以在搜索的时候给经常访问的节点更高的权重，来加快搜索效率。这样就结合了伸缩树的特点，但是没有那么直接，没有访问一次就直接提到根。我们实现这个做法是采用了 wiki 上建议，每次访问给一个随机数，当超过当前节点的权重时，就赋予这个权重然后 <code class="language-plaintext highlighter-rouge">Sift-up</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.improve_search</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.aragon_seidel_search_suggestion</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// https://en.wikipedia.org/wiki/Treap</span>
<span class="k">fn</span> <span class="nf">aragon_seidel_search_suggestion</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">neww</span> <span class="o">=</span> <span class="nf">random</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">neww</span> <span class="o">&gt;</span> <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">w!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">neww</span><span class="p">);</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="插入">插入</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">Sift-up</code> 修复新节点插入时可能造成的对堆的性质的破坏</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nf">random</span><span class="p">()</span> <span class="p">});</span>

    <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.siftup</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>和标准的二叉搜索树的删除方法一致。有一点需要额外调整，就是当被删除的节点左右孩子都不为空的时候。这时候 <code class="language-plaintext highlighter-rouge">y</code> 与 <code class="language-plaintext highlighter-rouge">y.left</code> , <code class="language-plaintext highlighter-rouge">y.right</code></p>

<p>的权重大小关系就不确定了，需要对 <code class="language-plaintext highlighter-rouge">y</code> 进行 <code class="language-plaintext highlighter-rouge">Sift-down</code> 操作。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-1       case-2

                    z            z
                    \            \
                    y            z.right
                                /
                                / (left-most)
                                y
                                \
                                y.right
                */</span>

            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>

            <span class="cm">/* Only y and y.left and maybe y.right violate weight */</span>
            <span class="k">self</span><span class="nf">.siftdown</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="创建">创建</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// impl Treap</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">Self</span> <span class="p">{</span>
        <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
        <span class="n">improve_search</span><span class="p">:</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">improve_search</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.improve_search</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">self</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>树堆是一个相对来讲容易理解，实现简单（相对红黑树家族），性能表现令人满意的二叉搜索树的数据结构。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(3) - 伸展树（Splay Tree）</title><link href="/algs/BST-3-Splay-Tree.html" rel="alternate" type="text/html" title="BST(3) - 伸展树（Splay Tree）" /><published>2023-01-30T00:00:00+08:00</published><updated>2023-01-30T00:00:00+08:00</updated><id>/algs/BST%20-%203%20-%20Splay%20Tree</id><content type="html" xml:base="/algs/BST-3-Splay-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">伸缩树</code>（<code class="language-plaintext highlighter-rouge">Splay Tree</code>）是 <a href="https://en.wikipedia.org/wiki/Daniel_Sleator">Daniel Sleator</a> and <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a> 在 1985 年提出，它的想法就是一个，把最近访问的节点 roll 到根节点。</p>

<p>它的性质与 CPU 缓存机制非常契合，又不需要存储额外字段，常用于缓存和垃圾回收器的实现。</p>

<p>但是这样的性质也导致</p>

<ol>
  <li>查询的时候也会修改自身的结构，这在多线程环境和纯函数编程语言里会造成很大的麻烦；</li>
  <li>这不是很“体面“的平衡方法，依赖于数据访问的有一定的随机性，顺序访问会造成数据结构蜕化为链表（前一个根节点总是成为当前根节点的右子树）</li>
</ol>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({});</span>
<span class="nd">def_tree!</span><span class="p">(</span><span class="n">Splay</span> <span class="p">{});</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">Splay</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="基础操作">基础操作</h2>

<h3 id="splay">Splay</h3>

<p><code class="language-plaintext highlighter-rouge">Splay树</code> 最基础的操作当然就是 <code class="language-plaintext highlighter-rouge">Splay</code> 操作，就是把树中的一个节点旋转到根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">splay</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="split">Split</h3>

<p>给定树中一个节点 <code class="language-plaintext highlighter-rouge">x</code> ，把树分为比 <code class="language-plaintext highlighter-rouge">x</code> 小（包含 <code class="language-plaintext highlighter-rouge">x</code> ）和比 <code class="language-plaintext highlighter-rouge">x</code> 大的两部分。方法是把 <code class="language-plaintext highlighter-rouge">x</code> 旋转到根，然后分出 <code class="language-plaintext highlighter-rouge">x</code> 的右子树和 <code class="language-plaintext highlighter-rouge">x</code> 的其余部分。</p>

<p>需要注意的是分割的时候需要断开连接。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">split</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">x_right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">disconn!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_right</span><span class="p">);</span>

    <span class="p">(</span><span class="n">x</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="n">x_right</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="join">Join</h3>

<p>给两个节点，把节点代表的子树合并为一棵完整的树。能够合并前提是这两棵子树其中一棵的最大值小于另一棵的最小值，方法是把较小子树的最大值 <code class="language-plaintext highlighter-rouge">splay</code> （最大值节点的右子树为空），然后把另一棵较大的子树放到根节点的右子树位置。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">fn</span> <span class="nf">join</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">trees</span><span class="p">:</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">trees</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">s</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s_max</span> <span class="o">=</span> <span class="nd">bst_maximum!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s_max</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">s_max</span><span class="nf">.clone</span><span class="p">();</span> <span class="c1">//  s maybe not root node</span>
        <span class="nd">conn_right!</span><span class="p">(</span><span class="n">s_max</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>注意，对<strong>子树</strong> <code class="language-plaintext highlighter-rouge">Splay</code> 的时候不会更新所属母树的根节点（左子树的根不一定是母树的根），需要手动保证树的根节点为左子树的根节点。</p>

<h2 id="总装">总装</h2>

<h4 id="搜索">搜索</h4>

<p>找到节点后额外执行 <code class="language-plaintext highlighter-rouge">Splay</code> 操作。在 Rust 实现里，如 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏所示，我们使用一个 tricky 的方法绕过可变性检查。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="cd">/// Hack method convert self to self_mut</span>
<span class="nd">macro_rules!</span> <span class="n">mut_self</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$self</span><span class="p">:</span> <span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
         <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="p">(</span><span class="nv">$self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="k">Self</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="k">Self</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">mut_self!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>这里对 <code class="language-plaintext highlighter-rouge">mut_self</code> 这个宏稍微展开讲一下：</p>

<p>作为一门现代性的语言（发明于21世纪的第二个十年，比传统主流编程语言年轻20岁），Rust 有很多编程模型上的新的探索（或者说从先锋性语言身上吸收了很多成熟的特性），前面的博文比如 Fib 堆的Rust实作、BST基础等等都谈过这里不赘述 。</p>

<p>这些特性在内存安全方面，在多线程环境下，有巨大的好处，但当编程对象是传统的树、图上的算法时，就显得非常不兼容，按照编程模型，这些传统算法都要重新设计！而另一方面， Rust 作为一门系统级编程语言，不管是出于对运行效率的极致追求还是对 C 库的向下兼容，它还是提供一种传统的，“不安全“的指针的编程模型。对指针上的操作可以绕过 Rust 诸多特性安全检查：<strong>生命周期</strong>、<strong>可变性</strong>、<strong>单一所有权</strong>等等。</p>

<p>对于 Rust 标准库的实现，他们就是在内部大量使用指针（做了一定的包装）来处理我们所面临的问题，但是他们不厚道的地方在于他们不愿意把他们标准库内部实现使用的方便工具全部开放出来，结果某种程度使得第三方不得不重新发明轮子。</p>

<p>前面我们把 key 和 val 两个字段都使用指针，就是为了能够创建非局部的引用，而 <code class="language-plaintext highlighter-rouge">mut_self</code> 通过把引用转换为指针再转换回引用，也是为了能把只读引用转换为可变引用 。</p>

<h4 id="插入">插入</h4>

<p>我们这里的插入实现，是 Rust 风格的，也就是糅合了 Push 和 Update ，需要根据插入的节点是否存在来选择 <code class="language-plaintext highlighter-rouge">splay</code> 的节点，这需要修改一下一般的插入方法。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">});</span>

    <span class="cm">/* modify a little bst_insert */</span>

    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">popped</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">splay_at</span> <span class="o">=</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">popped</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="nf">.replace_val</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
                <span class="n">splay_at</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.splay</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splay_at</span><span class="p">);</span>

    <span class="n">popped</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="删除">删除</h4>

<p>找到搜索节点后，（如果节点存在）<code class="language-plaintext highlighter-rouge">Split</code> 该节点，此时左子树的根节点应该就是要被删除的节点，删掉之后，把左子树的左孩子（<code class="language-plaintext highlighter-rouge">Split</code> 得到的左子树的右孩子为空）和右子树 <code class="language-plaintext highlighter-rouge">Join</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl Splay</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.split</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">s_left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="nd">disconn!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s_left</span><span class="p">);</span>

        <span class="k">self</span><span class="nf">.join</span><span class="p">((</span><span class="n">s_left</span><span class="p">,</span> <span class="n">l</span><span class="p">));</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(4) - 替罪羊树（SG）</title><link href="/algs/BST-4-SG-Tree.html" rel="alternate" type="text/html" title="BST(4) - 替罪羊树（SG）" /><published>2023-01-29T00:00:00+08:00</published><updated>2023-01-29T00:00:00+08:00</updated><id>/algs/BST%20-%204%20-%20SG%20Tree</id><content type="html" xml:base="/algs/BST-4-SG-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">替罪羊树</code>（<code class="language-plaintext highlighter-rouge">Scapegoat Tree</code>）初始是在 1989 年由 <a href="https://en.wikipedia.org/w/index.php?title=Arne_Andersson_(computer_scientist)&amp;action=edit&amp;redlink=1">Arne Andersson</a> 发明，而在 1993 年 <a href="https://en.wikipedia.org/w/index.php?title=Igal_Galperin&amp;action=edit&amp;redlink=1">Igal Galperin</a> and <a href="https://en.wikipedia.org/wiki/Ronald_L._Rivest">Ronald L. Rivest</a> 正式提出这个概念。</p>

<p>它是说不用每次修改树结构后都进行重平衡的操作，而是当检测到树的不平衡程度达到阈值时直接重构以某个节点为根的树。</p>

<p>搜/插/删的平均时间复杂度与其他自平衡二叉搜索树一样，都是 $O(\text{log}\ \text{n})$ ，但是由于重构的存在，插/删的最坏时间复杂度为 $O(\text{n})$ 。</p>

<p>它使用一个 $\alpha$ 因子衡量平衡性，$ 0.5 \lt \alpha \lt 1$ ，最终维护一个宽松的 $\alpha\text{-height}$ 平衡。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_tree!</span><span class="p">(</span>
    <span class="cd">/// Scapegoat Tree</span>
    <span class="n">SG</span>
    <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="cd">/// nodes count including marked</span>
        <span class="n">max_cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({});</span>

</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span>
    <span class="n">SG</span> <span class="k">-&gt;</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">);</span>
</code></pre></div></div>

<p>由于不存在严格的平衡，就不进行平衡校验了。</p>

<h2 id="重平衡">重平衡</h2>

<h3 id="重构">重构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_flatten_cleanup!</span><span class="p">();</span>
<span class="nd">impl_build_cleanup!</span><span class="p">();</span>

<span class="cd">/// impl SG</span>

<span class="cd">/// Rebuild at p, return new root</span>
<span class="k">fn</span> <span class="nf">rebuild_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">bst_build!</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">bst_flatten!</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// ...</span>
</code></pre></div></div>

<h3 id="插入重平衡">插入重平衡</h3>

<p>插入的时候，从插入的节点开始向上检查，找到第一个不平衡的节点，在该节点上进行重构。</p>

\[\begin{array}{l}
\texttt{size}\text{(left)} &amp;\leqslant\ α*\texttt{size}\text{(node)}\\
\texttt{size}\text{(right)} &amp;\leqslant\ α*\texttt{size}\text{(node)}
\end{array}\]

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span> <span class="o">+</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// impl SG</span>

<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">size_self</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">pp</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">size_sib</span> <span class="o">=</span> <span class="n">sib</span><span class="nf">.size</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">size_max</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">size_self</span><span class="p">,</span> <span class="n">size_sib</span><span class="p">);</span>

        <span class="n">size_self</span> <span class="o">+=</span> <span class="n">size_sib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">size_max</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">/</span> <span class="n">size_self</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.alpha</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pp</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">p_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">conn_left!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">conn_right!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="删除重平衡">删除重平衡</h3>

<p>删除的时候，直接考虑最大节点数与现有节点数的关系。</p>

\[\text{NodeCount} \leqslant α*\text{MaxNodeCount}\]

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>重构后需要重置最大节点数为当前结点数。</p>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">SG</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">&amp;&amp;</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">"bad alpha {alpha}"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">max_cnt</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">popped</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="k">self</span><span class="py">.cnt</span><span class="p">,</span> <span class="k">self</span><span class="py">.max_cnt</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">bst_delete!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>原始替罪羊树本身理论最坏时间复杂度不好，实际性能测试也不好，呃应该是相当相当差。</p>

<p>它的优势是保持平均的理论时间复杂度 $O(\text{log}\ \text{n})$ 情况下，由于没有额外字段，在考虑到数据对齐的情况下，每个节点可以节省多至 $1/3$ 的内存。</p>

<p>但是实际运行实在是太太太太慢了！两块儿最慢，一个是树的重构，一个是插入时动态计算节点大小，这么一看，所谓没有额外字段根本没有意义，因为省略了 size 字段严重地拖累了运行时间 。</p>

<p>接下来会在本篇基础上加入 size 字段，和惰性删除的特性，介绍 LSG （惰性替罪羊树）。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(4.1) - 惰性替罪羊树（LSG）</title><link href="/algs/BST-4.1-LSG-Tree.html" rel="alternate" type="text/html" title="BST(4.1) - 惰性替罪羊树（LSG）" /><published>2023-01-29T00:00:00+08:00</published><updated>2023-01-29T00:00:00+08:00</updated><id>/algs/BST%20-%204.1%20-%20LSG%20Tree</id><content type="html" xml:base="/algs/BST-4.1-LSG-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">替罪羊树</code> 的基本概念前文已经介绍过，这里主要做两个变化，一个是增加 <code class="language-plaintext highlighter-rouge">size</code> 字段来省略动态计算 <code class="language-plaintext highlighter-rouge">size</code> 的时间，另一个是使用惰性删除。</p>

<p>由于重构的存在，替罪羊树本来就很适合使用惰性删除的方法。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_tree!</span><span class="p">(</span>
    <span class="cd">/// Lazy Scapegoat Tree</span>
    <span class="n">LSG</span>
    <span class="p">{</span>
        <span class="n">cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="cd">/// nodes count including marked</span>
        <span class="n">max_cnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="n">LSG</span><span class="p">);</span>

<span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="nb">bool</span> <span class="p">});</span>
<span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">LSG</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_balance</span><span class="p">(</span><span class="k">self</span><span class="py">.alpha</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">);</span>

</code></pre></div></div>

<h3 id="搜插删时的小变化">搜/插/删时的小变化</h3>

<h4 id="搜索">搜索</h4>

<p>惰性搜索，如果找出的节点已被删除标记，那么仍然返回 <code class="language-plaintext highlighter-rouge">None</code> 。</p>

<h4 id="插入">插入</h4>

<p>惰性插入，当节点已存在时，用插入的节点的值替换既有节点的值（实现上注意手动管理内存的问题），如果节点已被标记删除，还要取消标记，并且给当前数量节点数 +1 。</p>

<h4 id="删除">删除</h4>

<p>惰性删除，删除节点时返回值，标记删除，但仍然保留节点（实现上注意手动管理内存的问题）。</p>

<h2 id="重平衡">重平衡</h2>

<h3 id="重构">重构</h3>

<p>重构的时候清除被标记删除的节点</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl LSG</span>

<span class="k">fn</span> <span class="nf">rebuild_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">part_nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dead_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="nd">bst_flatten!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">deleted!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">part_nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">dead_nodes</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">-=</span> <span class="n">dead_nodes</span><span class="p">;</span>

    <span class="nd">bst_build!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">part_nodes</span><span class="p">[</span><span class="o">..</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="插入重平衡">插入重平衡</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_flatten_cleanup!</span><span class="p">(</span>
    <span class="k">fn</span> <span class="nf">flatten_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">size!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
<span class="nd">impl_build_cleanup!</span><span class="p">(</span>
    <span class="k">fn</span> <span class="nf">build_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.update_size</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="c1">// impl Node</span>

<span class="k">fn</span> <span class="nf">update_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">size!</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="mi">1</span> <span class="o">+</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span> <span class="o">+</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.size</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>


<span class="c1">// impl LSG</span>

<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">pp</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">pp</span><span class="nf">.update_size</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">size_max</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nf">max</span><span class="p">(</span><span class="n">sib</span><span class="nf">.size</span><span class="p">(),</span> <span class="n">p</span><span class="nf">.size</span><span class="p">());</span>

        <span class="k">if</span> <span class="n">size_max</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">/</span> <span class="n">pp</span><span class="nf">.size</span><span class="p">()</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.alpha</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">pp</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">p_dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">conn_left!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">conn_right!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">LSG</span> <span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="o">&amp;&amp;</span> <span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">"bad alpha {alpha}"</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">alpha</span><span class="p">,</span>
            <span class="n">cnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">max_cnt</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="k">self</span><span class="nf">.insert_retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_delete!</span><span class="p">(</span><span class="n">lazy</span> <span class="p">|</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="k">self</span><span class="py">.cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="o">*</span> <span class="k">self</span><span class="py">.alpha</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.max_cnt</span> <span class="k">as</span> <span class="nb">f32</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rebuild_at</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="k">self</span><span class="py">.max_cnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cnt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nf">Some</span><span class="p">(</span><span class="n">popped</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>省去了插入时巨慢的动态计算 <code class="language-plaintext highlighter-rouge">size</code> 的过程，但还是很慢，而且这样也不省内存了，真的是没什么用呐，替罪羊树。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(1) - 左偏红黑树</title><link href="/algs/BST-2-RB-Tree-1-LLRB-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(1) - 左偏红黑树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%201%20-%20LLRB%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-1-LLRB-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>LLRB 是简化后红黑树，基本来源是一个 2008年 <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> （原始红黑树的两位联合发明人之一）的教学 PPT ，和红黑树一样，基本也不太行（指得是实现复杂，不直观，而且不体面（指得是删除操作依靠节点内容的交换））</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(2) - AA树</title><link href="/algs/BST-2-RB-Tree-2-AA-Tree.html" rel="alternate" type="text/html" title="BST(2) - RB(2) - AA树" /><published>2023-01-20T00:00:00+08:00</published><updated>2023-01-20T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%202%20-%20AA%20Tree</id><content type="html" xml:base="/algs/BST-2-RB-Tree-2-AA-Tree.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<h3 id="专属辅助">专属辅助</h3>

<h2 id="重平衡">重平衡</h2>

<h3 id="插入重平衡">插入重平衡</h3>

<h2 id="总装">总装</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(2) - RB(0) - 原始红黑树</title><link href="/algs/BST-2-RB-Tree-0-Origin.html" rel="alternate" type="text/html" title="BST(2) - RB(0) - 原始红黑树" /><published>2023-01-19T00:00:00+08:00</published><updated>2023-01-19T00:00:00+08:00</updated><id>/algs/BST%20-%202%20-%20RB%20Tree%20-%200%20-%20Origin</id><content type="html" xml:base="/algs/BST-2-RB-Tree-0-Origin.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>红黑树是一种对平衡的要求比前面介绍的 <code class="language-plaintext highlighter-rouge">AVL树</code> 宽松一些的自平衡二叉搜索树，因此虽然查询性能稍差，但有更少的 插/删 所需要的旋转次数，也就是写的性能更加优秀。它是在在 1978 年由 <a href="https://en.wikipedia.org/wiki/Leonidas_J._Guibas">Leonidas J. Guibas</a> and <a href="https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)">Robert Sedgewick</a> 联合提出，用红黑色标识区分主要是考虑到排版系统和手写方面的好处。（它模仿了 $4$ 阶 <code class="language-plaintext highlighter-rouge">B树</code>）</p>

<p>它把节点分为红色和黑色（空节点视为黑色），规定新增的节点都是红色，而红色节点的父节点不能也是红色节点，在这种情况下保持每个节点的所有叶子节点到该节点的路径上黑色结点数相等，或者简称黑高相等，这样就能保持树的平衡性。另外应该是出于减少不必要重平衡的操作，特别规定根节点应设为黑色。</p>

<p>在红色节点不能连续的情况下，如果黑高相等，那意味着最大的树高的差距不超过 $1$ 倍。</p>

<h3 id="系列展望">系列展望</h3>

<p>红黑树，由于一些历史原因很流行，在工程领域有众多的应用，在学术领域衍生出了很多变种。比如 Linux 上的 CFS（ <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely Fair Scheduler</a>）任务调度系统、系统调用 <code class="language-plaintext highlighter-rouge">epoll</code> 的实现，Java 8 的 HashMap 里组织哈希碰撞的元素用了红黑树代替链表，TreeMap 很多都是红黑树的变种。而在后面还会介绍几个有名的红黑树变种。</p>

<p>这里可以保证，不管是类比 <code class="language-plaintext highlighter-rouge">2-4树</code> 还是学习了前面的红黑树（或变种）对于后面的红黑树变种在实现上的理解没有任何帮助。归根结底红黑树就不是一个和我们之前或之后介绍的所有自平衡二叉树那样概念很清楚，实现很简单的一个东西。这个数据结构就是非常的怪。</p>

<p>由于红黑树的这种不简单的、怪的设计，使得结构变化后修复它变得过于复杂，特别是按照传统在二叉搜索树删除节点的做法，当被删节点左右子树都不为空的时候，情况复杂到难以处理，这导致几乎所有的实现都在使用一个<strong>非常非常 Tricky 的方法：假交换</strong>，来规避这种过于复杂的情况，使得可以只处理一个孩子为空的情况，即使这样仍然相当复杂。</p>

<h4 id="假交换">假交换</h4>

<p>比起通过旋转改变节点间的实际的引用关系，假交换是仅仅交换节点实际内容： <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">val</code> 字段，而不改变引用关系，这样可以规避对复杂节点关系的处理。</p>

<p>但是正如它所做的事情客观的展示那样，<strong>假交换非常的不体面</strong>，它彻底破坏了节点引用与键值对的固定关系，引入了潜在的 Bug （比如你可能保存了之前查询到的某个节点的引用，然后对另外节点进行操作时，意外地发现之前持有的节点的 <code class="language-plaintext highlighter-rouge">key</code>， <code class="language-plaintext highlighter-rouge">val</code> 字段也发生了改变）</p>

<p><em>我个人是非常非常不喜欢这种糟糕的 tricky 的方式，但整个红黑树系列操作的基础就是这种不体面的假交换，所以我说这个红黑树算法本身就很怪。</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">swap</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">node</span> <span class="p">|</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$y:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nv">$y</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">x_attr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nv">$attr</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">y_attr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nv">$attr</span><span class="p">);</span>

            <span class="nd">attr!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nv">$attr</span><span class="p">,</span> <span class="n">y_attr</span><span class="p">);</span>
            <span class="nd">attr!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nv">$attr</span><span class="p">,</span> <span class="n">x_attr</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// Used in red-balck tree serials</span>
<span class="cd">///</span>
<span class="cd">/// Trciky method</span>
<span class="nd">macro_rules!</span> <span class="n">fake_swap</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$y:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nv">$y</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="nd">swap!</span><span class="p">(</span><span class="n">node</span><span class="p">|</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="nd">swap!</span><span class="p">(</span><span class="n">node</span><span class="p">|</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">color</span><span class="p">:</span> <span class="n">Color</span> <span class="p">});</span>
<span class="nd">impl_tree!</span><span class="p">(</span><span class="n">RB</span> <span class="p">{});</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}({:?})"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="k">self</span><span class="nf">.color</span><span class="p">())</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil({:?})"</span><span class="p">,</span> <span class="k">self</span><span class="nf">.color</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="专属辅助">专属辅助</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Static Stats</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">color</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Color</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">Black</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">is_red</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.is_red</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">is_black</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.is_black</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">color_flip</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="nf">.is_some</span><span class="p">(),</span> <span class="s">"Color flip on None"</span><span class="p">);</span>

        <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="k">self</span><span class="nf">.color</span><span class="p">()</span><span class="nf">.rev</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">RB</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_black_balance</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Validation Helper</span>

    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_rb_rule</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.is_black</span><span class="p">())</span>
        <span class="p">}</span>

        <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
        <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_rb_rule</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cd">/// 应该给每个节点校验，但是存储黑高是一个问题，单独搞一个数据结构又太费</span>
    <span class="cd">/// 于是多次总体校验的方式</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_black_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">use</span> <span class="nn">itertools</span><span class="p">::</span><span class="n">Itertools</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">is_black_blance</span> <span class="o">=</span>
        <span class="k">self</span>
            <span class="nf">.leafs</span><span class="p">()</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.black_depth_to</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
            <span class="nf">.tuples</span><span class="p">()</span>
            <span class="nf">.all</span><span class="p">(|(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">is_black_blance</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">black_depth_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">p</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">depth</span>
    <span class="p">}</span>

    <span class="cd">/// store paren for nil leaf</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">leafs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">leafs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">leafs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="k">self</span><span class="nf">.clone</span><span class="p">()];</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

            <span class="c1">// 两片本质一样的叶子只保留其中一页</span>
            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">right</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">leafs</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">leafs</span>
    <span class="p">}</span>

<span class="p">}</span>

</code></pre></div></div>

<h2 id="重平衡">重平衡</h2>

<p>在介绍具体的重平衡事务之前，先强调一下对于红黑树而言，旋转结束要<strong>额外交换新旧根的颜色</strong>，这给后面不管是插入还是删除的重平衡操作提供了便利。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">RB</span> <span class="k">-&gt;</span>
    <span class="k">fn</span> <span class="nf">rotate_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* swap color */</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">swap!</span><span class="p">(</span><span class="n">node</span> <span class="p">|</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_black</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="nf">.is_black</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="插入重平衡">插入重平衡</h3>

<p><em>插入思路来源于 brilliant.org 相关页面</em></p>

<p>插入节点后的重平衡是比较容易的，无非是如何处理新增节点导致的<strong>红违背（red violation）</strong>，也就是父子两个节点都是红色节点的情况。</p>

<p>这时主要有三种情况：</p>

<p>假设插入的红节点为 $\texttt{i}$ ，$\texttt{i}$ 的父节点为 $\texttt{p}$ ， $\texttt{p}$ 的父节点为 $\texttt{pp}$ ， $\texttt{p}$ 的邻居节点是 $\texttt{psib}$</p>

<h4 id="case-1">case-1</h4>

<p>$\texttt{psib}$ 是红节点，只需要把 $\texttt{pp}$ , $\texttt{p}$ , $\texttt{psib}$ 反色，并一路向上修复，这样既修复了红违背又保持了黑平衡</p>

<p><img src="/../assets/img/bst_rb/insert_case1_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case1_end.png" alt="修复" /></p>

<h4 id="case-2">case-2</h4>

<p>$\texttt{psib}$ 是黑节点，并且 $\texttt{p} \rightarrow \texttt{i}$ 的方向与 $\texttt{pp} \rightarrow \texttt{p}$ 的方向相反，向 $\texttt{p} \rightarrow \texttt{i}$ 的反方向旋转，到 <strong>case-3</strong></p>

<p><img src="/../assets/img/bst_rb/insert_case2_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case2_end.png" alt="修复" /></p>

<h4 id="case-3">case-3</h4>

<p>$\texttt{psib}$ 是黑节点，并且 $\texttt{p} \rightarrow \texttt{i}$ 的方向与 $\texttt{pp} \rightarrow \texttt{p}$ 的方向相同，向 $\texttt{p} \rightarrow \texttt{i}$ 的反方向旋转，并且把 $\texttt{p}$ 和 $\texttt{pp}$ 反色</p>

<p><img src="/../assets/img/bst_rb/insert_case3_start.png" alt="初始" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/insert_case3_end.png" alt="修复" /></p>

<p><em>case-2 可以直接双旋，然后反色一步到位地解决</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// impl RB</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="n">color</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">Black</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">Red</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="n">color</span> <span class="p">});</span>

    <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">self</span><span class="nf">.fix_red_violation</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

    <span class="n">popped</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">fix_red_violation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">p</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="cm">/* Both p and pp is RED */</span>

    <span class="k">let</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">red_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">p_dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">psib_dir</span> <span class="o">=</span> <span class="n">p_dir</span><span class="nf">.rev</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">psib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>

    <span class="cm">/* case-1 */</span>

    <span class="k">if</span> <span class="n">psib</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">p_dir</span> <span class="o">==</span> <span class="n">red_dir</span> <span class="p">{</span>
            <span class="cm">/* case-3 */</span>
            <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-2 */</span>
            <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">psib_dir</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>  <span class="c1">// psib is red</span>
        <span class="n">p</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="n">pp</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="n">psib</span><span class="nf">.color_flip</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">color!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">Black</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
        <span class="k">self</span><span class="nf">.fix_red_violation</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// impl ...</span>
</code></pre></div></div>

<h3 id="合法的颜色关系">合法的颜色关系</h3>

<p>在介绍仍然相当复杂的删除重平衡之前，作为一个基础，先认识一下符合红约束和黑平衡条件下的“合法“的颜色关系。</p>

<p>假设父节点 $\texttt{p}$ 和它的两个孩子 $\texttt{c}_0$ , $\texttt{c}_1$ ：</p>

<p><img src="/../assets/img/bst_rb/normal_case_1.png" alt="" /> <img src="/../assets/img/bst_rb/normal_case_2.png" alt="" /> <img src="/../assets/img/bst_rb/normal_case_3.png" alt="" /> <img src="/../assets/img/bst_rb/normal_case_4.png" alt="" /></p>

<table>
  <thead>
    <tr>
      <th>$P$</th>
      <th>$C_0$</th>
      <th>$C_1$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span style="color:#cd0404">Red</span></td>
      <td><span style="color:black">Black</span></td>
      <td><span style="color:black">Black</span></td>
    </tr>
    <tr>
      <td><span style="color:black">Black</span></td>
      <td><span style="color:black">Black</span></td>
      <td><span style="color:black">Black</span></td>
    </tr>
    <tr>
      <td><span style="color:black">Black</span></td>
      <td><span style="color:#cd0404">Red</span></td>
      <td><span style="color:#cd0404">Red</span></td>
    </tr>
    <tr>
      <td><span style="color:black">Black</span></td>
      <td><span style="color:black">nil</span> (or <span style="color:#cd0404">Red</span>)</td>
      <td><span style="color:#cd0404">Red</span> (or <span style="color:black">nil</span>)</td>
    </tr>
  </tbody>
</table>

<p>借助这个关系列表，可以提高我们对红与黑的理解：</p>

<p>红色表示约束，只要有一个节点是红色，那它的左右孩子和父母的颜色就都是确定的了（都是黑色）；而黑色是无所谓的，没有约束的，一个黑色节点的孩子可以是任意颜色。</p>

<p>反过来从删除的角度讲，可以随意删除一个红色节点，而黑色节点则需要进行调整。</p>

<p>另外我们还发现当黑色节点的一个孩子是红色另一个孩子是黑色时，这个黑孩子一定是 $\texttt{nil}$ 节点。这还要回到红色的性质，红色 $\texttt{c}_1$ 的两个孩子一定是黑节点，如果 $\texttt{c}_0$ 是非 $\text{nil}$ 的黑节点，那么 $\texttt{c}_0$ 子树的 $\texttt{nil}$ 节点到 $\texttt{p}$ 的黑高都一定比 $\texttt{c}_1$ 的两个黑孩子的多 $1$ 。</p>

<h3 id="删除重平衡">删除重平衡</h3>

<p><em>删除来源于和 en.wiki 相关页面</em></p>

<p>在介绍删除重平衡之前有必要先介绍以下删除操作：</p>

<ol>
  <li>使用假交换确保被删除的节点至少有一个孩子是空的；</li>
  <li>用非空的孩子替换被删除的节点</li>
</ol>

<p>如果被删节点是红色的，那删除不会造成性质的破坏；</p>

<p>如果被删除的节点是黑色的，但如果替换节点是红色的，可以把红色染黑，这样黑平衡仍然得到了维护；</p>

<p>但如果被删除节点是黑色的，替换节点也是黑色的，但是它们已经是根节点了，这样当然也不影响黑平衡；</p>

<p>否则，以替换节点为根的子树的黑高少 $1$ ，我们可以形象地把这种情况称为 <strong>double black</strong> ，好像是两个黑节点被压到了一个节点上，表明这里黑高少了 $1$ 。处理这个双重黑节点就是删除重平衡要做的事情。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl RB</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
<span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">successor</span> <span class="o">=</span> <span class="nd">bst_minimum!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="nd">fake_swap!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">successor</span><span class="p">);</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">successor</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">z_dir</span> <span class="o">=</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">index_of_child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">};</span>

        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span> <span class="nb">Right</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nb">Left</span> <span class="p">});</span>
        <span class="nd">subtree_shift!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_black</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">child</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">color!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Black</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">z_dir</span><span class="p">)</span> <span class="o">=</span> <span class="n">z_dir</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.fix_double_black</span><span class="p">(</span><span class="n">z_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Some</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.into_value</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>由于双黑节点不是根节点，并且由于黑高少 $1$ ，它的邻居节点必然也不能是空节点，这样我们就有了以下的基本节点关系：</p>

<p>不妨设双黑节点为 $\texttt{n}$ ，父节点为 $\texttt{p}$ ，邻居节点为 $\texttt{sib}$ ，邻居节点中与 $\texttt{n}$ 同向的孩子节点为 $\texttt{sib}_c$ ，反向的孩子节点为 $\texttt{sib}_d$ ，则所有的情况考虑的就是 $\texttt{p}$, $\texttt{sib}$ , $\texttt{sib}_c$ , $\texttt{sib}_d$ 这四个节点。</p>

<p>对 <strong>double black</strong> 的修复可以把这四个节点的颜色关系分为 $5$ 种情况，其中有三种是基础情况，剩下两种可以通过转换为基本情况来处理。</p>

<h4 id="case-1-1">(case-1)</h4>

<p>$\texttt{p}$, $\texttt{sib}$ , $\texttt{sib}_c$ , $\texttt{sib}_d$  全是黑色：</p>

<p>$\texttt{sib}$ 反色为红，这样 $\texttt{n}$ 和 $\texttt{sib}$ 树的节点的黑高就都少了 $1$ 。但它们是（在 $\texttt{p}$ 上）平衡了，但 $\texttt{p}$ 整体黑高就少了 $\texttt{1}$ ，双黑圈就套到了 $\texttt{p}$上，问题没有直接解决，但是可以推后，什么问题可以留给后代解决（在 $\texttt{p}$ 上继续递归），那也就相当于解决了。</p>

<p><img src="/../assets/img/bst_rb/remove_case_1_1.png" alt="" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/remove_case_1_2.png" alt="" /></p>

<h4 id="case-2-1">(case-2)</h4>

<p>$\texttt{p}$ 是<span style="color:#cd0404">红色</span>，$\texttt{sib}$ , $\texttt{sib}_c$ , $\texttt{sib}_d$  全是<span style="color:black">黑色</span>：</p>

<p>交换 $\texttt{p}$ 与 $\texttt{sib}$ 的颜色，这样 $\texttt{sib}$ 的黑高没有变化，而 $\texttt{sib}$ 的黑高增加了 $1$ ，这样双黑节点就直接解决了，这是一种完美的情况。</p>

<p><img src="/../assets/img/bst_rb/remove_case_2_1.png" alt="" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/remove_case_2_2.png" alt="" /></p>

<h4 id="case-3-1">(case-3)</h4>

<p>$\texttt{sib}$ 是<span style="color:black">黑色</span>， $\texttt{sib}_d$ 是<span style="color:#cd0404">红色</span>，（按照前述， $\texttt{sib}_c$  <span style="color:#cd0404">红色</span>或者<span style="color:black">黑色</span>，保持原状），$\texttt{p}$ 是任意颜色：</p>

<ol>
  <li>$\texttt{p}\leftrightarrow\texttt{sib}$ 旋转交换位置和颜色</li>
  <li>$\texttt{sib}_d$ 颜色翻转为黑色</li>
</ol>

<p>对于 $\texttt{n}$ ，增加了一个黑节点，黑高补全了；</p>

<p>对于 $\texttt{sib}_c$ 叶子的黑高不变，$\texttt{sib}_d$ 路径上的黑节点少了 $\texttt{sib}$ 但自己变成了黑节点，对于自己的叶子黑高也是不变的（自己原来是红节点，不可能是叶子节点）这样双黑节点也解决了，这是另一种完美情况。</p>

<p><img src="/../assets/img/bst_rb/remove_case_3_1.png" alt="" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/remove_case_3_3.png" alt="" /></p>

<h4 id="case-4">[case-4]</h4>

<p>$\texttt{sib}$ 是<span style="color:black">黑色</span>， $\texttt{sib}_d$ 是<span style="color:black">黑色</span>而且 $\texttt{sib}_c$ 是<span style="color:#cd0404">红色</span>，$\texttt{p}$ 是任意颜色：</p>

<ol>
  <li>$\texttt{sib}\leftrightarrow\texttt{sib}_c$ 旋转交换位置和颜色</li>
</ol>

<p>$\texttt{p}$ 的右子树的叶子节点的黑高不变（ $\texttt{sib}_c$ 两个孩子的叶子黑高不变，$\texttt{sib}_d$ 的叶子黑高不变）</p>

<p>这样情况就变成了，<strong>(case-3)</strong> （新 $\texttt{sib}$ 黑色，新 $\texttt{sib}_d$ 红色）的情况 。</p>

<p><img src="/../assets/img/bst_rb/remove_case_4_1.png" alt="" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/remove_case_4_3.png" alt="" /></p>

<h4 id="case-5">[case-5]</h4>

<p>$\texttt{sib}$ 是<span style="color:#cd0404">红色</span> （$\texttt{sib}_d$ ，$\texttt{sib}_c$ 都是<span style="color:black">黑色</span>）</p>

<ol>
  <li>$\texttt{p}\leftrightarrow\texttt{sib}$ 旋转交换位置和颜色</li>
</ol>

<p>$\texttt{sib}_c$ , $\texttt{sib}_d$ 的黑高不变，$\texttt{n}$ 也还是双黑节点。</p>

<p>这时新的 $\texttt{sib}$ 变为 $\texttt{sib}_c$ （新的 $\texttt{sib}$ 为黑色）。根据新 $\texttt{sib}$ 的颜色关系选择 <strong>(case-2)</strong> 、 <strong>(case-3)</strong> 、 <strong>(case-4)</strong> 继续处理</p>

<p><img src="/../assets/img/bst_rb/remove_case_5_1.png" alt="" />  <img src="/../assets/img/bst_rb/rarrow.png" alt="" />  <img src="/../assets/img/bst_rb/remove_case_5_3.png" alt="" /></p>

<h4 id="流程图">流程图</h4>

<p>上述列举的情况虽然多且繁，有些复杂，但通过流程图还是能看得很清楚的。</p>

<p><em>用 dot 画图的时候因为一个边指定 portPos后导致 dir 、arrowtail、arrowhead 属性设置都失效的问题，浪费一天时间，没解决，不知道这是什么特性还是 bug ，只能凑活一个图</em></p>

<p><img src="/../assets/img/bst_rb/remove_control_flow.png" alt="" /></p>

<h4 id="实现">实现</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl RB</span>

<span class="cd">/// Refer to my blog (BST(2) - RB(0) - 原始红黑树)</span>
<span class="k">fn</span> <span class="nf">fix_double_black</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">:</span> <span class="n">Dir</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sib_dir</span> <span class="o">=</span> <span class="n">x_dir</span><span class="nf">.rev</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sib_dir</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sib_c</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sib_d</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">sib_dir</span><span class="p">);</span>

    <span class="cm">/* case-5 */</span>
    <span class="k">if</span> <span class="n">sib</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">);</span>

        <span class="n">sib</span> <span class="o">=</span> <span class="n">sib_c</span><span class="p">;</span>
        <span class="n">sib_c</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">x_dir</span><span class="p">);</span>
        <span class="n">sib_d</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">sib</span><span class="p">,</span> <span class="n">sib_dir</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">macro_rules!</span> <span class="n">case_3</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="nv">$p:ident</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="nv">$x_dir:ident</span><span class="p">,</span> <span class="n">sib_d</span><span class="o">=</span><span class="nv">$sib_d:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">$p</span><span class="p">,</span> <span class="nv">$x_dir</span><span class="p">);</span>
            <span class="nv">$sib_d</span><span class="nf">.color_flip</span><span class="p">();</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="cm">/* case-3 */</span>
    <span class="k">if</span> <span class="n">sib_d</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">case_3!</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="n">x_dir</span><span class="p">,</span> <span class="n">sib_d</span><span class="o">=</span><span class="n">sib_d</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* case-4 */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">sib_c</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">sib</span><span class="p">,</span> <span class="n">sib_dir</span><span class="p">);</span>
        <span class="nd">case_3!</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">x_dir</span><span class="o">=</span><span class="n">x_dir</span><span class="p">,</span> <span class="n">sib_d</span><span class="o">=</span><span class="n">sib</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* case-2 */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">p</span><span class="nf">.is_red</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">swap!</span><span class="p">(</span><span class="n">node</span> <span class="p">|</span> <span class="n">p</span><span class="p">,</span> <span class="n">sib</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* case-1 */</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">sib</span><span class="nf">.color_flip</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">pp</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">pp</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.fix_double_black</span><span class="p">(</span><span class="nd">index_of_child!</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">pp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p>哎呀我这代码写得太漂亮了，实在有必要自卖自夸一下：</p>

<ol>
  <li>结构清晰，教学模板！</li>
  <li>最后的尾递归也实在漂亮，而且在现代编译器的优化里，递归调用通常还会快于手写的循环！</li>
</ol>

<p>与之相比的是另一个业界广为流传的版本比如 <a href="https://github.com/openjdk/jdk/blob/6f9106e0d0d9f082f0a61009f95d1b8663dd8d4f/src/java.base/share/classes/java/util/TreeMap.java#L2676">OpenJDK TreeMap实现</a> ，注释里可能暗示抄自 CLR (dot net runtime) ，但我强烈怀疑 CLR 也未必是原创，毕竟红黑树是很早就有的概念。不管原创是谁，这个版本显然看起来代码行数较少，但实在难以理解，它是混合了一部分删除的代码和合并了 $\texttt{p}$ 红 <strong>(case-2)</strong> 的情况 。</p>

<p>我们强调代码一定要简单和易于理解，这绝大多数情况下都比一时的绝对性能还要重要！简单就利于机器优化，易于理解就利于人工优化，这都利于算法的演进与特化。像我们对比的版本，显然就是典型的代代相传的祖宗，谁都不敢改，全是一模一样然后注释里写，本代码抄自 xxx 。而像我们的代码不仅简单，而且有易于理解的优势，不管是调整流程还是省略掉几个宏重复的一些代码，改动都很容易。</p>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">BST(1) - AVL树</title><link href="/algs/BST-1-AVL-Tree.html" rel="alternate" type="text/html" title="BST(1) - AVL树" /><published>2023-01-17T00:00:00+08:00</published><updated>2023-01-17T00:00:00+08:00</updated><id>/algs/BST%20-%201%20-%20AVL%20Tree</id><content type="html" xml:base="/algs/BST-1-AVL-Tree.html"><![CDATA[<p>前文介绍了<a href="./BST - 0 - Basic.md">二叉搜索树基础</a> ，这里是第一个自平衡的二叉搜索树 – <code class="language-plaintext highlighter-rouge">AVL树</code>，它是在 1962 年由前苏联的科学家 <a href="https://en.wikipedia.org/wiki/Georgy_Adelson-Velsky">Georgy Adelson-Velsky</a> 和 <a href="https://en.wikipedia.org/wiki/Evgenii_Landis">Evgenii Landis</a> 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。</p>

<p>顺带一提，有的地方讲 <code class="language-plaintext highlighter-rouge">AVL树</code> 实现比红黑树复杂，这令人费解，因为不管相比原始红黑树还是左偏红黑树，<code class="language-plaintext highlighter-rouge">AVL</code> 的实现都足够简单，而且易于理解。</p>

<h2 id="基本概念">基本概念</h2>

<p><code class="language-plaintext highlighter-rouge">AVL树</code>对树平衡的要求是（每个节点）左右树高的差距不超过 $1$ 。</p>

<p>定义 $\texttt{BF}$（Balance Factor）= 右子树高 - 左子树高，于是有 $\texttt{BF} \in $ { -1, 0, 1 } 。</p>

<p>于是我们需要一个额外的节点字段 $\texttt{height}$ 来辅助记录。</p>

<h2 id="基础定义">基础定义</h2>

<h3 id="共同结构">共同结构</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_node!</span><span class="p">();</span>
<span class="nd">impl_node_!</span><span class="p">({</span> <span class="n">height</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">});</span>
<span class="nd">impl_tree!</span><span class="p">(</span><span class="n">AVL</span> <span class="p">{});</span>

<span class="nd">impl_rotate_cleanup!</span><span class="p">(</span><span class="n">AVL</span> <span class="k">-&gt;</span>
    <span class="k">fn</span> <span class="nf">rotate_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* update height */</span>
        <span class="n">x</span><span class="nf">.update_height</span><span class="p">();</span>
        <span class="n">z</span><span class="nf">.update_height</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}(h: {})"</span><span class="p">,</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="p">),</span> <span class="nd">height!</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="专属辅助">专属辅助</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">update_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">height!</span><span class="p">(</span>
                <span class="k">self</span><span class="p">,</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="nf">max</span><span class="p">(</span>
                    <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">(),</span>
                    <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Static Stats</span>

    <span class="k">fn</span> <span class="nf">height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">height!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">bf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">-</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="平衡校验">平衡校验</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">impl_balance_validation!</span><span class="p">(</span><span class="n">AVL</span> <span class="k">-&gt;</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">balance_validation</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.recalc_height</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.root</span><span class="nf">.validate_bf</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">);</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// Recursively validate BF:</span>
    <span class="cd">///</span>
    <span class="cd">/// BF(X): H(right(X)) - H(left(X))</span>
    <span class="cd">///</span>
    <span class="cd">/// BF(X) in {-1, 0, 1}</span>
    <span class="cd">///</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">validate_bf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span>
            <span class="k">self</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_bf</span><span class="p">();</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.validate_bf</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Recursively calculate height stats dynamically instead of using static height</span>
    <span class="nd">#[cfg(test)]</span>
    <span class="k">fn</span> <span class="nf">recalc_height</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.recalc_height</span><span class="p">();</span>
            <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="nf">.recalc_height</span><span class="p">();</span>

            <span class="k">self</span><span class="nf">.update_height</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="重平衡">重平衡</h2>

<p><strong>一般的重平衡操作</strong></p>

<p>从入口节点开始，一路向上直到根节点，检查每个节点是否失衡，如果失衡根据前文讲的情况：</p>

<ol>
  <li>较高的子树的方向与子树较高子树的方向一致，一次单旋；</li>
  <li>方向不一致，双旋</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl&lt;K: Ord, V&gt; AVL&lt;K, V&gt; </span>
<span class="c1">// ...</span>

<span class="cd">/// Bottom up fixing</span>
<span class="k">fn</span> <span class="nf">retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">p</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">p</span><span class="nf">.update_height</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">p</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">high</span> <span class="o">=</span>
            <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nd">left!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="p">{</span>
                <span class="nb">Right</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nb">Left</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

            <span class="k">if</span> <span class="nd">child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span><span class="nf">.height</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">())</span><span class="nf">.height</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">high</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>对于插入操作简化后的重平衡：</strong></p>

<p>对于插入操作的重平衡操作，可以简化检查较高子树的方向这一步，因为总是检查重平衡所在的节点较高：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl ...</span>

<span class="nd">#[allow(unused)]</span>
<span class="k">fn</span> <span class="nf">insert_retracing</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="k">mut</span> <span class="n">y</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* x
       |
       z
       |
       y
    */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">z</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">z</span><span class="nf">.update_height</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">x</span><span class="nf">.bf</span><span class="p">()</span><span class="nf">.abs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">index_of_z</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">index_of_y</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">index_of_z</span> <span class="o">==</span> <span class="n">index_of_y</span> <span class="p">{</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nd">rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index_of_z</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">z</span> <span class="o">=</span> <span class="nd">double_rotate!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">index_of_z</span><span class="nf">.rev</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="总装">总装</h2>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">AVL</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>
    <span class="cd">/// Public API</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span> <span class="n">BST</span> <span class="p">{</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>

        <span class="k">let</span> <span class="n">popped</span> <span class="o">=</span> <span class="nd">bst_insert!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// self.insert_retracing(z);</span>
        <span class="k">self</span><span class="nf">.retracing</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

        <span class="n">popped</span>
    <span class="p">}</span>


    <span class="k">pub</span> <span class="k">fn</span> <span class="n">remove</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span>
    <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span>
    <span class="p">{</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">z</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">retracing_entry</span> <span class="o">=</span> <span class="nd">bst_delete!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="k">self</span><span class="nf">.retracing</span><span class="p">(</span><span class="n">retracing_entry</span><span class="p">);</span>

            <span class="nf">Some</span><span class="p">(</span><span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="py">.val</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前文介绍了二叉搜索树基础 ，这里是第一个自平衡的二叉搜索树 – AVL树，它是在 1962 年由前苏联的科学家 Georgy Adelson-Velsky 和 Evgenii Landis 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。]]></summary></entry><entry><title type="html">BST(0) - 二叉搜索树基础</title><link href="/algs/BST-0-Basic.html" rel="alternate" type="text/html" title="BST(0) - 二叉搜索树基础" /><published>2023-01-14T00:00:00+08:00</published><updated>2023-01-14T00:00:00+08:00</updated><id>/algs/BST%20-%200%20-%20Basic</id><content type="html" xml:base="/algs/BST-0-Basic.html"><![CDATA[<p>作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。</p>

<h2 id="定义">定义</h2>

<p>二叉搜索树是二叉树，但是额外需要每个节点满足：左孩子（如果有的话）的 <code class="language-plaintext highlighter-rouge">key</code> 比它的小，而右孩子的 <code class="language-plaintext highlighter-rouge">key</code> 比它的大 。</p>

<h2 id="实现前言">实现前言</h2>

<p>考虑如何在实现上（Rust）把本文介绍的二叉搜索树的基础操作作为后面实现的具体种类的带自平衡的二叉搜索树的基础 ，也就是怎么用一种比较好的方式复用这些代码。</p>

<p>对于像 <code class="language-plaintext highlighter-rouge">C++/C#/Java</code> 风格的同时继承数据和行为的面向对象语言，可以使用同心圆套圈儿的 “继承“ 来复用代码 。而对于 Rust 这种只有行为共享而没有数据共享的纯粹的抽象机制（Trait机制），由于不能对属性进行直接的访问，只能使用方法来访问属性，这会使实现的代码非常啰嗦（每次具体类型都需要实现一遍属性访问的方法）。另外一个问题在于由于对象需要放在堆上（避免定义上的循环引用和做对象的向上（upcast）或向下（downcast）地转换），实际上是使用 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;Node&gt;&gt;</code>，每次调用都要复杂解引用，这一点在前面 <code class="language-plaintext highlighter-rouge">FibHeap</code> 实现问题上已经讲过。</p>

<p>这里采取了完整包装（复杂包装）和重度使用宏机制来做代码复用 。</p>

<h3 id="完整包装">完整包装</h3>

<p>假定树的实际的内部节点为 <code class="language-plaintext highlighter-rouge">Node_</code>，包装器的节点为 <code class="language-plaintext highlighter-rouge">Node</code> ，为避免智能指针（<code class="language-plaintext highlighter-rouge">Rc</code>）造成的循环引用，还引入了包装器的弱引用版本 <code class="language-plaintext highlighter-rouge">WeakNode</code>，最后树结构为 <code class="language-plaintext highlighter-rouge">Tree</code> 。</p>

<h4 id="内部节点-node_-伪代码">内部节点 <code class="language-plaintext highlighter-rouge">Node_</code> 伪代码：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node_</span> <span class="p">{</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="p">,</span>
    
    <span class="n">key</span><span class="p">,</span>
    <span class="n">val</span>
<span class="p">}</span>
</code></pre></div></div>

<p>反向引用使用弱节点类型</p>

<h4 id="包装的节点-node-伪代码">包装的节点 <code class="language-plaintext highlighter-rouge">Node</code> 伪代码：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nf">Node</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>包装器可能是一个实际的节点，或者是 <code class="language-plaintext highlighter-rouge">none</code></p>

<h4 id="弱引用的节点-weaknode">弱引用的节点 <code class="language-plaintext highlighter-rouge">WeakNode</code>：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nf">WeakNode</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>把强引用 <code class="language-plaintext highlighter-rouge">Rc</code> 替换成弱引用 <code class="language-plaintext highlighter-rouge">Weak</code></p>

<h4 id="树本身的结构">树本身的结构：</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种完整包装的优点在于可以完美地上位替代传统的基于指针结构的树结构的实现，但是肉眼可见地过于复杂，比如如果我们要访问节点 <code class="language-plaintext highlighter-rouge">x</code> 的左孩子：</p>

<p><code class="language-plaintext highlighter-rouge">x.0.clone().unwrap().as_ref().borrow().left</code></p>

<p>写这样出的代码简直是地狱！</p>

<p>好在可以用几乎完美的 Rust 宏来解决这件事</p>

<h3 id="用宏抽象">用宏抽象</h3>

<p><strong>关于使用宏来拓展语言的抽象机制主要有以下几个类别：</strong></p>

<ol>
  <li>函数分发：函数根据参数个数进行函数分发；</li>
  <li>代码 Mixin：定义语法 Item（结构体、函数、宏），实现方法；</li>
  <li>嵌套压缩：省略掉每次固定的一长串儿连续的属性访问与方法调用</li>
</ol>

<h4 id="压缩包装">压缩包装</h4>

<p>关于节点的访问的简化，是在前文 <code class="language-plaintext highlighter-rouge">FibHeap</code> 实现里面使用的那一套宏的升级。</p>

<p><strong>访问与修改节点的指定属性的宏：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="cm">/* to pass runtime borrow check  */</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_unr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
                <span class="n">_attr</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Access {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
            <span class="p">}</span>
    	<span class="p">}</span> 
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">bor</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span> <span class="p">{</span>
                <span class="n">bor</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span> <span class="o">=</span> <span class="nv">$val</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"MAccess {} on None"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$attr</span><span class="p">));</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>生成属性访问宏的宏：</strong></p>

<p>由于从 API 设计的角度，部分属性需要使用指针来绕过生命周期的限制，从而返回引用，所以生成宏特制了这一部分</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">ptr</span> <span class="p">|</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">}</span>
                <span class="p">};</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$val:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">,</span> <span class="nv">$$val</span><span class="p">)</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nv">$name</span><span class="p">;</span>

            <span class="nn">concat_idents</span><span class="p">::</span><span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">name_mut</span> <span class="o">=</span> <span class="nv">$name</span><span class="p">,</span> <span class="n">_mut</span> <span class="p">{</span>
                <span class="nd">macro_rules!</span> <span class="n">name_mut</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span> <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">}</span>
                    <span class="p">};</span>
                <span class="p">}</span>
                <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="n">name_mut</span><span class="p">;</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>生成属性访问宏：</strong></p>

<p>显然其中节点的 <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">val</code> 都是存储在堆上（通过 <code class="language-plaintext highlighter-rouge">Box</code>），节点里保存唯一的指针</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">def_attr_macro!</span><span class="p">(</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">height</span>
<span class="p">);</span>
<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">ptr</span> <span class="p">|</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>堆上数据封装与解包的宏：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>对内部节点封装与解包：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">BST</span> <span class="p">{</span> <span class="nv">$key:expr</span><span class="p">,</span> <span class="nv">$val:expr</span> <span class="nv">$</span><span class="p">(,</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">)</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>

            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$key</span><span class="p">),</span>
            <span class="n">val</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$val</span><span class="p">),</span>

            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="n">FREE</span> <span class="p">{</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$attr:ident</span> <span class="p">:</span> <span class="nv">$attr_val:expr</span><span class="p">),</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$attr</span><span class="p">:</span> <span class="nv">$attr_val</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="辅助定义">辅助定义</h4>

<p><strong>实现内部节点：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_node_</span> <span class="p">{</span>
    <span class="p">({</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span><span class="p">)</span><span class="o">*</span> <span class="p">})</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">left</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">K</span><span class="p">,</span>
            <span class="n">val</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">V</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span><span class="p">,</span>
            <span class="p">)</span><span class="o">*</span>
        <span class="p">}</span>
        
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">into_value</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">oldval</span> <span class="o">=</span> <span class="k">self</span><span class="py">.val</span><span class="p">;</span>
                <span class="k">self</span><span class="py">.val</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">();</span>
                <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldval</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.key</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">unboxptr!</span><span class="p">(</span><span class="k">self</span><span class="py">.key</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.val</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">unboxptr!</span><span class="p">(</span><span class="k">self</span><span class="py">.val</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}: {:?}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.key</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.val</span> <span class="p">})</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意，为了绕过对引用的生命周期的限制，采用了手动的方式管理内存，这意味着在节点解构方法上也要手动释放内存，而在返回值的时候也要对应把指针摆到 <code class="language-plaintext highlighter-rouge">null</code> 处避免 <strong>double free</strong> 的问题。</p>

<p><strong>实现节点包装（强和弱）：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">impl_node</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="cd">/// Used for reverse reference to avoid circular-reference</span>
        <span class="cd">///</span>
        <span class="cd">/// So we can easy auto drop</span>
        <span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="n">Weak</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="nf">WeakNode</span><span class="p">(</span>
                    <span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="p">}</span>

            <span class="nd">#[allow(unused)]</span>
            <span class="k">fn</span> <span class="nf">as_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">rc</span><span class="nf">.as_ptr</span><span class="p">(),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">null_mut</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="nd">#[allow(unused)]</span>
            <span class="k">fn</span> <span class="nf">replace_val</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">oldvptr</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="nd">attr!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldvptr</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                            <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="kc">false</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">PartialEq</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Eq</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span>
                    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="o">=</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">strong</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"weak node upgrade failed"</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">))</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
                <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>实现树：</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">def_tree</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span>
        <span class="nv">$treename:ident</span> <span class="p">{</span> <span class="nv">$</span><span class="p">(</span>
            <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr:meta]</span><span class="p">)</span><span class="o">*</span>
            <span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span><span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="k">=&gt;</span>
    <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
        <span class="nd">#[derive(Debug)]</span>
        <span class="nd">#[allow(unused)]</span>
        <span class="k">pub</span> <span class="k">struct</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

            <span class="cm">/* extra attr */</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="nv">$ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_tree_debug</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$treename:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">fn</span> <span class="n">debug_write</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span><span class="o">&gt;</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
                <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">W</span>
            <span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span>
            <span class="p">{</span>
                <span class="cm">/* print header */</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{self:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>


                <span class="cm">/* print body */</span>

                <span class="k">if</span> <span class="k">self</span><span class="py">.root</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Ok</span><span class="p">(());</span>
                <span class="p">}</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">this_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[</span><span class="k">self</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">()];</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">while</span> <span class="o">!</span><span class="n">this_q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"############ Level: {lv} #############"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                    <span class="k">let</span> <span class="k">mut</span> <span class="n">nxt_q</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nd">vecdeq!</span><span class="p">[];</span>

                    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">this_q</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{x:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="p">{</span>
                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{x:?} | L-&gt; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                            <span class="k">if</span> <span class="n">left</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{left:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                                <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                            <span class="p">}</span>

                            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; R-&gt; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                            <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                            <span class="k">if</span> <span class="n">right</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{right:?}"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                                <span class="n">nxt_q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
                            <span class="p">}</span>
                            <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"nil"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">this_q</span> <span class="o">=</span> <span class="n">nxt_q</span><span class="p">;</span>
                    <span class="n">lv</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"------------- end --------------</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

                <span class="nf">Ok</span><span class="p">(())</span>
            <span class="p">}</span>


            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">debug_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

                <span class="k">self</span><span class="nf">.debug_write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

                <span class="nd">println!</span><span class="p">(</span><span class="s">"{cache}"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">impl_tree</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr:meta]</span><span class="p">)</span><span class="o">*</span>
        <span class="nv">$treename:ident</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span>
                <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr:meta]</span><span class="p">)</span><span class="o">*</span>
                <span class="nv">$name</span><span class="p">:</span> <span class="n">ident</span> <span class="p">:</span> <span class="nv">$ty</span><span class="p">:</span> <span class="n">ty</span>
            <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">)</span> <span class="k">=&gt;</span>
    <span class="p">{</span>
        <span class="nd">def_tree!</span><span class="p">(</span>
            <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">attr]</span><span class="p">)</span><span class="o">*</span>
            <span class="nv">$treename</span> <span class="p">{</span>
                <span class="nv">$</span><span class="p">(</span>
                    <span class="nv">$</span><span class="p">(</span><span class="nd">#[</span><span class="err">$</span><span class="nd">field_attr]</span><span class="p">)</span><span class="o">*</span>
                    <span class="nv">$name</span> <span class="p">:</span> <span class="nv">$ty</span>
                <span class="p">),</span><span class="o">*</span>
            <span class="p">}</span>
        <span class="p">);</span>
        <span class="nd">impl_tree_debug!</span><span class="p">(</span><span class="nv">$treename</span><span class="p">);</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Ord</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nv">$treename</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="nd">val!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">pub</span> <span class="k">fn</span> <span class="n">get_mut</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span>
            <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">bst_search!</span><span class="p">(</span><span class="k">self</span><span class="py">.root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="nd">val_mut!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对树的实现宏分为三个宏是为了方便后面不同树种的灵活使用。</p>

<p>这里在树的实现里的 <code class="language-plaintext highlighter-rouge">get</code> 方法，有 Trait 条件 <code class="language-plaintext highlighter-rouge">where K: Borrow&lt;Q&gt;, Q: Ord + ?Sized</code> ，这也是 Rust 标准库里对于数据结构的 <code class="language-plaintext highlighter-rouge">get</code> 方法普遍采取的约束条件。</p>

<p>在这里有必要说明一下关于 <strong>Borrow</strong> 与 <strong>AsRef</strong> 的区别有，这两个广泛使用的类型表示的 Trait 有相同的签名：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">Borrowed</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Borrowed</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">trait</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实现了上面的 Trait 比如 <code class="language-plaintext highlighter-rouge">Borrow</code> 就有 <code class="language-plaintext highlighter-rouge">K: Borrow&lt;Q&gt; =&gt; K.borrow(): &amp;Q</code></p>

<p>常见的都实现了两个 Trait 的比如 <code class="language-plaintext highlighter-rouge">String -&gt; &amp;str</code> , <code class="language-plaintext highlighter-rouge">PathBuf -&gt; &amp;Path</code></p>

<p>这两个 Trait 的区别在于：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Borrow</code> 有一个对于 <code class="language-plaintext highlighter-rouge">T</code> 的笼统类型实现（blanket implementation）：</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span> 
<span class="k">where</span> 
   <span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span>
</code></pre></div></div>

<p>这让我们可以直接把 <code class="language-plaintext highlighter-rouge">&amp;K</code> 作为 <code class="language-plaintext highlighter-rouge">K.borrow()</code> 的返回类型，而 <code class="language-plaintext highlighter-rouge">AsRef</code> 由于类型系统的限制（为了避免另一个用于自动解引用的 blanket implementation 的重叠）</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">&amp;</span><span class="n">T</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="n">U</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
</code></pre></div></div>

<p>这个笼统实现是说任何 <code class="language-plaintext highlighter-rouge">T.as_ref() -&gt; &amp;U</code> 都有 <code class="language-plaintext highlighter-rouge">&amp;T.as_ref() -&gt; &amp;U</code> ，但其中 <code class="language-plaintext highlighter-rouge">AsRef&lt;U&gt;</code> 与 <code class="language-plaintext highlighter-rouge">AsRef&lt;T&gt;</code> 存在语义重叠的部分，而现有的类型系统没法儿进行区分（这非常可惜，也极大地限制了 Rust 充满想法的类型系统的生态发展）</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Borrow</code> 需要保证 <code class="language-plaintext highlighter-rouge">Hash, Eq, Ord</code> 与原类型的一致性</li>
</ol>

<p>对以上用于压缩包装和辅助定义的宏的具体用例不清楚的，可以参考后续的关于具体自平衡二叉搜索树介绍的博文</p>

<h4 id="错误定位">错误定位</h4>

<p>重度使用宏的编码方式的最大的问题在于，对几乎所有已知的编程语言，缺乏系统完整好用的调试手段，这是有待发展的领域，特别考虑到很多上世纪90年代创建的主流语言根本就没有宏机制 。</p>

<p>对于 Rust 宏代码最大问题在于无法准确定位宏中的错误和 Debug ，宏展开后的代码没法能还原为在原宏中的位置 。</p>

<p>所以为了缓解这个问题，需要我们手动的插入锚点，当调用失败的时候打印错误信息 。</p>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="左右方向">左右方向</h3>

<p>不管是左右孩子还是左右旋转，都需要一个指示方向是左还是右的结构</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">#[derive(Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">enum</span> <span class="n">Dir</span> <span class="p">{</span>
    <span class="nb">Left</span><span class="p">,</span>
    <span class="nb">Right</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">use</span> <span class="nn">Dir</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>


<span class="k">impl</span> <span class="n">Dir</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nb">Left</span> <span class="k">=&gt;</span> <span class="nb">Right</span><span class="p">,</span>
            <span class="nb">Right</span> <span class="k">=&gt;</span> <span class="nb">Left</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_left</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">matches!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nb">Left</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="访问孩子">访问孩子</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p:expr</span><span class="p">,</span> <span class="nv">$dir:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">left!</span><span class="p">(</span><span class="nv">$p</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nd">right!</span><span class="p">(</span><span class="nv">$p</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="连接孩子">连接孩子</h3>

<p><strong>需要注意使用中会出现可能孩子或父母都是 none 的情况</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">conn_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$dir:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nv">$child</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nv">$paren</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paren</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">paren</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">attr!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="nv">$dir</span><span class="p">,</span> <span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>

                <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="nf">.downgrade</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">conn_left</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">conn_child!</span><span class="p">(</span><span class="nv">$paren</span><span class="p">,</span> <span class="nv">$child</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">conn_right</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">conn_child!</span><span class="p">(</span><span class="nv">$paren</span><span class="p">,</span> <span class="nv">$child</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="索引孩子的方向">索引孩子的方向</h3>

<p>根据引用的相等性判断一个节点的孩子是它的左孩子还是右孩子</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">index_of_child</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$paren</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">$child</span><span class="p">;</span>

            <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">Left</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">paren</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">Right</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">unreachable!</span><span class="p">()</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="断开连接">断开连接</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">disconn</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$paren:expr</span><span class="p">,</span> <span class="nv">$child</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nv">$child</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nv">$paren</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">paren</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">dir</span> <span class="o">=</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">dir</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">left!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">right!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="nd">paren!</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="替换节点">替换节点</h3>

<p>这个操作可以称为：<code class="language-plaintext highlighter-rouge">subtree_shift</code> 或者 <code class="language-plaintext highlighter-rouge">transplant</code> ，就是把一个节点 <code class="language-plaintext highlighter-rouge">u</code> 从它的父节点那里替换为另一个节点 <code class="language-plaintext highlighter-rouge">v</code> 。</p>

<p>这需要检查节点 <code class="language-plaintext highlighter-rouge">u</code> ，如果是根节点，直接替换根节点，这时注意</p>

<ol>
  <li>替换的节点 <code class="language-plaintext highlighter-rouge">v</code> 的父节点仍然需要设置（设置为 <code class="language-plaintext highlighter-rouge">none</code>），因为有时要检查父节点是否为 <code class="language-plaintext highlighter-rouge">none</code> 来判断是否为根节点；</li>
  <li>当 <code class="language-plaintext highlighter-rouge">u</code> 为根节点时设置 <code class="language-plaintext highlighter-rouge">v</code> 的父节点时仍然需要检查 <code class="language-plaintext highlighter-rouge">v</code> 是否为 <code class="language-plaintext highlighter-rouge">none</code></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">subtree_shift</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree:expr</span><span class="p">,</span> <span class="nv">$u:expr</span><span class="p">,</span> <span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nv">$u</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nv">$v</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">if</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">v</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">paren!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="n">tree</span><span class="py">.root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">paren</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

                <span class="k">match</span> <span class="nd">index_of_child!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nb">Left</span> <span class="k">=&gt;</span> <span class="nd">conn_left!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                    <span class="nb">Right</span> <span class="k">=&gt;</span> <span class="nd">conn_right!</span><span class="p">(</span><span class="n">paren</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">}</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小-vs-最大">最小 vs 最大</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Leftmost</span>
<span class="nd">macro_rules!</span> <span class="n">bst_minimum</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">while</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Right most</span>
<span class="nd">macro_rules!</span> <span class="n">bst_maximum</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">while</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最小/最大 一个是用于前驱/后继的查询，还可以用在从一个有序的数据集里快速构建搜索二叉树的时候（这时候每次插入节点时可以跳过逐层比较，直接找到最大值，插入它的右节点）</p>

<h3 id="前驱-vs-后继">前驱 vs 后继</h3>

<p>**Predecessor: **</p>

<p>该节点有左孩子，那么显然是左孩子（做为根的树）的最大值就是直接前驱；</p>

<p>否则，向上查询，如果节点恰好是是父节点的右孩子，那么父节点就是直接前驱，否则一路到根为止，向上 Left-most ，直到一个是右孩子关系是父节点，这样要么找到一个节点，要么返回一个 <code class="language-plaintext highlighter-rouge">none</code> 节点</p>

<p><strong>Successor:</strong></p>

<p>该节点有右孩子，那么显然是右孩子（做为根的树）的最小值就是直接后继；</p>

<p>否则，向上 Right-most 直到一个左孩子关系的节点或者返回一个 <code class="language-plaintext highlighter-rouge">none</code> 节点</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return predecessor-node or none-node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_predecessor</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="cm">/* child: left, right-most */</span>
        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">bst_maximum!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="cm">/* paren: left-most-up, right */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="k">while</span> <span class="n">y</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">left!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">y</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="cd">/// Return successor-node or none-node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_successor</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="cm">/* child: right, left-most */</span>
        <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">bst_minimum!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="cm">/* paren: right-most-up, left */</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>

            <span class="k">while</span> <span class="n">y</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">y</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="基础操作">基础操作</h2>

<h3 id="递归-vs-展开">递归 vs 展开</h3>

<p>关于二叉搜索树的基础操作实现有递归的版本和展开的版本，传统上认为，递归的版本由于存在函数栈展开时的开销（保存/恢复 上下文），在时间效率上总是不如展开的版本，但实际上由于现代编译器的优化，情况可能相反。</p>

<p>比如在 C++ OJ 测试的时候，（插入新节点时）递归版本实际更快一点 。</p>

<p>由于递归的实现总是很简单，这里重点列出展开版本的代码</p>

<h3 id="搜索">搜索</h3>

<p>显然就是简单的二叉搜索，直到找到匹配的 <code class="language-plaintext highlighter-rouge">key</code> 或者节点耗尽</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">bst_search</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$k</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nv">$k</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.borrow</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">x</span>
    	<span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="插入">插入</h3>

<ol>
  <li>先查询节点，直达找到同 <code class="language-plaintext highlighter-rouge">key</code> 的节点或者等下一层节点耗尽；</li>
  <li>同 <code class="language-plaintext highlighter-rouge">key</code> 节点更新，不同 <code class="language-plaintext highlighter-rouge">key</code> 按照大小关系插入，需要特别考虑根节点为空的情况</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return Option&lt;V&gt;</span>
<span class="nd">macro_rules!</span> <span class="n">bst_insert</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$z</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
	<span class="p">{</span>
        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$tree</span><span class="py">.root</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">;</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">y</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nv">$tree</span><span class="py">.root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="nd">key!</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">y</span><span class="nf">.replace_val</span><span class="p">(</span><span class="n">z</span><span class="p">)),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除">删除</h3>

<p>相对复杂的一个操作，最后返回（可选地）需要执行重平衡操作的起始节点。</p>

<p>如果节点的左孩子或右孩子为空，直接用不为空的那一个孩子代替被删除的节点（这时重平衡的点就是被删节点的父节点）；</p>

<p>如果节点的孩子都不为空，就找它的直接后继，这又要分两种情况：</p>

<ol>
  <li>如果被删节点的右孩子没有左孩子，也就是右孩子本身就是直接后继，这样直接做右孩子对被删节点的 <code class="language-plaintext highlighter-rouge">subtree-shift</code> ，然后右孩子的左枝连接到被删节点的左孩子（重平衡点为右孩子）；</li>
  <li>如果有右孩子有左孩子，那么直接后驱就是右孩子的 Left-most 假设为 <code class="language-plaintext highlighter-rouge">y</code>，这样相比第一种情况，首先还要额外处理 <code class="language-plaintext highlighter-rouge">y</code> 节点的右孩子的（Left-most 没有左孩子），<code class="language-plaintext highlighter-rouge">subtree-shift(y, y.right)</code>，而让 <code class="language-plaintext highlighter-rouge">y</code> 的右枝连接被删节点的右孩子（重平衡点为 <code class="language-plaintext highlighter-rouge">y</code> 节点）</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return retracing node</span>
<span class="nd">macro_rules!</span> <span class="n">bst_delete</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$z</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">if</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* case-1       case-2

                 z            z
                  \            \
                   y            z.right
                               /
                              / (left-most)
                             y
                              \
                              y.right
            */</span>

            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nd">bst_successor!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
                <span class="nd">conn_right!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="惰性插查删">惰性插/查/删</h3>

<p>对于一些没有严格平衡因素约束的二叉搜索树，可以采用另一种删除的方式，就是删除时只标记节点，当被标记的节点到达阈值时，重构整棵树，典型的比如 <code class="language-plaintext highlighter-rouge">替罪羊树</code>（<code class="language-plaintext highlighter-rouge">Scapegoat Tree</code>）。</p>

<p>这样的话，当插入同 <code class="language-plaintext highlighter-rouge">key</code> 的新节点时可以恢复旧的被删节点，而查询时要排除被标记的节点。</p>

<h3 id="扁平化">扁平化</h3>

<p>中序遍历树的某个子树，得到一个顺序化表示的子树的节点列表</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// In-order Traversals</span>
<span class="nd">macro_rules!</span> <span class="n">bst_flatten</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$z</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>  <span class="c1">// paths</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">x</span><span class="nf">.is_some</span><span class="p">());</span>

        <span class="nv">'outter</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span>
            <span class="k">while</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">while</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                    <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="nv">'outter</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">x</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">());</span>
            <span class="n">x</span><span class="nf">.flatten_cleanup</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">nodes</span>
    <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="建构树">建构树</h3>

<p>按照二分的思路，从一个有序列表上建构一棵平衡的二叉搜索树。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">bst_build</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$nodes</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">bst_build_</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">nodes</span><span class="nf">.len</span><span class="p">();</span>

            <span class="k">if</span> <span class="n">lo</span> <span class="o">==</span> <span class="n">hi</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">+</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="nf">bst_build_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">lo</span><span class="o">..</span><span class="n">mid</span><span class="p">]);</span>
            <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="nf">bst_build_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="n">hi</span><span class="p">]);</span>

            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

            <span class="n">p</span><span class="nf">.build_cleanup</span><span class="p">();</span>

            <span class="n">p</span>
        <span class="p">}</span>

        <span class="nf">bst_build_</span><span class="p">(</span><span class="nv">$nodes</span><span class="p">)</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="自平衡基础">自平衡基础</h2>

<p>二叉搜索树自平衡的基础是树的旋转（rotation），从模式上，又可以分为单旋和双次单旋 ，从方向上又可以分为左和右。</p>

<h3 id="单旋">单旋</h3>

<p>旋转的作用在于在保持 <code class="language-plaintext highlighter-rouge">key</code> 的大小关系的情况下调整某左右树的树高差距。如果右树过高，就向左旋转；如果左树过高，就向右旋转。</p>

<p>旋转完成后，根据不同种类的自平衡二叉树的需要，执行定制的用于收尾更新的 <code class="language-plaintext highlighter-rouge">rotate_cleanup</code> 操作，传入参数是旧的根 <code class="language-plaintext highlighter-rouge">x</code> 和旋转后新的根 <code class="language-plaintext highlighter-rouge">z</code> 。</p>

<p>以左旋为例子，根节点 <code class="language-plaintext highlighter-rouge">x</code> 变为左孩子，而让 <code class="language-plaintext highlighter-rouge">x</code> 的右孩子 <code class="language-plaintext highlighter-rouge">z</code> 变为根节点；源 <code class="language-plaintext highlighter-rouge">z</code> 的左孩子变为 <code class="language-plaintext highlighter-rouge">x</code> 的右节点；</p>

<p>右旋则是一个镜像相反的过程</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Simple Rotation (return new root)</span>
<span class="cd">/// ```no_run</span>
<span class="cd">///             left rotate</span>
<span class="cd">///    x        =========&gt;          z</span>
<span class="cd">///  /  \                          / \</span>
<span class="cd">/// t1   z                        x   t4</span>
<span class="cd">/// |   / \                      / \   |</span>
<span class="cd">///   t23 t4                    t1 t23 |</span>
<span class="cd">///     |  |                     |   |</span>
<span class="cd">///        |</span>
<span class="cd">///            right rotate</span>
<span class="cd">///     x      ==========&gt;           z</span>
<span class="cd">///   /  \                         /   \</span>
<span class="cd">///  z    t4                      t1    x</span>
<span class="cd">/// /  \   |                      |    /  \</span>
<span class="cd">///t1 t23                         |  t23  t4</span>
<span class="cd">/// |  |                              |    |</span>
<span class="cd">/// |</span>
<span class="cd">/// ```</span>
<span class="cd">///</span>
<span class="nd">macro_rules!</span> <span class="n">rotate</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$rotation</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rotation</span> <span class="o">=</span> <span class="nv">$rotation</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">z</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">t23</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">rotation</span><span class="nf">.is_left</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">t23</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t23</span><span class="p">);</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">t23</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>

            <span class="nd">conn_left!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t23</span><span class="p">);</span>
            <span class="nd">subtree_shift!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
            <span class="nd">conn_right!</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="n">tree</span><span class="nf">.rotate_cleanup</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="n">z</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从模式上讲，当根节点 <code class="language-plaintext highlighter-rouge">x</code> 比较高的子树 <code class="language-plaintext highlighter-rouge">y</code> 的方向（左或右）与 <code class="language-plaintext highlighter-rouge">y</code> 较高子树的方向一致，只需要做一次单旋。</p>

<p>但如果不是这样呢，也就是两个较高子树的方向相反，就需要两次旋转，先在较高子树上旋转，使得两个较高子树的方向一致，然后再在根节点上旋转。</p>

<h3 id="双旋">双旋</h3>

<p>假设根节点 <code class="language-plaintext highlighter-rouge">x</code> 较高的子树 <code class="language-plaintext highlighter-rouge">z</code> 是 <code class="language-plaintext highlighter-rouge">x</code> 的右子树，而 <code class="language-plaintext highlighter-rouge">z</code> 的较高子树 <code class="language-plaintext highlighter-rouge">y</code> 是 <code class="language-plaintext highlighter-rouge">z</code> 的左子树：</p>

<ol>
  <li>先以 <code class="language-plaintext highlighter-rouge">z</code> 为根，向右旋转，结果是 <code class="language-plaintext highlighter-rouge">y</code> 代替了 <code class="language-plaintext highlighter-rouge">z</code> ，而 <code class="language-plaintext highlighter-rouge">z</code> 成了 <code class="language-plaintext highlighter-rouge">y</code> 的右孩子，于是根为 <code class="language-plaintext highlighter-rouge">x</code> 的树变成了都是右子树较高；</li>
  <li>以 <code class="language-plaintext highlighter-rouge">x</code> 为根，向左旋转，旋转完成</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Double Rotation (return new root)</span>
<span class="cd">/// ```no_run</span>
<span class="cd">///             rotate [right]-left         rotate right-[left]</span>
<span class="cd">///    x        =========&gt;         x        =========&gt;       y</span>
<span class="cd">///  /   \                        /  \                      / \</span>
<span class="cd">/// t1    z                      t1   y                    x   z</span>
<span class="cd">/// |   /  \                     |   / \                  / \ / \</span>
<span class="cd">///    y   t4                      t2   z                t1 t2t3t4</span>
<span class="cd">///   / \   |                       |  / \                |  | | |</span>
<span class="cd">///  t2 t3                            t3 t4</span>
<span class="cd">///   |  |                            |   |</span>
<span class="cd">/// ```</span>
<span class="nd">macro_rules!</span> <span class="n">double_rotate</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tree</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$snd_rotation</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="nv">$tree</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">snd_rotation</span> <span class="o">=</span> <span class="nv">$snd_rotation</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="nf">.rev</span><span class="p">());</span>
        <span class="nd">rotate!</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">snd_rotation</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="简单测试">简单测试</h2>

<p>其中 <code class="language-plaintext highlighter-rouge">balance_validation</code> 是每个特例定制的平衡校验方法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="nd">macro_rules!</span> <span class="n">test_dict</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$dict</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">get_one</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">rand</span><span class="p">::</span><span class="nn">random</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">dict</span> <span class="o">=</span> <span class="nv">$dict</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">batch_num</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">elems</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">keys</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

            <span class="cm">/* Verify Create */</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nf">get_one</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">;</span>

                <span class="k">if</span> <span class="n">keys</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">keys</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
                <span class="n">elems</span><span class="nf">.push</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

                <span class="nd">assert!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">(),</span> <span class="s">"insert res invalid"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">),</span> <span class="s">"insert query failed"</span><span class="p">);</span>

                <span class="c1">// println!("{i}. insert: ");</span>

                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">dict</span><span class="nf">.balance_validation</span><span class="p">();</span>

            <span class="cm">/* Verify Update */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">));</span>

                <span class="k">let</span> <span class="n">newv</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">500</span><span class="p">;</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newv</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
                <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">newv</span><span class="p">);</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newv</span><span class="p">));</span>
            <span class="p">}</span>


            <span class="cm">/* Verify Remove */</span>

            <span class="k">use</span> <span class="nn">rand</span><span class="p">::{</span><span class="nn">prelude</span><span class="p">::</span><span class="n">SliceRandom</span><span class="p">,</span> <span class="n">thread_rng</span><span class="p">};</span>

            <span class="n">elems</span><span class="nf">.shuffle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nf">thread_rng</span><span class="p">());</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">batch_num</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">),</span> <span class="s">"[dict remove] Assure get Some"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s">"[dict remove] Assert remove failed"</span><span class="p">);</span>
                <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">dict</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">),</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"[dict remove] Assure get None"</span><span class="p">);</span>

                <span class="c1">// sample to save time</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">dict</span><span class="nf">.balance_validation</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>

        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="后续">后续</h2>

<p>接下来介绍具体的自平衡二叉搜索树：</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AVL树</code>；</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Red-black树</code>（简称 <code class="language-plaintext highlighter-rouge">RB Tree</code>）：</p>

    <ol>
      <li><code class="language-plaintext highlighter-rouge">原始红黑树</code></li>
      <li><code class="language-plaintext highlighter-rouge">左偏红黑树</code> （<code class="language-plaintext highlighter-rouge">Left-leaning Red-black Tree</code>， <code class="language-plaintext highlighter-rouge">LLRB</code>）</li>
      <li><code class="language-plaintext highlighter-rouge">AA树</code></li>
    </ol>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">替罪羊树</code>（（Lazy）<code class="language-plaintext highlighter-rouge">Scapegoat Tree</code>）；</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">伸缩树</code>（<code class="language-plaintext highlighter-rouge">Splay Tree</code>）；</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">树堆</code> (<code class="language-plaintext highlighter-rouge">Treap</code>)</p>
  </li>
</ol>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。]]></summary></entry><entry><title type="html">编译器前端基础</title><link href="/algs/CompilerFrontEndBasic.html" rel="alternate" type="text/html" title="编译器前端基础" /><published>2022-12-23T00:00:00+08:00</published><updated>2022-12-23T00:00:00+08:00</updated><id>/algs/CompilerFrontEndBasic</id><content type="html" xml:base="/algs/CompilerFrontEndBasic.html"><![CDATA[<h2 id="关于龙书">关于龙书</h2>

<p>本篇介绍的基本概念来自于经典的龙书（<em>Compilers Principles, Techniques and Tools</em>））。而整个龙书，不幸地是，很多技术概念完全是以 类C 语言为前提做的介绍，从名字上，从章节目录上感到应该有帮助，实际没用。</p>

<p>另外对于 LR，LL 这些，似乎专注于做一个通用编译器的生成器，而不是编译器，而现在既然已有大量的通用生成器，但21世纪以来编程语言的发展趋势，是手写编译器，这背后一个重要原因机器性能的发展带来的质的变化：编译器性能得到了释放，手写可以得到更定制化地，更丰富特性地满足语言要求目标的复杂编译器。</p>

<p>在完成对于这些概念学习后，我得到的最大收获是这些东西确实没什么用。这里就不得不提一下计算机科学领域和某些领域一样，很喜欢把一些平常的概念，易见的规律冠以专有名词，搞得明明一眼明了的简单事情变得特别抽象，下面就有一个鲜活的例子。</p>

<p>因此我们对于这些概念的介绍也将专注于背后的算法思想，而不是照本宣科。</p>

<h2 id="再探-first-set--follow-set">再探 First Set &amp;&amp; Follow Set</h2>

<p>显然，但有必要强调，不管是 First Set 还是 Follow Set 针对得都是 <strong>非终结符（non-terminal）</strong></p>

<p>在提这两个概念的时候，我们假设语法规则以巴科斯范式（Backus Normal Form）的形式给出</p>

<h3 id="first-set">First Set</h3>

<p>是指，对于一个非终结符号，它的每条产生式（production）的首个（first）终结符（terminal）的集合 （包括特殊的 ε 符号）</p>

<h3 id="follow-set">Follow Set</h3>

<p>是指，对于一个非终结符号，在所有产生式构成的语法上，紧跟在该非终结符后面的终结符（包括特殊的 $ 符号表示语法的终结）</p>

<h2 id="shift-reduce">Shift-reduce</h2>

<p>LR（Leftmost rightmost-derivation）parsing 的核心操作是 shift-reduce ，它是一个有栈结构的优先状态机，要么暂时处理不了推入栈中，要么弹出栈中元素向上合并。</p>

<p>在手写编译器过程中，LR完全是用不上的，但可以在一点上发挥重要作用，就是按照操作符的优先级处理中缀表达式：就是把用二元中缀操作符处理成树型结构。</p>

<p>可以用后缀表达式也就是逆波兰式（Reverse Polish Notation，RPN）也就是后根序（Post-order，LRN（left right node））遍历的形式方便地表示这棵树。</p>

<p>如下是代码片段，完整见<sup id="fnref:m6parser-kit" role="doc-noteref"><a href="#fn:m6parser-kit" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Return Reverse Polish Notation (RPN) form (or Post-order, LRN(left right node) traversal)</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">parse_infix_expr</span><span class="o">&lt;</span><span class="n">O</span><span class="p">:</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bops</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">O</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">pris</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">InfixExpr</span><span class="o">&lt;</span><span class="n">O</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">bops</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pris</span><span class="nf">.len</span><span class="p">());</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">bops</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Resort the Infix expression by precedence (they don't change left most expr srcloc)</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">out_bop_stack</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">bops</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">out_pri_stack</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">pris</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">staging_bop_stack</span><span class="p">:</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">O</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">stack!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">expr_stack</span> <span class="o">=</span> <span class="nd">stack!</span><span class="p">[</span><span class="nn">InfixExpr</span><span class="p">::</span><span class="nf">E</span><span class="p">(</span><span class="n">out_pri_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())];</span>

    <span class="c1">// out_bop_stack would be same with out_pri_stack in size.</span>
    <span class="k">while</span> <span class="o">!</span><span class="p">(</span><span class="n">out_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">staging_bop_stack</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// Reduce</span>
        <span class="k">if</span> <span class="n">out_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span>
            <span class="p">||</span> <span class="o">!</span><span class="n">staging_bop_stack</span><span class="nf">.is_empty</span><span class="p">()</span>
                <span class="o">&amp;&amp;</span> <span class="n">staging_bop_stack</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.precedence</span><span class="p">()</span>
                    <span class="c1">// &gt;= for left associative operator</span>
                    <span class="o">&gt;=</span> <span class="n">out_bop_stack</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.precedence</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">bop</span> <span class="o">=</span> <span class="n">staging_bop_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">rhexpr</span> <span class="o">=</span> <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">lfexpr</span> <span class="o">=</span> <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="n">expr_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">lfexpr</span><span class="nf">.combine</span><span class="p">(</span><span class="n">bop</span><span class="p">,</span> <span class="n">rhexpr</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="c1">// Shift</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">staging_bop_stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">out_bop_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="n">expr_stack</span><span class="nf">.push</span><span class="p">(</span><span class="nn">InfixExpr</span><span class="p">::</span><span class="nf">E</span><span class="p">(</span><span class="n">out_pri_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">expr_stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="ll">LL</h2>

<p>LL （Leftmost leftmost derivation）parsing 是一个从上到下的解析过程。</p>

<p>最常见的问题是左递归，就是某个非终结符的某个产生式的第一项是一个非终结符，这个非终结符直接或间接地会导会这个非终结符本身。</p>

<p>但这些都是形式推导方面的问题，通过重构生成式，使得终结符出现在产生式第一项可以解决这个问题。</p>

<h3 id="ll1">LL(1)</h3>

<p>参考<sup id="fnref:rust-ll1engine" role="doc-noteref"><a href="#fn:rust-ll1engine" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="lln">LL(n)</h3>

<p>基于状态机而不是形式符号推导</p>

<p>在手写编译器过程中，几乎不会考虑到形式推导里面的什么左递归什么二元歧义。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:m6parser-kit" role="doc-endnote">
      <p>https://github.com/minghu6/m6parserkit <a href="#fnref:m6parser-kit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rust-ll1engine" role="doc-endnote">
      <p>https://github.com/minghu6/rust-ll1engine <a href="#fnref:rust-ll1engine" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[关于龙书]]></summary></entry></feed>