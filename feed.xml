<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-11T11:24:29+08:00</updated><id>/feed.xml</id><title type="html">MINGHU6’s Blog</title><subtitle>Coding somethings</subtitle><entry><title type="html">LeetCode Best Time to Buy and Sell Stock</title><link href="/oth/LeetCodeBuySellStock.html" rel="alternate" type="text/html" title="LeetCode Best Time to Buy and Sell Stock" /><published>2023-10-01T00:00:00+08:00</published><updated>2023-10-01T00:00:00+08:00</updated><id>/oth/LeetCodeBuySellStock</id><content type="html" xml:base="/oth/LeetCodeBuySellStock.html"><![CDATA[<h2 id="0121-best-time-to-buy-and-sell-stock"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">0121. Best Time to Buy and Sell Stock</a></h2>

<p><em>Easy</em></p>

<p>单次交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0122-best-time-to-buy-and-sell-stock-ii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">0122. Best Time to Buy and Sell Stock II</a></h2>

<p><em>Medium</em></p>

<p>不限次数交易</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="0123-best-time-to-buy-and-sell-stock-iii"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">0123. Best Time to Buy and Sell Stock III</a></h2>

<p><em>Hard</em></p>

<p>限制两次交易</p>

<h3 id="破题">破题</h3>

<p>题目的复杂程度终于提升到了有点儿意思的程度，这里的关键是搞清楚“最多两次”交易的限制条件到底对我们的模型意味着什么？</p>

<p>可以认为，做两次交易的收益总是不差于一次交易，只要在计算模型上把一次交易视为两次交易的边缘值。</p>

<h3 id="解两遍扫描">解①两遍扫描</h3>

<p>把价格表分为两部分，左边用于第一次交易，右边用于第二次交易，这样只需要检查每个位置的两次交易之和，求一个最大值即可。可以让左边分割的串从空串开始，这样就包含了一次交易的情况。</p>

<p>每次分割的左边串的最大收益可以依靠前面 <a href="#0121-best-time-to-buy-and-sell-stock">0121. Best Time to Buy and Sell Stock</a> 来计算，而分割的右边串则可以预先运用同样的算法反向扫描，保存个位置的计算结果，在从左开始扫描的时候查询表即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>


    <span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lo</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>运行时间：760 ms (beats 98.06%)，内存占用：30.5 MB (beats 72.56%, ~100%)</p>

<h3 id="解规范解">解②规范解</h3>

<p>在上一个解的时候，我们通过组合单次求解的方法来计算两次交易得到的最大收益，而这个单次求解的方法好像扫描一个个位置就可以进行该位置的更新，（因为当天交易收益总是零，因此是否允许当天交易都不重要），这暗示我们很可能有一个扫描每个位置就可以计算出两次交易的最大收益的模型。</p>

<p>这才引出对股票买卖问题的统一模型：</p>

<p>累积计算每次买或卖的收益，买的收益是 $-\text{price}$ ，卖的收益是买的收益加上 $\text{price}$ ，下次交易的收益基础是之前的收益。</p>

<p>对于两次买卖就有：</p>

\[\begin{align}
\text{buy}_1 &amp;= \max(\text{buy}_1',\text{-price})\\
\text{sell}_1 &amp;= \max(\text{buy}_1',\text{price})\\
\text{buy}_2 &amp;= \max(\text{sell}_1',\text{-price})\\
\text{sell}_2 &amp;= \max(\text{buy}_2',\text{price})\\
\end{align}\]

<p>也就是：$\text{buy}_1 \rightarrow \text{sell}_1 \rightarrow \text{buy}_2 \rightarrow \text{sell}_2$</p>

<p>有必要解释下，按照自然流程，两次交易至少应该是第一天 $\text{buy}_1$ ，第二天 $\text{sell}_1$ ，第三天 $\text{buy}_2$，第四天 $\text{sell}_2$，是一个 $4$ 天的窗口，但是这需要额外检查下数据长度，而把这些操作压缩到一天，并不影响结果，而且可以适应长度不足 $4$ 的情况。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell1</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy1
</span>    <span class="n">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell2</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prices[0]+buy2
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">buy1</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell1</span> <span class="o">&lt;</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell1</span> <span class="o">=</span> <span class="n">buy1</span><span class="o">+</span><span class="n">price</span>
        <span class="k">if</span> <span class="n">buy2</span> <span class="o">&lt;</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
            <span class="n">buy2</span> <span class="o">=</span> <span class="n">sell1</span><span class="o">-</span><span class="n">price</span>
        <span class="k">elif</span> <span class="n">sell2</span> <span class="o">&lt;</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
            <span class="n">sell2</span> <span class="o">=</span> <span class="n">buy2</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell2</span>
</code></pre></div></div>

<p>运行时间：670 ms (beats 99.76%)，内存占用：30.5 MB (beats 88.72%, ~100%) 。</p>

<p>这个统一模型在一遍扫描就解决了问题，并且省掉了前面的 $O(n)$ 的内存占用<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> 。</p>

<h2 id="0188-best-time-to-buy-and-sell-stock-iv"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">0188. Best Time to Buy and Sell Stock IV</a></h2>

<p><em>Hard</em></p>

<p>上面问题的一般化，不是限制两次交易，而是给定的参数 $k$ 次。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># buy[i] - sell[i+1]
</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span><span class="p">:</span>
                <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">price</span>
            <span class="k">elif</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span><span class="p">:</span>
                <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">price</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：59 ms (Beats 99.16%, ~100%)，内存占用：16.36MB (Beats 82.07%，~100%)。</p>

<h2 id="0309-best-time-to-buy-and-sell-stock-with-cooldown"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">0309. Best Time to Buy and Sell Stock with Cooldown</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有冷冻期</p>

<h3 id="破题-1">破题</h3>

<p>购买冷冻期机制的引入改变了整个的模型，使得我们不能像前面的那个无限次数交易那样简单统计所有增量，就可以得到答案。</p>

<p>如果遵循股票买卖整个系列的顺序来做题，题解可能格外困难，因为很容易受到前面解题思路的影响，而重构整个模型并没有那么直观，因此我认为应该把这道题标记为 Hard 难度。</p>

<p>因此，让我们先从最简单地、最基本地方法开始：一个基于递归，使用记忆化优化的，穷举所有可能的解决方法。</p>

<h3 id="解递归记忆化">解①递归记忆化</h3>

<p>逐个读取价格表，分两个模式：等待购入和等待卖出。下面分别用 $\text{Buy}$ 和 $\text{Sell}$ 表示这两个模式，在 $\text{Buy}$ 模式下有两种选择：在当前价格日卖出和下一天再说，同样地 $\text{Sell}$ 模式也有两种选择，以当前价格卖出和下一天再说。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">Buy</span> <span class="o">=</span> <span class="n">auto</span><span class="p">(),</span>
    <span class="n">Sell</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">recur</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cand1</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cand2</span> <span class="o">=</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Sell</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cand1</span><span class="p">,</span> <span class="n">cand2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recur</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="n">Buy</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：52 ms (beats 44.28%, ~100%)，内存占用：21.06 MB (beats 31.05%)。</p>

<h3 id="解迭代dp">解②迭代DP</h3>

<p>上面的递归实现，可以帮助我们理清普通 DP 版本的实现思路。</p>

<p>对于交易有限次数的股票模型，可以穷举所有所有轮次买和卖的状态，但是对于不限次数的模型，则不能这样穷举，只能区分买和卖，不能辨别轮次。</p>

<p>尝试从正面看这个问题，分别用 <code class="language-plaintext highlighter-rouge">buy</code> 和 <code class="language-plaintext highlighter-rouge">sell</code> 两个数组代表一个前缀价格串上的最后操作是买或卖带来的最大收益。</p>

<p>这样，</p>

<ol>
  <li>
    <p>买的最大收益是要比较前一天买的最大收益（意味着当前没有买卖）以及包含冷冻期在内的卖的最大收益加上当前价格；</p>
  </li>
  <li>
    <p>卖的最大收益则是前一天卖的最大收益（意味着当前没有买卖）或者前一天买的最大收益加上当前价格（当前卖出）</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">sell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sell</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：36 ms (beats 98.07%, ~100%)，内存占用：16.39 MB (beats 99.34%) 。</p>

<p>当然，仔细观察代码，会发现 $O(n)$ 的内存占用是不必要的，实际上只需要维护三个持久变量：$\text{buy}_0$, $\text{buy}_1$ 和 $\text{sell}_0$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">prices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">buy0</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy0</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sell0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">buy2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy1</span><span class="p">,</span> <span class="n">sell0</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell0</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">sell0</span> <span class="o">=</span> <span class="n">sell1</span>
        <span class="n">buy1</span><span class="p">,</span> <span class="n">buy0</span> <span class="o">=</span> <span class="n">buy2</span><span class="p">,</span> <span class="n">buy1</span>

    <span class="k">return</span> <span class="n">sell0</span>
</code></pre></div></div>

<p>运行时间：45 ms (beats 79.16%, ~100%)，内存占用：16.56 MB (beats 87.33%. ~100%) 。</p>

<h2 id="0714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">0714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2>

<p><em>Medium</em></p>

<p>不限次交易，有交易费</p>

<h3 id="解状态dp">解①状态DP</h3>

<p>直接按照前面交易冻结日的股票交易模型，易得</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fee</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>
    <span class="n">buy</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sell</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">buy1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buy</span><span class="p">,</span> <span class="n">sell</span><span class="o">-</span><span class="n">price</span><span class="p">)</span>
        <span class="n">sell1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sell</span><span class="p">,</span> <span class="n">buy</span><span class="o">+</span><span class="n">price</span><span class="o">-</span><span class="n">fee</span><span class="p">)</span>

        <span class="n">buy</span> <span class="o">=</span> <span class="n">buy1</span>
        <span class="n">sell</span> <span class="o">=</span> <span class="n">sell1</span>

    <span class="k">return</span> <span class="n">sell</span>
</code></pre></div></div>

<p>运行时间：566 ms (beats 77%, ~100%)，内存占用：23.7 MB (beats 67.29%, ~100%) 。</p>

<h3 id="解贪心">解②贪心</h3>

<p>但是还是有方法利用  <a href="#0122-best-time-to-buy-and-sell-stock-ii">0122. Best Time to Buy and Sell Stock</a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>虽然形式上压缩到了一天，但是我们的计算公式也暗示，实际上不可能同时更新，实质上全部更新还是至少需要四天，对于一次交易也至少需要两天 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>虽然在测试上也看不这个内存节省的区别来，但毕竟是 Python 嘛，内存模型并不节省 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[0121. Best Time to Buy and Sell Stock]]></summary></entry><entry><title type="html">0115 - Distinct Subsequences</title><link href="/oth/LeetCode0115.html" rel="alternate" type="text/html" title="0115 - Distinct Subsequences" /><published>2023-09-30T00:00:00+08:00</published><updated>2023-09-30T00:00:00+08:00</updated><id>/oth/LeetCode0115</id><content type="html" xml:base="/oth/LeetCode0115.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/distinct-subsequences/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.18/0115_distinct_subseq/py0115">源代码</a></p>

<p>判断一个串的所有（非连续）子序列里，等于目标串的数量。</p>

<p>这里要特别关注<strong>解3：子序列的窗口范式</strong></p>

<h2 id="解正解">解①正解：</h2>

<p>这个是最直接的推导思路，考虑 $s$ 的前缀从 $s[..0]$ 逐个增加字符直到 $s[..n]$ ，观察对样本串 $t$ 它的前缀随之的变化。</p>

<p>假设增加了一个字符 $x$ ，那么对于样本串 $t$ ，所有出现 $x$ 的位置的前缀都会因此受到影响。</p>

<p>假设 $x$ 出现在 $t$ 的所有位置是 P，则有 $\text{dp}[P] := \text{dp}[P] + \text{dp}[P-1]$，也就是 $x$ 前面的前缀会因为 $x$ 的加入，而使得包含 $x$ 的前缀数量增加。特别地，当 $t$ 的前缀是空串的时候，设定值总是为 $1$ ，这样可以方便统一地计算。</p>

<p>那么该如何计算出 $x$ 出现在 $t$ 的所有位置呢，正好字符集很小（大小写字母），直接用列表保存最节省内存，可以在对 $t$ 的一遍扫描过程中把坐标加进对应字符的坐标列表里。</p>

<p>于是得到了下面的实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>
        <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">pre_v</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pre_i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">key</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">26</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">c_i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">pre_i</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre_v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">pre_v</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">pre_i</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>有几点需要特别说明的：</p>

<h4 id="1-快速失败地优化">1. 快速失败地优化</h4>

<p>譬如</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<p>这样的代码，几乎总是可以明显提高我们的运行表现，为一些应该很优，但由于 Python 匮乏地运行时优化而表现一般地实现挽尊：—— 。</p>

<h4 id="2-dp-数组的特异处">2. DP 数组的特异处</h4>

<p>从代码上乍看起来，这里的 $\text{dp}$ 数组和之前那些一般的 $\text{dp}$ 数组是一样的，我们只是照样把二维压缩到一维。</p>

<p>但这里特别地是，从计算过程上看，每一行并不是所有的数据都会被更新，没有被计算的数据应该继承自上一行，而不是被置为一个固定的初始值。</p>

<p>这样使用二维不仅浪费空间，而且并不方便，使用一维的空间，总是更好的选择。</p>

<h4 id="3-一维地实现">3. 一维地实现</h4>

<p>同样地，在使用压缩地 $\text{dp}$ 数组时，为了避免数据被覆盖，需要提前保存上一行的前一个位置的数据，但是我们预计算的位置并不一定是连续的，因此需要进行判断。对于不连续的位置，就不会存在数据覆盖的问题。</p>

<p>运行时间 94 ms (beats 92.81%)，内存占用：16.46 MB (beats 96.82%, ~100%) 。</p>

<h2 id="解递归迭代">解②递归+迭代：</h2>

<p>实际上如果我们理解了解①，那么可以把它转换成我们更熟悉地 $\text{dp}$ 实现。</p>

<p>只要考虑：</p>

<ol>
  <li>要么当 $s$ 的前缀拓展一个字符时，$t$ 也拓展一个字符，这只当 s 和 t 拓展的字符相等时才可以；</li>
  <li>要么无条件地跳过当前字符，也就是 $s$ 拓展字符，但是 $t$ 不拓展</li>
</ol>

<p>这样当：</p>

<ol>
  <li>$s$ 的长度小于 $t$ 时，当然返回 $0$；</li>
  <li>而当 $s$ 长度等于 $t$ 时，进行比较，返回 $1$ 或者 $0$；</li>
  <li>当 $m$ 长度为 $0$ 时，也就是递归的一般返回点，或者说初试情况，返回 $1$</li>
</ol>

<p>递归地版本最简洁，表现也最好：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">t</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">acc</span> <span class="o">+=</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<p>运行时间：70 ms (beats 93.39%)，内存占用：34.2 MB (beats 72.33%) 。</p>

<p>迭代的版本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span>

            <span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>运行时间：95 ms (beats 92.78%)，内存占用：16.5 MB (beats 96.74%) 。</p>

<h2 id="解另一个范式">解③另一个范式：</h2>

<p>这里要介绍得是规模递增的另一个范式，很少提到，但是由于有更好地迭代次数，是最快的实现。</p>

<p>对于上面的一般思路来说，是增加 $s$ 的前缀的字符，把问题规模一步步拓展到全局，而对于子序列地匹配，还可以这样考虑：</p>

<p>每一个文本串 $s$ 上面可以匹配目标串 $t$ 的子序列都可以看做，由某些在 $s$ 上的 $t$ 长度模式的对应位置字符构成。</p>

<p>这些构成 $t$ 的子序列的字符可以是连续的，也就是在同一个模式上，也可以不连续，那就是在不同的模式上。</p>

<p>这看起来就像是一个固定窗口在 $s$ 上滑动，探寻窗口对应位置的字符与 $t$ 上对应字符是否相等。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="tips">Tips：</h3>

<ol>
  <li>由于在外循环固定减少了 $m$ 长度的轮次，因此是相比上述更快的一个实现；</li>
  <li>同时快速失败地优化也被省略掉了，因为已经不能提升它的表现了</li>
</ol>

<p>运行时间：44 ms (beats 99.44%, ~100%)，内存占用：16.29 MB (beats 99.85%, ~100%) 。</p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">0087 - Scramble String</title><link href="/oth/LeetCode0087.html" rel="alternate" type="text/html" title="0087 - Scramble String" /><published>2023-09-19T00:00:00+08:00</published><updated>2023-09-19T00:00:00+08:00</updated><id>/oth/LeetCode0087</id><content type="html" xml:base="/oth/LeetCode0087.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/scramble-string/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.17/0087_scramble_str/py0087">源代码</a></p>

<p>因为这道题是 3k点赞，1k点踩， 于是看了下评论，结果为我的解题带来了非常大的负面影响：有一个评论里讲什么这道题的题解非常困难，但是用4套嵌套循环实现非常简单，这一直影响我的思路。</p>

<p>然而实际上这只是一道普通的 Top-down DP，或者说，记忆化搜索就可以通过的题目。</p>

<p>另外让人不爽地是这个文本：“<strong>Randomly</strong> decide to swap the two substrings……” ，随机地决定这种说法就很误导，让人搞不清问题到底是个什么类型的问题。</p>

<p>实际上这个问题很简单，把串按位置划分，从 $1\dots n-1 $，确保得到的两个子串的长度至少为 $1$；</p>

<p>而这两个子串有两种可能：保持原序或者颠倒顺序；</p>

<p>然后试着对子串继续应用这个划分，直到子串的长度为 $1$ 。</p>

<p>最终目的是检查 $s_1$ 能否变换到 $s_2$ 。</p>

<h2 id="解">解①：</h2>

<p>这个问题天然地适合利用递归解决，只不过可以通过保存一些中间结果来进行优化。</p>

<p>具体说就是遍历每一个划分子串的位置，然后对划分后的两种情况：原序和反序，分别进行判断。</p>

<p>对于原序，就是检查较小规模地同一问题 $s_1[0..i-1]$ 能够变换到 $s_2[0..i-1]$ ；以及 $s_1[i..n-1]$ 能够变换到 $s_2[i..n-1]$ ；</p>

<p>对于反序，就是检查$s_1[0..i-1]$ 能够变换到 $s_2[n-i..n-1]$；以及 $s_1[i..n-1]$ 能够变换到 $s_2[0..n-i-1]$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="p">:])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[:</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
            <span class="ow">or</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">s2</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>特别地，这里检查了字符集合是否相等，作为一个快速失败地（预测）优化<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<p>运行时间：58 ms (beats 78.15%, ~100%)，内存占用：17.9 MB (beats 36.12%, ~100%)。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>而用 <code class="language-plaintext highlighter-rouge">sorted</code> 比 <code class="language-plaintext highlighter-rouge">set</code> 明显要快，对于本题的最终结果的影响是差了 20 ms 。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">编辑距离</title><link href="/algs/EditDistance.html" rel="alternate" type="text/html" title="编辑距离" /><published>2023-08-26T00:00:00+08:00</published><updated>2023-08-26T00:00:00+08:00</updated><id>/algs/EditDistance</id><content type="html" xml:base="/algs/EditDistance.html"><![CDATA[<h2 id="基本概念">基本概念</h2>

<p>编辑距离是从一个串变换到另一个串，需要的基础操作的数量，用来衡量两个串的相似度，用在</p>

<ul>
  <li>自然语言处理上，比如拼写检查；</li>
  <li>生物学上，做 DNA 序列对比</li>
  <li>其他</li>
</ul>

<p>这里的基础操作包括：</p>

<ul>
  <li>插入一个字符</li>
  <li>删除一个字符</li>
  <li>替换一个字符（substitution）</li>
  <li>交换两个字符（transposition）</li>
</ul>

<p>编辑距离有：</p>

<h3 id="莱文斯坦距离">莱文斯坦距离</h3>

<p>Lavenshtein Distance，最常见的编辑距离，通常也会冠以“编辑距离”之名。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
  <li>替换</li>
</ul>

<h3 id="达梅劳-莱文斯坦距离">达梅劳-莱文斯坦距离</h3>

<p>Damerau-Lavenshtein Distance，莱文斯坦距离的变种，开始是用于拼写检查，补充了第四种基本的拼写错误，近邻序顺倒颠，但后来也推广用于衡量蛋白质序列间的变异。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
  <li>替换</li>
  <li>（邻近）交换</li>
</ul>

<h3 id="lcs-距离">LCS 距离：</h3>

<p>最长公共子序列距离。</p>

<p>基本操作：</p>

<ul>
  <li>插入</li>
  <li>删除</li>
</ul>

<h3 id="汉明距离">汉明距离</h3>

<p>Hamming Distance，用于网络传输，作为学习网络传输都会了解到的流的校验码 。</p>

<p>基本操作：</p>

<ul>
  <li>替换</li>
</ul>

<p>而且只允许同样长度的字符串。</p>

<h3 id="哈罗距离">哈罗距离</h3>

<p>Jaro Distance，只允许交换两个字符。</p>

<h2 id="dp-实现">DP 实现</h2>

<p>这些编辑距离，特别是类似于莱文斯坦距离这样的编辑距离都有一个常规地运用 DP 概念的实现。</p>

<p>时间复杂度是 $O(nm)$ ，空间复杂度是 $O(\min(n,m))$ 。</p>

<p>具体参考 <a href="/algs/TwoSeqDP.html">两序列DP</a></p>

<h2 id="注解">注解</h2>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[基本概念]]></summary></entry><entry><title type="html">两序列DP</title><link href="/algs/TwoSeqDP.html" rel="alternate" type="text/html" title="两序列DP" /><published>2023-08-26T00:00:00+08:00</published><updated>2023-08-26T00:00:00+08:00</updated><id>/algs/TwoSeqDP</id><content type="html" xml:base="/algs/TwoSeqDP.html"><![CDATA[<h2 id="前言">前言</h2>

<p>两个序列，一个模板序列，一个测试序列，使之“匹配”<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> 。</p>

<p>如果更小规模，这里就是指两个序列的前缀子串，的子问题的解决能适用贪心算法，直接被利用，计算出更大规模的问题。</p>

<h2 id="正则匹配">正则匹配</h2>

<p><a href="/oth/LeetCode0010.html">0010 - Regular Expression Matching</a></p>

<h3 id="简化版">简化版</h3>

<p><a href="/oth/LeetCodePacket1.html">0044 - Wildcard Matching</a></p>

<h2 id="编辑距离">编辑距离</h2>

<p>以莱文斯坦距离为例，对应有 LeetCode 原题： <a href="/oth/LeetCode0072.html">0072 - Edit Distance</a> 。</p>

<h2 id="代码模板">代码模板</h2>

<p>总有一个模板，利用惰性更新节省内存到一个单位的 $O(\min(n,m))$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">m</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre1</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="c1">// init cache[0]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pre0</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="c1">// calc cache[i]</span>

        <span class="n">pre1</span> <span class="o">=</span> <span class="n">pre0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">cache</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这里的“序列”和“串”没什么区别，不过有时候“串”就指字符串，使用“两序列DP ”而不是“两串DP” 主要是读起来更顺口一点儿 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">0053 - Maximum Subarray</title><link href="/algs/LeetCode0053.html" rel="alternate" type="text/html" title="0053 - Maximum Subarray" /><published>2023-08-18T00:00:00+08:00</published><updated>2023-08-18T00:00:00+08:00</updated><id>/algs/LeetCode0053</id><content type="html" xml:base="/algs/LeetCode0053.html"><![CDATA[<h2 id="前言">前言</h2>

<p>这篇的重点在于讲述从启发式算法到对 <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm">Kadane算法</a> 的独立再发现的过程。</p>

<h3 id="难度定位">难度定位</h3>

<p>对于 LeetCode 来说，本题的定位在 Medium 难度，只能说这是一个令人不满意的折中的结果。</p>

<p>首先这实在是一道太经典的题目，有很简单的解决方法，对于那些接触过它的人来说，只需要不到一分钟的时间就能写完，从这个角度上说，可以直接定位在 Easy 。</p>

<p>但对于那些并没有正式接触过的人来说，就题论题，从输入的数据规模来看，这道题的难度是非常高的，对于运行时语言来说，实际上只有 $O(n)$ 的解法能过，而且还必须是不太慢的 $O(n)$ 解法，而其他类似类型题目，通常 $O(n^2)$ 就能过，但从这一点，这就一定是 Hard 难度的题目。</p>

<p>总地来说，我们没有任何理由去假设用户的学习履历，而这道题本身就是一道 Hard 难度的题目，因此它定位就应该在 Hard 。</p>

<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/maximum-subarray/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.14/0053_max_subarr/py0053">源代码</a></p>

<p>求一个数组的最大值子序列。</p>

<p>首先可以想到<a href="/algs/SegmentTree.html">分段树</a>上有一个经典应用，就是计算最大子段和，这个时间复杂度是最优的，但一定不是最快的，在纯运行时语言里，这种复杂数据结构的表现都不会太好，因为本来可以忽略掉的无关操作都对时间有显著地影响。</p>

<p>何况这种方法写起来也不是很简单，因此先把这种方法放到最后，作为比较。</p>

<h2 id="解简单dptle">解⓪简单DP：TLE：</h2>

<p>最简单地记录两头索引的 DP，用前缀和数组 $O(1)$ 地计算区间和，时间复杂度为 $O(n^2)$ ，即使做了很多优化，比如压缩数组，排除负数（需要处理全是负数的情况），也仍然过不了关。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">accumulate</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">pref_sum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pref_sum</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">pref_sum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pref_sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>

<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">nums2</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">nums2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nums2</span>
</code></pre></div></div>

<h2 id="解启发式算法">解①启发式算法：</h2>

<p>这一节是本篇的重点，讲述我个人如何一步步从一个直觉地和局部经验地算法设计出本质上就是 Kadane 算法的过程。</p>

<h3 id="1-观察">1. 观察：</h3>

<p>最大子段和如果都是正数，那么整个数组的和就是最大子段和，这个题目就没有意义了，一定是有负数才让问题具有复杂性，当然如果全都是负数那么问题也很简单，就是最大的那一个单个负数（或者说绝对值最小的那个负数），而更多地应该是正数和负数混合的情况（零总是可以被简单忽略掉）。</p>

<p>这样地话，排除全负数地情况后考虑，如果数组结尾的的数字是非正数，那么它可以直接被忽略掉；但如果结尾是正数，那就要看它后面可能存在的来自负数的减益与来自正数的增益哪一个更大。</p>

<p>为了考虑方便和编写代码，可以就像前面算法一样对数组进行压缩：<code class="language-plaintext highlighter-rouge">compress</code>，合并临近的正值和非正值，这样总是可以得到一个正负相间的数组。</p>

<p>在这个基础上考虑什么时候能够保留结尾的正数呢？就是正数邻接的负数的绝对值小于这个正数，这样正负加起来一定对最大和有增益。反之，如果正负加起来小于等于零，那么显然这一段儿就可以被扔掉，因为没有任何增益。</p>

<h3 id="2-问题">2. 问题：</h3>

<p>那么如果一个正负组之后还有一个正负组该怎么样呢：</p>

<ol>
  <li>如果那个正负组仍然是非负收益，那么仍然可以保留；</li>
  <li>可是如果是负收益，又该如何判断是否该保留呢？</li>
</ol>

<p>试着考虑在数组的另一端也如此处理来压缩问题规模，但是这样仍然会遇到一个正收益的正负组后面的一个负收益的正负组问题。</p>

<h3 id="3-解决方法">3. 解决方法：</h3>

<p>看来不得不正面考虑正收益的正负组后面的出现负收益的正负组的问题，考虑直接合并我们遇到的正负组，就像我们压缩数组一样，如果是正收益就保留，如果是非负收益就抛弃，这样好像问题就解决了！</p>

<h3 id="4-观察">4. 观察：</h3>

<p>这样如果从两边开始一层层剥掉两头的正负组，是不是问题就能在 $O(n)$ 的时间内解决？！我们现在好像已经从对问题局部的优化开始，窥得了最优解的思路。我自己就把这个思路称为“洋葱变换”（Onion Transform）</p>

<p>像这样剥下去，最后应该得到：</p>

<ol>
  <li>一个“去核”洋葱，也就是剥到最后，发现里面什么都没有；</li>
  <li>或者带芯儿洋葱，最后剩下一个孤正数，因为前面都是正负组，而整个压缩后的数组是正负相间的。</li>
</ol>

<p>这样好像只要计算最后剩下的皮加上可能存在的芯的值，就能得到整个数组的最大子序列和。</p>

<h3 id="5-问题">5. 问题：</h3>

<p>但是，两头剥洋葱实际还有第三种情况，就是这根本是个“假洋葱”（Fake Onion），剥到最后发现里面剩一个负数，这应该是不存在的情况，但就是发生了，因为两头的正负组存在重叠，这样我们就不能正确计算了。</p>

<h3 id="6-解决方法">6. 解决方法：</h3>

<p>由于存在负芯儿的“假洋葱”，不能从两头剥，考虑直接从一头剥，这样肯定就不会出现正负组重叠的情况。</p>

<h3 id="7-观察">7. 观察：</h3>

<p>但这样好像就得到了一个未曾设想的局面：一段段儿由负数隔开的正值的最大子序列，也就是说在压缩正负组的过程就可以计算得到最大子序和。</p>

<p>至此为止我们得到了一个可运行的算法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_v</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">max_unit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># get max unit
</span>
    <span class="c1"># Onion Transform
</span>
    <span class="n">max_seq</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">layer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">layer</span>

            <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">max_seq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_seq</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_unit</span><span class="p">,</span> <span class="n">max_seq</span><span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：622 ms (beats 74.97%)，内存占用：30.42 MB (beats 83.1%) 。</p>

<p>（后来发现这个运行时间已经相当好了）</p>

<h3 id="8-思路推广">8. 思路推广：</h3>

<p>这个算法应该有更简洁、更一般化地表示，不需要数组压缩、也不必考虑正负组，只要能带来非负收益，就可以进行压缩。</p>

<h3 id="9-思路推广">9. 思路推广：</h3>

<p>使用一个追踪边的累积变量 <code class="language-plaintext highlighter-rouge">acc</code>，用它来代替对输入的边缘点的修改，同时也不需要直接检测收益是否为负，先计算加和，取它与新的边缘点的最大值。</p>

<p>这样可以得到一个非常简洁地形式：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)))</span>
</code></pre></div></div>

<p>总是使用前一个计算的值作为状态，也就是 <code class="language-plaintext highlighter-rouge">x</code> ，<code class="language-plaintext highlighter-rouge">y</code> 是当前的边缘点</p>

<p>这个版本并不是我写的，因为它使用 <code class="language-plaintext highlighter-rouge">itertools</code> 里面的工具虽然让代码看起来很简单，但根据以往经验，我就知道这个性能表现<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>并不怎么样，实际果然如此：</p>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：592 ms (beats 87.39%)，内存占用：30.56 MB (beats 51.70%) 。</p>

<p>运行时间相比前一个朴素版本不仅提升有限，内存占用甚至还更多了！足可见 <code class="language-plaintext highlighter-rouge">itertools</code> 有非常大的优化空间。</p>

<p>更适合当前版本的应该是：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;</span> <span class="n">acc</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">acc</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：537 ms (beats 99.80%)，内存占用：26.77 MB (beats 99.95%) 。</p>

<p>核心有三点：</p>

<ol>
  <li>普通循环替代 <code class="language-plaintext highlighter-rouge">itertools</code></li>
  <li>普通条件判断替代 <code class="language-plaintext highlighter-rouge">max</code></li>
  <li>预先计算一个变量也有有意义地性能提升</li>
</ol>

<p>实在是有些无语<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="与kadane算法">与Kadane算法：</h3>

<p>到了这一步，这可以发现，这就是 Kadane 算法做的事，我们只是独立地重新发明了它<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup></p>

<h3 id="与其他思路">与其他思路：</h3>

<p>这个最终的解决方法还可以通过 DP 或者说其他地算法思想推导得到，但总是实质一样，我并不考虑这里一定要使用什么思想来解决，就是一步步地想，如果最终要对它总结，我更愿意把它归类为在时间上进行 DP 的算法。</p>

<h2 id="解分段树">解②分段树：</h2>

<p>经典地一个分段树应用的题目，因为求得是整个数组的最大子序列和，因此只需要写建树的代码即可，返回根节点的值即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">min_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="s">""" DFS型 """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_build</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">tr</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="s">""" pref  0 # max prefix sum
        suff  1 # max suffix sum
        sum   2 # all sum
        ans   3 # max range sum
    """</span>

    <span class="k">if</span> <span class="n">tl</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">tl</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span><span class="o">+</span><span class="n">tr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sub_lf</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">mid</span><span class="o">-</span><span class="n">tl</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">i_lf</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">i_rh</span> <span class="o">=</span> <span class="n">i_lf</span><span class="o">+</span><span class="n">sub_lf</span>

    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">i_lf</span><span class="p">)</span>
    <span class="n">_build</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">i_rh</span><span class="p">)</span>

    <span class="n">data_lf</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_lf</span><span class="p">]</span>
    <span class="n">data_rh</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i_rh</span><span class="p">]</span>

    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">data_lf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="nb">max</span><span class="p">(</span><span class="n">data_lf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_rh</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_lf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_rh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：1067 ms (beats 5.02%)，内存占用：53.78 MB (beats 6.15%) 。</p>

<p>同样没有使用 Python 的类，而是元组，来保存每个点的 4 个基本信息，因为类实在是太慢啦！</p>

<h3 id="与其他思想">与其他思想</h3>

<p>如果不从分段树地角度看，也可以直接使用分治地思想做类似地操作，但是也依赖递归，区别是我们把递归需要保存的堆栈信息显式地存储到了起来。</p>

<h2 id="注解">注解</h2>

<p>###</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>至少是当前的 Python 3.10 版本 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>我认为从根本上讲，是原作者的观念保守，为了维持 Python 的纯解释性，从而放弃了很多更进一步地优化，并且也没有引进 JIT 的机制 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>可能区别是原始的 Kadane 算法面对的问题是只返回非负值，如果全都是负数就返回 $0$ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">1340 - Jump Games V</title><link href="/oth/LeetCode1340.html" rel="alternate" type="text/html" title="1340 - Jump Games V" /><published>2023-08-10T00:00:00+08:00</published><updated>2023-08-10T00:00:00+08:00</updated><id>/oth/LeetCode1340</id><content type="html" xml:base="/oth/LeetCode1340.html"><![CDATA[<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/jump-game-v/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.12/1340_jump_games_5/py1340">源代码</a></p>

<p>这个题的描述非常别扭，啰嗦还不得要领，配得示例图也抓不到展示的重点，让人很难进入这个题目，单就这个题目文本的编写我就要给出差评！</p>

<p>简而言之，还是跳一个范围 $d$，双向都可以，但是只能从高跳到低，包括中途经过的位置也要比起点低。</p>

<h3 id="数据限制">数据限制：</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= arr.length &lt;= 1000</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= arr[i] &lt;= 105</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= d &lt;= arr.length</code></li>
</ul>

<h2 id="解原始解">解①原始解：</h2>

<p>开始观察数据的特点，发现 $d$  的大小是整个给定数组 $\text{arr}$ 同级别的，而 $\text{arr}$ 的规模非常小，只有 $10^3$ ，这暗示了 $O(n^2)$ 的解决方法可能不是最优解，但应该足以通过。</p>

<p>在思考这个题的时候，由于没见过这个跳的方法，题目说明得又很蹩脚，头脑混沌不清，充斥着各种可能地思路，又看见了本题有一个排序的标签，觉得排序很可能在最优解里有扮演关键角色，于是构思出了一个相当蹩脚的原始实现，后来证明了大概是能通过的最慢解了。</p>

<p>思路如下：</p>

<ol>
  <li>先暴力找到每个位置左右能跳的范围，可以分别用 $\text{forward}$ 和 $\text{backward}$ 两个数组进行保存，花费 $O(d\cdot n)$；</li>
  <li>对 $\text{arr}$ 进行排序，花费 $O(n\text{log}n)$ ；</li>
  <li>对排序后的 $\text{arr}$ 进行遍历，因为只能从高到地跳，因此每个位置 $i$ 的下一跳的位置一定在它的前面，于是暴力地检查前面的每个位置，如果它的原始位置是能够一步跳到的，就进行比较，更新 $i$ 处索引最大能跳到的位置，花费 $O(n^2)$</li>
</ol>

<p>总的时间复杂度 $O(n^2)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">forward</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">backward</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">forward</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
</code></pre></div></div>

<p>运行时间：4348 ms (beats 5.24%)， 内存占用：16.66 MB (90.32%)</p>

<h2 id="解记忆化">解②记忆化：</h2>

<p>这个解是官方给出的，也是最常见的正解：</p>

<p>就是直接在原序列上计算，同样地暴力查找 $d$ 范围内符合条件的下一步位置，保存每个位置的计算结果，像这样时间复杂度也只有 $O(d\cdot n)$ ，比我们之前的方法 $O(n^2)$ 的复杂度要好，即使明明我们的思路看起来要聪明一些。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>这个思路能够成立是因为我们总是从高跳到低，不存在回路。</p>

<p>如果按照 DFS 的顺序计算，非常适合用递归地形式简单解决，配合上 Python 的函数式工具 <code class="language-plaintext highlighter-rouge">cache</code> 缓存所有同参数的调用，代码非常简洁：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">takewhile</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                      <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                      <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">subs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>  <span class="c1"># n &gt;= 1
</span></code></pre></div></div>

<p>运行时间：351 ms (beats 88.49%) ，内存占用：20.99 MB (beats 17.46%)</p>

<h3 id="概念解剖">概念解剖</h3>

<p>这里提到了“记忆化搜索”的概念，它是一个单独的分类，但从实质上讲也可以认为是 DP 的一类特定情况，这里就不特别区分二者了。</p>

<h3 id="语言责难">语言责难</h3>

<p>在我们当前的环境，Python 3.10 ，如果不使用 <code class="language-plaintext highlighter-rouge">cache</code> 而是手动保存结果的话，如下所示：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>

        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">subs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</code></pre></div></div>

<p>内存占用不出所料地降低到了：19.17 MB (beats 54.37%) ，但是运行时间也提高到了： 421 ms  (beats 80.95%) ，性能损失达到了 20% ，换言之，使用 <code class="language-plaintext highlighter-rouge">cache</code> 虽然增加了内存占用，但相比手动缓存，性能有明显提升。</p>

<p>如果说 <code class="language-plaintext highlighter-rouge">cache</code> 作为 <code class="language-plaintext highlighter-rouge">functools</code> 这个函数式编程辅助模块的一个代表<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，表现还是不错的，那另一个函数式编程的辅助模块 <code class="language-plaintext highlighter-rouge">itertools</code> 的表现就有些拉胯了：这些迭代器上的函数的性能可观察地不如普通地 <code class="language-plaintext highlighter-rouge">for</code> 循环。</p>

<p>比如把上面的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
    <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
    <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
<span class="p">)</span>
</code></pre></div></div>

<p>替换成</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">subs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">subs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>就有有 10% 级别的性能提升，这在像 Rust 这样的语言里是难以想象的！</p>

<h2 id="解排序反向构建">解③排序+反向构建：</h2>

<p>继续考虑上面的记忆化方法，DFS 的搜索顺序配合递归地实现只是说是一种实现方案，它很简洁很容易写，因此通常我们默认采用这种方法，但实际上当然也可以采用 BFS 的顺序以及迭代地实现，区别只是：</p>

<p>DFS 的迭代版本需要手动保存每一级的迭代器状态，而 BFS 需要保存某一级的所有孩子（当然还有该级的级数，也就是之前已经跳了多少步），不管怎样，实际问题地解决总是要到没有后代的节点，才能解决。</p>

<p>如果一个节点本身就是最小的高度，那么它一定没有子节点，或者周围 $d$ 范围内都是不低于它的节点，或者倒过来想，如果知道了所有高度严格小于某个节点的的节点信息（最大访问数、前向范围和后向范围），那么该节点的信息也可以利用这些信息<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>来直接得到：</p>

<ol>
  <li>
    <p>最大访问数是前一级节点的最大访问数加一，然后取它们的最大值；</p>
  </li>
  <li>
    <p>前一级节点的前向（顺扫描的方向）或后向（逆扫描的方向）范围，以后向为例，先选取后向的第一个元素，只要它小于当前元素，那么在不超过 $d$ 的范围，就可以直接把它的后向距离加入到当前位置的后向距离，然后从那个距离处继续向后扫描，直到超出 $d$ 的范围或者发现不小于当前元素的元素</p>
  </li>
</ol>

<p>有必要特别说明下这个前向或后向的范围，缓存这个值，可以减少位置值的比较次数<sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，虽然在求解最大访问数的时候复杂度仍然是 $O(d\cdot n)$ ，但实际证明这个做法让性能提高了 40% 以上。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">ans_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">forward_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward_cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="c1"># d &gt;= 1
</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="n">forward_cache</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">forward_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">i</span><span class="o">-</span><span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="n">backward_cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">backward_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">l</span><span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="n">ans_cache</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans_cache</span><span class="p">)</span>
</code></pre></div></div>

<p>这个方法本质上是记忆化方法的改进，省去了堆栈的开销，时间复杂度是 Better $O(d\cdot n)$ 。</p>

<p>运行时间：199 ms (beats 88.3%)，内存占用：16.9 MB (beats 73.24%)</p>

<p>实际结果看相当好了，与最优解相差不大了。</p>

<h2 id="解贪心记忆化">解➃贪心+记忆化：</h2>

<p>贪心思想地应用是时间复杂度最终能降低到 $O(n)$ 的关键<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>。</p>

<p>如之前 Jump Games 所示，$d$ 既然是连续的，就有贪心算法应用的空间，只不过还有一个限制条件，高度也要更低。</p>

<p>从反方向来考虑那些最长访问次数的位置序列，每个位置 $i$ 的前一个位置一定是距离它最近的更高的位置（当然左右方向分别考虑），否则如果不是最近的高度，要么从这个高度要么跳不到 $i$ ，因为中间还有不低于这个高度的位置，要么可以先跳到中间的一个高度的位置，然后跳到 $i$ ，总之都不是 $i$ 的直接前驱。</p>

<p>于是可以在 $O(n)$ 的时间复杂内找到每个位置的可能的直接前驱（分前向后向两个方向），然后可以在另一个 $O(n)$ 的复杂度内带记忆化地遍历每个位置，通过它的最多两个前驱，计算该位置的最大访问数，最后取最大值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">forward</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">backward</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="nb">range</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">storage</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">storage</span><span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">build</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">forward</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">backward</span><span class="p">)</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">backtrace</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">backtrace</span><span class="p">(</span><span class="n">forward</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">backward</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">backtrace</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：152 ms (beats 98.41%)，内存占用：19.52 MB （beats 42.46%）</p>

<h2 id="解贪心单调栈双指针dp">解➄贪心+单调栈+双指针+DP：</h2>

<p>前面的 $O(n)$ 复杂度的实现已经够好了，但是还有同复杂度但是更快的方法。</p>

<p>这个方法是从最快的样本代码里扒出来的，这个实现不仅融汇贯通了这些算法思想，而且代码细节上也是 Python 最优，几乎让人无法增删一笔，实在是优秀。</p>

<p>它区别于前一个方法的地方在于它把计算<strong>两个方向上的最近更高位置</strong>和<strong>求解最大访问次数</strong>能够放在一趟遍历过程中同时解决！</p>

<p>它的方法是这样：</p>

<ol>
  <li>使用单调栈至少可以计算后向的最近更高位置，而利用出栈的元素，又可以更新栈里前向的最近更高位置；</li>
  <li>实际上不需要维护最近更高位置，可以直接更新某个位置的最大访问次数</li>
</ol>

<p>具体过程：</p>

<p>扫描输入数组 $\text{arr}$ ，只要栈顶元素小于当前元素，就出栈；同时每次出栈时都把连带着所有与栈顶相等元素一同出栈，除了用栈顶元素从后向更新当前位置的最大访问数，还要利用所有连同出栈的相等的元素来前向更新新的栈顶元素的最大访问数（由于是单调不减栈，而且与旧栈顶相等的元素都出栈了，所以新栈顶一定严格大于出栈的所有元素）。</p>

<p>这样有一个问题，当扫描完成时，栈里的元素不一定都全部出栈了，因为最后一个元素不一定是最大的元素，这时要像前面一样，继续弹出栈顶元素，来前向地更新栈里后面的元素。</p>

<p>单独再加一段儿处理代码会很啰嗦，更合适地方法是在原数组尾部插入一个确定一定比所有元素都大的值，只是在求最大访问次数时排除尾部就行了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="n">max_int</span> <span class="o">=</span> <span class="mi">100_000</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_int</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">isoheight</span> <span class="o">=</span> <span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span>

            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">isoheight</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                <span class="n">isoheight</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">isoheight</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">j</span><span class="o">-</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<p>时间复杂度 Better $O(n)$</p>

<p>运行时间：120 ms (beats 100%)，内存占用：16.6 MB (beats 96.6%)</p>

<p>这段代码不仅从算法方法上，而且从代码编写上，实在已经是 Python 下面最快地写法了，任何比如拆分两个更新，使用迭代器都比这个实现更慢。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这实在暗示了其实思路还是没有走通，有很大的优化空间 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>可能所有 DP 相关算法的 Python 实现都会用到它 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>可以证明它的摊销最坏时间复杂度是 $O(1)$，想象每一级增加一个扫描位置，邻接位置的后一级就可以减少一个扫描位置，而且最终不超过 $n$ <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:3:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>本解直接来源于 LeetCode 用户 <em>gd303</em> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[题干]]></summary></entry><entry><title type="html">LeetCode Jump Games</title><link href="/oth/LeetCodeJumpGames.html" rel="alternate" type="text/html" title="LeetCode Jump Games" /><published>2023-08-02T00:00:00+08:00</published><updated>2023-08-02T00:00:00+08:00</updated><id>/oth/LeetCodeJumpGames</id><content type="html" xml:base="/oth/LeetCodeJumpGames.html"><![CDATA[<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.13/1871_">源代码</a></p>

<h2 id="44-jump-games-ii">44 Jump Games II</h2>

<p><em>虽然名字上第二个，但题目编号反而要比1要早</em></p>

<p><a href="https://leetcode.com/problems/jump-game-ii/description/">问题描述</a></p>

<p>求跳到尾部的最小步数<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<h3 id="解dp">解①DP</h3>

<p>这个题目本身带有 DP 的标签，首先也就想到了简单的 DP 思路：记录跳到每个位置所需要的最小步数，从左到右扫描，每到一个位置，就用当前步数加一来更新该位置下一步所能到达的那一些位置。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>这个算法的时间复杂度在官解和很多题解里直接标了 $O(n^2)$ ，但这是不准确的，因为根据题目标明的数据范围 <code class="language-plaintext highlighter-rouge">nums[i]</code> 的最大值与 <code class="language-plaintext highlighter-rouge">len(nums)</code> 的最大值不同，前者要小一个数量级，实际上是 1000 ，很多情况这可能只是一个稍微大一点的常数。</p>

<p>实际运行 3862 ms  (beats 25.91%)</p>

<p>说差也差，说不差，还有 10000+ ms 通过的朋友。</p>

<h3 id="解greedy">解②Greedy：</h3>

<p>做多了 DP 的题目，再想 Greedy 思路反而变得不太直观，所谓看山不是山。</p>

<p><strong>算法推论：</strong></p>

<p>探测每个位置下一步能够跳到的所有位置，比较它们下一步能够跳到的最远的位置，最远的那一个就是下一步要跳到的地方，这样直到可以等于或者超过终点。</p>

<p><strong>贪心的归纳法证明：</strong></p>

<p>定义：把用最小步数跳到终点的一个跳法儿称作一个<em>最短序列</em>。</p>

<p>只需要证明，这个算法的跳的每一个位置都在同一个<em>最短序列</em>里：</p>

<ol>
  <li>
    <p>初始时刻，起始位置显然一定在<em>最短序列</em>里</p>
  </li>
  <li>
    <p>假如上一个位置 $i_0$ 在最短序列里，那么从该位置出发，比较所有下一步可以跳到的位置，假如下一步跳最远的位置是 $j$ ，而存在另一个位置 $j_1\neq j$ 是这个最短序列里的下一步:</p>

    <p>定义通过 $j_1$ 的最短序列上的下一个位置为 $j_1’$ ，则：</p>

    <p>2.1. 如果 $j_1’ \geqslant j$ ，那是不是说明通过 $j_1$ 能够跳到的位置，通过 $j$ 也能跳到</p>

    <p>2.2. 如果 $j_1’ \lt j$ ，则有 $i \lt j_1 \lt j_1’$ ，那为什么不直接一步从 $i_0$ 跳到 $j_1’$ ，而是要花两步跳？ 这又和最短序列矛盾了</p>
  </li>
</ol>

<p>证毕。</p>

<p><strong>贪心成立关键在于：</strong></p>

<ol>
  <li>跳的步数是一个连续地范围</li>
  <li>跳的步数是非负值</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prev i
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">])],</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">step</span>
</code></pre></div></div>

<p>扫描了多长的候选位置，就至少跳过多少候选位置，时间复杂度为 $O(n)$ 。</p>

<p>运行时间：120 ms (beats 96.35%)，绝对地最优解。</p>

<h2 id="55-jump-games-i">55 Jump Games I</h2>

<p><em>虽然名字上第一个，但题目编号反而要比2要晚</em></p>

<p><a href="https://leetcode.com/problems/jump-game/description/">问题描述</a></p>

<h3 id="解greedy-1">解①Greedy-1：</h3>

<p>这个问题和上面 Games II 的题干看起来非常像，可以用一模一样的方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i0</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">i0</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">i0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i0</span><span class="p">])),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<p>但是数据的规模发生了变化，<code class="language-plaintext highlighter-rouge">nums[i]</code> 的最大值反而要比 <code class="language-plaintext highlighter-rouge">len(nums)</code> 的最大值大一个数量级，时间复杂度应该类似于上面 Games II 的 DP 解法。</p>

<p>实际运行时间：6041 ms (beats 8.5%)</p>

<h3 id="解-greedy-2">解② Greedy-2：</h3>

<p>由于本题 <code class="language-plaintext highlighter-rouge">len(nums)</code> 比 <code class="language-plaintext highlighter-rouge">nums[i]</code> 有较小的数据规模，何况追求得最小步数而是最大可达位置，最好是可以只扫描 <code class="language-plaintext highlighter-rouge">nums</code> 数组。</p>

<p>可以这样考虑：如果终点是不可达的，那么在 <code class="language-plaintext highlighter-rouge">nums</code> 上一定存在一个真正的终点位置，如果能够找到这个终点位置，就可以进行判断了。</p>

<p>可是终点是什么样的呢？</p>

<p>首先终点的步长应该是零，否则从它就可以跳到更右边的位置，而它也就不是终点了。</p>

<p>其次，任何终点左边的位置一步之内都最多跳到终点。</p>

<p>如果从 <code class="language-plaintext highlighter-rouge">nums</code> 的尾部开始向左扫描，如果一个位置可以一步到达尾部，那么就可以把尾部设置到该位置，如果在结束的时候尾部没有归为零，终点就是尾部前一个位置。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">lf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lf</span><span class="p">:</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">lf</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>运行时间：394 ms (beats 98.95%)</p>

<p>也可以从正面开始扫描，寻找终点，但除了让代码更复杂一点没有任何好处。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">to</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">to</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>运行时间：428 ms (beats 96.53%)</p>

<h2 id="1306-jump-games-iii">1306 Jump Games III</h2>

<p><a href="(https://leetcode.com/problems/jump-game-iii/)">问题描述</a></p>

<p>从给定位置开始跳，每次有左右两个方向，不是跳一个范围，而是一个固定地步长。</p>

<p>谈不到什么算法的简单题目。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="s">""" false: unvisited, true: visited """</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>运行时间：249 ms (beats 98.79%)，内存占用： 23.6 MB (beats 47.8%， ~ 100%)</p>

<p>题目很简单，但是有两点细节很值得一提：</p>

<ol>
  <li>这个题目内存占用最低地情况就是 23 MB ，如果不创建新的结构，而是直接在 <code class="language-plaintext highlighter-rouge">arr</code> 上就地修改<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，几乎不会节约任何内存占用，只少了大概 0.3 MB ，不知道造成这个原因的技术细节是什么，可能只是 Python 的内存分配器一次性地申请了很大的内存<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>；</li>
  <li>而更令人意想不到地是这个题目的解的内存占用可以达到 80 MB！粗略地看了一下，它们全都是使用了基于哈希表的数据结构（<code class="language-plaintext highlighter-rouge">set</code>，<code class="language-plaintext highlighter-rouge">map</code>，<code class="language-plaintext highlighter-rouge">default_dict</code>，etc.）而不是数组来标记访问，一方面它们的访问速度相较于列表并没有明显地更慢，另一方面它们占用了有点儿意料之外地更多的内存。</li>
</ol>

<p>对于第一点，CPython 显然不如 JVM 那样有很详细或者冗繁地参数控制，更不如编译型语言对内存使用那样地节约，这没什么好说的。</p>

<p>对于第二点，必须申明地是，必须实际地考虑哈希表的实现，由于负载因子（fill factor）的存在<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>，至少内部的空间容量就是原数组的倍数，再考虑存储碰撞元素的列表甚至树形结构指针的开销，实际地哈希表占据的空间如果有个数组的两倍也毫不奇怪（但是像 Python 这样确实有些夸张，内存开销大概是普通列表的 1000 倍的级别，只能说完全地对象语言是这样的）。</p>

<p><strong>因此一个很重要地原则是，如果是追踪一个已知列表的每个元素状态，直接使用列表无论时间还是空间性能都要优于使用哈希表。</strong></p>

<h2 id="1345-jump-game-iv">1345. Jump Game IV</h2>

<p><a href="https://leetcode.com/problems/jump-game-iv/description/">问题描述</a></p>

<p>固定跳点，每个点可以跳到三类地方，+1/-1/同值点，求从头跳到尾的最小步数。</p>

<p>非常类似于 Games III ，前者被标定为 Medium 难度，现在只不过又缝了一个哈希表的使用，难度就被定位到 Hard 级了。<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup><sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<p>运用哈希表统计同值点，用 BFS 求取最小步数，需要注意得是哈希表上的元素在被访问过后必须弹出，否则时间复杂度会劣化到 $O(n^2)$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">val</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">nxt_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">step</span>

            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">val</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">pop</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">nxt_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">step</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">nxt_queue</span>

    <span class="k">return</span> <span class="n">step</span>
</code></pre></div></div>

<p>运行时间：549 ms (beats 98.59%)，内存占用：29.6 MB （beats 94.3%）</p>

<p>关于使用什么样的算法和数据结构来对同值位置进行统计，可以继续 Games  III 的讨论，当一般地值域比元素数大一个数量级，就是一定要使用哈希表的情况。</p>

<h2 id="1340-jump-game-v">1340. Jump Game V</h2>

<p>有单独一篇博文来讨论： <a href="/oth/LeetCode1340.html">LeetCode1340</a></p>

<h2 id="1696-jump-game-vi">1696. Jump Game VI</h2>

<p><a href="https://leetcode.com/problems/jump-game-vi/description/">问题描述</a></p>

<p>乍看起来很简单，但是做起来令人有些不快，因为它作为中等难度的题，但寻找 $O(n)$ 的解决方案并不如我预计得那样容易。</p>

<p>题目求解最大的跳的位置和，也是跳一个连续范围，看起来就是利用贪心地思想寻找一个简单方法就 OK 了，但是没有这样的方法，想了很长时间，就是发现在所有位置的值中，如果是正的，一定在序列里，但如果是负的，就存在一个更少的步数但更大（绝对值）的负值与更多的步数而更小的负值，这就不适合贪心算法了。</p>

<h3 id="解分治dp">解①分治+DP：</h3>

<p>只能一步一步考虑，从索引 $0$ 的位置，第一步跳到的位置，有 $k$ 个，可以线性地计算出它们的最大值，包括这个长度为 $k$ 数组的后缀最大值，那么对于下一个 $k$ 长度的区间，它们每个位置的最大访问和就可以通过前 $k$ 个的后缀最大值和当前 $k$ 个的前缀最大值计算得出，这样一直到计算出了到最后一个位置的最大访问和，整个时间复杂度都是线性的。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">prev_postfix_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
    <span class="n">cur_prefix_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>

    <span class="n">blk_rem</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">k</span>
    <span class="n">max_blks</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">blk_rem</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">k</span><span class="p">]):</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">acc</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">+=</span> <span class="n">v</span>

    <span class="k">for</span> <span class="n">blk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_blks</span><span class="p">):</span>
        <span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="n">cur_prefix_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_postfix_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">blk</span><span class="o">*</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">blk</span> <span class="o">==</span> <span class="n">max_blks</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">blk_rem</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">blk_rem</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">prev_postfix_max</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">blk</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>
            <span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_prefix_max</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cache</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">init</span> <span class="o">+</span> <span class="n">cache</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="n">blk_rem</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">]</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：826 ms (beats 80.95%)，内存占用：30.50 MB (beats 52.38%)</p>

<h3 id="解双头单调栈dp">解②双头单调栈+DP：</h3>

<p>本方法是上面方法的规整解，可以使用优先级队列维护之前最大的统计和的位置，当堆顶的元素过期（即与当前位置差距超过 $k$ ）就弹出，不过这样每次弹出栈顶元素需要的时间复杂度就是 $O(\text{log}n)$ ，总共的时间复杂度 $O(n\text{log}n)$ 。</p>

<p>可以用双头的单调栈，从头到尾严格减的顺序，每次检查栈头最大值，如果“过期”就弹出（$i$ 最多增加一次，因此只需要检测一次），用栈顶的访问最大值和当前值加和计算出当前位置的访问最大值，把栈尾所有不超过当前访问最大值的索引位置弹出，然后把当前索引位置插入尾部。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">q</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">while</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：773 ms (beats 97.14%)，内存占用：30.53 MB (beats 52.38%)</p>

<h2 id="1871-jump-game-vii">1871 Jump Game VII</h2>

<p><a href="https://leetcode.com/problems/jump-game-vii/description/">问题描述</a></p>

<p><em>首先吐槽下这个题的测试用例很不健全，导致有些 $O(n^2)$ 复杂度的算法甚至比 $O(n)$ 的算法都快</em> 。</p>

<p>这个题目是单向跳，跳的步长是一个固定的范围： <code class="language-plaintext highlighter-rouge">[minJump, maxJump]</code> ，而且只能跳到值为 <code class="language-plaintext highlighter-rouge">‘0’</code> 的位置，从头开始跳，看能否跳到最后一个。</p>

<p>又是一个跳的这个范围不是从 $1$ 开始，但仍然是连续的，这就启发我们仍然可能找到一个基于贪心地思想的 $O(n)$ 的解决方案。</p>

<p>把值为 <code class="language-plaintext highlighter-rouge">‘0’</code> 的位置称为可跳位置，事实上，这个题目破题的关键是向前查找可跳位置是否可以跳到。</p>

<h3 id="解贪心序">解🄋贪心：序</h3>

<p>可以用一个列表保存所有可跳到的位置，然后使用最多两次二分搜索就可以判断出 <code class="language-plaintext highlighter-rouge">[minJump, maxJump]</code> 范围内是否有可跳到的位置跳到当前位置：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span> <span class="o">&lt;=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">r</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">:</span>
                    <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">continue</span>

    <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>时间复杂度是 $O(n\text{log}n)$</p>

<p>运行时间：439 ms (beats 36.99%)，内存占用：21.1 MB (beats 25.62%)</p>

<h3 id="解贪心双头栈">解①贪心：双头栈</h3>

<p>如果能悟出了贪心算法，那么马上就能想到前面 Jump Game VI 里面使用过的双头单调栈，只不过这里更简单，序号本来就是自然增长的，不需要特别维护单调性，弹出头部所有小于 <code class="language-plaintext highlighter-rouge">i-maxJump</code> 的索引。</p>

<p>因为之后永远都不会检查到这些位置了，然后检查新的栈头是否大于等于 <code class="language-plaintext highlighter-rouge">i-minJump</code> ，成立的话就说明存在前面一个可跳到的位置能够跳到当前位置，这就把当前位置索引插入到尾部，当然如果所有栈已经空了，就提前返回失败，因为已经没有任何可跳到的位置能继续向前跳了。</p>

<p>最后检查栈的尾是否有最后一个索引编号。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：201 ms (beats 96.49%)，内存占用：20.50 MB (beats 48.76%)</p>

<h3 id="解贪心其他">解②贪心：其他</h3>

<p>这里介绍本质相同地另外几个 $O(n)$ 的算法：</p>

<h4 id="dp--滑动窗口">DP + 滑动窗口</h4>

<p>利用一个数组 <code class="language-plaintext highlighter-rouge">dp</code> 记录扫描过的位置是否可跳达，使用一个变量 <code class="language-plaintext highlighter-rouge">cnt</code> 来追踪当前位置$i$ 的 <code class="language-plaintext highlighter-rouge">[i-maxJump, i-minJump]</code> 范围里可跳达位置的数量，到时候检查这个变量是否为零，就可以判断当前可跳位置是否可以跳到。</p>

<p>维护 <code class="language-plaintext highlighter-rouge">cnt</code>：</p>

<ol>
  <li>当 <code class="language-plaintext highlighter-rouge">dp[i-minJump]</code> 是 <code class="language-plaintext highlighter-rouge">true</code> 时，说明随着窗口滑动新进来了一个可跳到的位置，<code class="language-plaintext highlighter-rouge">cnt</code> 就加一；</li>
  <li>当 <code class="language-plaintext highlighter-rouge">dp[i-maxJump-1]</code> 是 <code class="language-plaintext highlighter-rouge">false</code> 时，说明随着窗口滑动，原本尾部的可跳到的位置出去了，<code class="language-plaintext highlighter-rouge">cnt</code> 就减一</li>
</ol>

<p>基本代码和下面方法一样，这里就不赘写了。</p>

<h4 id="前缀和">前缀和</h4>

<p>这个是官解，只不过用了一个记录可跳到位置的数量和的前缀数组 <code class="language-plaintext highlighter-rouge">prefix</code> 代替 <code class="language-plaintext highlighter-rouge">dp</code>，用前缀和之差代替对 <code class="language-plaintext highlighter-rouge">cnt</code> 的追踪。</p>

<p>这个有点儿意思得地方是，它用了 <code class="language-plaintext highlighter-rouge">prefix[i-minJump] - prefix[i-maxJump-1]</code> 来计算 <code class="language-plaintext highlighter-rouge">[i-maxJump, i-minJump]</code> 范围内可跳到位置的数量，让人想起了树状数组也采用同样的方法来计算区间值。</p>

<p>有一点让人不爽地是，必须单独处理 <code class="language-plaintext highlighter-rouge">[0, maxJump+1]</code> 部分的内容来初始化前缀树组。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">minJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxJump</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'0'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">maxJump</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="n">it</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">minJump</span><span class="p">,</span> <span class="n">maxJump</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">:</span>
            <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s">'0'</span> <span class="ow">and</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">minJump</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">maxJump</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div></div>

<p>算法复杂度 $O(n)$ 。</p>

<p>运行时间：173 ms (beats 97.52%)，内存占用：21.07 MB (beats 25.62)</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>题目确保一定会跳到结尾 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>比如取负值表示访问过的状态 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>黑箱测试结果比较支持这个看法 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>为了避免在内部数组接近填满时哈希性能地急速下降 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>可能是知识体系的不同，这些前面的 LeetCode 的题目难度普遍不高，这和我最初做图上的问题以及扫描线的问题的难度感完全不是一个等级的 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>在做了一些题后，我对 LeetCode 出题思路也有了一些把握，Medium 难度题目只涉及单一知识点，而 Hard 难度题目就是两个独立的知识点缝在一起，一般还是一大一小 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[源代码]]></summary></entry><entry><title type="html">Why Greedy？</title><link href="/algs/Greedy.html" rel="alternate" type="text/html" title="Why Greedy？" /><published>2023-08-01T00:00:00+08:00</published><updated>2023-08-01T00:00:00+08:00</updated><id>/algs/Greedy</id><content type="html" xml:base="/algs/Greedy.html"><![CDATA[<h2 id="前言">前言</h2>

<p>“贪心”的这个概念根本就有问题：</p>

<ol>
  <li>从适用条件上讲，它过于地宽泛而没有用；</li>
  <li>从内容上讲，它只是机械地总结了结果，而缺乏提示最关键的思考过程</li>
</ol>

<p>真正地问题在于为什么 Greedy 成立，以及成立的内在核心条件是什么？<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">1</a></sup></p>

<p>这是一个两步递进的问题，首先是证明 Greedy 成立，Greedy 形式上总是由一个阶段的局部最优解来得到全局最优解，这天然适合用归纳法<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup>来进行证明，只要证明初始条件的成立<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>和前一个阶段的局部最优解能够导出下一个阶段的局部最优解。</p>

<p>然后可以发现 Greedy 成立的条件会有类似之处，进行真正有意义地总结。</p>

<p>下面我们介绍一些贪心算法的实例，来进行观察。</p>

<h2 id="树上直径">树上直径</h2>

<p>求解非负权树形图的直径。</p>

<p>树形图（Tree Graph），就是像树一样的无向连通图，也就是无环地无向连通图。</p>

<p>树上的直径就是两点间最长的简单路径<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">4</a></sup>。</p>

<h3 id="算法推论">算法推论</h3>

<p>这时图上任意一点 $v_0$ ，以它为起点，距离最远的一个点是 $v_1$，则 $v_1$ 一定是直径的两个端点之一，然后再以 $v_1$ 为起点寻找距它最远的点 $v_2$ 就得到了直径。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup></p>

<h3 id="贪心证明">贪心证明</h3>

<p>考虑树的直径一定横跨左右子树<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup>，而 $P_{v_0\rightarrow v_1}$ 只有两种可能：  与直径有交点或者没有交点 。</p>

<p>如果没有交点，就是 $P_{v_0\rightarrow v_1}$ 只在一侧的子树上的情况，那么如果连接树的根节点和 $P_{v_0\rightarrow v_1}$ 上最近根的一个点 $v_1’$ ，假设根节点是 $v_R$ ，同侧子树的直径的端点是 $v_d$ ，那么根据直径的性质，$|v_1’ \rightarrow v_1| \leqslant |v_R\rightarrow v_1’ \rightarrow v_1| \leqslant |v_R\rightarrow v_d|$ ，这样就有 $|v_0\rightarrow v_1’ \rightarrow v_1| \leqslant |v_0\rightarrow v_R\rightarrow v_d|$ 。</p>

<ol>
  <li>如果 $|v_0\rightarrow v_1’ \rightarrow v_1| \lt |v_0\rightarrow v_R\rightarrow v_d|$ ，构造出的新路径 $P_{v_0\rightarrow v_R\rightarrow v_d}$ 就是更长的距离 $v_0$ 的路径，这就与前提条件相悖；</li>
  <li>否则 $|v_0\rightarrow v_1’ \rightarrow v_1| = |v_0\rightarrow v_R\rightarrow v_d|$ ，这意味着 $P_{v_R\rightarrow v_0\rightarrow v_1’\rightarrow v_1}$ 要么比原路径 $P_{v_R\rightarrow v_d}$ 更长，这就和前提条件相悖，要么相等<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">7</a></sup>，$|v_1’ \rightarrow v_1| = |v_R\rightarrow v_1’ \rightarrow v_1| = |v_R\rightarrow v_d|$ 这就说明 $P_{v_R\rightarrow v_1’\rightarrow v_1}$ 也是一条可选的直径（的一部分），此时 $v_1$ 当然就是直径的一个端点。</li>
</ol>

<p>如果存在交点，假设交点是 $v_1’$ ，直径的与 $v_0$ 异侧的端点是 $v_{d}$ ，假如 $v_1 \neq v_d$，那么总能构造出更长的距离 $v_0$ 的路径或者树的直径，否则就是存在多条相等的直径，$v_1$ 是另一条直径的端点。</p>

<p>因此证明了 $v_1$ 总是直径的一个端点，当然也证明了 $v_2$ 也是直径的一个端点<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">8</a></sup>。</p>

<h3 id="成立条件">成立条件</h3>

<p>这个贪心算法能够成立的核心条件有两个：</p>

<ol>
  <li>树形图不存在环，两个点之间的简单路径有且只有一条；</li>
  <li>非负权边，这让数学上的“不等式缩放”（scaling）能够成立。</li>
</ol>

<h2 id="dijkstra-最短路径">Dijkstra 最短路径</h2>

<p>一提到贪心算法，可能是很多人第一时间想到 dijkstra 算法，以前在学校时，数据结构课的老师总是喜欢强调它是一种贪心算法，当时就觉得这是句干话，因为我们完全不会因为它是贪心算法就理解它的原理或者清楚它的工作过程，现在我们来重新回顾下<a href="/algs/GraphSP.html">这个算法</a>：</p>

<p>非负权边的无向连通图，求解从某个点 $v_0$ 出发到其他所有点的最短路径。</p>

<h3 id="算法推论-1">算法推论</h3>

<p>可以依次求出距离 $v_0$ 最短、次短、第三短。。。。。。的点的路径，每求出一个点，就用这个最短路径更新与它直接相连的那些点。</p>

<p>初始可以认为与 $v_0$ 直接相连点的最短路径就它们的直接路径长度，而其他点的最短路径是无穷大。</p>

<h3 id="贪心证明-1">贪心证明</h3>

<ol>
  <li>由于是非负路径，初始时首先可以依次确定与 $v_0$ 直接相连的那些点的最短距离</li>
  <li>同样由于是非负路径，到某个点 $v_1$ 的最短路径上的前驱点 $v_1’$ 的最短路径一定更小，首先会被求出，而 $v_1$ 的最短路径因此会被正确更新<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup></li>
</ol>

<h3 id="成立条件-1">成立条件</h3>

<p>显然最重要的就是边的权重是非负值，这再次允许我们进行非比较地不等式缩放。</p>

<h2 id="jump-games">Jump Games</h2>

<p><a href="/oth/LeetCodeJumpGames.html"></a></p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:10" role="doc-endnote">
      <p>贪心算法就总是第一眼看上去感觉好像是对的，但是又不能 100% 确定，证明它或者理解它为什么是对的比实现它要复杂得多 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Inductive Reasoning，也许用诱导推理这个词更能把握它的内核，而且总是可以联想到后缀数组的诱导排序（Induced Sorting）算法，反过来归纳一词总让人误以为这是一种经验猜测而不是逻辑推理 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>这通常是显而易见的 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>没有重复点的路径 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>两步地贪心算法 QAQ <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>不这样的话，假如只在其中一棵子树上，通过连接另一侧子树上的点、根节点和直径的近端的点，就能构造出更长的直径 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>存在零权重的边 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Deductive Reasoning，诱导推理的反过程–演绎推理 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>如果存在零权边，那么总可以等价地交换这些零权边连接的点的位置，并不影响结论 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;algs&quot;]" /><summary type="html"><![CDATA[前言]]></summary></entry><entry><title type="html">LeetCode Packet 1</title><link href="/oth/LeetCodePacket1.html" rel="alternate" type="text/html" title="LeetCode Packet 1" /><published>2023-07-29T00:00:00+08:00</published><updated>2023-07-29T00:00:00+08:00</updated><id>/oth/LeetCodePacket1</id><content type="html" xml:base="/oth/LeetCodePacket1.html"><![CDATA[<h2 id="44-wildcard-matching"><a href="https://leetcode.com/problems/wildcard-matching/">44. Wildcard Matching</a></h2>

<p>各方面都更像 <a href="/oth/LeetCode0010.html">0010 - Regular Expression Matching</a> II ，前者是正则匹配，后者则是一般 shell 上文件名的匹配，而且后者（也就是本题）的 DP 实现可以把时间和空间性能很好地结合在一起。</p>

<p>把模式串的遍历放在外循环，唯一需要仔细考虑下的就是每一轮 DP 的初始化：</p>

<ol>
  <li>第一轮的 DP，$\text{dp}[0] = \text{true}$ ，也就是空串匹配空串，其他位置是非空文本串匹配空模式串，显然全都是 $\text{false}$ ；</li>
  <li>第二轮及之后的 DP，如果对应位置是 <code class="language-plaintext highlighter-rouge">*</code> 符号，$\text{dp}[0]$ 就等于前一轮的 $\text{dp}[0]$ ，否则就排除了模式串前缀全是星符号的情况，就一定是 $\text{false}$</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># j = 0
</span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">:</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prev1</span> <span class="o">=</span> <span class="n">prev1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prev1</span> <span class="o">=</span> <span class="n">prev1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev1</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>和一个直接使用 <code class="language-plaintext highlighter-rouge">fnmatch.fnamtch</code> 的运行时间一致。</p>

<h2 id="403-frog-jump"><a href="https://leetcode.com/problems/frog-jump/">403. Frog Jump</a></h2>

<p>一个最优时间复杂度为 $O(n^2)$ 的动态规划的题目，有点儿无语了。</p>

<p>分为自顶向下（渐进递归），和自底向上两个实现方法，这种时间复杂度 $O(n^2)$ 的题目实在没什么好讲的。</p>

<p>使用哈希表而不是二维数组的好处是可以直接把值放进表里，而不需要额外的值的哈希表来查找值对应的索引<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">k_candicates</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]})</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k_candicates</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k_candicates</span><span class="p">[</span><span class="n">v</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>时间复杂度：$O(n^2)$ 。</p>

<p>运行时间：164 ms (beats 74.64%)，内存占用：17.6 MB (beats 98.33%)</p>

<h2 id="2498-frog-jump-ii"><a href="https://leetcode.com/problems/frog-jump-ii/">2498. Frog Jump II</a></h2>

<p>从头跳到尾，跳过去再跳回来，每次不能跳跳过的石头，每一跳的最大值即为整个路径的值，求最小的路径值。</p>

<p>既然是跳过去再跳回来，那么可以在一遍扫描的时候直接找两条最短的路径，由于没有任何跳跃的限制，因此不存在某一跳较大但因此其他跳较小的情况，因为总是可以通过较小的跳跳到该位置，这就可以使用贪心地思想，直接寻找最小的下一跳。</p>

<p>可以直接从序号一开始，两两一组，1跳3，2跳4，如此，这就是最小的路径值的跳法儿。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>时间复杂度 $O(n)$ 。</p>

<p>运行时间：558 ms (beats 98.8%)，内存占用：31.12 MB (beats 44.23%) 。</p>

<p>必须吐槽下，这个完全是 $O(1)$ 的内存使用内存占用居然不是最好的，因为还有处理过程中直接修改输入数组（弹出元素）的情况。</p>

<p>可以用一种混合地写法看起来更简洁：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">stones</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stones</span><span class="p">)</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="n">stones</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>但由于 <code class="language-plaintext highlighter-rouge">ans</code> 的比较次数多了一倍，性能要稍差些。</p>

<p>运行时间：580 ms</p>

<h2 id="62-unique-paths"><a href="https://leetcode.com/problems/unique-paths/">62. Unique Paths</a></h2>

<p>非常常见的动态规划的一类题目，利用计算过的更小规模的值计算后面更大的值。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
</code></pre></div></div>

<p>时间复杂度 $O(mn)$ 。</p>

<p>运行时间：46 ms (beats 44.10%)，内存占用：16.4 MB (beats 48.70%) 。</p>

<p>如果只是单次求解，可以把空间规模缩减到 $O(\min(m,n))$ ，就像之前 Wildcard Matching 那样，但这意义不大，特别地对于这道题目，记忆空间的缩减也有数学上的解释，就是当前位置值就是取杨辉三角上一行的前一个位置和上一行的同一个位置之和。</p>

<p>而实际上杨辉三角展示得是就是组合数的代数性质，可以直接求组合数，空间占用就变成了 $O(1)$。</p>

<p>从组合的观点看，因为我们的走法儿每一步是不受前面步的影响，唯一限制就是横向要走 $m-1$ 步，纵向要走 $n-1$ 步，因此总地组合空间就是从 $m-1+n-1$ 步中选取 $m-1$ 或 $n-1$ 步：$\displaystyle C_{m+n-2}^{m-1}$ 。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">comb</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>具体时间复杂度由组合数的计算方法决定，使用原始地算数运算大概有 $O(\min(m,n))$ 。</p>

<p>运行时间：39 ms (beats 77.42%)，内存占用：16.1 MB (beats 99.75%) 。</p>

<h2 id="63-unique-paths-ii"><a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a></h2>

<p>出题者使用了“绊脚石”排除了简单的数学解法，但是递归 DP 仍然有效，只要排除石头挡路的情况。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>时间复杂度 $O(nm)$</p>

<p>运行时间：56 ms (beats 23.68%)，内存占用：16.8 MB (beats 7.1%, ~100%) 。</p>

<p>虽然好像时间内存排名不是很高，但是实际数据上差别不大，和前面一样也可以缩减到 $O(\min(m,n)$ 的内存占用，不赘述了。</p>

<h2 id="64-minimum-path-sum"><a href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum</a></h2>

<p>和独特路径完全一样。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="o">@</span><span class="n">cache</span>
    <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dp</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="97-interleaving-string"><a href="https://leetcode.com/problems/interleaving-string/">97. Interleaving String</a></h2>

<p>交错两个字符串 $s_1$ 和 $s_2$ ，看是否等于第三个字符串 $s_3$ 。</p>

<p>这个成立的渐进式条件是，$s_1$ 、 $s_2$ 的前缀同样可以交错成 $s_3$ 的某个前缀。</p>

<p>因此可以从前缀长度是 $0$ 的空子串开始，判断两种情况：</p>

<ol>
  <li>$s_1$ 前缀的下一个字符是否等于 $s_3$ 前缀的下一个字符；</li>
  <li>$s_2$ 前缀的下一个字符是否等于 $s_3$ 前缀的下一个字符</li>
</ol>

<p>这也分别构成两种情况的递归，递归的参数应该是匹配的 $s_1$ 、 $s_2$ 和 $s_3$ 的前缀长度 $i, j, k$ 。</p>

<p>但实际上 $k$ 是可以被省略的，当匹配发生时，那么 $k=i+j$ 。</p>

<p>另外有两个快速失败的优化：</p>

<ol>
  <li>长度不等，快速失败</li>
  <li>字符和每个字符的次数（multiset）不等，快速失败<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></li>
</ol>

<h3 id="递归版本">递归版本：</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s3</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n1</span><span class="o">+</span><span class="n">n2</span> <span class="o">!=</span> <span class="n">n3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s3</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">recur</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span> <span class="o">==</span> <span class="n">n3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span> <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s3</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">recur</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span> <span class="ow">and</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">s3</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">recur</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">recur</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>以 $i,j$ 某一个参数为外循环，而不是同时尝试增加 $i,j$ ，这样就得到了迭代的版本。迭代版本有一个好处是可以压缩记忆的内存从 $O(n^2)$ 到 $O(n)$ ，因为记忆只涉及前一行和当前行（<code class="language-plaintext highlighter-rouge">mem[i-1][j], mem[i][j-1]</code>）。</p>

<h3 id="迭代版本">迭代版本：</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s3</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">!=</span> <span class="n">n3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">s3</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">mem</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s3</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s3</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">mem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s3</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">mem</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s3</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">mem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">mem</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
</code></pre></div></div>

<p>需要特别注意下 $s_1$ 是空串的情况。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>这实在有些脱裤子放屁 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>在 Python3（3.10）<code class="language-plaintext highlighter-rouge">Counter(s1) + Counter(s2)</code> 优于 <code class="language-plaintext highlighter-rouge">COunter(s1+s2)</code> 以及 <code class="language-plaintext highlighter-rouge">sorted(s1+s2)</code> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="[&quot;oth&quot;]" /><summary type="html"><![CDATA[44. Wildcard Matching]]></summary></entry></feed>