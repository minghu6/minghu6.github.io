<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            Boyer-Moore算法
        
    "
/>

<meta property="og:url" content="//algs/BM.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        Boyer-Moore算法
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="d-flex align-items-center justify-content-between h-100">
  <span id="breadcrumb">

    

    

    

    
    <span>
      <a href="/">
        <img src="/assets/img/icons/home.png">
      </a>
    </span>
    

    

    

    

    

    

    
  </span><!-- endof #breadcrumb -->

  <section class="logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </section>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>

</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">Boyer-Moore算法</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      August 01, 2020
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p>author: minghu6</p>

<p><em>(2nd) revised at 2024-10-29</em></p>

<p><em>本章节内容需要以《前缀函数与KMP算法》作为前置章节。</em></p>

<p>之前的KMP算法将前缀匹配的信息用到了极致，</p>

<p>而 BM 算法背后的基本思想是通过 <strong>后缀匹配</strong> 获得比前缀匹配更多的信息来实现更快的跳转。</p>

<h2 id="基础介绍">基础介绍</h2>

<p>想象一下，如果我们的的模式字符串 $\texttt{pat}$ ，被放在文本字符串 $\texttt{string}$ 的头部，使它们的第一个字符对齐。</p>

\[\begin{aligned}
\qquad \texttt{pat}:\qquad &amp;\texttt{EXAMPLE} \\
\texttt{string}:\qquad &amp;\texttt{HERE IS A SIMPLE EXAMPLE} \dots \\
&amp;\qquad\ \ \ \, \Uparrow
\end{aligned}\]

<p>$\texttt{pat}$ 的长度为 $\texttt{\texttt{patlen}}$</p>

<p>$\texttt{string}$ 的长度 $\texttt{stringlen}$。</p>

<p><em>按照算法惯例，设定字符串的基底为 $1$</em></p>

<p>追踪下 $\texttt{string}$ 上的第 $\texttt{patlen}$ 个字符 $\texttt{char}$ ，考虑我们能得到什么信息：</p>

<h3 id="观察-1">观察 1</h3>

<p>如果我们知道 $\texttt{char}$ 不在 $\texttt{pat}$ 中,  可以直接将 $\texttt{pat}$ 和 $\texttt{string}$ 指针向下滑动 $\texttt{patlen}$ 个字符（然后重新开始后缀匹配）。</p>

<h3 id="观察-2">观察 2</h3>

<p>如果我们知道 $\texttt{char}$ 在 $\texttt{pat}$ 中，并且离尾端至少有 $\Delta_1$ 个字符，可以直接将 $\texttt{pat}$ 和 $\texttt{string}$ 指针向下滑动 $\Delta_1$ 个字符。</p>

<p>以失配字符 $\texttt{char}$ 为参数，在 $\texttt{pat}$ 上构建计算 $\Delta_1$ 的函数，：</p>

\[\begin{array}{ll}
\textbf{int}\ \texttt{delta1} (\textbf{char}\ \texttt{char}) \\
\qquad \textbf{if}\ \texttt{char} \notin \texttt{pat}\\
\qquad\qquad\textbf{return}\ \texttt{patlen} \\
\qquad \textbf{else} \\
\qquad\qquad\textbf{return}\ \texttt{patlen} - i\ \ \text{/* } i = \max\lbrace i\vert\ 
\texttt{pat}[i] = \texttt{char} \rbrace  \text{ */}
\end{array}\]

<h3 id="观察-3-a">观察 3-a</h3>

<p>假设不是在 $\texttt{pat}$ 的最后一个字符，而是倒数第 $m+1$ 个字符上失配，那么 $\texttt{pat}$ 向下滑动 $k = \Delta_1 - m$ ，而 $\texttt{string}$ 指针仍然向下滑动 $k + m = \Delta_1$ （因为要重新从尾部开始匹配）。</p>

<h3 id="观察-3-b">观察 3-b</h3>

<p>假设在倒数第 $m+1$ 个字符上失配，已匹配完的 $m$ 个字符的后缀子串为 $\texttt{subpat}$，作者把 $\texttt{pat}$ 上所有与后缀子串 $\texttt{subpat}$ 相等的子串称为 plausible reoccurrence，其中最右边的 $\texttt{subpat}$ 称为 rightmost plausible reoccurrence ，简称 $\texttt{rpr}$ 。</p>

<p>定义 $\texttt{rpr}(j)$ 表示后缀子串 $\texttt{pat}[j+1\dots]$ 的 $\texttt{rpr}$ 的起始位置，得到 $\Delta_2$ ：</p>

\[\begin{array}{ll}
\textbf{int}\ \texttt{delta2}(\textbf{int}\ j) \ \ \text{/* j为失配字符索引 */} \\

\qquad\textbf{return}\ \texttt{patlen} + 1 -\texttt{rpr}(j) \\

\end{array}\]

<p>这样在失配时， $\texttt{pat}$ 向下滑动 $\max(\Delta_1,\Delta_2) - m$ ，$\texttt{string}$ 上的指针向下滑动 $\max(\Delta_1,\Delta_2)$  （全都需要重新从尾部开始匹配）。</p>

<h3 id="实例说明">实例说明</h3>

<p>箭头指向失配字符 $\texttt{char}$：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad\ \ \ \Uparrow
\end{aligned}\]

<p>$\texttt{F}$ 不在 $\texttt{pat}$ 中，根据 <strong>观察 1</strong> ，把 $\texttt{pat}$ 直接向下滑动 $\texttt{patlen}$ 个字符，也就是 $7$ 个字符；</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\quad\ \ \, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad\ \ \, \ \qquad\quad\ \ \ \Uparrow
\end{aligned}\]

<p>根据 <strong>观察 2</strong>，我们需要将 $\texttt{pat}$ 向下滑动 $4$ 个字符使得 $\texttt{_}$ 字符对齐：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\qquad\quad\ \ \, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad\ \ \, \qquad\qquad\qquad \Uparrow
\end{aligned}\]

<p>现在$\texttt{char:\ T}$ 匹配了，把指针向前一步，继续匹配：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\qquad\quad\ \ \, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad \; \qquad\qquad\quad\ \ \ \Uparrow
\end{aligned}\]

<p>在 $\texttt{L}$ 上失配，因为 $\texttt{L}$ 不在 $\texttt{pat}$ 中，根据 <strong>观察 3-a</strong> ，$\texttt{pat}$ 向下滑动 $k= \Delta_1-m=7-1=6$ 个字符，而 $\texttt{string}$ 上指针向下移动 $\Delta_1=7$ 个字符：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\qquad\qquad\qquad\ \ \,\, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad\ \ \ \; \qquad\qquad\qquad\qquad\ \ \ \Uparrow
\end{aligned}\]

<p>这时 $\texttt{char}$ 又一次匹配到了 $\texttt{pat}$ 的最后一个字符 $\texttt{T} $，继续向前匹配，匹配到了 $\texttt{A}$ ，再向前匹配，发现在字符 $\texttt{-}$ 失配：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\qquad\qquad\qquad\ \ \,\, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad\ \, \ \qquad\qquad\qquad\quad\ \ \ \,\, \Uparrow
\end{aligned}\]

<p>此时根据 <strong>观察 3-b</strong> ，$\Delta_1=4$，$\Delta_2=7-0 = 7$，即 $\texttt{string}$ 上指针向下滑动 $\max(\Delta_1,\Delta_2)= 7$， $\texttt{pat}$ 向下滑动 $\max(\Delta_1,\Delta_2)-m= 7-2=5$，使得后缀 $\texttt{AT}$ 对齐：</p>

\[\begin{aligned}
\texttt{pat}:\qquad\qquad &amp;\qquad\qquad\qquad\qquad\qquad\quad \;\, \texttt{AT-THAT} \\
\texttt{string}:\ \ \ \dots\ &amp;\texttt{WHICH-FINALLY-HALTS.--AT-THAT-POINT} \dots \\
&amp;\qquad \ \, \ \quad\qquad\qquad\qquad\qquad\quad \ \ \; \Uparrow
\end{aligned}\]

<p>现在我们在 $\texttt{string}$ 上找到了一个 $\texttt{pat}$ 的匹配。而我们只花费了$14$ 次对 $\texttt{string}$ 的引用，其中 $7$ 次是完成一个成功的匹配所必需的比较次数（ $\texttt{patlen}=7$ ），另外 $7$ 次让我们跳过了 $22$ 个字符！</p>

<h2 id="算法设计">算法设计</h2>

<h3 id="匹配算法">匹配算法</h3>

\[\begin{array}{ll}
i \gets \texttt{patlen}. \\ 
\\
\textbf{loop}\\
\qquad \textbf{if}\ i &gt; \texttt{stringlen} \\
\qquad \qquad \textbf{return}\ \texttt{false} \\
\\
\qquad j \gets \texttt{patlen} \\
\\
\qquad \textbf{loop}
\\
\qquad\qquad \textbf{if}\ j &lt; 1 \\
\qquad\qquad\qquad \textbf{return}\ i+1 \\
\\
\qquad\qquad\textbf{if}\ \texttt{string}[i]=\texttt{pat}[j] \\
\qquad\qquad\qquad j \gets j-1 \\
\qquad\qquad\qquad i \gets i-1 \\
\\
\qquad\qquad\qquad \textbf{continue} \\
\\
\qquad\qquad\textbf{break}\\
\\
\qquad i \gets i+\max(\texttt{delta1}(\texttt{string}[i]), \texttt{delta2}(j)) \\
\\
\end{array}\]

<p>$i$ 表示 $\texttt{string}$ 上的全局指针，$j$ 表示 $\texttt{pat}$ 局部指针。</p>

<p>$\textbf{return}\ \texttt{false}$ 表示 $\texttt{pat}$ 不在 $\texttt{string}$ 中，返回数字表示 $\texttt{pat}$ 在 $\texttt{string}$ 左起第一次出现的位置。</p>

<h3 id="textttrprj">$\texttt{rpr}(j)$</h3>

<p>让我们完整定义下 $\texttt{rpr}(j)$ 函数。</p>

<p>根据前文定义，$\texttt{rpr}(j)$ 表示 $\texttt{subpat}=\texttt{pat}[j+1\dots]$ 在 $\texttt{pat}$ 上最右边相等子串的起始位置。</p>

<p>假设找到的 $\texttt{rpr}$ 字串为 $\texttt{pat}[k\dots k+\texttt{patlen}-j-1]=\texttt{subpat}$，首先允许拓展 $k$ 到 $k \lt 1$ ，相当于在 $\texttt{pat}$ 前面补充一段虚拟前缀，这就向下兼容了所有可能的 plausible reoccurrence 情况。</p>

<p>另外当 $k&gt;1$ 时，考虑一种优化，如果 $\texttt{pat}[k]=\texttt{pat}[j]$ ，那么显然 $\texttt{pat}[k\dots k+\texttt{patlen}-j-1]$ 就是一个无效的 plausible reoccurrence ，因为 $pat[j]$ 本身是失配字符，那么向下滑动后重新从尾部开始匹配，在 $\texttt{pat}[k]$ 处还是会失配。</p>

<p>最后考虑到 $\texttt{delta2}(\texttt{patlen}) = 0$ ， 所以设置 $\texttt{rpr}(\texttt{patlen}) = \texttt{patlen}$ 。</p>

<h4 id="实例说明-1">实例说明</h4>

\[\begin{aligned}
\textit{j}:&amp; &amp;\texttt{1 2 3 4 5 6 7 8 9} \\
\texttt{pat}:&amp; &amp;\texttt{A B C X X X A B C} \\
\texttt{rpr}(j):&amp; &amp;\texttt{4 3 2 1 0 2 1 0 9} \\
\text{sign}:&amp; &amp;\texttt{- - - - - - - - +}
\end{aligned}\]

<p>$j = 1$ ，$\texttt{subpat = BCXXXABC}$， $\texttt{[(BCXXX)ABC]XXXABC}$，$\texttt{rpr}(1)=-4$；</p>

<p>$j = 6$ ，$\texttt{subpat = ABC}$，$\texttt{[ABC]XXXABC}$，$\texttt{rpr}(6)=1$；</p>

<p>$j = 7$ ，$\texttt{subpat = BC}$，$\texttt{A[BC]XXXABC}$，又因为 $\texttt{pat}[1]=\texttt{pat}[7]$，所以改为 $\texttt{[(BC)]ABCXXXABC}$ ，所以 $\texttt{rpr}(j)=-1$；</p>

<p>$j = 9 = \texttt{patlen}$，根据定义，$\texttt{rpr}(9)= \texttt{patlen}=9$。</p>

<p>以及另外一个例子：</p>

\[\begin{aligned}
\textit{j}:&amp; &amp;\texttt{1 2 3 4 5 6 7 8 9} \\
\texttt{pat}:&amp; &amp;\texttt{A B Y X C D E Y X} \\
\texttt{rpr}(j):&amp; &amp;\texttt{7 6 5 4 3 2 3 0 9} \\
\text{sign}:&amp; &amp;\texttt{- - - - - - + - +}
\end{aligned}\]

<h3 id="匹配算法的改进">匹配算法的改进</h3>

<p>最后，实践过程中考虑到搜索过程中估计有 $80\%$ 的时间用在了基于 <strong>观察 1</strong> 和 <strong>观察 2</strong> 的跳转上，也就是 $\texttt{string}[i]$ 和 $\texttt{pat}[\texttt{patlen}]$ 不匹配，然后跳过整个 $\texttt{patlen}$ 的情况。</p>

<p>为此进行优化，定义一个 $\texttt{delta0}$：</p>

\[\begin{array}{ll}
\textbf{int}\ \texttt{delta0}(\textbf{char}\ \texttt{char}) \\
\qquad \textbf{if}\ \texttt{char}=\texttt{pat}[\texttt{patlen}] \\
\qquad\qquad \textbf{return}\ \texttt{large} \\
\qquad \textbf{return}\ \texttt{delta1}(\texttt{char})
\end{array}\]

<p>其中 $\texttt{large}$ 是一个足够大的数，满足 $\texttt{large} \gt \texttt{stringlen + patlen}$ ，用作信号功能。</p>

<p>用 $\texttt{delta0}$ 代替 $\texttt{delta1}$ ，得到改进后的匹配算法：</p>

\[\begin{array}{ll}
i \gets \texttt{patlen} \\
\\
\textbf{if} \ i &gt; \texttt{stringlen} \\
\qquad\textbf{return}\ \texttt{false}\\
\\
\textbf{loop} \\
\qquad\ \text{/* fast */}\\
\\
\qquad\ \textbf{while}\ i \leqslant \texttt{stringlen} \\
\qquad\qquad i \gets i + \texttt{delta0}(\texttt{string}[i])\\
\\
\qquad\ \text{/* undo */}\\
\\
\qquad\ \textbf{if}\ i \leqslant\ \text{large}\\
\qquad\qquad\textbf{return}\ \texttt{false}\\
\\
\qquad i \gets i-\texttt{large} - 1 \\
\qquad j \gets \texttt{patlen} - 1. \\
\\
\qquad\ \text{/* slow */}\\
\\
\qquad\textbf{loop}\\
\qquad\qquad \textbf{if}\ j &lt; 1 \\
\qquad\qquad \qquad \textbf{return}\ i+1 \\
\\
\qquad\qquad\textbf{if}\ \texttt{string}[i]=\texttt{patlen}[j]\\
\qquad\qquad\qquad j \gets j-1 \\
\qquad\qquad\qquad i \gets i-1 \\
\\
\qquad\qquad\qquad\textbf{continue} \\
\\
\qquad\qquad\textbf{break}\\
\\
\qquad i \gets i + \max(\texttt{delta1}(\texttt{string}[i]), \texttt{delta2}(j)) \\
\\
\end{array}\]

<p>$\text{fast：}$ 只要一直在 $\texttt{pat}$ 尾字符上失配，就不需要考虑 $\Delta_2$ 。</p>

<p>$\text{undo：}$ 从 $\text{fast}$ 滑落有两种情况，一种是正常的发现尾字符匹配，由于 $\texttt{+large}$ 导致滑落；</p>

<p>还有一种是 $\texttt{string}$ 指针走完了，于是滑落下来，对于此种情况 $0\leqslant i \leqslant \texttt{large} $ ，直接返回 $\texttt{false}$ ，表明子串不存在。</p>

<p>在继续下落前应该还原 $i$ 指针，并把它额外向前拨 $1$ ，因为尾字符已经匹配了。</p>

<p>$\text{slow:}$ 原算法的主要匹配代码。</p>

<p>经过改进，可以跳过 $\Delta_2$ 的多余计算，使得在通常字符集下搜索字符串的性能有明显的提升。</p>

<h2 id="textttdelta2">$\texttt{delta2}$</h2>

<p>探寻 $\texttt{delta2}$ 实现，也是不易，要进行一番技术史的考据和对 KMP 算法融会贯通基础上进行重新发明。</p>

<h3 id="历史细节">历史细节</h3>

<p>发表在 1977 年 10 月的 <em>Communications of the ACM</em> 上的在 Boyer、Moor 的论文<sup id="fnref:1977BM" role="doc-noteref"><a href="#fn:1977BM" class="footnote" rel="footnote">1</a></sup>只描述了一个静态表，并没有说明如何生成它。</p>

<p>对 $\texttt{delta2}$ 具体实现的讨论反而出现在 1977 年 6 月 Knuth、Morris、Pratt 在 <em>SIAM Journal on Computing</em> 上正式联合发表KMP算法的 <em>Fast Pattern Matching in Strings</em><sup id="fnref:1977KMP" role="doc-noteref"><a href="#fn:1977KMP" class="footnote" rel="footnote">2</a></sup> （除 KMP 外，还有若干字符串匹配的算法构想和介绍，其中就包括了 BM 算法），这听力来有点儿魔幻：</p>

<ol>
  <li>
    <p>1969 年夏天 Morris 为某个大型机编写文本编辑器时利用有限自动机的理论发明了等价于 KMP 算法的字符串匹配算法，而他的算法由于过于复杂，被不理解他算法的同事当做 bug 修改得一团糟。</p>
  </li>
  <li>
    <p>1970 年 KMP 中的 K，Kruth 在研究 Cook 的 two-way deterministic pushdown automaton 的理论时受到启发，也独立发明了 KMP 算法的雏形，并把它展示给他的同事 P，Pratt ，Pratt 改进了算法的数据结构。</p>
  </li>
  <li>
    <p>1974 年 Boyer、Moor 发现通过更快地跳过不可能匹配的文本能实现比 KMP 更快的字符串匹配（ Gosper 也独立地发现了这一点），而一个只有原始 $\texttt{delta1}$ 定义的匹配算法是 BM 算法的最初版本。</p>
  </li>
  <li>
    <p>1975 年 Boyer、Moor 提出了原始的 $\texttt{delta2}$ 表，而这个版本的 $\texttt{delta2}$ 表不仅不会对性能有所改善，还会在处理小字符表时拖累性能表现，而同年 MIT 人工智能实验室的 Kuipers 和 Knuth 向他们提出了类似的关于 $\texttt{delta2}$ 的改进建议，于是 Boyer、Moor 在论文的下一次修改中提到了这个建议，并设想用一个二维表代替 $\texttt{delta1}$ 和 $\texttt{delta2}$ 。</p>
  </li>
  <li>
    <p>1976 年 1 月 Knuth 证明了有关  $\texttt{delta2}$ 的改进会得到更好的性能，于是 Boyer、Moor两人又一次修改了论文，得到了现在版本的 $\texttt{delta2}$ 定义。同年 4 月，斯坦福的 Floyd 又发现了 Boyer、Moor 两人第一版本的公式中的严重的统计错误，并给出了现在版本的公式。</p>
  </li>
  <li>
    <p>Standish 又为 Boyer、Moor 提供了现在的匹配算法的改进。</p>
  </li>
  <li>
    <p>1977 年 6 月 Knuth、Morris、Pratt 正式联合发表了 KMP 算法的论文，其中在提及比 KMP 表现更好的算法中提出了 $\texttt{delta2}$ 的构建方式。（其中也感谢了 Boyer、 Moor 对于证明线性定理（linearity theorem）提供的帮助）</p>
  </li>
</ol>

<p>这是一个团结、友谊和协作的故事，也是一个大佬带我飞的故事。</p>

<h3 id="朴素算法">朴素算法</h3>

<p>在介绍 Knuth 的 $\texttt{delta2}$ 构建算法之前，根据定义，我们会有一个 $O(n^3)$ 朴素算法：</p>

<p><em>虽然时间复杂度看起来糟糕透了，但考虑到 $\texttt{delta2}$ 的只构建一次而且 $\texttt{pat}$ 通常长度有限，</em></p>

<p><em>很多时候这已经够用了，除非是搜索长度成百上千的不同  $\texttt{pat}$ 。</em></p>

<ol>
  <li>对于每个 $j \in 1\dots \texttt{patlen}$ 在 $-\texttt{patlen}-j-1\dots j$ 上从右到左暴力寻找第一个等于 $\texttt{subpat}$ 的子串；</li>
  <li>逐字符进行比较，当指针 $i\lt 1$ 时直接返回字符匹配成功（因为是虚拟前缀）；</li>
  <li>当子串匹配成功时检查是否 $i\lt 1$ 或 $\texttt{pat}[i] \neq \texttt{pat}[j] $；</li>
  <li>最后令 $\texttt{pat}[\texttt{patlen}] = 0 $ 。</li>
</ol>

<p><em>注意实现代码里的字串的基底为 $0$</em></p>

<pre><code class="language-Rust">use std::cmp::Eq;

pub fn build_delta2_table_naive(p: &amp;'a [impl Eq]) -&gt; Vec&lt;usize&gt; {
    let patlen = p.len();
    let lastpos = patlen - 1;
    let mut delta2 = vec![];

    for j in 0..patlen {
        let subpatlen = (lastpos - j) as isize;

        if subpatlen == 0 {
            delta2.push(0);
            break;
        }

        for i in (-subpatlen..=j as isize).rev() {
            // subpat 匹配
            if (i..i + subpatlen)
            .zip(j + 1..patlen)
            .all(|(rpr_index, subpat_index)| {
                if rpr_index &lt; 0 {
                    return true;
                }

                if p[rpr_index as usize] == p[subpat_index] {
                    return true;
                }

                false
            })
            &amp;&amp; (i &lt;= 0 || p[(i - 1) as usize] != p[j])
            {
                delta2.push((lastpos as isize - i) as usize);
                break;
            }
        }
    }

    delta2
}
</code></pre>

<p>特别地，对Rust语言特性进行必要地解释，下不赘述：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">usize</code> 和 <code class="language-plaintext highlighter-rouge">isize</code> 是和内存指针同字节数的无符号整数和有符号整数。</li>
  <li>索引数组、向量、分片时使用 <code class="language-plaintext highlighter-rouge">usize</code> 类型的数字（因为在做内存上的随机访问并且下标不能为负值），所以如果需要处理负值要用<code class="language-plaintext highlighter-rouge">isize</code>，而进行索引时又要用<code class="language-plaintext highlighter-rouge">usize</code>，这就看到使用<code class="language-plaintext highlighter-rouge">as</code>关键字进行二者之间的数值转换。</li>
  <li><code class="language-plaintext highlighter-rouge">impl PartialEq</code> 用作泛型，这样可以同时支持<code class="language-plaintext highlighter-rouge">Unicode</code>编码的<code class="language-plaintext highlighter-rouge">char</code>和二进制的<code class="language-plaintext highlighter-rouge">u8</code> 和其他所有实现了 <code class="language-plaintext highlighter-rouge">PartialEq</code> 的数据类型。</li>
</ul>

<p>这是个显见的时间复杂度为 $O(n^3)$ 的暴力算法。</p>

<h3 id="高效算法">高效算法</h3>

<p>下面我们要介绍的是时间复杂度为 $O(n)$，但是需要额外 $O(n)$ 空间复杂度的高效算法。</p>

<p>需要指出的是，虽然 1977 年 Knuth 提出了这个构建方法，然而他的原始版本的构建算法存在一个缺陷，会产生不出符合定义的 $\texttt{delta2}$。</p>

<p>Rytter 在 1980 年 <em>SIAM Journal on Computing</em> 上发表的文章 <sup id="fnref:1980Rytter" role="doc-noteref"><a href="#fn:1980Rytter" class="footnote" rel="footnote">3</a></sup> 对此提出了修正，但是 Rytter 这篇文章在细节上还有令人疑惑的地方，包括不限于</p>

<ul>
  <li>示例中奇怪的 $\Delta_2$ 数值（不清楚他依据的 $\texttt{delta2}$ 是否和最终版 $\texttt{delta2}$ 的定义有差别，但我实在不想因为这事儿继续考古了😱）</li>
  <li>明显地复述 Knuth 算法时的笔误、算法上错误的缩进（可能是文章录入时的问题？）</li>
  <li>可读性很差的变量命名（考虑到那是个 goto 语句、汇编语言和大型机的时代，随性的变量命名倒也很合理）</li>
</ul>

<p>总之你绝不想看他那个修正算法的具体实现，不过好在他的文字描述比伪代码清晰多了，现在我们用更清晰的思路和代码结构去重新发明 $\texttt{delta2}$ 的构建算法：</p>

<p>$\texttt{delta2}$ 的定义比较复杂，高效实现的关键，是按照 $\texttt{subpat}$ 的 plausible reoccurrence（以下简称 <em>重现</em> ）位置分类处理。</p>

<p>按照 <em>重现</em> 位置从前到后，分为三类：</p>

<ol>
  <li>
    <p><em>重现</em>  完全在 $\texttt{pat}$ 左边，比如 $\texttt{[(EYX)]ABYXCDEYX}$ ，此时 $\texttt{rpr}(j) = 1-\texttt{subpatlen}$ ，而根据定义 $\texttt{subpatlen}=\texttt{patlen} - j$ ，于是得到 $\texttt{delta2}(j) = \texttt{patlen} - \texttt{rpr}(j) + 1 = 2 \times \texttt{patlen} - j$；</p>
  </li>
  <li>
    <p><em>重现</em> 有一部分在 $\texttt{pat}$ 左边，有一部分是 $\texttt{pat}$ 前缀，比如$\texttt{[(XX)ABC]XXXABC}$，此时 $\texttt{patlen} &lt; \texttt{delta2}(j) &lt; 2 \times \texttt{patlen} - j$；</p>
  </li>
  <li>
    <p><em>重现</em> 完全在 $\texttt{pat}$ 中，比如 $\texttt{AB[YX]CDEYX} $ ，此时 $\texttt{delta2}(j) \leqslant \texttt{patlen} $。</p>
  </li>
</ol>

<p>接下来讨论如何高效地计算这三种情况：</p>

<h4 id="case-1">case-1</h4>

<p>这是最简单的情况， $\texttt{delta2}(j)$  是确定值。</p>

<p>这也是 <em>重现</em> 的兜底情况，要通过一次遍历，在这里完成 $\texttt{delta2}$ 的初始化，之后看是否在 <strong>case-2</strong> , <strong>case-3</strong> 上有更新的机会。</p>

<h4 id="case-2">case-2</h4>

<p>此时应该是 $\texttt{subpat}$ 的某个后缀和 $\texttt{pat}$ 的某个前缀相等。</p>

<p>比如之前的例子：</p>

\[\begin{aligned}
\textit{j}:&amp; &amp;\texttt{1 2 3 4 5 6 7 8 9} \\
\texttt{pat}:&amp; &amp;\texttt{A B C X X X A B C} \\
\end{aligned}\]

<p>$\texttt{delta2}(4)$ 的 <em>重现</em>  $\texttt{[(XX)ABC]XXXABC}$，在 $\texttt{subpat} = \texttt{XXABC}$ 的后缀与 $\texttt{pat}$ 的前缀中，有一个（最长的）相等子串 $\texttt{ABC}$。</p>

<p><em>这就来到了《前缀函数与KMP算法》所涉及的领域，实际上对第二和第三种情况的计算都离不开前缀函数，或者更一般地讲，DP 思想。</em></p>

<p>计算此种情况下的 $\texttt{delta2}(j)$：</p>

<p>设相等的前后缀长度为 $\texttt{prefixlen}$。</p>

<p>于是有 $\texttt{pat}$ 左边部分的长度为 $\texttt{subpatlen}-\texttt{prefixlen} = \texttt{patlen} - j - \texttt{prefixlen}$；</p>

<p>$\texttt{rpr}= \texttt{pat}[1-( \texttt{patlen} - j - \texttt{prefixlen})\dots  \texttt{prefixlen}]$；</p>

<p>$\texttt{delta2}(j) = \texttt{patlen} - \texttt{rpr}(j) = 2 \times \texttt{patlen} - j - \texttt{prefixlen}$。</p>

<p>实际上要计算所有长度不同的 $\texttt{subpat}$ 后缀与 $\texttt{pat}$ 前缀相等的情况。</p>

<p>也就是计算 $\texttt{pat}$ 所有真（真就真在不包括它自己）后缀和真前缀相等的情况，然后按照长度从大到小，将 $\texttt{delta2}(j)$ 分区间进行计算。</p>

<p>假如 $\texttt{pat}$ 上有三组长度不同的相等前后缀，记为 $\texttt{pat}[i_1\dots]$、 $\texttt{pat}[i_2\dots]$ 和 $ \texttt{pat}[i_3\dots]$ 。</p>

<p>于是有：</p>

<ul>
  <li>$1\leqslant j \lt i_1 $ ， $\texttt{prefixlen} = \texttt{patlen} - i_1 + 1$</li>
  <li>$i_1\leqslant j \lt i_2 $ ， $\texttt{prefixlen} = \texttt{patlen} - i_2 + 1$</li>
  <li>$i_2\leqslant j \lt i_3 $ ， $\texttt{prefixlen} = \texttt{patlen} - i_3 + 1$</li>
  <li>$i_3\leqslant j $ ， $\texttt{prefixlen} =0$ ，实际上是 <strong>case-1</strong> 的情况</li>
</ul>

<p>如何计算 $\texttt{pat}$ 所有相等的真前缀和真后缀（的长度）呢？</p>

<p>可以利用 KMP 里的前缀函数。</p>

<p>让我们回顾一下前缀函数 $\pi[i]$ ，它表示 $\texttt{pat}[\dots i]$ 最长的那对儿相等真前缀和真后缀的长度。</p>

<p>$\pi[\texttt{patlen}]$ 就是 $\texttt{pat}$ 上最长的一对儿相等真前缀和真后缀。</p>

<p>那么如何计算其他次长、次次长、次次次长…… 的相等真前缀和真后缀长度呢？</p>

<p>回想一下前缀函数的计算过程，$\pi[i]$ 首先检查下 $\texttt{pat}[\pi[i-1] + 1]$ 是否等于 $\texttt{pat}[\texttt{patlen}]$ ；</p>

<p>否则再检查 $\texttt{pat}[\pi[\pi[i-1]] + 1]$ ，$\texttt{pat}[\pi[\pi[\pi[i-1]]] + 1]$ ，等等，直到等于 $\texttt{pat}[\texttt{patlen}]$ ，或者滑落到 $\texttt{pat}[1]$ 为止。</p>

<p>利用同样的规律，反推回去：</p>

<p>$\texttt{prefixlen}_1 = \pi[\texttt{patlen}]$；</p>

<p>$\texttt{prefixlen}_2 = \pi[\pi[\texttt{patlen}]]$；</p>

<p>$\texttt{prefixlen}_3 = \pi[\pi[\pi[\texttt{patlen}]]]$；</p>

<p>直到 $\texttt{prefixlen}_n = 0$ 。</p>

<p>这样就完成了对  $\texttt{delta2}(j)$ 的计算</p>

<h4 id="case-3">case-3</h4>

<p><em>重现</em> 完全在 $\texttt{pat}$ 中。</p>

<p>需要按照从右到左的顺序，在 $\texttt{pat}[0\dots \texttt{patlen}-1]$ 中搜索符合条件的 $\texttt{subpat}$ 。</p>

<p><em>开启脑洞：既然是个字符串搜索的问题，那么当然可以用 BM 算法本身递归地解决，设置结束条件是 $\texttt{patlen} = 1 $。</em></p>

<p>Knuth 发现如果从尾部开始建立“前缀”函数，失配时相等的子串恰好就是一个保证下一个字符和作为 $\texttt{pat}$ 后缀的 $\texttt{subpat}$ 的下一个字符不相同的（因为失配了）合法 <em>重现</em> 。</p>

<p>这个过程中只要检查每一个遇到的 <em>重现</em> ，就可以完成 <strong>case-3</strong> 的 $\texttt{delta2}$ 更新。</p>

<h4 id="具体实现">具体实现</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">compute_pi</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">impl</span> <span class="nb">Eq</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pi</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0usize</span><span class="p">;</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()];</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">pat</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">j</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pi</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">build_delta2_table_improved_minghu6</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="k">impl</span> <span class="nb">Eq</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">pat</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">patlen</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">lastpos</span> <span class="o">=</span> <span class="n">patlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">delta2</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">patlen</span><span class="p">);</span>

    <span class="cm">/* case-1: delta2[j] = 2 * lastpos - j */</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">patlen</span> <span class="p">{</span>
        <span class="n">delta2</span><span class="nf">.push</span><span class="p">(</span><span class="n">lastpos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* case-2: lastpos &lt;= delata2[j] &lt; 2 * lastpos - j */</span>

    <span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="nf">compute_pi</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">prefixlen</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">lastpos</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">prefixlen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">i</span><span class="o">..</span><span class="p">(</span><span class="n">patlen</span> <span class="o">-</span> <span class="n">prefixlen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">delta2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="n">prefixlen</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">patlen</span> <span class="o">-</span> <span class="n">prefixlen</span><span class="p">;</span>
        <span class="n">prefixlen</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">prefixlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/* case-3: delata2[j] &lt; lastpos */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span>
    <span class="n">suffix</span><span class="p">[</span><span class="n">lastpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">patlen</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="n">lastpos</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">patlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">suffix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">patlen</span> <span class="o">&amp;&amp;</span> <span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">delta2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">i</span> <span class="p">{</span>
                <span class="n">delta2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">i</span>
            <span class="p">}</span>

            <span class="n">j</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">delta2</span><span class="p">[</span><span class="n">lastpos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">delta2</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="复杂度分析">复杂度分析</h4>

<p><strong>case-1</strong> 初始化的时候是一个 $O(N)$ ；</p>

<p><strong>case-2</strong> 计算前缀函数是一个 $O(N)$ ，和遍历 $\texttt{prefixlen}$ 不超过 $O(N)$；</p>

<p><strong>case-3</strong> 从尾部计算前缀函数是一个 $O(N)$ ，回退过程顺带更新也不超过 $O(N)$；</p>

<p>加起来不超过 $O(5\cdot N)$ ，另外需要一个和 $\texttt{pat}$ 等长的辅助空间，用来存储前缀函数，</p>

<p>因此这个构建算法的时间复杂度是 $O(N)$ ，空间复杂度是 $O(N)$ 。</p>

<h2 id="galil规则">Galil规则</h2>

<h3 id="最坏情况">最坏情况</h3>

<p>在不覆盖（onoverlapping）的多次匹配情况下，</p>

<p>如果 $\texttt{string}$ 的字母表很小（$\Delta_1$ 失效），并且 $\texttt{pat}$ 由非常短的子串循环构成（$\Delta_2$ 失效），最坏时间复杂度会回到 $O(m\cdot n) $ 。</p>

<p>一个极端的例子是 $\texttt{pat} = \texttt{AAA}$， $\texttt{string} = \texttt{AAAAA}\dots$。</p>

<h3 id="最短周期-k">最短周期 $k$</h3>

<p>假定一个 $\texttt{pat}$ ，它是某个子串 $U$ 重复 $n$ 次构成的字符串 $UUUU\dots$ 的前缀，那么我们称 $U$ 为 $\texttt{pat}$ 的一个周期。</p>

<p>比如，对于 $\texttt{pat} = \texttt{ABCABCAB}$ ，$\texttt{ABC}$ 就是这个它的一个周期，当然 $\texttt{ABCABC}\dots$ 也是它的一个周期，但我们只关注最短的那个。</p>

<p>显然，$\texttt{pat}$ 至少拥有一个长度为它自身的周期，我们规定它的最短周期为 $k$，$k\leqslant \texttt{patlen}$。</p>

<p>在搜索过程中，假如我们的 $\texttt{pat}$ 成功地完成了一次匹配，那么依照周期的特点，实际上只需将 $\texttt{string}$ 上的指针向下滑 $k$ 个字符，比较这 $k$ 个字符是否等于 $\texttt{pat}[\texttt{patlen} - k + 1\dots ]$ 就可以直接判断是否存在 $\texttt{pat}$ 的又一个匹配。</p>

<p>而如何计算这个最短周期的长度呢，假如我们知道 $\texttt{pat}$ 的相等的一对儿前缀后缀，设它们的长度为 $\texttt{prefixlen}$，那么有 $\texttt{pat}[i] = \texttt{pat}[i+(patlen-\texttt{prefixlen})]$。</p>

<p>而从数学的角度看这个公式，显然我们已经有了长度为 $\texttt{patlen}-\texttt{prefixlen}$ 的周期，而当我们知道 $\texttt{pat}$ 最长的那一对相等的前缀后缀，我们就得到了 $\texttt{pat}$ 最短的周期。</p>

<p>而这个最长相等的前后缀长度，就是 $\pi[\texttt{patlen}]$ ，在我们在构建 $\texttt{delta2}$ 的时候已经计算过了。</p>

<h3 id="实践评价">实践评价</h3>

<p>从实践的角度上说，理论上的最坏情况并不容易影响性能表现，哪怕是很小的只有 $4$ 的字符集的随机文本测试下这种最坏情况的影响也小到难以观察。</p>

<p>也因此如果没有很好地设计，使用 Galil 法则反而会拖累一点平均的性能表现，但对于一些极端特殊的比如上述例子中的 Gulil 规则的应用确实会使得性能表现提高数倍。</p>

<h2 id="具体实现-1">具体实现</h2>

<h3 id="字符类型">字符类型</h3>

<p>上世纪70年代那个时候，人们考虑字符，默认的前提是它是ASCII码，但现在的多字节编码方案不管是 GB18030 还是 Unicode ，采用的都是变长的字节编码方案，但是：</p>

<ol>
  <li>字符串匹配算法高效的关键在于字符索引的快速跳转</li>
  <li>字符索引一定要建立在等宽字符的基础上，</li>
</ol>

<p>所以匹配的对象要么是二进制字节，要么是固定码点的列表。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">GetDelta1</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">get_delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">trait</span> <span class="n">BMMatch</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">build_delta1_table</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="k">Self</span><span class="p">],</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">GetDelta1</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="k">Self</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="k">Self</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">patlen</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">lastpos</span> <span class="o">=</span> <span class="n">patlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">pat</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">HashMapWrapper</span> <span class="p">{</span> <span class="n">patlen</span><span class="p">,</span> <span class="n">map</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">GetDelta1</span> <span class="k">for</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">256</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="nb">u8</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">get_delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="p">[</span><span class="o">*</span><span class="nb">char</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="k">as</span> <span class="n">_</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">BMMatch</span> <span class="k">for</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">build_delta1_table</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="k">Self</span><span class="p">],</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">GetDelta1</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="k">Self</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">delta1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pat</span><span class="nf">.len</span><span class="p">();</span> <span class="mi">256</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">lastpos</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">lastpos</span> <span class="p">{</span>
            <span class="n">delta1</span><span class="p">[</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">delta1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">BMPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">pat</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.into</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">BMPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">M</span><span class="p">:</span> <span class="n">BMMatch</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">_delta1</span> <span class="o">=</span> <span class="nn">M</span><span class="p">::</span><span class="nf">build_delta1_table</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">delta2</span> <span class="o">=</span> <span class="nf">build_delta2_table_improved_minghu6</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nf">compute_k</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>

        <span class="n">BMPattern</span> <span class="p">{</span>
            <span class="n">pat</span><span class="p">,</span>
            <span class="n">_delta1</span><span class="p">,</span>
            <span class="n">delta2</span><span class="p">,</span>
            <span class="n">k</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">BMMatch</span> <span class="o">+</span> <span class="nb">Eq</span><span class="o">&gt;</span> <span class="n">BMPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">delta0</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">char</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">LARGE</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.delta1</span><span class="p">(</span><span class="nb">char</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">._delta1</span><span class="nf">.get_delta1</span><span class="p">(</span><span class="nb">char</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">string</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">pat</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pat</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">patlastpos</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">stringlastpos</span> <span class="o">=</span> <span class="n">string</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">patlastpos</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">patlastpos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">string</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.find_map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="o">*</span><span class="n">v</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">stringlastpos</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">stringlastpos</span> <span class="p">{</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="k">self</span><span class="nf">.delta0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LARGE</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">-=</span> <span class="n">LARGE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">j</span> <span class="o">=</span> <span class="n">patlastpos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="nf">max</span><span class="p">(</span><span class="k">self</span><span class="nf">.delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="k">self</span><span class="py">.delta2</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Find overlapping</span>
    <span class="k">fn</span> <span class="nf">find_all</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span>
    <span class="k">where</span>
        <span class="n">M</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
            <span class="nd">#[coroutine]</span>
            <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">patlen</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="k">self</span><span class="py">.k</span><span class="p">;</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.find</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">i</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>

                    <span class="k">loop</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="n">suffix</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">patlen</span> <span class="o">+</span> <span class="n">k</span> <span class="p">{</span>
                            <span class="k">return</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="k">if</span> <span class="n">suffix</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">patlen</span><span class="o">..</span><span class="n">i</span> <span class="o">+</span> <span class="n">patlen</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="p">[</span><span class="n">patlen</span> <span class="o">-</span> <span class="n">k</span><span class="o">..</span><span class="p">]</span> <span class="p">{</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>

                            <span class="k">yield</span> <span class="n">i</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">else</span> <span class="p">{</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                    <span class="n">base</span> <span class="o">+=</span> <span class="n">shift</span><span class="p">;</span>

                    <span class="n">suffix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">suffix</span><span class="p">[</span><span class="n">shift</span><span class="o">..</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">},</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cd">/// Galil rule shortest period k</span>
<span class="cd">///</span>
<span class="cd">/// k = patlen - prefixlen</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">compute_k</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="k">impl</span> <span class="nb">Eq</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">patlen</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">lastpos</span> <span class="o">=</span> <span class="n">patlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="nf">compute_pi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="n">patlen</span> <span class="o">-</span> <span class="n">pi</span><span class="p">[</span><span class="n">lastpos</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="算法变种">算法变种</h2>

<p><em>也可以叫做只使用 $\Delta_1$ 的算法变种。</em></p>

<h3 id="simplified-boyer-moore-算法">Simplified Boyer-Moore 算法</h3>

<p>BM 算法最复杂的地方就在于构建 $\texttt{delta2}$ 表（有一个通俗的名字，<strong>好后缀</strong> 表）的构建，而实践中一般字符集上的匹配性能只在于 $\Delta_1$ （通俗的名字是 <strong>坏字符</strong> 表）（后面的理论计算也证明了这一点），于是出现了仅仅使用 $\texttt{delta1}$ 表的简化版BM 算法。</p>

<h3 id="boyer-moore-horspol-算法">Boyer-Moore-Horspol 算法</h3>

<p>Horspol 算法同样是基于坏字符的规则，不过是在与 $\texttt{pat}$ 尾部对齐的字符上应用 $\Delta_1$ ，这个效果类似于前文对<a href="#匹配算法的改进">匹配算法的改进</a>，所以它的通常表现优于原始 BM、和匹配算法改进后的 BM 差不多。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">HorspoolPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">M</span><span class="p">:</span> <span class="n">BMMatch</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">_delta1</span> <span class="o">=</span> <span class="nn">M</span><span class="p">::</span><span class="nf">build_delta1_table</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">pat</span><span class="p">,</span> <span class="n">_delta1</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">Eq</span><span class="o">&gt;</span> <span class="n">HorspoolPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">._delta1</span><span class="nf">.get_delta1</span><span class="p">(</span><span class="nb">char</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">stringlen</span> <span class="o">=</span> <span class="n">string</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">patlastpos</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">patlastpos</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringlen</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">patlastpos</span><span class="o">..=</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">patlastpos</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="k">self</span><span class="nf">.delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="boyer-moore-sunday-算法">Boyer-Moore-Sunday 算法</h3>

<p>Sunday 算法同样是利用坏字符规则，只不过相比 Horspool 更进一步，属于是不演了：</p>

<p>既然绝大多数情况下匹配算法做的工作就是在跳适配字符，那么匹配失败后直接关注 $\texttt{pat}$ 尾部对齐的那个字符的下一个字符（因为下一个字符一定也在比较的序列里），从而可以更快地失败。</p>

<p>需要稍微修改一下 $\texttt{delta1}$ 表， 偏移量 $+1$ ，并且将计算尾字符也计算在内。</p>

<p>Sunday 算法通常用作一般情况下实现最简单而且平均表现最好之一的实用算法，通常表现比 Horspool、BM 都要快一点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SundayPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">],</span>
    <span class="n">_delta1</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">GetDelta1</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">M</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">SundayPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">M</span><span class="p">:</span> <span class="n">BMMatch</span> <span class="o">+</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">_delta1</span> <span class="o">=</span> <span class="nn">M</span><span class="p">::</span><span class="nf">build_delta1_table</span><span class="p">(</span><span class="n">pat</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">pat</span><span class="p">,</span> <span class="n">_delta1</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">Eq</span><span class="o">&gt;</span> <span class="n">SundayPattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="nb">char</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">char</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
            <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">._delta1</span><span class="nf">.get_delta1</span><span class="p">(</span><span class="nb">char</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">stringlen</span> <span class="o">=</span> <span class="n">string</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">patlastpos</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">patlastpos</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringlen</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">patlastpos</span><span class="o">..=</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">patlastpos</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">stringlen</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="k">self</span><span class="nf">.delta1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="bmhbnfs-算法">BMHBNFS 算法</h3>

<p><em>是 CPython 实现 <code class="language-plaintext highlighter-rouge">stringlib</code> 模块时用到的 <code class="language-plaintext highlighter-rouge">find</code> 的算法<sup id="fnref:B5S" role="doc-noteref"><a href="#fn:B5S" class="footnote" rel="footnote">4</a></sup>，似乎国内更有名气，不清楚为何叫这个名字，怎么就“AKA”了，以下简称 B5S。</em></p>

<h4 id="既要快">既要快</h4>

<p>该算法属于是还有高手，结合了 Horspool 和 Sunday ，不仅追求快速失败，还要尽量一口气跳过整个 $\texttt{pat}$ ：</p>

<p>先看尾端的下一个字符，如果不能靠这个字符跳过整个 $\texttt{pat}$ ，就再试下尾端的字符。</p>

<h4 id="又要省">又要省</h4>

<p>对于 Horspool 只保留尾字符失配时的 $\Delta_1$ 叫做 $\texttt{skip}$ ；</p>

<p>对于 Sunday 只用一个 $\texttt{pat}$ 上构建的字母表，字母表还要用一个 <em>概率数据结构</em> 来尽可能节省空间，当末尾的下一个字符不在字母表里时直接跳过 $\texttt{patlen} + 1$ 。</p>

<h4 id="bloom-过滤器"><a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom 过滤器</a></h4>

<p>Bloom 过滤器是一种 <em>概率数据结构</em> ，是通过牺牲准确率（和运行时间）来节省存储空间的 <code class="language-plaintext highlighter-rouge">Set</code> 类型的数据结构，存在假阳性（False Positive，FP），也就是集合中不存在的项会被误判为存在，但不存在假阴性（False Negatives，FN），也就是不会把存在的项误判为不存在。</p>

<p>这就像一个筛子一样，把 <strong>一些</strong> 不符合条件的值过滤出去。</p>

<p>一个标准的 Bloom 过滤器，要达到最佳 FP 概率，需要使用多个哈希函数做多次检查，但由此带来的时间常数是不可接受的。</p>

<p>这里简单地通过一个掩码把一部分二进制位映射到数据里，而目前已知最快的非加密哈希算法 xxHash<sup id="fnref:xxHash" role="doc-noteref"><a href="#fn:xxHash" class="footnote" rel="footnote">5</a></sup>，所需时间都要高一个数量级。</p>

<p>考虑做一个 $8$ bit 数据的字母表，一般情况需要 $2^8 = 256$ 个 <code class="language-plaintext highlighter-rouge">bool</code> 空间，用 bit 代替 byte 做存储，可以省掉 $3$ 个信息位，如果再舍弃其中 $2$ 个信息位，那么就只需要 $2^{8-5} = 2^3 = 8$ 个字节也就是一个 <code class="language-plaintext highlighter-rouge">u64</code> 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SimpleBloomFilter</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span> <span class="n">SimpleBloomFilter</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">SimpleBloomFilter</span> <span class="p">{</span> <span class="n">data</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.data</span><span class="p">)</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">elem</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">self</span><span class="py">.data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">elem</span> <span class="o">&amp;</span> <span class="mi">63</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里做得实际就是将一个字节的信息映射为它的前 $6$ 位，原作者建议至少要映射 $5$ 位。</p>

<h4 id="具体实现-2">具体实现</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">B5SSpacePattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">M</span><span class="p">],</span>
    <span class="n">patalphabet</span><span class="p">:</span> <span class="n">SimpleBloomFilter</span><span class="p">,</span>
    <span class="cd">/// patpatlastpos delta1</span>
    <span class="n">skip</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">B5SSpacePattern</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span><span class="n">pat</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">SimpleBloomFilter</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">patalphabet</span> <span class="o">=</span> <span class="nn">SimpleBloomFilter</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="c1">//let mut alphabet = FastBloomFilter::with_rate(p.len(), 0.15);</span>
        <span class="k">let</span> <span class="n">lastpos</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">skip</span> <span class="o">=</span> <span class="n">pat</span><span class="nf">.len</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">pat</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">patalphabet</span><span class="nf">.insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="k">if</span> <span class="n">pat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pat</span><span class="p">[</span><span class="n">lastpos</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">skip</span> <span class="o">=</span> <span class="n">lastpos</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">patalphabet</span><span class="nf">.insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pat</span><span class="p">[</span><span class="n">lastpos</span><span class="p">]);</span>

        <span class="p">(</span><span class="n">patalphabet</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">stringlen</span> <span class="o">=</span> <span class="n">string</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">patlen</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pat</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">patlastpos</span> <span class="o">=</span> <span class="n">patlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">patlastpos</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringlen</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="p">[</span><span class="n">patlastpos</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">patlastpos</span><span class="o">..</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="k">self</span><span class="py">.pat</span><span class="p">[</span><span class="o">..</span><span class="n">patlastpos</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">patlastpos</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">stringlen</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.patalphabet</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                    <span class="c1">// sunday</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="n">patlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// horspool</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="k">self</span><span class="py">.skip</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">stringlen</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.patalphabet</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                    <span class="c1">// sunday</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="n">patlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个算法在通常情况下，在 $O(1)$ 的空间复杂度下却有着最快的时间性能，简直神中神！</p>

<p>只是在特殊的小字符集上的性能表现会回退到 $O(n\cdot m)$，而这是原作者所能接受的。</p>

<h2 id="理论分析">理论分析</h2>

<p>现在我们通过一个简单的概率模型来做一些绝不枯燥的理论分析，借此可以发现一些有趣而更深入的事实。</p>

<h3 id="建立模型">建立模型</h3>

<p>想象一下，我们滑动字符串 $\texttt{pat}$ 到某个新的位置，这个位置还没有完成匹配，我们可以用发现失配所需要的代价与失配后 $\texttt{pat}$ 能够向下滑动的距离的比值来衡量算法的平均性能表现。</p>

<p>假如这个代价是用对 $\texttt{string}$ 的引用来衡量，那么我们就可以知道平均每个字符需要多少次 $\texttt{string}$ 的引用，这是在理论上衡量算法表现的关键指标；</p>

<p>而如果这个代价是用机器指令衡量，那我们可以知道平均每个字符需要多少条机器指令；</p>

<p>当然也可以有其他的衡量方式，这并不影响什么，这里我们采用对 $\texttt{string}$ 的引用进行理论分析。</p>

<p>同时为我们的概率模型提出一个假设：</p>

<p>$\texttt{pat}$，$\texttt{string}$ 中的每个字符是独立随机变量，它们出现的概率相等，为 $p$ ，$p$ 取决于全字母表的大小。</p>

<p>显然，假如全字母表的大小为 $q$ ，则 $p=\dfrac{1}{q}$ ，例如我们基于字节的串匹配算法，可以近似为 $q=\dfrac{1}{256}$。</p>

<p>现在可以更准确地刻画这个比率，$\texttt{rate}(\texttt{patlen}, p)$：</p>

\[\frac{\sum_{m=0}^{\texttt{patlen}-1} \texttt{cost}(m) \times \texttt{prob}(m)}{\sum_{m=0}^{\texttt{patlen}-1} \texttt{prob}(m) \times \sum_{k=1}^{\texttt{patlen}} \texttt{skip}(m,k) \times k }\]

<p>其中，$\texttt{cost}(m)$ 为前面讨论到的在匹配成功了 $m$ 个字符后失配时的代价：</p>

\[\texttt{cost}(m) = m+1\]

<p>$\texttt{prob}(m)$ 为匹配成功 $m$ 个字符后失配的概率（其中 $1-p^{\texttt{patlen}}$ 排除掉 $\texttt{pat}$ 全部匹配的情况）：</p>

\[\texttt{prob}(m) = \frac{p^m(1-p)}{1-p^{\texttt{patlen}}}\]

<p>$\texttt{skip}(m,k)$ 为发生失配时 $\texttt{pat}$ 向下滑动 $k$ 个字符的概率。</p>

<p>实际上所有字符串匹配算法的核心就是 $\texttt{skip}(m,k)$，下面我们会通过分析 $\Delta_1$ 和 $\Delta_2$ 来计算 BoyerMoore 算法的$\texttt{skip}(m,k)$。</p>

<h3 id="计算-textttskipmk">计算 $\texttt{skip}(m,k)$</h3>

<h4 id="delta_1">$\Delta_1$</h4>

<p>首先考虑 $\Delta_1$ 不起作用的情况，也就是发现失配字符在 $\texttt{pat}$ 上重现的位置在已经匹配完的 $m$ 个字符中，这种情况的概率$\texttt{probdelta1-worthless}$为：</p>

\[\texttt{probdelta1-worthless}(m) = 1 - (1-p)^m\]

<p>而对于 $\Delta_1$ 起作用的情况，可以根据 $k$ 的范围分为四种情况进行讨论：</p>

<ol>
  <li>
    <p>$k = 1$</p>

    <p>1.1 失配字符对应位置的下一个字符恰好等于失配字符；</p>

    <p>1.2 失配字符已经是 $\texttt{pat}$ 右手起最后一个字符。</p>
  </li>
  <li>
    <p>$1 \lt k \lt  \texttt{patlen}-m$，$\texttt{pat}$ 在失配字符对应位置的左边还有与失配字符相等的字符，并且不满足 <em>1.</em>；</p>
  </li>
  <li>
    <p>$k = \texttt{patlen} - m$，在失配字符对应位置左边找不到另一个与失配字符相等的字符，并且不满足 <em>1.</em> ，这时 $\texttt{pat}$ 有最大的向下滑动距离；</p>
  </li>
  <li>
    <p>$k \gt \texttt{patlen} - m$，对于 $\Delta_1$，这是不可能存在的情况。</p>
  </li>
</ol>

<p>于是有计算 $\Delta_1$ 的概率函数：</p>

\[probdelta1(m,k) =
\left\{ \begin{array}{lcl}
(1-p)^m\times \left\{ \begin{array}{lcl} 1  &amp; \text{for} &amp;m+1=\texttt{patlen} \\ p &amp;\text{for}&amp;m+1\neq \texttt{patlen}  \\\end{array}\right. &amp; \text{for} &amp; k = 1 \\
(1-p)^{m+k-1}\times p &amp; \text{for} &amp; 1 &lt; k &lt; \texttt{patlen} - m\\
(1-p)^{\texttt{patlen}-1} &amp; \text{for} &amp; k = \texttt{patlen} - m\\
0 &amp; \text{for} &amp; \texttt{patlen} - m &lt; k \leqslant \texttt{patlen}
\end{array}\right.\]

<h4 id="delta_2">$\Delta_2$</h4>

<p>对于 $\Delta_2$ 概率的计算，根据定义，首先计算某个 $\texttt{subpat}$ 的 <em>重现</em> 概率，只要考虑该 <em>重现</em> 左边还有没有字符来提供额外的判断与失配字符是否相等的检查：</p>

\[\texttt{probpr}(m,k) =
\left\{ \begin{array}{lcl}
(1-p)\times p^m &amp; \text{for} &amp; 1 \leqslant k &lt; \texttt{patlen} - m\\
p^{\texttt{patlen}-k} &amp; \text{for} &amp; \texttt{patlen} - m \leqslant k \leqslant \texttt{patlen}
\end{array}\right.\]

<p>于是 $\texttt{delta2}(m,k)$ 就可以通过保证 $\texttt{pr}(m,k)$ 存在并且 $k$ 更小的 $\Delta_2$ 不存在，来递归计算：</p>

\[\texttt{probdelta2}(m,k) = \texttt{probpr}(m,k)(1-\sum_{n=1}^{k-1} \texttt{probdelta2}(m, n))\]

<h4 id="delta_1-cup--delta_2---delta_1-cap--delta_2">$\Delta_1 \cup  \Delta_2 - \Delta_1 \cap  \Delta_2$</h4>

<p>前面已经独立讨论了 $\Delta_1$ ，$\Delta_2$ 的概率函数，不过还需要额外考虑一下这两个概率函数之间相互影响的情况，虽然只是一个很少数的情况：</p>

<p>当 $\texttt{delta2}$ 计算的 $k$ 为 $1$ 的时候，根据 $\Delta_2$ 定义我们就知道</p>

<p>$\texttt{pat}[\texttt{patlen}-m] = \texttt{pat}[\texttt{patlen}-m + 1]\dots =\texttt{pat}[\texttt{patlen}]$</p>

<p>而这种情况已经排除了 $\Delta_1$ 不起作用的情况，因为当如前文讨论的，$\Delta_1$ 不起作用要求与失配字符 $\texttt{pat}[\texttt{patlen}-m]$ 相等的字符出现在 $\texttt{pat}[\texttt{patlen}-m+1]\dots \texttt{pat}[\texttt{patlen}]$ 中， 这就产生了不可能在倒数 $m+1$ 个字符上失配的矛盾。</p>

<p>因此针对 $\Delta_1$ 不起作用的情况需要一个稍微修改过的 $\Delta_2$ 概率函数 ：</p>

\[\texttt{probdelta2'}(m,k) =
\left\{ \begin{array}{lcl}
0 &amp; \text{for} &amp; k = 1\\
\texttt{probpr}(m,k)(1-\sum_{n=2}^{k-1} \texttt{probdelta2}'(m, n)) &amp; \text{for} &amp; 1 \leqslant k \leqslant \texttt{patlen}
\end{array}\right.\]

<p>于是通过组合 $\Delta_1$ 和 $\Delta_2$ 起作用的情况，我们就得到了 BoyerMoore 算法的 $\texttt{skip}$ 概率函数：</p>

\[\texttt{skip}(m,k) = \left\{\begin{array}{lcl}
\texttt{probdelta1}(m, 1) \times \texttt{probdelta2}(m, 1) &amp; &amp; k = 1\\
\\
\\
\\
\texttt{prodelta1 - worthless}(m)\times \texttt{probdelta2'}(m, 1)\\
\quad +\ \texttt{probdelta1}(m, k)\times \sum_{n=1}^{k-1} \texttt{probdelta2}(m, n)\\
\quad +\ \texttt{probdelta2}(m, k)\times \sum_{n=1}^{k-1} \texttt{probdelta1}(m,n)\\
\quad +\ \texttt{probdelta1}(m, k)\times \texttt{probdelta2}(m, k)
&amp; &amp; 1 &lt; k \leqslant \texttt{patlen}
\end{array}\right.\]

<h3 id="分析比较">分析比较</h3>

<p>为了结构清晰、书写简单、演示方便，我们使用 Python 平台的 Lisp 方言 Hy (v0.13) 来进行实际计算：</p>

<p><code class="language-plaintext highlighter-rouge">myprob.hy</code></p>

<pre><code class="language-Hy">(require [hy.contrib.sequences [defseq seq]])

(import [hy.contrib.sequences [Sequence end-sequence]])
(import [hy.models [HySymbol]])


(defmacro simplify-probfn [patlen p probfn-list]
    "(prob-xxx patlen p m k) -&gt; (prob-xxx-s m k)"
    (lfor probfn probfn-list
        [(setv simplified-probfn-symbol (HySymbol (.format "{}-s" (name probfn))))
        `(defn ~simplified-probfn-symbol [&amp;rest args] (~probfn patlen p #*args))]))

(defn map-sum [range-args func]
    (setv [start end] range-args)
    (-&gt; func (map (range start (inc end))) sum))

(defn cost [m] (+ m 1))

(defn prob-m [patlen p m]
    (/
        (* (** p m) (- 1 p))
        (- 1 (** p patlen))))

(defn prob-delta_1 [patlen p m k]
    (cond [(= 1 k) (* (** (- 1 p) m)
                      (if (= (inc m) patlen) 1 p))]
          [(&lt; k (- patlen m)) (* p (** (- 1 p) (dec (+ k m))))]
          [(= k (- patlen m)) (** (- 1 p) (dec patlen))]
          [(&gt; k (- patlen m)) 0]))


(defn prob-delta_1-worthless [p m] (- 1 (** (- 1 p) m)))


(defn prob-pr [patlen p m k] (if (&lt; patlen (+ m k))
                                (* (- 1 p) (** p m))
                                (** p (- patlen k))))


(defn prob-delta_2 [patlen p m]
    "prob-delta_2(_, k) = prob-delta_2-seq[k]"
    (defseq prob-delta_2-seq [n]
        (cond [(&lt; n 1) 0]
              [(= n 1) (prob-pr patlen p m 1)]
              [(&gt; n 1) (* (prob-pr patlen p m n) (- 1 (sum (take n prob-delta_2-seq))))]))
    prob-delta_2-seq)


(defn prob-delta_2-1 [patlen p m]
    (defseq prob-delta_2-1-seq [n]
        (cond [(&lt; n 2) 0]
              [(&gt;= n 2) (* (prob-pr patlen p m n) (- 1 (sum (take n prob-delta_2-1-seq))))]))
    prob-delta_2-1-seq)


(defn skip [patlen p m k prob-delta_2-seq prob-delta_2-1-seq]
    (simplify-probfn patlen p [prob-delta_1])
    (if (= k 1) (* (prob-delta_1-s m 1) (get prob-delta_2-seq 1))
        (sum [(* (prob-delta_1-worthless p m) (get prob-delta_2-1-seq k))
              (* (prob-delta_1-s m k) (sum (take k prob-delta_2-seq)))
              (* (get prob-delta_2-seq k) (map-sum [1 (- k 1)]
                                                  (fn [n] (prob-delta_1-s m n))))
              (* (prob-delta_1-s m k) (get prob-delta_2-seq k))])))


(defn bm-rate [patlen p]
    (simplify-probfn patlen p [prob-m prob-delta_2 prob-delta_2-1 skip])
    (/
        (map-sum [0 (dec patlen)]
            (fn [m] (* (cost m) (prob-m-s m))))

        (map-sum [0 (dec patlen)]
            (fn [m]
                (setv prob-delta_2-seq (prob-delta_2-s m)
                      prob-delta_2-1-seq (prob-delta_2-1-s m))
                (* (prob-m-s m) (map-sum [1 patlen]
                                    (fn [k] (* k (skip-s m k prob-delta_2-seq prob-delta_2-1-seq)))))))))
</code></pre>

<p>并且为了进行比较，还额外计算了简化BM算法:</p>

<p><code class="language-plaintext highlighter-rouge">myprob.hy</code></p>

<div class="language-hy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">simplified-bm-skip</span><span class="w"> </span><span class="p">[</span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">simplify-probfn</span><span class="w"> </span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">[</span><span class="n">prob-delta_1</span><span class="p">])</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-delta_1-s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-delta_1-worthless</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">prob-delta_1-s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">sbm-rate</span><span class="w"> </span><span class="p">[</span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">simplify-probfn</span><span class="w"> </span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">[</span><span class="n">prob-m</span><span class="w"> </span><span class="n">simplified-bm-skip</span><span class="p">])</span><span class="w">
    </span><span class="p">(</span><span class="nb">/</span><span class="w">
        </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">patlen</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">cost</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-m-s</span><span class="w"> </span><span class="n">m</span><span class="p">))))</span><span class="w">

        </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">patlen</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-m-s</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="n">patlen</span><span class="p">]</span><span class="w">
                                        </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="nf">simplified-bm-skip-s</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">)))))))))</span><span class="w">
</span></code></pre></div></div>

<p>和 KMP 算法：</p>

<p><code class="language-plaintext highlighter-rouge">myprob,hy</code></p>

<div class="language-hy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">prob-pi</span><span class="w"> </span><span class="p">[</span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w">
    </span><span class="s">"prob-pi-s(m, l) = prob-pi-seq[m][l]"</span><span class="w">
    </span><span class="p">(</span><span class="nf">defseq</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">[]]</span><span class="w">
              </span><span class="p">[(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="w">
              </span><span class="p">[(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">[(</span><span class="nb">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">]]</span><span class="w">
              </span><span class="p">[(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">lfor</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
                            </span><span class="p">(</span><span class="nb">+</span><span class="w">
                                </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">getone</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="no">:default</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">p</span><span class="p">))</span><span class="w">
                                </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">i</span><span class="p">)))))]))</span><span class="w">
    </span><span class="n">prob-pi-seq</span><span class="p">)</span><span class="w">


</span><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">at-least-1</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">


</span><span class="p">(</span><span class="nb">defn</span><span class="w"> </span><span class="n">kmp-rate</span><span class="w"> </span><span class="p">[</span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">simplify-probfn</span><span class="w"> </span><span class="n">patlen</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="p">[</span><span class="n">prob-m</span><span class="w"> </span><span class="n">prob-pi</span><span class="p">])</span><span class="w">
    </span><span class="p">(</span><span class="nb">setv</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-pi-s</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nb">/</span><span class="w">
        </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">patlen</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">cost</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-m-s</span><span class="w"> </span><span class="n">m</span><span class="p">))))</span><span class="w">

        </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">patlen</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">prob-m-s</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">map-sum</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nf">at-least-1</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">m</span><span class="p">))]</span><span class="w">
                                        </span><span class="p">(</span><span class="nb">fn</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">(</span><span class="nf">skip</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">prob-pi-seq</span><span class="p">)))))))))</span><span class="w">
</span></code></pre></div></div>

<p>然后我们就可以通过Python上的<code class="language-plaintext highlighter-rouge">plotnine</code>图形包看一下计算的数据（并用高斯过程回归拟合曲线）：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">plotnine</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">hy</span>

<span class="kn">from</span> <span class="nn">my_prob</span> <span class="kn">import</span> <span class="n">bm_rate</span><span class="p">,</span> <span class="n">sbm_rate</span><span class="p">,</span> <span class="n">kmp_rate</span>


<span class="n">theme_update</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">element_text</span><span class="p">(</span><span class="n">family</span><span class="o">=</span><span class="s">"SimHei"</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="n">model_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s">'rate'</span><span class="p">:[],</span> <span class="s">'alg'</span><span class="p">:[],</span> <span class="s">'patlen'</span><span class="p">:[]}</span>
    <span class="n">categories_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">bm_rate</span><span class="p">,</span> <span class="s">'BoyerMoore'</span><span class="p">),</span>
                       <span class="p">(</span><span class="n">sbm_rate</span><span class="p">,</span> <span class="s">'S BoyerMoore'</span><span class="p">),</span>
                       <span class="p">(</span><span class="n">kmp_rate</span><span class="p">,</span> <span class="s">'KMP'</span><span class="p">),</span>
                       <span class="p">(</span><span class="k">lambda</span> <span class="n">patlen</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">patlen</span><span class="p">,</span> <span class="s">'$</span><span class="se">\\</span><span class="s">frac{1}{</span><span class="se">\t</span><span class="s">exttt{patlen}}$'</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">alg_fun</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">categories_list</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s">'rate'</span><span class="p">].</span><span class="n">extend</span><span class="p">([</span><span class="n">alg_fun</span><span class="p">(</span>\<span class="n">texttt</span><span class="p">{</span><span class="n">patlen</span><span class="p">},</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">patlen</span> <span class="ow">in</span> <span class="n">model_range</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s">'alg'</span><span class="p">].</span><span class="n">extend</span><span class="p">([</span><span class="n">label</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">model_range</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s">'patlen'</span><span class="p">].</span><span class="n">extend</span><span class="p">(</span><span class="n">model_range</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ggplot</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">aes</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'patlen'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'rate'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'alg'</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">geom_point</span><span class="p">()</span>
            <span class="o">+</span> <span class="n">geom_smooth</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">'gpr'</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">labs</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'Algs'</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s">'$</span><span class="se">\t</span><span class="s">exttt{patlen}$'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'$</span><span class="se">\\</span><span class="s">frac{cost}{skip}$'</span><span class="p">))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">plot(1/256, '$p= \\frac{1}{256}$')</code>：</p>

<div class="sx-center">
<img src="/assets/img/bm/bm_plot256.svg" alt="BM_plot256" style="zoom: 200%;" /></div>

<p>观察这个图像，令人印象深刻的首先就是抬头的一条天蓝色线，几乎笔直地画出了算法性能的下限，不愧是 KMP 算法，$O(n)$ 的时间复杂度，一看就很真实。( ﾟ▽ﾟ)/</p>

<p>接着会发现 BoyerMoore 算法与简化版 BoyerMoore 算法高度重叠的这条红绿紫曲线，同时也是 $\dfrac{1}{\texttt{patlen}}$ ，</p>

<p>这就是在一般字符集下随机文本搜索能达到的$O(\dfrac{n}{m})$的强力算法吗？ (ﾟ△ﾟ;ﾉ)ﾉ</p>

<p>另外此时可以绝大多数的字符跳转依靠 $\Delta_1$（比 $\Delta_2$ 高几个数量），这也是基于 $\texttt{delta1}$ 表的 BM 变种算法最佳的应用场景！</p>

<p>接着我们可以看一下在经典的小字符集，比如在 DNA { A, C, T, G } 碱基对序列中算法的性能表现（<code class="language-plaintext highlighter-rouge">plot(1/4, '$p= \\frac{1}{4}$')</code>）：</p>

<div class="sx-center">
<img src="/assets/img/bm/bm_plot4.svg" alt="BM_plot4" style="zoom:200%;" /></div>

<p>曲线出现了明显的分化，当然 KMP 还是一如既往地稳定。 ( ﾟ▽ﾟ)/</p>

<p>如果此时在测试中监控一下 $\texttt{delta1}$ 表和 $\texttt{delta2}$ 表作用情况，会发现 $\texttt{delta2}$ 起作用的次数超过了 $\texttt{delta1}$ ，而且贡献的跳过字符数更是远超 $\texttt{delta1}$ ，思考下，这件事其实也很好理解。</p>

<p>总结一下，通过概率模型的计算，一方面看到了在较大的字符集，比如日常搜索的过程中 BoyerMoore 系列算法的优越表现，其中主要依赖 $\texttt{delta1}$ 表实现字符跳转；另一方面，在较小的字符集里，$\texttt{delta1}$ 的作用下降，而 $\texttt{delta2}$ 的作用得到体现。</p>

<p>如果有一定富裕空间的情况下，使用完整的空间复杂度为 $O(m)$ 的 BoyerMoore 算法应该是一种适用各种情况、综合表现都很优异的算法选择。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1977BM" role="doc-endnote">
      <p>https://dl.acm.org/doi/10.1145/359842.359859 <a href="#fnref:1977BM" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1977KMP" role="doc-endnote">
      <p>https://epubs.siam.org/doi/abs/10.1137/0206024 <a href="#fnref:1977KMP" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1980Rytter" role="doc-endnote">
      <p>https://epubs.siam.org/doi/10.1137/0209037 <a href="#fnref:1980Rytter" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:B5S" role="doc-endnote">
      <p>https://web.archive.org/web/20040907193754/http://effbot.org/zone/stringlib.htm <a href="#fnref:B5S" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:xxHash" role="doc-endnote">
      <p>https://cyan4973.github.io/xxHash/ <a href="#fnref:xxHash" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/BM.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
