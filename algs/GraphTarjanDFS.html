<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            Tarjan DFS
        
    "
/>

<meta property="og:url" content="//algs/GraphTarjanDFS.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        Tarjan DFS
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="align-items-center justify-content-between h-100">
  <span class="logo" id="topbar-logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </span>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>
  <span id="breadcrumb">

    

    

    

    
  </span><!-- endof #breadcrumb -->
</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">Tarjan DFS</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      May 20, 2023
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p><em>本文资料来源于<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></em></p>

<p>Tarjan 其实是老朋友了，之前介绍过的<a href="/algs/FibHeap.html">斐波那契堆</a>（1986），他就是它的两位作者之一， 现在是要介绍他早期（1972、1973）发表的通过图上 DFS 来线性时间解决<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">3</a></sup>：</p>

<ol>
  <li>在无向图上划分双联通分量</li>
  <li>查找强连通分量</li>
</ol>

<p>其中一些概念也是（可能）后续一些基于 DFS 的算法的基础。</p>

<h2 id="深度优先遍历">深度优先遍历</h2>

<p>对一个连通无向（简单）图，如下所示：</p>

<p><img src="/assets/img/tarjandfs/graph.png" alt="图1" /></p>

<p>（<em>默认按照字母顺序</em>）进行深度优先地图上遍历：</p>

\[\begin{array}{l}
\text{A}\rightarrow \text{B}\rightarrow \text{C}\rightarrow \text{D}\rightarrow &amp;\text{E}\rightarrow &amp;\text{F}\curvearrowright \text{A}\\
&amp;&amp; \text{F}\rightarrow&amp;\text{G}\curvearrowright\text{D}\\
&amp;&amp;&amp;\text{G}\curvearrowright\text{B}\\
&amp;\text{E}\rightarrow&amp;\text{H}\curvearrowright \text{A}\\
&amp;&amp;\text{H}\curvearrowright \text{C}
\end{array}\]

<p>得到一个包含一棵生成树 $\text{T}$ 的有向图 $\text{P}$，并按照访问顺序，从 $1$ 开始给 $\text{P}$ 上每个点编号：</p>

<p><img src="/assets/img/tarjandfs/dfs.png" alt="" /></p>

<p>后面的算法都以 DFS 构建的有向图 $\text{P}$ 为基础，观察它的<strong>回溯边</strong>的情况。</p>

<p><strong>回溯边</strong>，可以分为两种情况：</p>

<ol>
  <li>如上图所示，从某个点回到它的一个祖先节点的一条边，比如 $\text{G}\curvearrowright\text{D}$ ，可以叫它<strong>叶边（frond）</strong>；</li>
  <li>上图没有的，从某个点回到不是它祖先节点（但是也比它更早访问到）的一条边，比如$\text{G}\curvearrowright\text{H}$ ，可以叫它<strong>横叉边（cross link）</strong></li>
</ol>

<p>如果 $\text{P}$ 的所有回溯边都是叶边，那么可以称它为<strong>棕榈树（palm tree）</strong><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>。</p>

<p>可以发现，在任意无向连通图上做 DFS ，构建的有向图 $\text{P}$ 一定是棕榈树；反之任意棕榈树 $\text{P}$ 一定可以由一个它的无向图版本做 DFS 得到。</p>

<p>换言之，无向图 DFS，不存在横叉边。运用反证法：因为是无向图，如果存在横叉边，那么它就应该作为 DFS 过程中生成树上的一条边，而不是回溯边。</p>

<p>根据某个点的所有后代的回溯边所能到达的编号最小的点，引出一个关键概念 – <strong>LOWPT</strong><sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">5</a></sup>：</p>

<p>$\text{lowpt}(v)$ 定义为从 $v$ 出发，经过零个或更多的树弧，和最多一条回溯边，所能到达的编号最小的点（我们不妨用 $\text{index}(v)$ 表示 $v$ 点的编号）。</p>

<h2 id="双联通分量">双联通分量</h2>

<p>有了前面的知识铺垫，我们可以通过 DFS ，首先来解决在无向图上的双连通分量（biconnected component, bcc）的划分问题，而在具体讨论之前，有必要先理清下概念：</p>

<h3 id="概念">概念</h3>

<p><strong>2-连通图</strong></p>

<p>读作 $2$ 点连通图，是 <a href="https://en.wikipedia.org/wiki/K-vertex-connected_graph">$k$ 点连通图</a>的一个实例，也就是一个连通图里有只有删除两个点才能导致图不连通。</p>

<p><strong>双连通图</strong></p>

<p>双联通图（biconnected graph）大多数情况下和 2-连通图（2-connected graph）是等价的，只在一个例外，就是只包含一条边的图仍然是双联通图，但一般不被视为 2-连通图<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">6</a></sup><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">7</a></sup>。</p>

<p>双连通图之所以有这么个特殊例外，就是为了方便把图按双连通分量进行划分，对剩下的散碎边，每条边都可以视为一个最小的双连通分量。</p>

<h3 id="算法">算法</h3>

<p>划分双连通分量的关键在于寻找分量之间的衔接点（articulation point）<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>。</p>

<p>衔接点可以利用计算的 $\text{lowpt}$ 寻找：在 DFS 构建的有向图 $\text{P}$ 上，如果一个点的 $\text{lowpt}$ 不低于它的父节点的编号，那么它的父节点就是一个衔接点。</p>

<p>比如，对于下图</p>

<p><img src="/assets/img/tarjandfs/bcc_raw.png" alt="" /></p>

<p>DFS 构建的有向图：</p>

<p><img src="/assets/img/tarjandfs/bcc_tree.png" alt="" /></p>

<p>上图 G 点的 $\text{lowpt}(3)=2=\text{index}(2)$ ，因此 $3$ 的父节点 $2$ 就是一个衔接点，如果此时把之前遍历过程中入栈的边 $2\rightarrow 3$ ，$3\rightarrow 4$，$4\rightarrow2$ 从栈顶依次弹出，那么就收集了一个双联通分量的划分。</p>

<p>最终如下图：</p>

<p><img src="/assets/img/tarjandfs/bcc_bccs.png" alt="" /></p>

<p>伪代码有些吃力不讨好，不如直接看实现</p>

<h3 id="实现">实现</h3>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.6/coll_graph/src/bcc.rs">源代码</a></p>

<h4 id="数据结构">数据结构</h4>

<p>每个点要保存它的 DFS 编号和 $\text{lowpt}$ ，用 <code class="language-plaintext highlighter-rouge">Option</code> 类型指示该点是否被访问。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">DFSMeta</span> <span class="p">{</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lowpt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="整体过程">整体过程</h4>

<p>把图中每个点从 $1$ 开始编号，使用一个数组保存它们的元信息。</p>

<p>对图上每个点遍历，如果该点没有被标记过，就执行 DFS 子过程，这么做是考虑到给定的图不一定是连通的，需要在不同分量上分别进行 DFS。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">bcc_tarjan</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bccs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">g</span><span class="py">.e</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">bccs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">DFSMeta</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span> <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">u</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_bcc</span><span class="p">(</span>
                <span class="n">g</span><span class="p">,</span>
                <span class="n">u</span><span class="p">,</span>
                <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bccs</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stack</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">index</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vertexs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">bccs</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dfs-子过程">DFS 子过程</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dfs_bcc</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">bccs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">stack</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">vertexs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DFSMeta</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFSMeta</span> <span class="p">{</span>
        <span class="n">index</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">),</span>
        <span class="n">lowpt</span><span class="p">:</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">stack</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
            <span class="nf">dfs_bcc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">bccs</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowpt</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="p">{</span>
                <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowpt</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">==</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="p">{</span>
                <span class="c1">// u is cut point</span>
                <span class="c1">// get biconnected component</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">bcc</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

                <span class="k">loop</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nd">ordered_insert!</span><span class="p">(</span>
                        <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bcc</span><span class="p">,</span>
                        <span class="k">if</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span> <span class="p">{</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="p">}</span>
                    <span class="p">);</span>

                    <span class="k">if</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">u</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="nd">ordered_insert!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">bccs</span><span class="p">,</span> <span class="n">bcc</span><span class="p">,</span> <span class="p">|</span><span class="n">bcc</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">|</span> <span class="n">bcc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">p</span> <span class="p">{</span>
            <span class="n">stack</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="p">{</span>
                <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowpt</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>部分参数解释</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">p</code>，对于无向（简单）图，需要传一个父节点参数 $p$ 来标记“来边”；</li>
  <li><code class="language-plaintext highlighter-rouge">bccs</code> 保存划分出的双连通分量的边集，用边集而不是点集是因为双连通分量之间有点是有交合的（就是衔接点），但是边集是不相交的；</li>
  <li><code class="language-plaintext highlighter-rouge">stack</code> 保存 DFS 过程访问过的边，用来发现衔接点后收集新的双连通分量的边；</li>
  <li><code class="language-plaintext highlighter-rouge">index</code> 点访问的顺序</li>
</ol>

<p><strong>过程解释</strong></p>

<p>初始化被访问点的编号 $\text{index}$ 和 $\text{lowpt}$ ，其中 $\text{lowpt}$ 初始化的时候与编号一致。</p>

<p>遍历访问点 $u$ 所有的出边，如果出边的头节点 $v$ 未被编号，就推边入栈，并在 $v$ 上执行 DFS 操作，之后利用 $\text{lowpt}(v)$ 更新 $\text{lowpt}(u)$ ，并检查 $\text{lowpt}(v)$ 是否不小于 $\text{index}(u)$ <sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">9</a></sup>，如果是，就收集栈上的边，直到收集完起点为 $u$ 的边<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">10</a></sup>；</p>

<p>如果 $v$ 已被编号，就用它的编号更新 $\text{lowpt}(u)$ ，当然要排除父节点的情况，避免重复访问同一条边。</p>

<p>另外如果对边集里的边和边集的顺序有要求，那么这个过程还要额外进行一个排序。</p>

<p><strong>ordered_insert</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_export]</span>
<span class="nd">macro_rules!</span> <span class="n">ordered_insert</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$vec:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="nv">$vec</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">vec</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec</span><span class="p">[</span><span class="n">oldidx</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">vec</span><span class="nf">.insert</span><span class="p">(</span><span class="n">inseridx</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                <span class="nb">None</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
    <span class="p">(</span><span class="nv">$vec:expr</span><span class="p">,</span> <span class="nv">$x:expr</span><span class="p">,</span> <span class="nv">$f:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="nv">$vec</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nv">$f</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">vec</span><span class="nf">.binary_search_by_key</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">oldidx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec</span><span class="p">[</span><span class="n">oldidx</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
            <span class="p">},</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">inseridx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">vec</span><span class="nf">.insert</span><span class="p">(</span><span class="n">inseridx</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                <span class="nb">None</span>
            <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度">时间复杂度</h3>

<p>不考虑对结果的标准化问题，时间复杂度显然为 $O(V)+O(E)$</p>

<h2 id="强连通分量">强连通分量</h2>

<p>前面讲了无向图上双连通分量的划分，但对于有向图而言，DFS 将不会是一个简单的棕榈树的结构，因为边的方向是固定的，而不是双向都可以的，但（据作者说：“The more complicated structure which results in this case is still simple enough to prove useful in at least one application.”）</p>

<p>不过不管那些，还可以用一个与上述算法非常相似的过程解决有寻找<strong>向图上的强连通分量问题（strong connected component，scc）</strong>。</p>

<h3 id="算法-1">算法</h3>

<p>如果从一个点出发，最后又回到了该点，那么这个点就是强连通分量的根节点。也就是说，如果在 $u$ 点的所有出边 DFS 结束后，发现 $\text{index}(u)=\text{lowpt}(u)$ ，那么 $u$ 就是一个强连通分量的根节点，而此时收集栈上所有编号大于 $u$ 的点，就得到了这个强连通分量的点集。</p>

<h3 id="实现-1">实现</h3>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.6/coll_graph/src/scc.rs">源代码</a></p>

<p>数据结构</p>

<p>新字段 <code class="language-plaintext highlighter-rouge">on_stack</code> 用来指示当前节点是否在栈上，这样相比用单独的哈希集合来维护，有更好的局部性。而之所以要检查节点是否在栈上，后面会解释。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">struct</span> <span class="n">DFSMeta</span> <span class="p">{</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lowlink</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">on_stack</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="整体过程-1">整体过程</h4>

<p>和划分 BCC 时一样，区别只在于，使用了点集取代边集，这是因为只需要寻找从 SCC 而不是对图进行划分。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">scc_tarjan</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">comps</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">g</span><span class="py">.e</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">comps</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">max_v</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">DFSMeta</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span> <span class="n">max_v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">u</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_scc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">comps</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">stack</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vertexs</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">comps</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="dfs子过程">DFS子过程</h4>

<p>同样类似于划分 BCC ，需要注意得是在 DFS 过程中，由于是有向图，所以要考虑 $u$ 的出边节点 $v$ 不与它在同一 SCC 的情况，判断方法是：如果不在同一 SCC ，那么在 DFS 过程中必然已经划分到其他的 SCC 中去了，因此已经从栈上弹出了，所以只需要检查该点是否还在栈上就可以，这就是 <code class="language-plaintext highlighter-rouge">on_stack</code> 字段的作用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dfs_scc</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">comps</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">stack</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">vertexs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DFSMeta</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFSMeta</span> <span class="p">{</span>
        <span class="n">index</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">),</span>
        <span class="n">lowlink</span><span class="p">:</span> <span class="o">*</span><span class="n">index</span><span class="p">,</span>
        <span class="n">on_stack</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="o">*</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">dfs_scc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vertexs</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="p">{</span>
                <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.lowlink</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span>
        <span class="o">&amp;&amp;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.on_stack</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="p">{</span>
                <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* start a new scc */</span>

    <span class="k">if</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.lowlink</span> <span class="o">==</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="py">.index</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">new_comp</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">ordered_insert!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">new_comp</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
            <span class="n">vertexs</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="py">.on_stack</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">u</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nd">ordered_insert!</span><span class="p">(</span><span class="n">comps</span><span class="p">,</span> <span class="n">new_comp</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">|</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>不考虑对结果的标准化问题，时间复杂度显然为 $O(V)+O(E)$</p>

<h3 id="无向图">无向图</h3>

<p>显然上述求取有向图上 SCC 的算法也完全适应于求取无向图上的连通分量问题。一般使用并查集（multiset union, disjoint set union, union find, etc.）直接计算的话，每条边需要额外付出并查集的 $O(\text{log}(V))$ 的时间复杂度，表现要差于 Tarjan 算法。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://scholar.google.com/scholar?oi=bibs&amp;cluster=15533190727229683002&amp;btnI=1&amp;hl=en">Depth-first search and linear graph algorithms</a> R Tarjan - SIAM journal on computing, 1972 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://scholar.google.com/scholar?oi=bibs&amp;cluster=15317103615758324241&amp;btnI=1&amp;hl=en">Algorithm 447: efficient algorithms for graph manipulation</a> J Hopcroft, R Tarjan - Communications of the ACM, 1973 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:9" role="doc-endnote">
      <p>第二篇论文还提到了在双联通分量上的简单路径划分，但是既缺乏具体解释，流程图也模糊不清，伪代码还是 goto 结构的，令人实在没有时间去看了 <a href="#fnref:9" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>“棕榈树”和“叶边”都是作者在论文<sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>里起的形象名字 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>曾经，在第一篇论文里，作者提出的<strong>LOWPT</strong>的定义是：“That is, LOWPT(v) is the smallest vertex reachable from v by traversing zero or more tree arcs followed by at most one frond. ”；还提出了另外一个相似的概念 <strong>LOWLINK</strong>：“That is, LOWLINK (v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one frond or cross-link.” 。这两者的本质上显然是相同的，区别只在于一个是应用在无向图上（划分bcc）所以回溯边只经过叶边，而另一个是应用在有向图上（划分scc）所以回溯边可能经过叶边或者横叉边，至于“在同一个分量里”的说法，只能说是回溯的必然结果，而不是限制。而在第二篇论文里，作者也不再区分，而是统一使用了LOWPT。 <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Biconnected_graph# <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>当然单点图，也就是不含边的图既不是双连通图也不是2-连通图 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>也就是割点（cut point），但是割点有些抽象，我们不会进入那个领域 <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:10" role="doc-endnote">
      <p>这里直接检查了 $\text{lowpt}(u)$ 是否被更新得更小 <a href="#fnref:10" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:11" role="doc-endnote">
      <p>注意栈上的顺序与访问的顺序是反向的 <a href="#fnref:11" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <span>
        <a href="/">
          <img src="/assets/img/icons/home.png" class="pl-4 pb-4">
        </a>
      </span>
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/GraphTarjanDFS.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
