<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            0336 - Palindrome Pairs
        
    "
/>

<meta property="og:url" content="//algs/LeetCode0336.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        0336 - Palindrome Pairs
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="align-items-center justify-content-between h-100">
  <span class="logo" id="topbar-logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </span>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>
  <span id="breadcrumb">

    

    

    

    
  </span><!-- endof #breadcrumb -->
</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">0336 - Palindrome Pairs</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      July 12, 2023
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p><em>通常为了分类页面的干净，不将LeetCode题解的文章放到算法分类里，但这一篇实在精彩，涉及了其他算法没有介绍过的，关于大量子串比较的通解性思路</em></p>

<h2 id="题干">题干</h2>

<p><a href="https://leetcode.com/problems/palindrome-pairs/description/">问题描述</a></p>

<h2 id="破题">破题</h2>

<p><a href="https://github.com/minghu6/leet-code/tree/v0.1.7/0335_palindrome_pairs">源代码</a></p>

<p>有必要特别强调下这道题的数据特点：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 &lt;= words.length &lt;= 5000</code></li>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= words[i].length &lt;= 300</code></li>
  <li><code class="language-plaintext highlighter-rouge">words[i]</code> consists of lowercase English letters.</li>
</ul>

<p>如果单从题目名字出发，认为这是一个核心在于用更低时间复杂度寻找回文串的问题，那就是从根本上搞错了方向。</p>

<p>把单词数记为 $n$ ，单词长度记为 $k$ ：</p>

<ol>
  <li>这里情况是 $n$ 比 $k$ 高一个数量级，性能瓶颈首先在于单词数而不是单词长度；</li>
  <li>在 300 这个长度上，$O(k^2)$ 的简单算法通常远远好于时间复杂度为 $O(k)$ 的那些复杂算法</li>
</ol>

<p>而这个问题实际上，如果是每个单词两两比较，那么无论如何都会 TLE（Time Limit Exceed），必须寻找一种能降低单词数的时间复杂度的方法。</p>

<p>这也就引出了本文介绍的大量子串比较的通解性思路。</p>

<p><strong>Tips:</strong></p>

<ul>
  <li>给出的每个单词都是独特的；</li>
  <li>在答案里排除标号相同，也就是单词自身就是回文的情况</li>
</ul>

<h2 id="解-trie">解① Trie：</h2>

<p>当提到多个子串的比较时，我们就可以想到前缀树（Trie）这种思路<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>，我们用它保存每个单词的后缀<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。</p>

<p>如果作为前缀的单词长度 $\geqslant$ 作为后缀的单词长度：</p>

<p>在单词后缀的最后一个字母上标记单词的索引，表示这是一个单词的结束，此时应该检查前缀单词的其余部分是否为空或者是一个回文串。</p>

<p>否则：</p>

<p>在把单词加入到 Trie 的时候，后缀每向前一位，就要检查下剩余部分是否构成一个回文串，如果是的话，就把这个单词的索引储存在到该位置节点里。</p>

<p>节点的结构如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PostfixTrieNode</span> <span class="p">{</span>
    <span class="n">is_word</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">rest_palindromes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">26</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">PostfixTrie</span> <span class="p">{</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PostfixTrieNode</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">is_word</code> 是当前缀单词长度较长或相等时，表示有一个后缀单词结束了，保存该后缀单词的索引；</li>
  <li><code class="language-plaintext highlighter-rouge">rest_palindromes</code> 是当前缀单词较短，表示当前缀单词结束后，后缀的其余部分仍然构成回文的那些单词的索引；</li>
  <li><code class="language-plaintext highlighter-rouge">children</code> 保存 Trie 下一级节点（的索引），保存索引而不是节点本身，是为了规避 Rust 严格的数据所有权检查</li>
</ul>

<p>树的创建和节点的创建：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">PostfixTrie</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">PostfixTrieNode</span><span class="p">::</span><span class="nf">new</span><span class="p">()],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">push_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">node_i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.push</span><span class="p">(</span><span class="nn">PostfixTrieNode</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="py">.children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node_i</span><span class="p">);</span>

        <span class="n">node_i</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">PostfixTrieNode</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">is_word</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">rest_palindromes</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
            <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="nb">None</span><span class="p">;</span> <span class="mi">26</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>根节点就是索引为 $0$ 的节点。</p>

<p><strong>加入一个单词：</strong></p>

<p>对于一个长度为 $k$ 的单词来讲，需要考虑从没有匹配到匹配到最后一个字符，一共 $k$ 种情况，其中没有匹配针对的前缀是空串的情况。最后在最后一个字符的 Trie 节点上打上单词结束的标记。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">PostfixTrie</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">add_word</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">word_i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="o">..=</span><span class="n">word</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.rest_palindromes</span><span class="nf">.push</span><span class="p">(</span><span class="n">word_i</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">rank</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.push_child</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.is_word</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">word_i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>搜索匹配</strong></p>

<p>搜索匹配的时候，稍微复杂一些，必须跟踪匹配的情况，如果前缀单词遍历完后没有发生失配，就需要检查此时是否也是后缀单词的一个结束（也就是前后缀长度相等的情况）并且把可能的后缀单词中没结束并且剩余部分是回文加入答案。</p>

<p>追踪匹配，在循环外单独处理有一个好处，就是适用于前缀是空串的情况。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">PostfixTrie</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">search_palindrome</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">word_i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">matched</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">word</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.is_word</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">pairs</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">word_i</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">rank</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.children</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">matched</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="py">.is_word</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">word_i</span> <span class="p">{</span>
                    <span class="n">pairs</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">word_i</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">pairs</span><span class="nf">.extend</span><span class="p">(</span><span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
                <span class="py">.rest_palindromes</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.cloned</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">j</span><span class="p">|</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">word_i</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">])</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">pairs</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>完整过程：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">words</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">trie</span> <span class="o">=</span> <span class="nn">PostfixTrie</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">trie</span><span class="nf">.add_word</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="nf">.as_bytes</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ans</span><span class="nf">.extend</span><span class="p">(</span><span class="n">trie</span><span class="nf">.search_palindrome</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="nf">.as_bytes</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>总结：</strong></p>

<p>总地来说 Trie 也并不能特别地节省内存，总长度为 $n$ 的串存储到 Trie 上也仍然需要 $O(n)$ 的时间复杂度，唯一明显好处是可以缩短单词地匹配范围，把单词比较次数从原来的 $O(n^2)$ 降低为 $O(n)$ 。</p>

<p>对于本题，Rust Trie 实现大概是 276 ms / 373 MB 的水平<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup>。</p>

<p>这个级别的内存消耗显然过分了，特别是对于 Rust 而言，按照以往经验，一个好的 Rust 题解的内存消耗应该在 10 MB 以内，几百 MB 的消耗与其他语言相比也非常糟糕；</p>

<p>时间性能勉强还算可以，我知道 C++ 的题解里的最好地有 200+ ms ，而 Java 的题解最好地可以达到 100+ ms<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">4</a></sup> ，相较之下，这个表现显然还不够好。</p>

<h2 id="解-长度基数">解② 长度基数：</h2>

<p>这个思路非常类似于基数排序，它成立的关键是单词的长度非常有限，如果能事先哈希所有的单词，然后遍历每个单词的时候根据它的长度范围，构造后缀，在哈希表上查找符合后缀的单词。</p>

<p>对于每个单词检查所有长度不超过它的单词，在做回文对判断时，必须要有较长的那一个单词的信息，然后才能根据它的后缀，检查可能的较短的那个词是否存在，不管它们哪一个在前，哪一个在后。</p>

<p><strong>时间优化：</strong></p>

<p>可以事先统计所有单词的长度，排除掉实际上不存在的长度可能。</p>

<p><strong>空间节省：</strong></p>

<p>在做单词哈希的时候，并不保存单词的反串儿，而是原串的分片，而在查询的时候动态创建反串，这利用了回文的对称性质，哈希表上保存的分片只是原串的引用，不必因此创建新的字符串，而搜索时创建的反串又是一次性的，我们可以非常有把握地认为优化会这个反串分配的空间会被重新利用。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">words</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">words_map</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">len_maps</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">words_map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">word</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">len_maps</span><span class="nf">.insert</span><span class="p">(</span><span class="n">word</span><span class="nf">.len</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">lens</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">len_maps</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">word</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.as_bytes</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">rev_word</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">word</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.len</span><span class="p">();</span>

        <span class="k">for</span> <span class="o">&amp;</span><span class="n">k</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">lens</span><span class="p">[</span><span class="o">..</span><span class="n">lens</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="c1">// word is prefix</span>
            <span class="c1">// word[0..k] =R= rev_word[0..k]</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">words_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rev_word</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">..</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">[</span><span class="n">k</span><span class="o">..</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">i</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// word is postfix</span>
            <span class="c1">// word[n-k..] =&gt; rev_word[n-k..]</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">words_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rev_word</span><span class="p">[</span><span class="o">..</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">word</span><span class="p">[</span><span class="o">..</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">words_map</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rev_word</span><span class="p">[</span><span class="o">..</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">word</span> <span class="o">&gt;</span> <span class="n">rev_word</span> <span class="p">{</span>
                <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">i</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
                <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="n">j</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="k">as</span> <span class="n">_</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>


<span class="cd">/// Quickest method on len(word) &lt;= 300</span>
<span class="nd">#[inline]</span>
<span class="k">fn</span> <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">s</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.eq</span><span class="p">(</span><span class="n">s</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>总结：</strong></p>

<p>单词长度的统计和排序是 $O(n\text{log}n)$ ，对于本题，$\text{log}n$ 相当于一个非常小的常数，因此这段开销可以忽略不计，而相比于 Trie 解，不需要检查每个串的所有后缀是否是回文，而只检查部分后缀（存在该长度的串），并且有更好的局部性，因此提高了性能。</p>

<p>性能表现：107 ms / 6.6 MB 。</p>

<p>运行时间比 Trie 快了一倍，但也只是和 Java 的最好情况打平，只能说差强人意，不过内存的占用控制在 10 MB 以内，还是令人非常满意的。</p>

<h2 id="解-串排序">解③ 串排序：</h2>

<p>有什么能比长度基数的比较更快的方法吗？</p>

<p>在前面基数长度的题解中，仍然是有无谓地单词比较，最好的办法是能只比较确定有共同回文部分的串。</p>

<p>这个方法的思路并没有出现在热门题解中，是我从 Python 的最佳提交中看来的，非常简单，而且具有通用性，在很多其他问题上也有这样的处理思路。</p>

<p>如果把所有单词的正串和反串放在一起排序，那么按照字符串比较的字典序<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>，会有如下几个关键性质：</p>

<ol>
  <li>
    <p>有最长公共前缀的字符串会紧挨在一起，而且短的在前，长的在后，不管它们是正串还是反串，这都不影响回文的判断；</p>
  </li>
  <li>
    <p>如果存在构成回文对的一对单词的正反串，那么其中的短串一定是长串的前缀，而且两个串的正反性是不同的；</p>
  </li>
  <li>
    <p>反之从某个串 $s_i$ 的位置 $i$ 向后检查，如果发现了一个前缀不包含 $s_i$ 的串 $s_j$ ，那显然 $s_j$ 以及之后的串肯定不与 $s_i$ 构成回文对</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">words</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">words_and_revs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">words</span><span class="nf">.len</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.into_bytes</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">forward</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

        <span class="n">words_and_revs</span><span class="nf">.push</span><span class="p">((</span><span class="n">forward</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">));</span>
        <span class="n">words_and_revs</span><span class="nf">.push</span><span class="p">((</span><span class="n">backward</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">words_and_revs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">short_is_forward</span><span class="p">,</span> <span class="n">short_i</span><span class="p">))</span> <span class="k">in</span>
        <span class="n">words_and_revs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">long</span><span class="p">,</span> <span class="n">long_is_forward</span><span class="p">,</span> <span class="n">long_i</span><span class="p">)</span> <span class="k">in</span> <span class="n">words_and_revs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">short_is_forward</span> <span class="o">==</span> <span class="n">long_is_forward</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">long</span><span class="nf">.starts_with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">short</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">long_i</span> <span class="o">!=</span> <span class="n">short_i</span> <span class="o">&amp;&amp;</span> <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">long</span><span class="p">[</span><span class="n">short</span><span class="nf">.len</span><span class="p">()</span><span class="o">..</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="o">*</span><span class="n">long_is_forward</span> <span class="p">{</span>
                        <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="o">*</span><span class="n">long_i</span><span class="p">,</span> <span class="o">*</span><span class="n">short_i</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="o">*</span><span class="n">short_i</span><span class="p">,</span> <span class="o">*</span><span class="n">long_i</span><span class="p">]);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>总结：</strong></p>

<p>排序的方法省掉了所有不必要的串的比较，只检查每个前后缀对称的单词对儿一次回文，局部性也不错，拥有理论和实际的最佳时间性能，唯一难受的点在于数据读取的方向是固定的，没有高效的从后向前读的方法，这使得我们不得不实际上为每一个反串创建一份正向的版本，这增加了一些内存的开销。</p>

<p>性能表现：61 ms / 7.7 MB</p>

<p>没什么好说的，就是双优地时、空表现。</p>

<h3 id="串排序内存节省版本">串排序（内存节省版本）</h3>

<p>接下来我们带着做实验的心态，尝试用无实体数据的方法表示反串，从而节省内存。</p>

<p>静态类型语言要求严格地向量是单态的，因此对于正串和反串，都需要同一类型的包装，需要实现它们的比较方法：</p>

<p>显然由于反串的存在，它们的比较方法只能逐个字节进行，这不影响时间复杂度，但很可能极大地影响实际的性能。</p>

<p>这里使用堆上地动态 Trait 对象来统一正串和反串创建的两种不同的迭代器。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">struct</span> <span class="n">Slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="n">dir</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">is_forward</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">raw</span><span class="p">,</span> <span class="n">dir</span><span class="p">:</span> <span class="n">is_forward</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[inline]</span>
    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.dir</span> <span class="p">{</span>
            <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="py">.raw</span><span class="nf">.iter</span><span class="p">())</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="k">self</span><span class="py">.raw</span><span class="nf">.len</span><span class="p">();</span>

            <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_fn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">}</span>
            <span class="p">}))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="nb">PartialOrd</span> <span class="k">for</span> <span class="n">Slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="n">other</span><span class="nf">.iter</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="nb">Ord</span> <span class="k">for</span> <span class="n">Slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同时由于不存在实际的串结构，那么 <code class="language-plaintext highlighter-rouge">startswith</code> 和余部回文检测的方法也要改写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Slice</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>    
	<span class="k">fn</span> <span class="nf">starts_with</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.iter</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">e</span> <span class="k">in</span> <span class="n">other</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">pe</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">true</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">rem_is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">skipped</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.dir</span> <span class="p">{</span>
            <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="n">skipped</span><span class="o">..</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">is_palindrome_or_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.raw</span><span class="p">[</span><span class="o">..</span><span class="k">self</span><span class="nf">.len</span><span class="p">()</span><span class="o">-</span><span class="n">skipped</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>主过程方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">solve</span><span class="p">(</span><span class="n">words</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">words_and_revs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">words</span><span class="nf">.len</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">in</span> <span class="n">words</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">words_and_revs</span><span class="nf">.push</span><span class="p">((</span><span class="nn">Slice</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">word</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="k">true</span><span class="p">),</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">));</span>
        <span class="n">words_and_revs</span><span class="nf">.push</span><span class="p">((</span><span class="nn">Slice</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">word</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="k">false</span><span class="p">),</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">words_and_revs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">short_i</span><span class="p">))</span> <span class="k">in</span>
        <span class="n">words_and_revs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">long</span><span class="p">,</span>  <span class="n">long_i</span><span class="p">)</span> <span class="k">in</span> <span class="n">words_and_revs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">short</span><span class="py">.dir</span> <span class="o">==</span> <span class="n">long</span><span class="py">.dir</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">long</span><span class="nf">.starts_with</span><span class="p">(</span><span class="o">&amp;</span><span class="n">short</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">long_i</span> <span class="o">!=</span> <span class="n">short_i</span> <span class="o">&amp;&amp;</span> <span class="n">long</span><span class="nf">.rem_is_palindrome_or_empty</span><span class="p">(</span><span class="n">short</span><span class="nf">.len</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">long</span><span class="py">.dir</span> <span class="p">{</span>
                        <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="o">*</span><span class="n">long_i</span><span class="p">,</span> <span class="o">*</span><span class="n">short_i</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="k">else</span> <span class="p">{</span>
                        <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="o">*</span><span class="n">short_i</span><span class="p">,</span> <span class="o">*</span><span class="n">long_i</span><span class="p">]);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>总结：</strong></p>

<p>运行性能：323 ms / 5.8 MB</p>

<p>动态地逐字节比较确实非常慢，但确实省到了内存，至少内存上可以说 beats 100% 。</p>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>很多批量查询地算法都使用了这种结构，比如基于KMP 前缀数组和 Trie 的 AC 自动机（AC Automaton） <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>或者每个单词串的反串儿的前缀 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>有一种看起来会节省内存的调整是把节点上为孩子预先分配的数组结构换成哈希表，但这不改变结构的本质上，毕竟哈希表的基础也是数组，只是时间与空间的平衡因子不同，实际测试结果也支持了这样的判断：换成哈希表后消耗的空间减半，但运行时间加倍 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>很符合我对 C++ 的一贯想象，值得一提的是 LeetCode 平台使用得还是 clang ，如果是 gnu g++ 那局面更不敢想象了 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>线性结构的比较默认采用字典序，它可以这样理解：从首元素开始两两比较，直到发现不同元素或者两个串都耗尽，较短的那一个串后面补空，相当于是权值最小的元素。但是有时候有些领域为了它们的某些方便，会判断较短的串一定比较长的串要小，但这种比较方法不能称之为字典序 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <span>
        <a href="/">
          <img src="/assets/img/icons/home.png" class="pl-4 pb-4">
        </a>
      </span>
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/LeetCode0336.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
