<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            斐波那契堆的实作 (for Rust)
        
    "
/>

<meta property="og:url" content="//algs/FibHeapImplRust.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        斐波那契堆的实作 (for Rust)
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="align-items-center justify-content-between h-100">
  <span class="logo" id="topbar-logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </span>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>
  <span id="breadcrumb">

    

    

    

    
  </span><!-- endof #breadcrumb -->
</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">斐波那契堆的实作 (for Rust)</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      November 13, 2022
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p>算法理论部分，在上一篇论文 <strong><a href="/algs/FibHeap.html">Fibonacci Heap</a></strong> 已经讲完了，下面是干活的部分<sup id="fnref:rust-impl" role="doc-noteref"><a href="#fn:rust-impl" class="footnote" rel="footnote">1</a></sup>：</p>

<h2 id="语言特定">语言特定</h2>

<h3 id="数据共享可变性与非null对象">数据共享、可变性与非null对象</h3>

<p>Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针  <code class="language-plaintext highlighter-rouge">Rc</code> (reference counter) 代替直接的指针，使用 <code class="language-plaintext highlighter-rouge">RefCell</code> 来“作弊“地绕开可变性检查，使用 <code class="language-plaintext highlighter-rouge">Option</code> 取代传统含 <code class="language-plaintext highlighter-rouge">null</code> 对象。但是这不可避免地使代码显得冗长，按说应该有语法糖或者辅助结构来做这件事，但是没有，这也是 Rust1 诸多不完美地方中的一处，好在可以通过写一点儿宏来解决这个问题。</p>

<h3 id="计数指针的强弱引用">计数指针的强弱引用</h3>

<p>另外的问题在于双向索引的链表结构会造成计数指针的循环引用，这会造成内存泄露的问题。Rust 提供了 <code class="language-plaintext highlighter-rouge">Weak</code> 计数指针的弱引用来解决这个问题。使用弱引用有两个方案：</p>

<ol>
  <li>所有正向引用（从左到右，从上到下）是正常的强引用，而反向引用（从右到左，从下到上）是弱引用，唯一例外是根链表，这只要在释放的时候手动去掉一个强引用，打破强引用的循环就可以了。</li>
  <li>所有引用都是弱引用，只在堆的头部的索引里保留唯一的强引用。</li>
</ol>

<p>方案 2 的好处是不需要在算法里区分强弱引用和做强弱转换，省事省心；但方案 1 的好处在于不依赖外部维持的强引用，每个节点都可以分型地单独使用，更符合个人美感所以暂时选择方案 1 。</p>

<h3 id="宏机制">宏机制</h3>

<p>最后是展开说明 Rust 的宏机制，它是 Rust 集众家之长，也是目前为止综合起来，最令我满意的宏机制的实现方案，虽然也有应有未有的地方。</p>

<p>Rust 的宏分为两种 ： 预处理宏（procedure macro）和声明式宏（declare macro）。</p>

<p><strong>预处理宏</strong></p>

<p>预处理宏是顾名思义，展开在提前的、单独的一遍扫描过程里，可以做到声明式宏做不到的所有，比如创造新的 Token 节点，但是没有语义感知，需要放置在单独的 crate 里面，编写使用也麻烦一点。</p>

<p><strong>声明式宏</strong></p>

<p>声明式宏名字并没有那么直观，是嵌在源文件中，和普通代码在同一过程中展开，有特殊的 <code class="language-plaintext highlighter-rouge">$crate</code> 指名当前所属 Crate ，功能相对受限，无法创建新的 Token，另外在实现上也有一些不体面的地方，不能说很健壮，但勉强说是够用了。</p>

<p>这里我们直接使用声明式宏来补充该有的语法糖。</p>

<h3 id="生命周期对引用的限制">生命周期对引用的限制</h3>

<p>同样不同于传统的编程模型，Rust 引入了生命周期的概念，区别于一般在安全点上动态运行的垃圾回收器，来作为一种静态的内存自动管理机制，属于从源头上解决了内存需要自动管理而传统垃圾回收器有运行期性能“毛刺“的问题。但是这又对提出了新问题：由于 <code class="language-plaintext highlighter-rouge">Rc</code> 所有权是 <code class="language-plaintext highlighter-rouge">GlobalAllocator</code> ，而不是 <code class="language-plaintext highlighter-rouge">FibHeap</code> ，因此它创建的引用，由于生命周期的限制，无法用在 <code class="language-plaintext highlighter-rouge">FibHeap</code> 返回引用的接口上。这个问题也是 <code class="language-plaintext highlighter-rouge">Rc</code> 、 <code class="language-plaintext highlighter-rouge">RefCell</code> 另一个比冗繁更要命的缺点，阅读了 Rust 和标准库内部组件的实现，看它们基本上都不使用这两个公开组件而是用 unsafe 的传统指针另写一套，功能上和这两个组件基本类似，唯一额外作用就是能绕开生命周期的限制。</p>

<p>在这里我们直接使用 <code class="language-plaintext highlighter-rouge">Box</code> 把需要导出引用的数据放到堆上而不是 <code class="language-plaintext highlighter-rouge">RefCell</code> 中，在 <code class="language-plaintext highlighter-rouge">RefCell</code> 里只保留原始指针，通过这种 unsafe 操作，绕过生命周期的限制（实际也可以绕过所有权、可变性等等所有 Rust 额外的检查）</p>

<h3 id="克隆clone与复制copy">克隆（clone）与复制（copy）</h3>

<p>这里对应的是内存模型里的<strong>值对象</strong>与<strong>引用对象</strong>，copy 针对的是值对象，clone 针对的是引用对象。二者的区别首先是概念上的、语义上的，值对象就是它本身只是内存里的一个数值，可以任意地在任何地方使用，没有任何其他语义上或物理上的外部关系；而引用对象就像广泛的用于传统面向对象语言里的普通对象，这里二者在概念上直接构成互补的关系。</p>

<p>从实现角度，copy 为了严格语义不被违反，限制了只能自动实现，基本的数值类型是可 copy 的，任何派生的可 copy 对象必须保证所有字段都是可 copy 的。从语义上讲，分配内存空间的对象都应该是不可 copy 的，什么 <code class="language-plaintext highlighter-rouge">Vec</code>，<code class="language-plaintext highlighter-rouge">array</code>， <code class="language-plaintext highlighter-rouge">String</code> … 都不行，因为分配内存本身就不能随意复制。</p>

<p>注意区别于传统上世纪 90 年代的那一批面向对象语言什么 Java、Python、Ruby、C# 等等，在这种传统编程模型里，所有对象都是引用，没有值对象的概念，更重要的是前面提到的数据共享上缺乏设计，于是在对象克隆的时候有深和浅的区别，有的也称 deep “copy” 和 swallow “copy”。</p>

<p>这种在数据共享上设计的匮乏是它们并发痛点的根源， 只熟悉那些语言的人可能会把这个东西和上面的 clone 与 copy 的概念错误地对应起来。实际上对于 Rust 而言并不常用到那些语言里常见的克隆深与浅的问题，因为 Rust 有一套新的安全编程模型，所有权、可变性、生命周期等等保证你要么转移对象所有权，要么克隆就是完全克隆。</p>

<p>但原则的城墙大门紧闭，但在总有几扇窗户是开着的，就像 <code class="language-plaintext highlighter-rouge">Rc</code>、<code class="language-plaintext highlighter-rouge">RefCell</code> 这种“怪胎“的存在，当我们不得不用它们在更高层面模拟传统编程模型的时候，就必须考虑自己有区分的实现深浅克隆的问题了。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="heap-node">Heap Node</h3>

<h4 id="structure--wrappers">Structure &amp;&amp; Wrappers</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="cd">/// Used for reverse reference to avoid circular-reference</span>
<span class="cd">///</span>
<span class="cd">/// So we can easy auto drop</span>
<span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// children number</span>

    <span class="cd">/// rev ref</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// rev ref</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Indicate that it has lost a child</span>
    <span class="n">marked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="sugar-macros">Sugar Macros</h4>

<p>谈到 Rust 的声明式宏，总是离不开 <a href="https://danielkeep.github.io/tlborm/book/index.html">黑小书</a> 和 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">基础文档</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////////////////////////////////////////</span>
<span class="c1">//// Attr macros</span>

<span class="cd">/// Clone attr</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">_unr</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">mattr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="n">mname</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">mattr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nd">attr!</span><span class="p">(</span><span class="nv">$node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">marked</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="heap-head">Heap Head</h3>

<h3 id="structure">Structure</h3>

<ol>
  <li>$\texttt{len}$ 和 $\texttt{rcnt}$ ，分别是节点数和根节点个数，它们只是额外的基本统计信息，可以省略；</li>
  <li>$\texttt{min}$ 是最小根；</li>
  <li>$\texttt{nodes}$ 是索引，这里专注主要功能的使用，所以使用 HashMap ，如果要实现 $O(1)$ 的 Union 方法就需要换成别的分型结构，比如二叉搜索树或者B-树</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">CollKey</span> <span class="o">=</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// roots count</span>
    <span class="n">rcnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// index of nodes</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="sugar-macros-1">Sugar Macros</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">node!</span><span class="p">(</span><span class="nv">$i</span><span class="p">,</span> <span class="nv">$k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$rank:expr</span><span class="p">,</span> <span class="nv">$marked:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">:</span> <span class="nv">$i</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$k</span><span class="p">),</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nv">$rank</span><span class="p">,</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">marked</span><span class="p">:</span> <span class="nv">$marked</span><span class="p">,</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="算法无关的基础方法">算法无关的基础方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">WeakNode</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">node</span><span class="na">.0</span><span class="p">;</span>
        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">children</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="cd">/// replace with new val, return old val</span>
    <span class="k">fn</span> <span class="nf">replace_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">oldk</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">newk</span> <span class="o">=</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="nd">mattr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="n">newk</span><span class="p">;</span>

        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldk</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// from self.min go through all roots</span>
    <span class="k">fn</span> <span class="nf">roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sibs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sibs</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="n">sib</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sibs</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">I</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="n">k</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// break circle dependency to enable drop</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.nodes</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法相关的基础方法">算法相关的基础方法</h3>

<h4 id="摘儿子">摘儿子</h4>

<p>在 update-key 的时候，需要把违背堆性质或者失去超过一个孩子的非根节点从父结点摘除。这就是这个方法的作用，需要仔细考虑，每一步都不能忽略：</p>

<p>假设被摘的节点为 $\texttt{x}$</p>

<ol>
  <li>如果 $\texttt{x}$ 的左邻居不为空，把左邻的右邻连接到 $\texttt{x}$ 的右邻，否则 $\texttt{x}$ 就是父节点的第一个孩子，这时还需要更新父节点的孩子到 $\texttt{x}$ 的右邻；</li>
  <li>如果 $\texttt{x}$ 的右邻居不为空，还把右邻的左邻更新为 $\texttt{x}$ 的左邻；</li>
  <li>父节点的 $\texttt{rank–}$ ；</li>
  <li>摘出来的节点去头和左右邻，只保留它的孩子</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cut_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">mchild!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">mrank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">rank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="cd">/// remove paren, left and right</span>
    <span class="k">fn</span> <span class="nf">purge_as_root</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">mparen!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="锄根">锄根</h4>

<p>在执行 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候，需要把一个根节点从根链表中移除：</p>

<ol>
  <li>根数自减，如果不为 $0$ ，意味着根链表还存在，就把左邻的右邻连接到右邻，右邻的左邻连接到左邻；</li>
  <li>purge</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...    </span>
<span class="k">fn</span> <span class="nf">remove_from_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.rcnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="插苗">插苗</h4>

<p>锄根的逆过程，把一个节点 $\texttt{x}$ 插入到根链表中：</p>

<ol>
  <li>根数 $\texttt{rcnt}$ 自增，保护性地 purge 节点 $\texttt{x}$ ；</li>
  <li>如果根链表不存在，把 $\texttt{x}$ 作为根链表的唯一节点，让它成为最小根并且左右邻指向自己；</li>
  <li>否则，头插法插入 $\texttt{x}$ ， $\texttt{x}$ 的右邻链接到最小根的右邻， $\texttt{x}$ 左邻链接到最小根，然后最小根的右邻链接到 $\texttt{x}$ ， $\texttt{x}$ 的右邻的左邻链接到  $\texttt{x}$</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">fn</span> <span class="nf">push_into_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>

        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...  </span>
</code></pre></div></div>

<h2 id="高空台-altitude-ground-test-facilities">高空台 （Altitude Ground Test Facilities）</h2>

<p>欲要善其事，必先利其器</p>

<p><strong>任何有一定复杂度的实现都非一蹴而就，而越是复杂度高的实现，越是需要测试与调试的部分先行，越是由测试的全面性、彻底性与调试工具的效率决定其进程速度。</strong></p>

<h3 id="打印方法">打印方法</h3>

<p>一个全面而又简洁的打印方法是进行状态观察的基础手段。</p>

<ol>
  <li>
    <p>对于 Fib 堆，简单遍历根节点地逐树打印，表明最小根；</p>
  </li>
  <li>
    <p>树的打印遵循 BFS 顺序，每层一行，同层不同父节点的由分号分开， 并且在开头表明父节点序号；</p>
  </li>
  <li>
    <p>单个节点打印它的权重（key）和索引（idx），如果被标记还要打印标记</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="k">self</span><span class="py">.rcnt</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}  ({i:03})  {}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="c1">// writeln!(f)?;</span>
            <span class="k">if</span> <span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"M=&gt;"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">sib</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">sib</span><span class="nf">.is_some</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}&gt;&gt; end &lt;&lt;{}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"R({:?}) "</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">curq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="k">self</span><span class="nf">.children</span><span class="p">())];</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxtq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="k">in</span> <span class="n">curq</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">children</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"P({:?}) "</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">childlen</span> <span class="o">=</span> <span class="n">children</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childlen</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">nxtq</span><span class="nf">.push</span><span class="p">((</span><span class="n">child</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">child</span><span class="nf">.children</span><span class="p">()));</span>
                <span class="p">}</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">nxtq</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="n">curq</span> <span class="o">=</span> <span class="n">nxtq</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"None"</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="s">"{:?}[{:?}]{}"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.idx</span><span class="p">,</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.key</span> <span class="p">},</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.marked</span> <span class="p">{</span> <span class="s">" X"</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="s">""</span> <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="克隆方法">克隆方法</h3>

<p>测试的时候，需要验证某一个状态是否正确，而当验证过程会影响测试对象本身状态时，就需要一个克隆方法来克隆一个被测试对象来进行这种有副作用地验证。</p>

<ol>
  <li>创建新的索引目录，对根链表逐根完全克隆，每克隆完一个，就和前一个克隆的节点双向链接起来，最后把头尾相连，构成一个循环链表；</li>
  <li>对于根链表上的每棵树克隆的时候，先创建新的根节点，并把新创建的节点加入新的索引目录里，然后对它孩子递归地调用节点的完全克隆方法，创造出的孩子左右相连，每个孩子的父节点也要指向自己创建的新的根节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rcnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rcnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">min</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">roots_iter</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_min</span><span class="p">)</span> <span class="o">=</span> <span class="n">roots_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">_min</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">root</span> <span class="k">in</span> <span class="n">roots_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newroot</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newroot</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newroot</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newroot</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">,</span>
            <span class="n">min</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">overall_clone</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// overall clone node body</span>
        <span class="k">let</span> <span class="n">newx</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">rank!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="c1">// update index reference</span>
        <span class="n">nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">newx</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// recursive call it</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">childen_iter</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="n">childen_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

            <span class="nd">mchild!</span><span class="p">(</span><span class="n">newx</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mparen!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">newx</span><span class="nf">.downgrade</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">childen_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">newx</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="主要算法方法">主要算法方法</h2>

<p>Fib 堆核心的算法就是三个：</p>

<ol>
  <li>Push</li>
  <li>Pop</li>
  <li>DecreaseKey</li>
</ol>

<h3 id="push-方法">Push 方法</h3>

<p>根据算法，创建新的节点和索引后，直接插入到根链表中； 如果 $\texttt{key}$ 比最小根小，就更新最小根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop-方法">Pop 方法</h3>

<p>（这里从使用的接口上讲，实际上需要的是 <code class="language-plaintext highlighter-rouge">pop_item</code> ）</p>

<ol>
  <li>如果长度为 $0$ ，不存在最小根，直接返回 <code class="language-plaintext highlighter-rouge">None</code>；</li>
  <li>否则长度自减，从最小根的右邻开始，遍历所有邻居，找到新的最小节点，如果最小根没有邻居（除它以外），就得到一个空节点；</li>
  <li>把旧的最小根指向的节点从根链表摘除，最小根指向新的最小节点（包括可能是空节点），开启树的规整，合并同秩树；</li>
  <li>树规整：创建一个 $\texttt{rank =&gt; node}$ 的 Map，遍历根链表，对于每个根，递归地查询 Map 是否有同秩的节点已经加入，有就合并两棵树，然后更新当前根节点为合并后的树的根节点，递归查询合并结束后，就插入当前树的秩和节点到 Map 中</li>
  <li>把旧的最小根节点从索引删除，返回旧的最小根的节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.1</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* push children of oldmin into roots */</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* update min */</span>

    <span class="k">let</span> <span class="n">newmin</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">sib</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span>
    <span class="nf">.cloned</span><span class="p">()</span>
    <span class="nf">.unwrap_or_default</span><span class="p">();</span>

    <span class="cm">/* just del old min */</span>

    <span class="k">self</span><span class="nf">.remove_from_roots</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">oldmin</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.replace</span><span class="p">(</span><span class="n">newmin</span><span class="p">);</span>


    <span class="k">self</span><span class="nf">.consolidate</span><span class="p">();</span>

    <span class="nf">Some</span><span class="p">((</span>
        <span class="k">self</span><span class="nf">.remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmin</span><span class="p">),</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">oldmin</span><span class="p">)</span><span class="py">.key</span><span class="p">),</span>
    <span class="p">))</span>
<span class="p">}</span>


<span class="cd">/// merge same rank trees recusively</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">consolidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rank</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">hashmap!</span><span class="p">();</span>

    <span class="k">for</span> <span class="k">mut</span> <span class="n">sib</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">rank</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.merge_same_rank_root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">rank</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">),</span> <span class="n">sib</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey-方法">DecreaseKey 方法</h3>

<p>对节点 $\texttt{x}$ 降 $\texttt{key}$ ，首先检查一下索引（检查是否 $\texttt{x}$ 的新 $\texttt{key}$ 确实较小），检查一下是否不是根节点并且堆性质违背（比父节点的 $\texttt{key}$ 更小），如果是，标记 $\texttt{x}$ ，设置 <em>cut-meld-unmark</em> 递归的起始点为 $\texttt{x}$ ，假装 $\texttt{x}$ 本身也是符合<em>cut-meld-unmark</em> 条件的一个父节点，否则设置起始点为空节点。最后由于是降 $\texttt{key}$ ，还要检查最小根是否需要更新为 $\texttt{x}$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">oldv</span><span class="p">,</span>
                <span class="s">"decrease violated! {:?} !(&lt;) {:?}"</span><span class="p">,</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="o">&amp;</span><span class="n">oldv</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"Empty index {i:?}"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decrease_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">unmeld_ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 假装x节点本身也是一个符合条件的父节点</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">unmeld_ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>cut-meld-unmark to roots :</strong></p>

<p>如果起始节点是空节点，就退出；递归地检查当前节点是否不为根节点并且被标记，是，就取消标记，从父节点被摘出，推进根链表，然后以父节点为新的起始节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">cut_meld_unmark_to_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ent</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">while</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">strongp</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="n">strongp</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">strongp</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 定义上不标记根，但这应该是无所谓的，标记对于可能的pop导致的树规整后的树情况更精确</span>
    <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="额外算法方法">额外算法方法</h2>

<h3 id="update-方法">Update 方法</h3>

<p>从语义上可以把 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的方法拓展为完整的更新key的方法 。</p>

<ol>
  <li>如果索引不存在，就插入节点，否则替换节点；</li>
  <li>如果 $\texttt{key}$ 相等，什么都不做；</li>
  <li>如果 $\texttt{key}$ 降低，就 <code class="language-plaintext highlighter-rouge">decrease-key</code> ；</li>
  <li>如果增加，就 <code class="language-plaintext highlighter-rouge">increase-key</code></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.increase_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>increase-key</strong> :</p>

<p>注意： 由于当对最小根 <code class="language-plaintext highlighter-rouge">increase-key</code> 的时候需要重新搜索最小根，时间复杂度为 $O(\texttt{rank})$ ，在不保证严格二项堆的性质时，最坏时间复杂度为 $O(\texttt{n})$  , 会破坏了整个 <code class="language-plaintext highlighter-rouge">update</code> 其他部分的 $O(\texttt{logn})$ 的性质。</p>

<p><code class="language-plaintext highlighter-rouge">increase-key</code> 的时候，同样地，当堆性质违背的时候（新的 $\texttt{key}$ 大于孩子节点）递归地执行 <em>cut-meld-unmark</em> 操作，区别在于升 $\texttt{key}$ 的是 $\texttt{x}$ 而要扫描的是x的孩子节点，好像是 $\texttt{x}$ 的孩子们降 $\texttt{key}$ 造成的堆性质违背。统计 $\texttt{x}$ 总共因为堆违背失去的孩子数（如果 $\texttt{x}$ 已被标记，初始化为 $1$ 否则为 $0$ ）。</p>

<p>检查失去的孩子节点数，如果没有，就把启动点设置为空节点；如果恰好为 $1$ ，确认标记x，以 $\texttt{x}$ 的父节点为启动点；如果大于 $1$ ，标记 $\texttt{x}$ ，以 $\texttt{x}$ 本身为启动点。</p>

<p><em>cut-meld-unmark</em>  递归地操作完成后，如果升 $\texttt{key}$ 的节点是最小根指向的节点，还要遍历根链表，更新最小根</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">increase_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">children_lost</span> <span class="o">=</span> <span class="k">if</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="n">children_lost</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="n">children_lost</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">min_node</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">min_node</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="典例片段">典例片段</h2>

<h3 id="prim-最小生成树">Prim 最小生成树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:rust-impl" role="doc-endnote">
      <p>https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs <a href="#fnref:rust-impl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <span>
        <a href="/">
          <img src="/assets/img/icons/home.png" class="pl-4 pb-4">
        </a>
      </span>
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/FibHeapImplRust.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
