<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="http://localhost:4000/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/style.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            斐波那契堆的实现（for Rust）
        
    "
/>

<meta property="og:url" content="http://localhost:4000//algs/FibHeapImplRust.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        斐波那契堆的实现（for Rust）
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="align-items-center justify-content-between h-100">
  <span class="logo" id="topbar-logo">
    <a href="http://localhost:4000/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </span>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>
  <span id="breadcrumb">

    

    

    

    
  </span><!-- endof #breadcrumb -->
</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">斐波那契堆的实现（for Rust）</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="http://localhost:4000/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      November 13, 2022
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p>算法理论部分，在上一篇文章 <strong><a href="http://localhost:4000/algs/FibHeap.html">Fibonacci Heap</a></strong> 已经讲完了，下面是实现的部分<sup id="fnref:rust-impl" role="doc-noteref"><a href="#fn:rust-impl" class="footnote" rel="footnote">1</a></sup>。</p>

<h2 id="关于节点索引">关于节点索引</h2>

<p>因为我们需要为 Fibonacci Heap 实现 DecreaseKey 的方法，因此需要维护一个用于记录堆中每个节点索引的 Map 。</p>

<p>作为某种对比，Rust 标准库里的 <a href="https://doc.rust-lang.org/alloc/collections/binary_heap/index.html">BinaryHeap</a> 根本就没有节点索引，可它居然也宣称支持 DecreaseKey 的方法，它只是插入“同值”的新节点来一定程度地代替 DecreaseKey，这比红黑树里面用“假交换”来做树删除节点后的重平衡还要糟糕：</p>

<ol>
  <li>需要用户自己定义一个额外的结构体，然后为它实现一些必要的 Trait，非常的麻烦；</li>
  <li>显然破坏了 DecreaseKey 的完整语义，引入潜在的Bug。</li>
</ol>

<p>不过另一方面，维护节点索引会显著地增加性能开销，让完美的数据结构不那么完美。</p>

<h2 id="数据结构">数据结构</h2>

<h3 id="node">Node</h3>

<h4 id="structure--wrappers">Structure &amp; Wrappers</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="cd">/// Used for reverse reference to avoid circular-reference</span>
<span class="cd">///</span>
<span class="cd">/// So we can easy auto drop</span>
<span class="k">struct</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">struct</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">idx</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c1">// children number</span>

    <span class="cd">/// rev ref</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// rev ref</span>
    <span class="n">paren</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">child</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// Indicate that it has lost a child</span>
    <span class="n">marked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="sugar-macros">Sugar Macros</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">////////////////////////////////////////</span>
<span class="c1">//// Attr macros</span>

<span class="cd">/// Clone attr</span>
<span class="nd">macro_rules!</span> <span class="n">attr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> 
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">_unr</span> <span class="o">=</span> <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_bor</span> <span class="o">=</span> <span class="n">_unr</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_attr</span> <span class="o">=</span> <span class="n">_bor</span>.<span class="nv">$attr</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nf">drop</span><span class="p">(</span><span class="n">_bor</span><span class="p">);</span>
            <span class="n">_attr</span>
        <span class="p">}</span> 
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">mattr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">,</span> <span class="nv">$attr:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$node</span><span class="nf">.clone</span><span class="p">()</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow_mut</span><span class="p">()</span>.<span class="nv">$attr</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">def_attr_macro</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$name:ident</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$</span><span class="p">(</span>
            <span class="nd">macro_rules!</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">attr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nd">concat_idents!</span> <span class="p">(</span><span class="n">mname</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="nv">$name</span> <span class="p">{</span>
                <span class="nd">#[allow(unused)]</span>
                <span class="nd">macro_rules!</span> <span class="n">mname</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="nd">mattr!</span><span class="p">(</span><span class="nv">$$node</span><span class="p">,</span> <span class="nv">$name</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">});</span>
        <span class="p">)</span><span class="o">+</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">key</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="nd">attr!</span><span class="p">(</span><span class="nv">$node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">def_attr_macro!</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">paren</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">marked</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="head">Head</h3>

<h4 id="structure">Structure</h4>

<ol>
  <li>$\texttt{len}$ 和 $\texttt{rcnt}$ ，分别是节点数和根节点个数，它们只是额外的基本统计信息，可以省略；</li>
  <li>$\texttt{min}$ 是最小根；</li>
  <li>$\texttt{nodes}$ 是索引，这里只关注主要功能的实现，所以使用 HashMap ，如果还要支持 $O(1)$ 的 Union 方法就需要换成 Ordered TreeMap，比如二叉搜索树或者B+树</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">CollKey</span> <span class="o">=</span> <span class="nb">Ord</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="cd">/// roots count</span>
    <span class="n">rcnt</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">min</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// index of nodes</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="sugar-macros-1">Sugar Macros</h4>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">boxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$v:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unboxptr</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$ptr:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="nv">$ptr</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">node</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">node!</span><span class="p">(</span><span class="nv">$i</span><span class="p">,</span> <span class="nv">$k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="p">(</span><span class="nv">$i:expr</span><span class="p">,</span> <span class="nv">$k:expr</span><span class="p">,</span> <span class="nv">$rank:expr</span><span class="p">,</span> <span class="nv">$marked:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node_</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">:</span> <span class="nv">$i</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="nv">$k</span><span class="p">),</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nv">$rank</span><span class="p">,</span>
            <span class="n">left</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">right</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">paren</span><span class="p">:</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">child</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">marked</span><span class="p">:</span> <span class="nv">$marked</span><span class="p">,</span>
        <span class="p">}))))</span>
    <span class="p">};</span>
<span class="p">}</span>


<span class="nd">macro_rules!</span> <span class="n">unwrap_into</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$node:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">try_unwrap</span><span class="p">(</span><span class="nv">$node</span><span class="na">.0</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.into_inner</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="辅助方法">辅助方法</h2>

<h3 id="算法无关的基础方法">算法无关的基础方法</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">WeakNode</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">ref</span> <span class="n">rc</span><span class="p">|</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="n">rc</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_some</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">node</span><span class="na">.0</span><span class="p">;</span>
        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">rc2</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="na">.0</span> <span class="p">{</span>
                    <span class="nn">Rc</span><span class="p">::</span><span class="nf">ptr_eq</span><span class="p">(</span><span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="n">other</span><span class="nf">.is_none</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">children</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nd">child!</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">while</span> <span class="n">child</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">res</span>
    <span class="p">}</span>
    
    <span class="cd">/// replace with new val, return old val</span>
    <span class="k">fn</span> <span class="nf">replace_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">oldk</span> <span class="o">=</span> <span class="nd">attr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">newk</span> <span class="o">=</span> <span class="nd">boxptr!</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="nd">mattr!</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="n">newk</span><span class="p">;</span>

        <span class="nd">unboxptr!</span><span class="p">(</span><span class="n">oldk</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">upgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">Node</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">weak</span><span class="p">|</span> <span class="n">weak</span><span class="nf">.upgrade</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">none</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">is_none</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.is_none</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">(</span><span class="k">self</span><span class="na">.0</span><span class="nf">.clone</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span><span class="p">:</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">(),</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="cd">/// from self.min go through all roots</span>
    <span class="k">fn</span> <span class="nf">roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sibs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sibs</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>

        <span class="k">while</span> <span class="o">!</span><span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sibs</span><span class="nf">.push</span><span class="p">(</span><span class="n">sib</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sibs</span>
    <span class="p">}</span>
    
    <span class="k">fn</span> <span class="nf">remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">I</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>

        <span class="n">k</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// break circle dependency to enable drop</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">();</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>

            <span class="k">self</span><span class="py">.nodes</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法相关的基础方法">算法相关的基础方法</h3>

<h4 id="摘儿子">摘儿子</h4>

<p>在 update-key 的时候，需要把违背堆性质或者失去超过一个孩子的非根节点从父结点摘除。这就是这个方法的作用，需要仔细考虑，每一步都不能忽略：</p>

<p>假设被摘的节点为 $\texttt{x}$</p>

<ol>
  <li>如果 $\texttt{x}$ 的左邻居不为空，把左邻的右邻连接到 $\texttt{x}$ 的右邻，否则 $\texttt{x}$ 就是父节点的第一个孩子，这时还需要更新父节点的孩子到 $\texttt{x}$ 的右邻；</li>
  <li>如果 $\texttt{x}$ 的右邻居不为空，还把右邻的左邻更新为 $\texttt{x}$ 的左邻；</li>
  <li>父节点的 $\texttt{rank–}$ ；</li>
  <li>摘出来的节点去头和左右邻，只保留它的孩子</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">cut_child</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">mchild!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="o">!</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nd">mrank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nd">rank!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="cd">/// remove paren, left and right</span>
    <span class="k">fn</span> <span class="nf">purge_as_root</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">mparen!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="锄根">锄根</h4>

<p>在执行 <code class="language-plaintext highlighter-rouge">pop</code> 操作的时候，需要把一个根节点从根链表中移除：</p>

<ol>
  <li>根数自减，如果不为 $0$ ，意味着根链表还存在，就把左邻的右邻连接到右邻，右邻的左邻连接到左邻；</li>
  <li>purge</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...    </span>
<span class="k">fn</span> <span class="nf">remove_from_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.rcnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="nd">left!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<h4 id="插苗">插苗</h4>

<p>锄根的逆过程，把一个节点 $\texttt{x}$ 插入到根链表中：</p>

<ol>
  <li>根数 $\texttt{rcnt}$ 自增，保护性地 purge 节点 $\texttt{x}$ ；</li>
  <li>如果根链表不存在，把 $\texttt{x}$ 作为根链表的唯一节点，让它成为最小根并且左右邻指向自己；</li>
  <li>否则，头插法插入 $\texttt{x}$ ， $\texttt{x}$ 的右邻链接到最小根的右邻， $\texttt{x}$ 左邻链接到最小根，然后最小根的右邻链接到 $\texttt{x}$ ， $\texttt{x}$ 的右邻的左邻链接到  $\texttt{x}$</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">fn</span> <span class="nf">push_into_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">self</span><span class="py">.rcnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="nf">.purge_as_root</span><span class="p">();</span>

    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
        <span class="nd">mright!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">);</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.downgrade</span><span class="p">();</span>

        <span class="nd">mright!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">mleft!</span><span class="p">(</span><span class="nd">right!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...  </span>
</code></pre></div></div>

<h2 id="高空台-altitude-ground-test-facilities">高空台 （Altitude Ground Test Facilities）</h2>

<p>欲要善其事，必先利其器。</p>

<p><strong>任何有一定复杂度的实现都非一蹴而就，而越是复杂度高的实现，越是需要测试与调试的部分先行，越是由测试的全面性、彻底性与调试工具的效率决定其进程速度。</strong></p>

<h3 id="打印方法">打印方法</h3>

<p>一个全面而又简洁的打印方法是进行状态观察的基础手段。</p>

<ol>
  <li>
    <p>对于 Fib 堆，简单遍历根节点地逐树打印，表明最小根；</p>
  </li>
  <li>
    <p>树的打印遵循 BFS 顺序，每层一行，同层不同父节点的由分号分开， 并且在开头表明父节点序号；</p>
  </li>
  <li>
    <p>单个节点打印它的权重（key）和索引（idx），如果被标记还要打印标记</p>
  </li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">CollKey</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="k">self</span><span class="py">.rcnt</span> <span class="p">{</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}  ({i:03})  {}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
            <span class="c1">// writeln!(f)?;</span>
            <span class="k">if</span> <span class="n">sib</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"M=&gt;"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">sib</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

            <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">sib</span><span class="nf">.is_some</span><span class="p">());</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="nd">right!</span><span class="p">(</span><span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}&gt;&gt; end &lt;&lt;{}"</span><span class="p">,</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">),</span> <span class="s">"-"</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">28</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"R({:?}) "</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">curq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="k">self</span><span class="nf">.clone</span><span class="p">(),</span> <span class="k">self</span><span class="nf">.children</span><span class="p">())];</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nxtq</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="k">in</span> <span class="n">curq</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">children</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"P({:?}) "</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">childlen</span> <span class="o">=</span> <span class="n">children</span><span class="nf">.len</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="k">in</span> <span class="n">children</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childlen</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">", "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">nxtq</span><span class="nf">.push</span><span class="p">((</span><span class="n">child</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">child</span><span class="nf">.children</span><span class="p">()));</span>
                <span class="p">}</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"; "</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">nxtq</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
                <span class="n">curq</span> <span class="o">=</span> <span class="n">nxtq</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"None"</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{:?}"</span><span class="p">,</span> <span class="k">self</span><span class="na">.0</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">Debug</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span><span class="o">&gt;</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">Node_</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="s">"{:?}[{:?}]{}"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.idx</span><span class="p">,</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span><span class="k">self</span><span class="py">.key</span> <span class="p">},</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.marked</span> <span class="p">{</span> <span class="s">" X"</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="s">""</span> <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="克隆方法">克隆方法</h3>

<p>测试的时候，需要验证某一个状态是否正确，而当验证过程会影响测试对象本身状态时，就需要一个克隆方法来克隆一个被测试对象来进行这种有副作用地验证。</p>

<ol>
  <li>创建新的索引目录，对根链表逐根完全克隆，每克隆完一个，就和前一个克隆的节点双向链接起来，最后把头尾相连，构成一个循环链表；</li>
  <li>对于根链表上的每棵树克隆的时候，先创建新的根节点，并把新创建的节点加入新的索引目录里，然后对它孩子递归地调用节点的完全克隆方法，创造出的孩子左右相连，每个孩子的父节点也要指向自己创建的新的根节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="k">self</span><span class="py">.len</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rcnt</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rcnt</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">min</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">roots_iter</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_min</span><span class="p">)</span> <span class="o">=</span> <span class="n">roots_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">_min</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="k">for</span> <span class="n">root</span> <span class="k">in</span> <span class="n">roots_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newroot</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newroot</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newroot</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newroot</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mleft!</span><span class="p">(</span><span class="n">min</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">len</span><span class="p">,</span>
            <span class="n">rcnt</span><span class="p">,</span>
            <span class="n">min</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">CollKey</span> <span class="o">+</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="n">FibHeap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">overall_clone</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">x</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// overall clone node body</span>
        <span class="k">let</span> <span class="n">newx</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nd">rank!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
        <span class="c1">// update index reference</span>
        <span class="n">nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">idx!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">newx</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="c1">// recursive call it</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">childen_iter</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="n">childen_iter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

            <span class="nd">mchild!</span><span class="p">(</span><span class="n">newx</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="nd">mparen!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">newx</span><span class="nf">.downgrade</span><span class="p">();</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">childen_iter</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">newchild</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.overall_clone</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

                <span class="nd">mright!</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">=</span> <span class="n">newchild</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="nd">mleft!</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span> <span class="o">=</span> <span class="n">cur</span><span class="nf">.downgrade</span><span class="p">();</span>

                <span class="n">cur</span> <span class="o">=</span> <span class="n">newchild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">newx</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="主要算法方法">主要算法方法</h2>

<p>Fib 堆核心的算法就是三个：</p>

<ol>
  <li>Push</li>
  <li>Pop</li>
  <li>DecreaseKey</li>
</ol>

<h3 id="push-方法">Push 方法</h3>

<p>根据算法，创建新的节点和索引后，直接插入到根链表中； 如果 $\texttt{key}$ 比最小根小，就更新最小根。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Impl FibHeap ...  </span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nd">node!</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.nodes</span><span class="nf">.insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">node</span><span class="nf">.clone</span><span class="p">());</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="pop-方法">Pop 方法</h3>

<p>（这里从使用的接口上讲，实际上需要的是 <code class="language-plaintext highlighter-rouge">pop_item</code> ）</p>

<ol>
  <li>如果长度为 $0$ ，不存在最小根，直接返回 <code class="language-plaintext highlighter-rouge">None</code>；</li>
  <li>否则长度自减，从最小根的右邻开始，遍历所有邻居，找到新的最小节点，如果最小根没有邻居（除它以外），就得到一个空节点；</li>
  <li>把旧的最小根指向的节点从根链表摘除，最小根指向新的最小节点（包括可能是空节点），开启树的规整，合并同秩树；</li>
  <li>树规整：创建一个 $\texttt{rank =&gt; node}$ 的 Map，遍历根链表，对于每个根，递归地查询 Map 是否有同秩的节点已经加入，有就合并两棵树，然后更新当前根节点为合并后的树的根节点，递归查询合并结束后，就插入当前树的秩和节点到 Map 中</li>
  <li>把旧的最小根节点从索引删除，返回旧的最小根的节点</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="na">.1</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_item</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* push children of oldmin into roots */</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* update min */</span>

    <span class="k">let</span> <span class="n">newmin</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
    <span class="nf">.into_iter</span><span class="p">()</span>
    <span class="nf">.min_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">sib</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span>
    <span class="nf">.cloned</span><span class="p">()</span>
    <span class="nf">.unwrap_or_default</span><span class="p">();</span>

    <span class="cm">/* just del old min */</span>

    <span class="k">self</span><span class="nf">.remove_from_roots</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="nf">.clone</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">oldmin</span> <span class="o">=</span> <span class="k">self</span><span class="py">.min</span><span class="nf">.replace</span><span class="p">(</span><span class="n">newmin</span><span class="p">);</span>


    <span class="k">self</span><span class="nf">.consolidate</span><span class="p">();</span>

    <span class="nf">Some</span><span class="p">((</span>
        <span class="k">self</span><span class="nf">.remove_from_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmin</span><span class="p">),</span>
        <span class="nd">unboxptr!</span><span class="p">(</span><span class="nd">unwrap_into!</span><span class="p">(</span><span class="n">oldmin</span><span class="p">)</span><span class="py">.key</span><span class="p">),</span>
    <span class="p">))</span>
<span class="p">}</span>


<span class="cd">/// merge same rank trees recusively</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">consolidate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rank</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">hashmap!</span><span class="p">();</span>

    <span class="k">for</span> <span class="k">mut</span> <span class="n">sib</span> <span class="k">in</span> <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span> <span class="p">{</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">rank</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sib</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.merge_same_rank_root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sib</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">rank</span><span class="nf">.insert</span><span class="p">(</span><span class="nd">rank!</span><span class="p">(</span><span class="n">sib</span><span class="p">),</span> <span class="n">sib</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="decreasekey-方法">DecreaseKey 方法</h3>

<p>对节点 $\texttt{x}$ 降 $\texttt{key}$ ，首先检查一下索引（检查是否 $\texttt{x}$ 的新 $\texttt{key}$ 确实较小），检查一下是否不是根节点并且堆性质违背（比父节点的 $\texttt{key}$ 更小），如果是，标记 $\texttt{x}$ ，设置 <em>cut-meld-unmark</em> 递归的起始点为 $\texttt{x}$ ，假装 $\texttt{x}$ 本身也是符合<em>cut-meld-unmark</em> 条件的一个父节点，否则设置起始点为空节点。最后由于是降 $\texttt{key}$ ，还要检查最小根是否需要更新为 $\texttt{x}$ 。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="nd">debug_assert!</span><span class="p">(</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">oldv</span><span class="p">,</span>
                <span class="s">"decrease violated! {:?} !(&lt;) {:?}"</span><span class="p">,</span>
                <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="o">&amp;</span><span class="n">oldv</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"Empty index {i:?}"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">decrease_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">unmeld_ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">p</span><span class="nf">.upgrade</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 假装x节点本身也是一个符合条件的父节点</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unmeld_ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">unmeld_ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>cut-meld-unmark to roots :</strong></p>

<p>如果起始节点是空节点，就退出；递归地检查当前节点是否不为根节点并且被标记，是，就取消标记，从父节点被摘出，推进根链表，然后以父节点为新的起始节点。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">cut_meld_unmark_to_roots</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ent</span><span class="p">:</span> <span class="n">WeakNode</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ent</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.upgrade</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="k">while</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">strongp</span> <span class="o">=</span> <span class="n">p</span><span class="nf">.upgrade</span><span class="p">();</span>

        <span class="n">strongp</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">x</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">strongp</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 定义上不标记根，但这应该是无所谓的，标记对于可能的pop导致的树规整后的树情况更精确</span>
    <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="额外算法方法">额外算法方法</h2>

<h3 id="update-方法">Update 方法</h3>

<p>从语义上可以把 <code class="language-plaintext highlighter-rouge">decrease-key</code> 的方法拓展为完整的更新key的方法 。</p>

<ol>
  <li>如果索引不存在，就插入节点，否则替换节点；</li>
  <li>如果 $\texttt{key}$ 相等，什么都不做；</li>
  <li>如果 $\texttt{key}$ 降低，就 <code class="language-plaintext highlighter-rouge">decrease-key</code> ；</li>
  <li>如果增加，就 <code class="language-plaintext highlighter-rouge">increase-key</code></li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">I</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.entry</span><span class="p">(</span><span class="n">i</span><span class="nf">.clone</span><span class="p">())</span> <span class="p">{</span>
        <span class="nf">Occupied</span><span class="p">(</span><span class="n">ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ent</span><span class="nf">.get</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">oldv</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.replace_key</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="k">match</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldv</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Less</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.decrease_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="nf">.increase_key_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">oldv</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">Vacant</span><span class="p">(</span><span class="n">_ent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<p><strong>increase-key</strong> :</p>

<p>注意： 由于当对最小根 <code class="language-plaintext highlighter-rouge">increase-key</code> 的时候需要重新搜索最小根，时间复杂度为 $O(\texttt{rank})$ ，在不保证严格二项堆的性质时，最坏时间复杂度为 $O(\texttt{n})$  , 会破坏了整个 <code class="language-plaintext highlighter-rouge">update</code> 其他部分的 $O(\texttt{logn})$ 的性质。</p>

<p><code class="language-plaintext highlighter-rouge">increase-key</code> 的时候，同样地，当堆性质违背的时候（新的 $\texttt{key}$ 大于孩子节点）递归地执行 <em>cut-meld-unmark</em> 操作，区别在于升 $\texttt{key}$ 的是 $\texttt{x}$ 而要扫描的是x的孩子节点，好像是 $\texttt{x}$ 的孩子们降 $\texttt{key}$ 造成的堆性质违背。统计 $\texttt{x}$ 总共因为堆违背失去的孩子数（如果 $\texttt{x}$ 已被标记，初始化为 $1$ 否则为 $0$ ）。</p>

<p>检查失去的孩子节点数，如果没有，就把启动点设置为空节点；如果恰好为 $1$ ，确认标记x，以 $\texttt{x}$ 的父节点为启动点；如果大于 $1$ ，标记 $\texttt{x}$ ，以 $\texttt{x}$ 本身为启动点。</p>

<p><em>cut-meld-unmark</em>  递归地操作完成后，如果升 $\texttt{key}$ 的节点是最小根指向的节点，还要遍历根链表，更新最小根</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// impl FibHeap ...</span>

<span class="k">fn</span> <span class="nf">increase_key_</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ent</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">children_lost</span> <span class="o">=</span> <span class="k">if</span> <span class="nd">marked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">for</span> <span class="n">child</span> <span class="k">in</span> <span class="n">x</span><span class="nf">.children</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nd">key!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span><span class="nf">.cut_child</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="k">self</span><span class="nf">.push_into_roots</span><span class="p">(</span><span class="n">child</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="n">children_lost</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="n">children_lost</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Less</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nn">WeakNode</span><span class="p">::</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="nd">paren!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="n">Greater</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">mmarked!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.downgrade</span><span class="p">();</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">self</span><span class="nf">.cut_meld_unmark_to_roots</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">x</span><span class="nf">.rc_eq</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.min</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">min_node</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.roots</span><span class="p">()</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min_by_key</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="nd">key!</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">self</span><span class="py">.min</span> <span class="o">=</span> <span class="n">min_node</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// ...</span>
</code></pre></div></div>

<h2 id="典例片段">典例片段</h2>

<h3 id="prim-最小生成树">Prim 最小生成树</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mst_prim</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">res</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="cm">/* choose an arbitray node as root */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">viter</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span> <span class="o">=</span> <span class="n">viter</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* setup rest collection */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init dis heap &amp;&amp; dis edge map */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">FibHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_edge</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">viter</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">dis</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
        <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="o">!</span><span class="n">rest</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// u is current vertex</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">_uw</span><span class="p">)</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c1">// "decrease-key" (It's increase-key actually for min-heap)</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">u_pair</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis_edge</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">u_pair</span> <span class="o">!=</span> <span class="n">u</span> <span class="p">{</span>
            <span class="n">res</span><span class="nf">.push</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_pair</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// calc adj</span>

        <span class="k">let</span> <span class="n">adjs</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

        <span class="cm">/* update dis heap */</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">adjs</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">w_uv</span><span class="p">:</span> <span class="nb">isize</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>

            <span class="k">if</span> <span class="n">w_uv</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w_uv</span><span class="p">);</span>
                <span class="n">dis_edge</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">res</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:rust-impl" role="doc-endnote">
      <p>https://github.com/minghu6/rust-minghu6/blob/snapshot-1/src/collections/heap/fib.rs <a href="#fnref:rust-impl" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <span>
        <a href="/">
          <img src="/assets/img/icons/home.png" class="pl-4 pb-4">
        </a>
      </span>
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/FibHeapImplRust.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="http://localhost:4000/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="http://localhost:4000/assets/js/jquery.slim.min.js"></script>
<script src="http://localhost:4000/assets/js/lity.min.js"></script>
<script src="http://localhost:4000/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "http://localhost:4000/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
