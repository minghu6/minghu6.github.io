<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/minghu6.jpeg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            短道水上漂（SP）
        
    "
/>

<meta property="og:url" content="//algs/GraphSP.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        短道水上漂（SP）
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="d-flex align-items-center justify-content-between h-100">
  <span id="breadcrumb">

    

    

    

    
    <span>
      <a href="/">
        Home
      </a>
    </span>
    

    

    

    

    

    

    
  </span><!-- endof #breadcrumb -->

  <section class="logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/minghu6.jpeg" />
      
    </a>
  </section>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>

</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">短道水上漂（SP）</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      December 01, 2022
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p>像水面上打漂儿出的石头，只是“一击就弹出“地了解关于最短路径（Shortest Path，以下简称SP）问题。</p>

<h2 id="前言">前言</h2>

<p>值得强调在前面得是，一般比如从构造实现上，会假定最基础的情况无向图，但最短路径是以<strong>有向图（强连通）</strong>为基础。所有下列介绍的算法的都假定一个有向图，而在无向图上，部分结论会有所不同。</p>

<p>遵循依赖关系，将依次介绍：</p>

<ol>
  <li>Floyd 算法 （全源）</li>
  <li>Bellman-Ford 算法 （单源）</li>
  <li>Bellman-Ford 算法的著名改进： SPFA 算法 （单源）</li>
  <li>Dijkstra 算法 （单源）</li>
  <li>Johnson 算法 （全源）</li>
</ol>

<h2 id="floyd-算法">Floyd 算法</h2>

<p>/flɔid/</p>

<h3 id="算法思想">算法思想</h3>

<p>这个算法当初是作为一个动态编程的范例提出，全源地计算图上最短路径问题。</p>

<p>假如对图上所有点编号 $1…n$ ，那么图上任何一条最短路径最多经过 $n$ 个点。一开始，我们只知道直接相连的两点之间的路径权重，但可以通过检查是否有 $w[x][1] + w[1][y] &lt; w[x][y]$ 得到最多经过点 $1$ 的两点间的最小路径。在此基础上如果在检查一遍经过点 $2$ 的两点间最短路径，就可以得到最多经过 $\lbrace 1,2 \rbrace$ 的两点间最短路径，以此类推，当检查过 $n$ 轮，就得到了最多经过 $\lbrace 1,2, …, n \rbrace$ 的最短距离，也就是整个图上的最短距离。</p>

<h3 id="伪代码">伪代码</h3>

<p>对于图 $G=(V, E)$</p>

\[\begin{array}{ll}
\texttt{let}\ w[x][y]\ \text{as shortest path's weight sum from}\ x\ \text{to}\ y\\ 
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets \{1,2,..,n\}\\
\qquad\texttt{for}\ y \gets \{1,2,...,n\}\\
\qquad\qquad \texttt{if}\ x=y\\
\qquad\qquad\qquad w[x][y] \gets 0\\
\qquad\qquad\ \texttt{elif}\ (x, y)\notin |E|  \\
\qquad\qquad\qquad w[x][y] \gets \infty \\
\qquad\qquad\ \texttt{else}\\
\qquad\qquad\qquad w[x][y] \gets w_{xy}
\\
\texttt{for}\ k \gets \{1,2,..,n\}\\
\qquad\texttt{for}\ x \gets \{1,2,...,n\}\\
\qquad\qquad\texttt{for}\ y \gets \{1,2,...,n\}\\
\qquad\qquad\qquad w[x][y] = \texttt{min}(w[x][k],\ w[k][y])
\end{array}\]

<h3 id="路径构造">路径构造</h3>

<p>如果单独地为每一对儿点存储独立路径，那么空间复杂度是 $O(n^3)$ ，有时候这可能不太妙，可以使用 $\text{next}$ 数组，存储一条路径的第一步的端点，用 $O(n)$ 的时间复杂度换取 $O(n^2)$ 的空间复杂度。</p>

<p>对于一条路径 $x_1 \rightarrow x_2 \rightarrow x_3\ …\rightarrow x_n$：</p>

\[\begin{array}{ll}
\text{next}[x_1][x_n] &amp;= x_2\\
\text{next}[x_2][x_n] &amp;= x_3\\
\text{next}[x_{n-1}][x_n] &amp;= x_n
\end{array}\]

<p>每次更新权重的时候，更新 $\text{next}$ 数组：</p>

\[\text{next}[x][y] = \text{next}[x][k]\]

<p>查询 $x \rightarrow y$ 最小路径时，展开 $\text{next}$ 数组（输出一个 $(x)..y$ 的路径，下同）：</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set P as path output}.\\
\\
p\ \gets x\\
P \gets \varnothing\\
\\
\texttt{loop if}\ \ p \neq y\\
\qquad p \gets \text{next}[p][y]\\
\qquad P \gets p \\
\end{array}\]

<h3 id="负环问题">负环问题</h3>

<p><strong>负环是指一条环状路径，其权重和为负值。</strong>显然负环的存在会使最短路径问题根本上不可解，因为任何一条路径都可以通过负环使得其权重和无限地减低下去。</p>

<p>对于有向图而言，显然 Floyd 可以处理不存在负环的负边的情况。<strong>但对于无向图，负边实质上是不可能的</strong>。因为无向图必须转为有向图来应用算法，而无向图的每条负边都意味着有向图的一个两条边构成的负环。</p>

<p>所以我们下面讨论的<strong>有向图负边权情况下探测负环的问题</strong> 。</p>

<p>方法是检查对角线上元素，也就是 $w[i][i], i \in |V|$ ，是否小于 $0$ ，如果是，意味着存在 $i\rightarrow i$ 的负环。</p>

<h4 id="负环路径构造">负环路径构造</h4>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set C as cycle output}\\
\texttt{let}\ \text{c as the known cycle vertex}\\
\\
C \gets \lbrace c \rbrace \\
p \gets \text{next}[c][c] \\
\\
\texttt{loop if}\ p \neq c\\
\qquad C \gets p\\
\qquad c \gets \text{next}[p][c]
\end{array}\]

<h3 id="实现">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPFloyd</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">next</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPFloyd</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_floyd</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">next</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// (total_weight, (src), .. , k1, k2, .. dst)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)),</span>
            <span class="nf">next_to_path</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">),</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.next</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_floyd</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="n">vertexs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">vertexs</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">spw</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">next</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="cm">/* init sp */</span>
    <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w</span><span class="p">);</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">y</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="p">{</span>
                <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">x</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">y</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">vertexs</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w_xk</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
                   <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">w_ky</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> 
                       <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> 
                    <span class="p">{</span>
                        <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span><span class="p">);</span>
                        <span class="nd">set!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)));</span>

                        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">w_xk</span> <span class="o">+</span> <span class="n">w_ky</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">cycle</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
                            <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>

                            <span class="k">while</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">y</span> <span class="p">{</span>
                                <span class="n">cycle</span><span class="nf">.push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                                <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">next</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
                            <span class="p">}</span>

                            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">spw</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度">时间复杂度</h3>

<p>显然时间复杂度为 $O(n^3)$</p>

<h2 id="bellman-ford-算法">Bellman-Ford 算法</h2>

<p>/ˈbelmən/-/fɔrd/</p>

<h3 id="算法思想-1">算法思想</h3>

<p>对比前面的 Floyd 算法考虑最短路径经过的点，Bellman-Ford 则考虑最短路径经过的边。</p>

<p>考虑对于 $n$ 个点的图，每一条最短路径最多包含 $n-1$ 条边（否则必然存在负环），从一条边的情况开始，遍历每条边，检查每个点到源点的最短距离是否可以被这条边更新，最后得到了最多包含一条边的最短路径；第二轮迭代，解决了最多包含两条边的情况；直到第 $n-1$ 轮，所有最短路径都必然已经得到。如果此时检查还有可以被边更新的最短路径，就必然存在负环。</p>

<h3 id="伪代码-1">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
\texttt{let}\ \text{dis}[x]\ \text{as shortest path's distance from}\ s\ \text{to}\ x \\
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets |V|\\
\qquad \texttt{if}\ x = s\\
\qquad\qquad \text{dis}[x] \gets 0\\
\qquad \texttt{elif}\ (s,x) \in |E|\\
\qquad\qquad \text{dis}[x]=w_{sx} \\
\qquad \texttt{else}\\
\qquad\qquad \text{dis}[x] = \infty\\
\\
\texttt{iterate}\ \text{|V|-1 times} \\
\qquad\texttt{for}\ (x, y) \gets |E|\\
\qquad\qquad \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})
\end{array}\]

<h3 id="路径构造-1">路径构造</h3>

<p>由于是加边的构造过程，路径构造采用了反向的 $\text{pre}$ 数组。</p>

<p>对于一条路径 $(s) \rightarrow x_1 \rightarrow x_2 \rightarrow x_3\ …\rightarrow x_n$：</p>

\[\begin{array}{ll}
\text{pre}[x_n] &amp;= x_{n-1}\\
\text{pre}[x_{n-1}] &amp;= x_{n-2}\\
\text{pre}[x_{2}] &amp;= x_1
\end{array}\]

<p>每次更新权重的时候，更新 $pre$ 数组：</p>

\[\text{pre}[y] = \text{pre}[x]\]

<p>查询 $x \rightarrow y$ 最小路径时，展开 pre 数组：</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set P as path output.}\\
\\
P \gets \varnothing \\
p \gets y \\
\\
\texttt{loop if}\ p \neq x\\
\qquad P \gets p\\
\qquad p \gets \text{pre}[p]\\
\\
\texttt{reverse}\ P\\
\end{array}\]

<h3 id="负环探测">负环探测</h3>

<p>负环问题<a href="#负环问题">前面</a>已经讲过，这里只讲负环探测。</p>

<p>当 $n-1$ 轮迭代后如果仍然有可以被更新的点，那么必然存在负环，而该点要么在负环上，要么在负环的下游。</p>

<p>这样以该点开始，用 $\text{pre}$ 数组向后找 $n$ 次，可以确保点一定在负环上，然后就可以构造负环路径。</p>

\[\begin{array}{l}
\texttt{let}\ \text{sequential set C as cycle output.}\\
\\
\texttt{for}\ (x, y, w_{xy}) \gets |E|\\
\qquad\texttt{if}\ \text{dis}[y] \lt \text{dis}[x] + w_{xy}\\
\qquad\qquad c \gets y  \\
\qquad\qquad \texttt{iterate}\ |V| \ \text{times}\\
\qquad\qquad\qquad c \gets \text{pre}[c]\\
\\
\qquad\qquad C \gets \lbrace c \rbrace \\
\qquad\qquad p \gets \text{pre}[c] \\
\\
\qquad\qquad\texttt{loop if}\ p \neq c\\
\qquad\qquad\qquad C \gets p\\
\qquad\qquad\qquad p \gets \text{pre}[p]\\
\\
\qquad\qquad \texttt{reverse}\ C\\
\qquad\qquad\text{exit with}\ C
\end{array}\]

<h3 id="实现-1">实现</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPBellmanFord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPBellmanFord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_bellman_ford</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_bellman_ford</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">src</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span><span class="p">);</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// negative cycle found!</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

                <span class="c1">// 确保在环上</span>
                <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">n</span> <span class="p">{</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nd">get!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">install_cycle</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">dis</span><span class="p">,</span> <span class="n">pre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-1">时间复杂度</h3>

<p>作为单源点算法，时间复杂度 $O(nm)$ ，如果求全源最短路径，就执行 $n$ 次该算法，那么就变成 $O(n^2m)$ 。</p>

<p>这个时间复杂度显然不太妙，事实上原始的 Bellman-Ford 算法是本文介绍的这几个算法里最慢的，下面我们会介绍它的一个广为人知的变体即所谓的 “SPFA“ 算法。这个改进算法虽然没有改变最坏时间复杂度，但在实际运行中对于随机图的表现相当好。</p>

<h2 id="so-called-spfa-算法">so-called ‘SPFA’ 算法</h2>

<p>这个 Bellman-Ford 的改进算法在 OI 界可谓大名鼎鼎，对于随机图的实际运行很快，而且实现方便。它是中国的研究员提出的，被认为本质上是 Tarjan 的图上广度优先遍历的一般化版本<sup id="fnref:wiki-spfa" role="doc-noteref"><a href="#fn:wiki-spfa" class="footnote" rel="footnote">1</a></sup> ，虽然从算法思想上的没有什么直接的关系。</p>

<h3 id="算法思想-2">算法思想</h3>

<p>’‘SPFA’ 的改进在于观察到每一轮用于“松弛“操作的边都是上一轮更新过的点连接的边。这很好理解，回到算式 $ \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})$ ，如果上一轮 $\text{dis}[x]$ 没有变，那么这一轮 $\text{dis}[y]$ 也就不会变。</p>

<p>这样的话，</p>

<ol>
  <li>从源点开始，把它加入等待的集合 $R$ ；</li>
  <li>每次从 $R$ 中取出一个点，遍历更新过的点连接的边，把其中更新的点加入 $R$ 中；</li>
  <li>当 $R$ 为空时，算法终止</li>
</ol>

<h3 id="伪代码-2">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
R \gets \lbrace s \rbrace\\
\\
\texttt{loop if}\ R\ \neq \varnothing \\
\qquad\ x \gets R\\
\qquad\texttt{for}\ (x, y, w_{wy})\ \texttt{in}\ \lbrace e\ |\ e[0]=x,\ e \in |E| \rbrace \\
\qquad\qquad\text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})\\
\qquad\qquad R \gets y
\end{array}\]

<p>路径构造同原始 Bellman-Ford 算法相同</p>

<h3 id="负环探测-1">负环探测</h3>

<p>负环探测由于没有全部边的迭代，因此有一点区别</p>

<p>有两种方法：</p>

<ol>
  <li>在于使用一个集合维护每个点经过的边数，显然最多不超过 $n-1$ 条，否则一定存在负环；</li>
  <li>每迭代完 $n$ 个点，就检查一下pre数组，是否展开后超过 $n-1$ 条路径</li>
</ol>

<p>第二种方法虽然最坏时间复杂度和第一种相同，但<sup id="fnref:spfa-early-termination" role="doc-noteref"><a href="#fn:spfa-early-termination" class="footnote" rel="footnote">2</a></sup>在稀疏图和随机图情况下，可以天差地别般更快地检测到负环 。</p>

<p>另外对于第一种方法，使用 FILO 的栈结构显然有助于更快地找到负环。</p>

<h3 id="实现-2">实现</h3>

<p>特别地对于无向图，‘SPFA’ 可以有意义地求解负权边图，因为可以单独跳过两端点构成的负环，这样就避免无向图的每条负边都构成有向图的一个两端点负环的情况。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPFA</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="cd">/// shortest path weight</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPFA</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_fa_early_termination</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sp_fa_early_termination</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">src</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vis</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="n">src</span><span class="p">];</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">vis</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="nd">vec!</span><span class="p">[])</span> <span class="p">{</span>
            <span class="c1">// 无向图不存在这条路径</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">g</span><span class="py">.dir</span> <span class="o">&amp;&amp;</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">dis_u</span><span class="p">)</span> <span class="o">=</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nd">getopt!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">||</span>
                   <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)));</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>

                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">=</span> <span class="nf">detect_negative_cycle</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pre</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="o">!</span><span class="n">vis</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">stack</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                        <span class="n">vis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">dis</span><span class="p">,</span> <span class="n">pre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度与继续改进">时间复杂度与继续改进</h3>

<p>最坏时间复杂度不变，仍是 $O(nm)$ ，但实际运行是很好的（相对于其他能处理负边权的算法）。另外对于特定情况的一些进一步的优化，主要是关于如何根据有关条件把点加到对头还是队尾，这里就不展开了。</p>

<p>但接下来介绍的是有限制条件的更最快的算法：Dijkstra 算法 。</p>

<h2 id="dijkstra-算法">Dijkstra 算法</h2>

<p>/ˈdaɪkstrəz/</p>

<h3 id="算法思想-3">算法思想</h3>

<p>说是 Dijkstra 和妻子逛商场的时候花20分钟想出来的寻找到几个不同商场的最短路的方法<sup id="fnref:wiki-dijkstra" role="doc-noteref"><a href="#fn:wiki-dijkstra" class="footnote" rel="footnote">3</a></sup> ，是一种自然想到的利用非负权边的缩放性质进行快速查找的方法。</p>

<p>回顾前面的两个算法：</p>

<p>Floyd 算法（全源）是 $\text{dis}[u][v] = \text{min}(\text{dis}[u][v],\ \text{dis}[u][k]+\text{dis}[k][v])$</p>

<p>Bellman-Ford 算法（单源）是  $\text{dis}[v] = \text{min}(\text{dis}[v],\ \text{dis}[u]+w_{uv})$</p>

<p>它们都是基于直接的全路径的比较，适用于包括负权边在内的各种情况，而 Dijkstra 算法则利用了非负权边的缩放性质，在非负权图上可以算得更快。</p>

<p>它考虑对于图 $G$ （有向强连通），设源点为 $s$ ， $d$ 为图上任一点，$d’$ 为 $s$ 到 $d$ 最短路径上 $d$ 的前驱点（即 $s\rightarrow…\rightarrow d’\rightarrow d$）， $\text{dis}$ 图上某点为到源点 $s$ 的最短距离，由于非负权边的性质， $dis[d’] \leqslant dis[d]$ 。</p>

<p>假如对 $\text{dis}$ 按照不减的顺序求出，每求出一个就更新该点的所有出边连接的点的 $\text{dis}$ ，那么下一个得到的最小 $\text{dis}$ 也仍然是所属点的最短距离。</p>

<p>这是一个归纳法的思考方向，让我们用规整的形式来更好地说明：</p>

<ol>
  <li>
    <p>初始地情况，$\text{dis}[s]=0$ ，它是最小的 $\text{dis}$，也不妨认为它是 $s\rightarrow s$ 的最短距离；</p>
  </li>
  <li>
    <p>当 $d$ 是剩下点中 $\text{dis}$ 最小的点时，由于它的最短路径（强连通图保证至少有一条 $s$ 到 $d$ 的路径）上的前驱点 $d’$ 满足 $\text{dis}[d’] \leqslant \text{dis}[d]$ ：</p>

    <p>2.1 如果 $\text{dis}[d’] \lt \text{dis}[d]$， $d’$  之前已经被计算出最短路径，而 $d$ 已经被 $d’$  的出边更新为最短路径</p>

    <p>2.2 特别地当 $w_{d’d}=0$ ，也就是 $\text{dis}[d’]=\text{dis}[d]$ ，$d’$ 可以忽略，直接找它的前驱 $d’’$ , 直到 $d^{(n)}=s$ ，总之都是之前已经被求出的</p>

    <p>所以当之前的 $\text{dis}$ 都是最短路径时， $d$ 也是最短路径</p>
  </li>
</ol>

<p>归纳证毕。</p>

<h3 id="伪代码-3">伪代码</h3>

<p>对于图 $G=(V, E)$ ，源点 $s$ ：</p>

\[\begin{array}{l}
\texttt{let}\ \text{dis}[x]\ \text{as shortest path's distance from}\ s\ \text{to}\ x \\
\texttt{let}\ w_{xy}\ \text{as edge weight from}\ x\ \text{to}\ y\\
\\
\texttt{for}\ x \gets |V|\\
\qquad \texttt{if}\ x = s\\
\qquad\qquad \text{dis}[x] \gets 0\\
\qquad \texttt{elif}\ (s,x) \in |E|\\
\qquad\qquad \text{dis}[x]=w_{sx} \\
\qquad \texttt{else}\\
\qquad\qquad \text{dis}[x] = \infty\\
\\
T \gets |V|\\
\\
\texttt{loop if}\ T \neq \varnothing\\
\qquad u \gets \text{min}(T) \text{ by dis}[u] \\
\\
\qquad\texttt{for}\ (x, y)\ \texttt{in}\ \lbrace e\ |\ e[0]=u,\ \ e[1] \in T,\ e \in |E| \rbrace \\
\qquad\qquad \text{dis}[y] = \texttt{min}(\text{dis}[y],\ \text{dis}[x] + w_{xy})
\end{array}\]

<p>路径构造由于是对边的“松弛“，所以仍然采用 $\text{pre}$ 数组构造。</p>

<h3 id="实现-3">实现</h3>

<p>用上前面实现的 <a href="/algs/DaryHeap.html">d-ary 堆</a> 来优化算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPDijkstra</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">pre</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPDijkstra</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">pre</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span> <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.pre</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pre</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis_m1</span> <span class="o">=</span> <span class="nn">M1</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">dis</span> <span class="o">=</span> <span class="nn">DaryHeap5</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rest</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">infi</span> <span class="o">=</span> <span class="nn">isize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.vertexs</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">src</span> <span class="p">{</span>
            <span class="n">dis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">dis</span><span class="nf">.insert</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">infi</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">dis_u</span><span class="p">))</span> <span class="o">=</span> <span class="n">dis</span><span class="nf">.pop_item</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">rest</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">dis_m1</span> <span class="k">=&gt;</span> <span class="n">u</span> <span class="k">=&gt;</span> <span class="n">dis_u</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">rest</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">dis_u</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">g</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="o">*</span><span class="nd">get!</span><span class="p">(</span><span class="n">dis</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">dis</span><span class="nf">.decrease_key</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                    <span class="nd">set!</span><span class="p">(</span><span class="n">pre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">(</span><span class="n">dis_m1</span><span class="p">,</span> <span class="n">pre</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度与综合利用">时间复杂度与综合利用</h3>

<p>作为单源点算法，使用我们实现里的 $O(1)$  时间复杂度的 32-ary 堆优化的情况下：</p>

<ol>
  <li>初始化 $\text{dis}$ 数组，$O(n)$</li>
  <li>$\text{dis}$ 排序 + 边松弛，$O(n) + O(m)$</li>
</ol>

<p>Dijkstra 算法的时间复杂度可以优化为 $O(m)$ （非常优秀，直接去掉了一个 $n$） 。</p>

<p>如果计算全源最短路径，就是 $O(nm)$ 。</p>

<p>不过 Dijkstra 毕竟受限于非负权边的图，如何利用它的高效，改善含负权边的图的全源最短路径 $O(n^3)$ 的计算效率？ 这就是接下来的Johnson 算法做的事情。</p>

<h2 id="johnson-算法">Johnson 算法</h2>

<h3 id="算法思想-4">算法思想</h3>

<p>基本想法是通过重新调整边的权重，使得每条边的权重不小于 $0$ ，并且保持每对儿点的最短路径不会因此受到影响。</p>

<p>我们采取这样一种方法，对于图 $G=(V, E)$ ，用“势能”标记 $G$ 中的每个点：</p>

<ol>
  <li>建立基准线，增加一个特殊的点 $q$ ，使得 $q$ 到 $G$ 中每一个点都有一条边，权重为一个固定值 $c$ （具体值无所谓，只是用来建立基准）</li>
  <li>运行一次以 $q$ 为源点的 Bellman-Ford 算法（当然我们要用我们最爱的 ‘SPFA’ 算法），以每个点到 $q$ 的最小距离 $h$ 为它的势能，原 $G$ 上每条边 $(u, v)$ 的权重都加上 $u\rightarrow v$ 两点的势能差，也就是 $h(u) - h(v)$</li>
</ol>

<p>这样同时满足了两个要求：</p>

<ol>
  <li>对于G上任意两点x、y，G上每条从x到y的路径，不管中间经过了多少个点，它们的最终权重和都增加了一个固定值，也就是 h(x) -h(y)，也就是这种调整不会影响任意点对的最短路径的判定；</li>
  <li>并且由于最短路径的性质 $h[v] \leqslant h[u]  + w_{uv}$ 也就是 $w_{uv} + h[u] - h[v] \geqslant 0$</li>
</ol>

<p>这样直接在重新平衡权重的图上做 $n$ 次Dijkstra 算法，就得到了全源的最短路径。当然查询最短路径的权重和时，要把加上的权重减去，也就是 $-(h[u]-h[v])$</p>

<h3 id="实现-4">实现</h3>

<p>路径构造是 $\text{pre}$ 数组，负环探测是利用 Bellman-Ford 算法</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">SPJohnson</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">,</span>
    <span class="n">h</span><span class="p">:</span> <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">spw</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">//// shortest path paths</span>
    <span class="n">sppre</span><span class="p">:</span> <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">SPJohnson</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Graph</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_johnson</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span> <span class="p">{</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span> <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// (total_weight, (src), .. , k1, k2, .. dst)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">query</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span>
            <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.spw</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">))</span> <span class="o">-</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.h</span> <span class="k">=&gt;</span> <span class="n">src</span><span class="p">)</span>
                <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="k">self</span><span class="py">.h</span> <span class="k">=&gt;</span> <span class="n">dst</span><span class="p">),</span>
            <span class="nd">pre_to_path!</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="k">self</span><span class="py">.sppre</span><span class="na">.0</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sp_johnson</span><span class="p">(</span>
    <span class="n">g</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span>
    <span class="p">(</span>
        <span class="n">M1</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">M2</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">),</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="cm">/* Create a new map with special node q*/</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">vertexs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">g2</span><span class="nf">.vertexs</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="n">vertexs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">vertexs</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">vertexs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">apush!</span><span class="p">(</span><span class="n">g2</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">q</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">if</span> <span class="o">!</span><span class="n">g</span><span class="py">.dir</span> <span class="p">{</span>
            <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">apush!</span><span class="p">(</span><span class="n">g2</span><span class="py">.e</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Using SPFA dst calc h((q, v)) */</span>
    <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="k">match</span> <span class="nf">sp_fa</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">h</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">((</span><span class="n">g2</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)),</span>
    <span class="p">};</span>

    <span class="cm">/* Reweight */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">in</span> <span class="n">g</span><span class="nf">.edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">g2</span><span class="py">.w</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="o">+</span> <span class="nd">get!</span><span class="p">(</span><span class="n">h</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="nd">get!</span><span class="p">(</span><span class="n">h</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* Calc spw and spp usign Dijkstra */</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">spw</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">isize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sppre</span> <span class="o">=</span> <span class="nn">M2</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">vertexs</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">sspw</span><span class="p">,</span> <span class="n">sspp</span><span class="p">)</span> <span class="o">=</span> <span class="nf">sp_dijkstra</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="nd">set!</span><span class="p">(</span><span class="n">spw</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">sspw</span><span class="p">);</span>
        <span class="nd">set!</span><span class="p">(</span><span class="n">sppre</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">sspp</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">spw</span><span class="p">,</span> <span class="n">sppre</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="时间复杂度-2">时间复杂度</h3>

<p>$O(nm) + O(nm) = O(nm)$ ，这样在负权图上也实现了最坏时间复杂度为 $O(nm)$ 的最短路径算法！</p>

<h2 id="尾声">尾声</h2>

<p>用力地掷出 SP 问题这一块飞石，最终在时间的河流上打出了一串儿的涟漪，虽然感觉花的时间长，但实际比想象花的时间还要长一点。特别是和 <a href="/algs/GraphMST.html">无向图上最小生成树问题</a> ，还有树上问题等比较，图上的算法思想还是有很多相通之处，有一些人名也串来串去，比如 Tarjan，有点儿图界 Knuth 的意思。</p>

<p>凡事总是勃勃兴起，忽而结束。</p>

<h2 id="引用">引用</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:wiki-spfa" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm <a href="#fnref:wiki-spfa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:spfa-early-termination" role="doc-endnote">
      <p>https://konaeakira.github.io/posts/using-the-shortest-path-faster-algorithm-to-find-negative-cycles.html <a href="#fnref:spfa-early-termination" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wiki-dijkstra" role="doc-endnote">
      <p>https://en.wikipedia.org/wiki/Dijkstra’s_algorithm <a href="#fnref:wiki-dijkstra" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <nav id="toc" data-toggle="toc"></nav>
    </div>

  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
