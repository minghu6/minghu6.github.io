<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            质数筛子拓展
        
    "
/>

<meta property="og:url" content="//algs/Prime2.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        质数筛子拓展
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="d-flex align-items-center justify-content-between h-100">
  <span id="breadcrumb">

    

    

    

    
    <span>
      <a href="/">
        <img src="/assets/img/icons/home.png">
      </a>
    </span>
    

    

    

    

    

    

    
  </span><!-- endof #breadcrumb -->

  <section class="logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </section>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>

</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">质数筛子拓展</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/algs.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHueOrange)">
            Algorithm
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      September 23, 2024
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><h2 id="前言">前言</h2>

<p>介绍一种特殊形式的筛子–增量筛子以及给出使用分段技术的筛子的并行化版本的实现代码。</p>

<h3 id="增量筛子">增量筛子</h3>

<p>增量筛子（incremental sieve），就是一种可以无限（内存空间限制内）获取质数的筛子，在不确定质数范围的情境下，配合函数式编程的风格，有它独特的作用。</p>

<h2 id="e-筛增量筛">E. 筛增量筛（√）</h2>

<p>可以预先计算 $k$ 个质数，用前 $k$ 个质数筛完 $[0, p_k^2]$ 范围内的质数，如果还要继续筛选，就以 $k=p_k^2$，进行下一轮筛选。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">p0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">pris</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>

            <span class="k">loop</span> <span class="p">{</span>
                <span class="c1">// ~p0^2</span>
                <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">round</span> <span class="o">=</span> <span class="nf">e_seg_sieve_0</span><span class="p">(</span>
                    <span class="o">&amp;</span><span class="n">pris</span><span class="p">,</span>
                    <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span><span class="p">,</span>
                    <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span> <span class="o">*</span> <span class="n">p0</span>
                <span class="p">)</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">round</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">round</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">pris</span><span class="nf">.extend</span><span class="p">(</span><span class="n">round</span><span class="p">);</span>
                <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法评价">算法评价</h3>

<p>性能在增量筛里勉强还算可用。</p>

<p>这只是把普通筛子算法在接口上改造成增量筛子的一个实例，理论上所有依赖预先计算开头一部分质数的一般筛子算法都可以仿照这种方式进行改造。</p>

<p>但是这种方式改造出的增量筛，它的性能曲线并不好看，充满一个个峰值，而好的增量筛子应该（随着质数个数增加），在性能（需求）上呈现平缓增长，贴合质数本身的增长曲线 $\frac{n}{\ln n}$ 。</p>

<p>下面会介绍几个专门的增量筛算法。</p>

<h2 id="bengelloun-增量筛">Bengelloun 增量筛（√√√）</h2>

<p>Bengelloun 增量筛<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>，也可以称为 LPF 增量筛，基于最小质因数分解 $c = \texttt{lpf}(c)\cdot f$ ，使用固定 $f$ 而在 $p$ 上遍历的思路。<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">4</a></sup></p>

<h4 id="思路分析">思路分析</h4>

<p><em>和 <a href="#gpf-增量筛">GPF 增量筛</a> 思路类似，但是简单很多，<strong>强烈建议</strong>先看 <a href="#gpf-增量筛">GPF 增量筛</a> 再回过来看本章节。</em></p>

<p>每个合数 $c$ 由同一个 $f$ 而更小的一个质数 $p’ \lt p,\ (p’ \leqslant \texttt{lpf}(f))$ 的 $c’ = p’\cdot f$ 标记。</p>

<p>而且简单地只要 $\texttt{lpf}(c)\gt 2$ ，上述标记就成立，只需特别处理偶数的情况。</p>

<h3 id="样例代码">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">bengelloun_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lastp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lpf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">5</span><span class="p">];</span> <span class="c1">// +1 cap for index start from 1.</span>

            <span class="k">yield</span> <span class="n">lastp</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">3</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">lpf</span><span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">n</span><span class="p">;</span>

                    <span class="n">lpf</span><span class="p">[</span><span class="n">lastp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="c1">// lpf[n] = n;</span>
                    <span class="n">lastp</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

                    <span class="c1">// =&gt; p_next &lt; 2n</span>
                    <span class="c1">// =&gt; p1 / p0 &lt; 2</span>
                    <span class="c1">// =&gt; (p1 / p0) * p_next &lt; 4n - 2</span>
                    <span class="n">lpf</span><span class="nf">.resize</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lpf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">// lp0 &gt; 2</span>
                    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>

                    <span class="c1">// min(f, lpf[f]) = truly lpf[f]</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="nf">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lpf</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">lpf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>  <span class="c1">// next prime after p</span>

                        <span class="n">lpf</span><span class="p">[</span><span class="n">p1</span> <span class="o">*</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果按照 GPF 增量筛的风味，可以把 <code class="language-plaintext highlighter-rouge">lpf[n / 2 * 3] = 3;</code> 放到 <code class="language-plaintext highlighter-rouge">else</code> 的代码块里。</p>

<h4 id="textttlpf-扩容">$\texttt{lpf}$ 扩容</h4>

<p>同样类似于 GPF 增量筛，下一个质数 $\lt 2n$ ，在此过程中最大的合数 $c \lt 2n-1 \lt 2n$ ：</p>

<ol>
  <li>$c$ 是偶数，扩张 $3 \div 2 = 1.5 \lt 2$ 倍；</li>
  <li>$c$ 不是偶数，扩张 相邻两个质数之比，$\lt 2$ 倍。</li>
</ol>

<p>因此在产生新的质数 $n$ 后扩容到 $4n$ 即可。</p>

<h4 id="储存-textttnext">储存 $\texttt{next}$</h4>

<p>利用和 GPF 增量筛同样的方式在 <code class="language-plaintext highlighter-rouge">lpf</code> 数组上存储 $\texttt{next}(p)$ 。</p>

<p>可以通过 <code class="language-plaintext highlighter-rouge">min(f, lpf[f])</code> 来比较简洁地得到真正的 $\texttt{lpf}(f)$ 。</p>

<h3 id="算法评价-1">算法评价</h3>

<p>目前最快的一档增量筛。</p>

<h2 id="gpf-增量筛">GPF 增量筛（√√√）</h2>

<p>GPF 增量筛<sup id="fnref:2:1" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>，和<a href="/algs/Prime1.html#gpf-筛子">普通 GPF 筛子</a>一样基于最大质因数分解 $c = f\cdot\texttt{gpf}(c)$，但主要以 $f$ 为常量，以 $p \geqslant \texttt{gpf}(f)$ 为增量。</p>

<h4 id="思路分析-1">思路分析</h4>

<p>回顾下普通的 GPF 筛子，是以 $p$ 为常量，遍历所有 $f\in \lbrace f\ \vert\ \texttt{gpf}(f) \leqslant p ,\ p\cdot f\leqslant N \rbrace$ 。</p>

<p>但是增量筛子并不能一次性求取一个预先确定范围的质数，而是按照大小的顺序逐个求取，如果仍然固定 $p$ ，由于不等式 $\texttt{gpf}(f) \leqslant p$ ，必须考虑最大质因数 $\leqslant p$ 范围内的每个级别的 $f$ ，或者说因为并不知道这些级别的 $f$ 之间的大小关系， 所以没办法快速得到 $\texttt{next}(f)$ 。</p>

<p>于是我们考虑固定 $f$ ，那么显然 $p$ 有一个确定的值的顺序，开始值是 $p=\texttt{gpf}(f)$ ，按照求解出的质数顺序逐步增加即可。</p>

<p>但是 $c = f\cdot\texttt{gpf}(f)$ 本身又该如何标记呢？这下只能重新固定 $p$ ，由前一个满足 $\texttt{gpf}(f) = p $ 的 $f$ <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">5</a></sup> 来标记，而满足条件的最小的 $f=p$ ，需要我们手动进行标记。</p>

<p>让我们把问题总结一下：</p>

<p>一个合数 $c = f \cdot p,\ (\texttt{gpf}(f) \leqslant p)$ ，</p>

<p>如果 $\texttt{gpf}(f) = p$ ，</p>

<p>           那么如果 $f=p$ ，那它是在发现某个数 $n=p^2$ 时被手动标记；</p>

<p>           否则，它是在前一个 $g\cdot p,\ (\texttt{gpf}(g) = p)$ 时被标记。</p>

<p>否则 $\texttt{gpf}(f) \lt p$ ，它是在前一个 $f\cdot q,\ (q \lt p)$ 时被标记。</p>

<h3 id="样例代码-1">样例代码</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// *LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE:* Algorithm 4.4.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">gpf_sieve_inf</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">from_coroutine</span><span class="p">(</span>
        <span class="nd">#[coroutine]</span>
        <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lastp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">sqp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// minimal (for square) prime</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">gpf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// (p, f)</span>

            <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>

            <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">3</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">sqp</span> <span class="o">*</span> <span class="n">sqp</span> <span class="p">{</span>
                    <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqp</span><span class="p">;</span>  <span class="c1">// add starter</span>
                    <span class="n">sqp</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">sqp</span><span class="p">];</span>  <span class="c1">// point to next prime after sqp</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">yield</span> <span class="n">n</span><span class="p">;</span>

                    <span class="c1">// gpf[n] = n;</span>
                    <span class="n">gpf</span><span class="p">[</span><span class="n">lastp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// point to next prime</span>
                    <span class="n">lastp</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
                    <span class="n">gpf</span><span class="nf">.resize</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
                    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>
                    <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">gpf</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>  <span class="c1">// next prime</span>

                    <span class="n">gpf</span><span class="p">[</span><span class="n">p1</span> <span class="o">*</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                    
                    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="nf">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">gpf</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="k">mut</span> <span class="n">f0</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                        <span class="k">while</span> <span class="nf">min</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">gpf</span><span class="p">[</span><span class="n">f0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span>
                            <span class="n">f0</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="p">}</span>

                        <span class="n">gpf</span><span class="p">[</span><span class="n">f0</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">},</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有几个实现的细节问题需要结合代码进行解释。</p>

<h4 id="textttgpf-扩容">$\texttt{gpf}$ 扩容</h4>

<p>根据增量筛的语义，应当在生成一个质数后，在下一个质数生成时对数组 <code class="language-plaintext highlighter-rouge">gpf</code> 进行扩容。</p>

<p>扩容大小做如下分析，如果当前生成的质数是 $n$ ，那么下一个质数 $\lt 2n$ <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">6</a></sup> 。</p>

<p>而且可以发现，每个数字标记的合数不超过自身的 $2$ 倍，分析如下：</p>

<ol>
  <li>
    <p>如果是 $p$ 增加的标记，那么相邻质数之比不超过 $2$；</p>
  </li>
  <li>
    <p>如果是 $f$ 增加的标记，虽然有 $\texttt{gpf}(f) = p$ 的限制，但因为 $2$ 是最小的质数，$2f$ 一定在下一个 $f$ 的序列里。</p>
  </li>
</ol>

<p>因此，到达下一个质数过程中最大的合数 $c\lt 2n$ ，那么最大标记的数为 $2c \lt 4n$ ，因此直接将数组 <code class="language-plaintext highlighter-rouge">gpf</code> 扩容到 $4n$ 即可。</p>

<h4 id="检查平方质数">检查平方质数</h4>

<p>根据算法，我们需要手动检测当前值是否是某个质数的平方。</p>

<p>这乍看上去是个棘手的任务，好在质数也是按照增序的方式产生，实际上只需要追踪当前 $\gt n$ 的最小质数，代码里我们使用 <code class="language-plaintext highlighter-rouge">sqp</code> 这个变量来做这个事情。</p>

<h4 id="储存-textttnext-1">储存 $\texttt{next}$</h4>

<p>原文构想使用一个大小为 $2n$ 的数组去为每个质数存储 $\texttt{next}(f)$ 和 $\texttt{next}(p)$ ，但实际并无特别的必要。</p>

<p>$\texttt{next}(f)$ 可以延迟到需要时再计算，而 $\texttt{next}(p)$ 的存储可以仿照 <a href="#bengelloun-增量筛">Bengelloun 增量筛</a> 一样利用 <code class="language-plaintext highlighter-rouge">gpf</code> 既有的空间：</p>

<p>对已发现的质数 $p$，<code class="language-plaintext highlighter-rouge">gpf[p]</code> 的空间实际是没有用的（代码里 <code class="language-plaintext highlighter-rouge">gpf[n] = n</code> 这行代码直接被注释掉了），可以利用它来存储  $\texttt{next}(p)$ 。</p>

<p>于是代码里使用了 <code class="language-plaintext highlighter-rouge">lastp</code> 来保存最后发现的质数，当发现新质数时就令 <code class="language-plaintext highlighter-rouge">gpf[lastp]</code> 指向这个新质数。</p>

<p>只不过这样的改动会稍微影响计算 $\texttt{next}(f)$ ，所以需要把 $f=p$ 的情况单独拿出来讨论，可以通过 <code class="language-plaintext highlighter-rouge">min(f, gpf[f])</code> 来比较简洁地得到真正的 $\texttt{gpf}(f)$ 。</p>

<h3 id="算法评价-2">算法评价</h3>

<p>目前最快的一档增量筛。</p>

<h2 id="并行化实现">并行化实现</h2>

<p>可以发现支持分片技术的筛子也意味着支持并行化处理。</p>

<h3 id="分段-e-筛">分段 E. 筛</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// set amount of cpu cores used in parallel tasks</span>
<span class="k">pub</span> <span class="k">static</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">e_seg_sieve_p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nd">sieve_spec_case!</span><span class="p">(</span><span class="n">n</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">fn</span> <span class="n">sieve_subtask</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
        <span class="n">l0</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">seg</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l0</span><span class="p">;</span>

        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">l1</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>

            <span class="k">for</span> <span class="o">&amp;</span><span class="n">p</span> <span class="k">in</span> <span class="n">pris</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">p</span><span class="o">..=</span><span class="n">end</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">seg</span><span class="nf">.set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">end</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">seg</span><span class="nf">.set_all</span><span class="p">();</span>
            <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ans</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pris_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pris</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">k_dekta</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">delta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">k_dekta</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">USED_CPU_CORES_NUM</span> <span class="p">{</span>
            <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">scope</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="nf">sieve_subtask</span><span class="p">(</span><span class="n">pris_ref</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
            <span class="p">}));</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">handles</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">});</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="分段固定轮筛">分段固定轮筛</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fixed_wheel_seg_sieve_p</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">WStruct</span> <span class="p">{</span> <span class="n">wheel_gap</span><span class="p">:</span> <span class="n">wg</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="nf">empty</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">n</span><span class="nf">.isqrt</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pris</span> <span class="o">=</span> <span class="nf">e_seg_sieve</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">np</span> <span class="o">=</span> <span class="n">pris</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">wg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// v = p_{k+1}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">np</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="p">{</span>
        <span class="c1">// Just rolling to n</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..=</span><span class="n">k</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

            <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
            <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">sieve_subtask</span><span class="p">(</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">pris</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span>
        <span class="n">np</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l0</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">l1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">WStruct</span> <span class="p">{</span>
            <span class="n">wheel</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span>
            <span class="n">wheel_gap</span><span class="p">:</span> <span class="n">wg</span><span class="p">,</span>
            <span class="n">prod</span><span class="p">,</span>
            <span class="c1">// ipm,</span>
            <span class="o">..</span>
        <span class="p">}</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l0</span><span class="p">;</span>

        <span class="cm">/* Init v, vi */</span>

        <span class="k">let</span> <span class="n">v_raw</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">prod_rem</span> <span class="o">=</span> <span class="n">v_raw</span> <span class="o">%</span> <span class="n">prod</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">prod_base</span> <span class="o">=</span> <span class="n">v_raw</span> <span class="o">-</span> <span class="n">prod_rem</span><span class="p">;</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="k">mut</span> <span class="n">vi</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prod_rem</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span> <span class="c1">// prod-1 is prime</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="n">prod_base</span> <span class="o">+</span> <span class="n">v0</span><span class="p">;</span>

        <span class="cm">/* Init factors */</span>
        <span class="c1">// absolute value</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">factors</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
            <span class="k">let</span> <span class="n">f_raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">p</span> <span class="o">-</span> <span class="n">l</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">prod_rem</span> <span class="o">=</span> <span class="n">f_raw</span> <span class="o">%</span> <span class="n">prod</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">prod_base</span> <span class="o">=</span> <span class="n">f_raw</span> <span class="o">-</span> <span class="n">prod_rem</span><span class="p">;</span>

            <span class="k">let</span> <span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span><span class="nf">.binary_search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prod_rem</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">),</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">prod_base</span> <span class="o">+</span> <span class="n">f0</span><span class="p">;</span>

            <span class="n">factors</span><span class="nf">.push</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">fi</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="cm">/* Run the algorithm */</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">bits</span> <span class="o">=</span> <span class="nn">BitVec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">l1</span> <span class="p">{</span>
            <span class="cm">/* sift for p_k..p_np */</span>

            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">np</span> <span class="o">-</span> <span class="n">k</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pris</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
                <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">f</span><span class="p">,</span> <span class="k">mut</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">while</span> <span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">delta</span> <span class="p">{</span>
                    <span class="n">bits</span><span class="nf">.set</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>

                    <span class="n">f</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="cm">/* accumulate primes */</span>

            <span class="k">while</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">+</span> <span class="n">delta</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="n">l</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">ans</span><span class="nf">.push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">v</span> <span class="o">+=</span> <span class="n">wg</span><span class="p">[</span><span class="n">vi</span><span class="p">];</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">wg</span><span class="nf">.len</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="cm">/* reset for next segment */</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
            <span class="n">bits</span><span class="nf">.set_all</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">ans</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">ans</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">scope</span><span class="p">(|</span><span class="n">scope</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pris_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pris</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">np</span> <span class="o">=</span> <span class="n">pris</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.rev</span><span class="p">()</span>
        <span class="nf">.find</span><span class="p">(</span>
            <span class="p">|(</span><span class="n">_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)|</span>  <span class="n">p</span> <span class="o">*</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">n</span>
        <span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">l</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">k_dekta</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">delta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">USED_CPU_CORES_NUM</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">k_dekta</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">USED_CPU_CORES_NUM</span> <span class="p">{</span>
            <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">scope</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
                <span class="nf">sieve_subtask</span><span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">pris_ref</span><span class="p">,</span>
                    <span class="n">np</span><span class="p">,</span>
                    <span class="n">l</span><span class="p">,</span>
                    <span class="nf">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                    <span class="n">delta</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">}));</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="n">k_dekta</span> <span class="o">*</span> <span class="n">delta</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">handles</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
            <span class="nf">.flatten</span><span class="p">()</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">});</span>

    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">pris</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.chain</span><span class="p">(</span><span class="n">ans</span><span class="nf">.into_iter</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>S.A. Bengelloun. An Incremental Primal Sieve. 1986. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Paul Pritchard. LINEAR PRIME-NUMBER SIEVES: A FAMILY TREE. 1987. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>不知道为什么，在 Pritchard 的论文引用里，Bengelloun 一律被写作 Bengalloun <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>对于增量筛子，固定 $f$ 而在 $p$ 上遍历的算法设计本身就有天然优势 ，所以后面 GPF 增量筛子也采用了这种设计，原因的具体分析二者也是相似的，所以这里省略了，直接参考 GPF 增量筛子即可。 <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>寻找 $f$ 这一步的复杂度分析本质上还要研究邻近质数的相关规律，但现在数学上好像还不能把这个规律搞得很清楚，不过根据经验判断，这一步的时间复杂度近似常量。同时这一步，只发生在遇到 $n = f’\cdot p^2,\ \texttt{gpf}(f’) = p$ 的时候。 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>根据前文介绍过<a href="/algs/Prime0.html#伯特兰-切比雪夫定理">伯特兰-切比雪夫定理</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/algs/Prime2.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
