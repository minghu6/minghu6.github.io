<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="/assets/style.css"/>
<link rel="stylesheet" href="/assets/js/lity.min.css"/>


<link rel='shortcut icon' type='image/jpeg' href='/d2.jpg' />


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="MINGHU6's Blog" />
<meta
    property="og:title"
    content="
        
            探讨 Rust 实现自引用结构
        
    "
/>

<meta property="og:url" content="//lang/BT-3-Extra-FlatBPT.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        探讨 Rust 实现自引用结构
    
</title>

</head>
<body class="index" data-spy="scroll" data-target="#toc" tabindex="0">

    <div class="header">
    <div id="topbar" class="align-items-center justify-content-between h-100">
  <span class="logo" id="topbar-logo">
    <a href="/" class="logo__link">
      
      <img class="logo__link__img" src="/d3.jpg" />
      
    </a>
  </span>

  <span id="search-wrapper" class="align-items-center">
    <!-- <i class="fas fa-search fa-fw"></i> -->
    <img src="/assets/img/icons/search.png">
    <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off"
      placeholder="Search...">
  </span>
  <span id="search-cancel">Cancel</span>
  <span id="breadcrumb">

    

    

    

    
  </span><!-- endof #breadcrumb -->
</div>


    

    <nav class="menu">
        
    </nav>
</div>


    <div class="page main">
    <main class="page__main" id="core-wrapper">
        <article class="post">

  <div class="post__title">
    <h1 class="post__title__text">探讨 Rust 实现自引用结构</h1>
  </div>
  <div class="post__meta">
    <div class="post__meta__category">
      
        
        <a href="/category/lang.html">
          <p class="post__meta__category__title" style="background: var(--c-themeHuePurple)">
            Language
          </p>
        </a>
      
    </div>
    <p class="post__meta__divider">·</p>
    <div class="post__meta__date">
      December 05, 2024
    </div>
    
  </div>

  

  <div class="post__content_container">
    <div class="post__content"><p><strong>别名：BT(3-extra) - Flat B+树（Vec like）</strong></p>

<p><strong>– 探索 Rust 编程模型下传统自引用数据结构的最佳实现</strong></p>

<p><strong>– 实验一种基于数组的扁平化节点和键值分离的 B+ 树实现</strong></p>

<h2 id="问题引入">问题引入</h2>

<p><strong>自引用数据结构（Self Referential Structures）</strong>，指存在递归定义的结构体，最简单的比如链表里的节点，</p>

<p>在 C 里使用<em>指针（Pointer）</em>实现这种定义</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
    <span class="p">..</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在传统的面向对象的语言比如 Java 里，直接使用<em>引用（Reference）</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但对于 Rust 而言，引入 <em>指针</em> 就破坏了内存安全（Memory safety），使用 <em>引用</em> 就面临可变性检查。</p>

<p>实在是进退失据，不知如何是好；或者说，按照 Rust 哲学自引用数据结构是一种反模式，事实上它也确实存在内存安全或并发编程方面的脆弱性。</p>

<p>但不管怎样，因为有大量的历史算法沉淀在自引用的结构里（树和图），无论如何都要找到一个在 Rust 里应付这种数据结构的办法，因为缺乏来自语言机制上的大力支持，这并不容易，实际变成了一个考验对 Rust 熟悉程度的一个门槛，像我自己用了 Rust 好几年了，到今天才算找到一点儿感觉，在此写下一个总结性的心得体会。</p>

<h2 id="两种常规方法">两种常规方法</h2>

<p>一般地讲，有两种常规的方法来实现自引用结构，一种是使用<strong>“官方指定”</strong>的“作弊器”，另一种是使用<strong>“官方使用”</strong>的“作弊器”。</p>

<h3 id="官方指定">官方指定</h3>

<p><strong>“官方指定”</strong>的作弊器指的是 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;T&gt;&gt;</code> 套装。</p>

<p>其中，<code class="language-plaintext highlighter-rouge">RefCell</code> 提供了一种通过不可变引用进行可变修改的办法，没有什么特别的，就是直接跳过了可变性检查。</p>

<p><strong>RefCell</strong></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">borrow</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="n">BorrowFlag</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="c1">// Stores the location of the earliest currently active borrow.</span>
    <span class="c1">// This gets updated whenever we go from having zero borrows</span>
    <span class="c1">// to having a single borrow. When a borrow occurs, this gets included</span>
    <span class="c1">// in the generated `BorrowError`/`BorrowMutError`</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"debug_refcell"</span><span class="nd">)]</span>
    <span class="n">borrowed_at</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">crate</span><span class="p">::</span><span class="nn">panic</span><span class="p">::</span><span class="n">Location</span><span class="o">&lt;</span><span class="k">'static</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[rustc_never_returns_null_ptr]</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="c1">// We can just cast the pointer from `UnsafeCell&lt;T&gt;` to `T` because of</span>
        <span class="c1">// #[repr(transparent)]. This exploits std's special status, there is</span>
        <span class="c1">// no guarantee for user code that this will work in future versions of the compiler!</span>
        <span class="k">self</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="o">!</span><span class="nb">Sync</span> <span class="k">for</span> <span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="c1">// Positive values represent the number of `Ref` active. Negative values</span>
<span class="c1">// represent the number of `RefMut` active. Multiple `RefMut`s can only be</span>
<span class="c1">// active at a time if they refer to distinct, nonoverlapping components of a</span>
<span class="c1">// `RefCell` (e.g., different ranges of a slice).</span>
<span class="c1">//</span>
<span class="c1">// `Ref` and `RefMut` are both two words in size, and so there will likely never</span>
<span class="c1">// be enough `Ref`s or `RefMut`s in existence to overflow half of the `usize`</span>
<span class="c1">// range. Thus, a `BorrowFlag` will probably never overflow or underflow.</span>
<span class="c1">// However, this is not a guarantee, as a pathological program could repeatedly</span>
<span class="c1">// create and then mem::forget `Ref`s or `RefMut`s. Thus, all code must</span>
<span class="c1">// explicitly check for overflow and underflow in order to avoid unsafety, or at</span>
<span class="c1">// least behave correctly in the event that overflow or underflow happens (e.g.,</span>
<span class="c1">// see BorrowRef::new).</span>
<span class="k">type</span> <span class="n">BorrowFlag</span> <span class="o">=</span> <span class="nb">isize</span><span class="p">;</span>
<span class="k">const</span> <span class="n">UNUSED</span><span class="p">:</span> <span class="n">BorrowFlag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Location</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Rc</code> 是引用计数器（Reference counter），是一种代表性的 GC 方法。</p>

<p><strong>Rc</strong></p>

<p>其中 <code class="language-plaintext highlighter-rouge">NonNull</code> 更多意义上是文档作用，表明这个指针不应被设为 <code class="language-plaintext highlighter-rouge">null</code>。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This is a `NonNull` to allow optimizing the size of this type in enums,</span>
    <span class="c1">// but it is not necessarily a valid pointer.</span>
    <span class="c1">// `Weak::new` sets this to `usize::MAX` so that it doesn’t need</span>
    <span class="c1">// to allocate space on the heap. That's not a value a real pointer</span>
    <span class="c1">// will ever have because RcInner has alignment at least 2.</span>
    <span class="c1">// This is only possible when `T: Sized`; unsized `T` never dangle.</span>
    <span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pointer</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// This is repr(C) to future-proof against possible field-reordering, which</span>
<span class="c1">// would interfere with otherwise safe [into|from]_raw() of transmutable</span>
<span class="c1">// inner types.</span>
<span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">strong</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">weak</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[cfg(not(no_global_oom_handling))]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// There is an implicit weak pointer owned by all the strong</span>
        <span class="c1">// pointers, which ensures that the weak destructor never frees</span>
        <span class="c1">// the allocation while the strong destructor is running, even</span>
        <span class="c1">// if the weak pointer is stored inside the strong one.</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">from_inner</span><span class="p">(</span>
                <span class="c1">// get 'static lifetimes raw pointer</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">leak</span><span class="p">(</span>
                    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                        <span class="n">RcInner</span> <span class="p">{</span> <span class="n">strong</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">weak</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">value</span> <span class="p">}))</span>
                    <span class="nf">.into</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.inc_weak</span><span class="p">();</span>
        <span class="n">Weak</span> <span class="p">{</span> <span class="n">ptr</span><span class="p">:</span> <span class="n">this</span><span class="py">.ptr</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
   
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">#[inline]</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_inner</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">RcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">ptr</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.dec_strong</span><span class="p">();</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span><span class="nf">.strong</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nn">ptr</span><span class="p">::</span><span class="nf">drop_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="p">(</span><span class="o">*</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.as_ptr</span><span class="p">())</span><span class="py">.value</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.inner</span><span class="p">()</span> <span class="p">{</span> <span class="n">inner</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">};</span>

        <span class="n">inner</span><span class="nf">.dec_weak</span><span class="p">();</span>
        <span class="c1">// the weak count starts at 1, and will only go to zero if all</span>
        <span class="c1">// the strong pointers have disappeared.</span>
        <span class="k">if</span> <span class="n">inner</span><span class="nf">.weak</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.alloc</span><span class="nf">.deallocate</span><span class="p">(</span>
                    <span class="k">self</span><span class="py">.ptr</span><span class="nf">.cast</span><span class="p">(),</span> 
                    <span class="nn">Layout</span><span class="p">::</span><span class="nf">for_value_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.ptr</span><span class="nf">.as_ptr</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这两种个组件都非常鸡肋，前者是假装解决问题，后者更是庸人自扰。</p>

<p><code class="language-plaintext highlighter-rouge">RefCell</code> 只是在用户端代码的级别上对指针进行了封装，没有能力提供任何有实质意义的安全保证，它唯一做的事情就是<strong>形式上</strong>封装了“不安全”的代码，使它变成“安全”的代码。</p>

<p><code class="language-plaintext highlighter-rouge">Rc</code> 的问题就更大，属于设计上就没想清楚，实验性的一个东西。首先，看代码的时候就思考一个问题，为什么要单独搞一个 <code class="language-plaintext highlighter-rouge">Weak</code> ，它不就是不“拥有”对象所有权的普通指针吗，搞到最后怎么那么复杂，先让 <code class="language-plaintext highlighter-rouge">Rc</code> 持有数据 <code class="language-plaintext highlighter-rouge">T</code>，再让 <code class="language-plaintext highlighter-rouge">Weak</code> 持有<code class="language-plaintext highlighter-rouge">T</code> 的容器 <code class="language-plaintext highlighter-rouge">RcInner</code> 😅；</p>

<p>其次，进一步考虑这个引用计数器本身到底有什么用？它自身的计数机制就依赖于生命周期，那么这个计数到底有什么用呢？且不说本身就额外破坏了单一所有权的原则，还要再引入弱引用机制来给循环引用打补丁（补丁还不能从根本上解决问题）。<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">1</a></sup></p>

<p>不仅如此，这两个组件的套装还有严重的人体工程学的问题。</p>

<h4 id="人工学问题">人工学问题</h4>

<p>这实际是个更广泛的问题，因为 Rust 的类型系统实际上是纯函数式的<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">2</a></sup>，而承载类型语义的是结构体，这导致增加一个特性就要套一层结构体，虽然都是 Zero Cost Abstraction<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">3</a></sup>，但实在不适合人机交互，这种条件下，实际上是需要做一些扁平化结构来利于人读人写。</p>

<p>回到 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;T&gt;&gt;</code> ，任何一个在 <code class="language-plaintext highlighter-rouge">T</code> 上的访问，对于 <code class="language-plaintext highlighter-rouge">Rc</code> 要 <code class="language-plaintext highlighter-rouge">as_ref</code> ，对于 <code class="language-plaintext highlighter-rouge">RefCell</code> 要 <code class="language-plaintext highlighter-rouge">borrow</code> ，最后结果上还要面临二段 Borrow 的可变性和生命周期检查的问题，特别是早期的版本。</p>

<p>而不管什么原因，总之就是官方自己标准库的各种实现都不用这个东西。<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<h3 id="官方使用">官方使用</h3>

<p>标准库里的自引用数据结构都是特化类型的指针，比如以下是标准库 <code class="language-plaintext highlighter-rouge">BTreeMap</code> 里的“树节点”类型</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// We want to be covariant in `K` and `V`.</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">InternalNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>

    <span class="cd">/// This node's index into the parent node's `edges` array.</span>
    <span class="cd">/// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.</span>
    <span class="cd">/// This is only guaranteed to be initialized when `parent` is non-null.</span>
    <span class="n">parent_idx</span><span class="p">:</span> <span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// The number of keys and values this node stores.</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>

    <span class="cd">/// The arrays storing the actual data of the node. Only the first `len` elements of each</span>
    <span class="cd">/// array are initialized and valid.</span>
    <span class="n">keys</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">CAPACITY</span><span class="p">],</span>
    <span class="n">vals</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">CAPACITY</span><span class="p">],</span>
<span class="p">}</span>

<span class="nd">#[repr(C)]</span>
<span class="c1">// gdb_providers.py uses this type name for introspection.</span>
<span class="k">struct</span> <span class="n">InternalNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// The pointers to the children of this node. `len + 1` of these are considered</span>
    <span class="cd">/// initialized and valid, except that near the end, while the tree is held</span>
    <span class="cd">/// through borrow type `Dying`, some of these pointers are dangling.</span>
    <span class="n">edges</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">NonNull</span><span class="o">&lt;</span><span class="n">LeafNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="更好的示范">更好的示范</h3>

<p>可以合并 <code class="language-plaintext highlighter-rouge">Rc</code> 和 <code class="language-plaintext highlighter-rouge">RefCell</code> 的功能，并且去掉对于 Rust 来说莫名奇妙的计数指针，改为单一所有权的指针和由它衍生出的普通指针。</p>

<p>这样做不仅优化了人机交互，而且不但没有损失任何之前 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;T&gt;&gt;</code> 对内存安全所作的所有担保，也就是堆上内存的自动释放，并且从根本上消除了循环引用带来的内存泄漏的可能性。<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">value</span><span class="p">:</span> <span class="nn">NonNull</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">into_raw</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nb">Ptr</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="k">self</span><span class="py">.value</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">from_raw</span><span class="p">(</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[repr(transparent)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">NonNull</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;*</span> <span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="k">self</span><span class="py">.value</span><span class="nf">.as_ptr</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="k">self</span><span class="py">.value</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Copy</span> <span class="k">for</span> <span class="nb">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>这样我们自己实现的 B+ 树可能就是如下这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">entries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">_marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">[();</span> <span class="n">M</span><span class="p">]</span><span class="o">&gt;</span>
    <span class="p">},</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Ptr</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="n">_marker</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="p">[();</span> <span class="n">M</span><span class="p">]</span><span class="o">&gt;</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">BPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">OwnedPtr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="第三种方法放弃指针">第三种方法：放弃指针</h2>

<p>在现行编程框架下仍然可以避免使用指针来实现自引用结构，方法是在根部持有所有节点，使用索引（比如下标）作为传统指针的替代，不过这样有一个限制，就是节点的索引不能变。</p>

<p>首先如果索引是一个 Map ，比如 HashMap 里 Key，那么这是一个方便解决的问题，但是使用 Map 就引入了额外的依赖，这是我们很多时候想要避免的事情，同时也会损失一些性能；</p>

<p>这样的话，考虑一个简单的基于向量的实现，用它的下标作为索引，得到一个惰性删除向量，这样当删除节点的时候不会改变既有节点的位置，而当插入新数据时可以复用被标记为删除的位置。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">deleted</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="k">self</span><span class="py">.deleted</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">const</span> <span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span>
            <span class="n">deleted</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_parts</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">deleted</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">deleted</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.deleted</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="n">idx</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data</span><span class="nf">.push</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
            <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"{idx} &gt; len {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">let</span> <span class="n">old</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>

        <span class="k">if</span> <span class="n">old</span><span class="nf">.is_some</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.deleted</span><span class="nf">.push</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">old</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.is_some</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样的实现虽然多了一层间接访问，但在一个综合了插入、删除和查询的综合测试看，这样结构的一个 B+ 树实现与标准库里的 <code class="language-plaintext highlighter-rouge">BTreeMap</code> 的性能几乎一致。</p>

<p><strong>测试的配置</strong></p>

<p><em>元组第一个数字是概率权重，第二个是操作名</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">roller</span> <span class="o">=</span> <span class="nn">RandomRoller</span><span class="p">::</span><span class="nf">with_candicates</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
    <span class="c1">// get</span>
    <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
    <span class="c1">// range</span>
    <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="nf">R</span><span class="p">(</span><span class="n">Unbounded</span><span class="p">,</span> <span class="n">Unbounded</span><span class="p">)),</span>
    <span class="c1">// insert</span>
    <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="c1">// remove </span>
    <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nf">D</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
<span class="p">]);</span>
</code></pre></div></div>

<p><strong>示例片段</strong></p>

<p><a href="https://github.com/minghu6/rust-minghu6/blob/v0.1.12/coll_st/src/bt/flatbpt.rs">完整代码</a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="cd">/// (key, dataid)</span>
        <span class="n">entries</span><span class="p">:</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="cd">/// *NOTE:* For root node, `paren` is nonsense.</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Internal</span> <span class="p">{</span>
        <span class="cd">/// (min-key of child, nodeid)</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">KVEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">paren</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>


<span class="nd">#[derive(Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FlatBPT</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="cd">/// uncouple data manage (avoid unnecessary mutability check)</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;*</span><span class="k">mut</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// nodes[0] would be root and should always not to be deleted</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">LazyDeleteVec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PartialInitArray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">C</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">arr</span><span class="p">:</span> <span class="p">[</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">C</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="注解">注解</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3" role="doc-endnote">
      <p>这个东西看起来就是对 C++ 或者其他传统系统编程语言的不假思索的模仿 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>在纯函数语言的世界里，它还远不够强大（也许 Rust 2.0 能改进），但对于传统的系统编程语言的世界已经是一种巨大的冲击 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>苦了编译器和代码静态分析的工具，但这也是随着计算机性能的提高，编程语言发展的应有之义 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>如果他们开始使用就会发现那是真的难用，无用而且折磨，折磨而且无用 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>在标准库里的 <code class="language-plaintext highlighter-rouge">XXCell</code>，特别地 <code class="language-plaintext highlighter-rouge">impl !Send</code> 和 <code class="language-plaintext highlighter-rouge">impl !Sync</code> ，来确保这种在可变性上的“作弊”手段不会被滥用导致 race condition，而对于我们用户端代码，只要不声明实现这两个 trait，本来就不会自动实现 <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>

    <div id="toc-wrapper" class="pl-0 pr-4 mb-5 post__toc">
      <span>
        <a href="/">
          <img src="/assets/img/icons/home.png" class="pl-4 pb-4">
        </a>
      </span>
      <nav id="toc" data-toggle="toc"></nav>
      <span>
        <a href="/lang/BT-3-Extra-FlatBPT.html#">
          <img src="/assets/img/icons/move-up.png" class="pl-0 pr-4 mb-5" >
        </a>
      </span>
    </div>
    <!-- <div id="toc-wrapper" class="pl-0 pr-4 mb-5">

    </div> -->
  </div>

</article>

    </main>

    <div class="page__comment">
        <script src="https://giscus.app/client.js"
            data-repo="minghu6/minghu6.github.io"
            data-repo-id="MDEwOlJlcG9zaXRvcnkxMTI3NDIxOTA="
            data-category="Announcements"
            data-category-id="DIC_kwDOBrhPLs4CSYaE"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="1"
            data-input-position="top"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>
</div>

    <!--
  The Search results
-->
<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-12 col-sm-11 post-content">
    <div id="search-hints">
    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>


    <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© minghu6</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

    <script src="/assets/js/jquery.slim.min.js"></script>
<script src="/assets/js/lity.min.js"></script>
<script src="/assets/js/tools.js"></script>


<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script>


<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script> -->
<script>
  MathJax = {
  tex: {
    inlineMath: [
      ['$','$'],
      ['\\(','\\)']
    ],
    displayMath: [
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
}
</script>

<!-- <script>
var navSelector = "#toc";
// only show two levels
$("body").scrollspy({
  target: navSelector,
});
</script> -->


    <!--
Jekyll Simple Search loader
See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->



<script src="/assets/js/simple-jekyll-search.min.js"></script>

<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: "/assets/search.json",
    searchResultTemplate: '  <div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0 justify-content-center">    <a href="{url}">{title}</a>    <div class="post__meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">      {categories}    </div>    <p>{snippet}</p>  </div>',
    noResultsText: '<p class="mt-5">No result</p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }
    }
  });

  $(function() {
    const btnSearchTrigger = $("#search-trigger");
    const btnCancel = $("#search-cancel");
    const main = $(".main");
    const topbarTitle = $("#topbar-title");
    const searchWrapper = $("#search-wrapper");
    const resultWrapper = $("#search-result-wrapper");
    const results = $("#search-results");
    const input = $("#search-input");
    const hints = $("#search-hints");

    const scrollBlocker = (function() {
      let offset = 0;
      return {
        block() {
          offset = window.scrollY;
          $("html,body").scrollTop(0);
        },
        release() {
          $("html,body").scrollTop(offset);
        },
        getOffset() {
          return offset;
        }
      };
    }());

/*--- Actions in mobile screens (Sidebar hidden) ---*/

    const mobileSearchBar = (function() {
      return {
        on() {
          topbarTitle.addClass("unloaded");
          btnSearchTrigger.addClass("unloaded");
          searchWrapper.addClass("d-flex");
          btnCancel.addClass("loaded");
        },
        off() {
          btnCancel.removeClass("loaded");
          searchWrapper.removeClass("d-flex");
          topbarTitle.removeClass("unloaded");
          btnSearchTrigger.removeClass("unloaded");
        }
      };
    }());

    const resultSwitch = (function() {
      let visible = false;

      return {
        on() {
          if (! visible) {
            scrollBlocker.block();
            resultWrapper.removeClass("unloaded");
            main.addClass("unloaded");
            visible = true;
          }
        },
        off() {
          if (visible) {
            results.empty();
            if (hints.hasClass("unloaded")) {
              hints.removeClass("unloaded");
            }
            resultWrapper.addClass("unloaded");
            main.removeClass("unloaded");
            scrollBlocker.release();

            input.val("");
            visible = false;
          }
        },
        isVisible() {
          return visible;
        }
      };

    }());

    function isMobileView() {
      return btnCancel.hasClass("loaded");
    }

    btnSearchTrigger.click(function() {
      mobileSearchBar.on();
      resultSwitch.on();
      input.focus();
    });

    btnCancel.click(function() {
      mobileSearchBar.off();
      resultSwitch.off();
    });

    input.focus(function() {
      searchWrapper.addClass("input-focus");
    });

    input.focusout(function() {
      searchWrapper.removeClass("input-focus");
    });

    input.on("input", () => {
      if (input.val() === "") {
        if (isMobileView()) {
          hints.removeClass("unloaded");
        } else {
          resultSwitch.off();
        }

      } else {
        resultSwitch.on();
        if (isMobileView()) {
          hints.addClass("unloaded");
        }
      }
    });

  });
</script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css">


</body>
</html>
