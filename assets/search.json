[ { "title": "Topological Sort", "url": "/algs/GraphTarjanDFS2.html", "categories": "algs", "date": "2023-05-25 00:00:00 +0800", "snippet": "是解决有前置课程限制的课表安排之类的问题，用有向边代表一个事件和它的前置事件，那么这样构成的有向图的拓扑排序（结果并不唯一）就是一个规划方案。拓扑排序的对图的要求是有向无环图（Directed Acyclic Graph，DAG），可以使用一个基于 DFS 的拓扑排序的方法，可以在线性时间里进行拓扑排序，并且能够检查环的存在。这个基于 DFS 的线性的拓扑排序的算法很可能也是来源于 Tarj..." }, { "title": "Tarjan DFS", "url": "/algs/GraphTarjanDFS.html", "categories": "algs", "date": "2023-05-20 00:00:00 +0800", "snippet": "本文资料来源于12Tarjan 其实是老朋友了，之前介绍过的斐波那契堆（1986），他就是它的两位作者之一， 现在是要介绍他早期（1972、1973）发表的通过图上 DFS 来线性时间解决3： 在无向图上划分双联通分量 查找强连通分量其中一些概念也是（可能）后续一些基于 DFS 的算法的基础。深度优先遍历对一个连通无向（简单）图，如下所示：（默认按照字母顺序）进行深度优先地图上遍历：\\[..." }, { "title": "树状数组", "url": "/algs/FenwickTree.html", "categories": "algs", "date": "2023-04-24 00:00:00 +0800", "snippet": "本文主要参考 OI-wiki 以及 cp-algorithms.com 相关页面1树状数组（Binary Indexed Tree, Fenwick Tree）2，以下简称 BIT，其命名是由于 Peter Fenwick 在 1994 年发表的文章里描述了这一结构，它的本质是通过高效地计算数组的前缀和来解决相关的问题。VS 分段树因此树状数组也能解决诸如给定区间的和之类的问题，只要这类问题..." }, { "title": "分片级联（Fractional Cascading）", "url": "/algs/FractionalCascading.html", "categories": "algs", "date": "2023-04-17 00:00:00 +0800", "snippet": "本文主要参考 wiki ，对其中一些内容进行了拓展，对个别错误进行了修正。分片级联是一种同时对多个有序列表进行二分查找的加速技术。假设有 $k$ 个有序列表，给定一个元素 $q$ ，查询在每个有序列表上的位置。思路原始做法依次在每个有序列表上执行二分查找，假设每个列表的平均长度为 $n$ ，总长度 $N=kn$ ， 则时间复杂度为 $O(k\\ \\text{log}\\ n)$ 。改进的做法可以..." }, { "title": "分段树（Segment Tree）", "url": "/algs/SegmentTree.html", "categories": "algs", "date": "2023-04-10 00:00:00 +0800", "snippet": "更常见的名字是线段树，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦1的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？本文基本算是对 cp-algorith..." }, { "title": "最大公约数（Great Common Divisor）", "url": "/algs/GCD.html", "categories": "algs", "date": "2023-04-06 00:00:00 +0800", "snippet": "假设对于非负整数，$a$ , $b$ ，求它们的最大公约数 $\\text{gcd}(a, b)$ ，以下简写作 $g$ 。数学上，最大公约数只有对两个非零整数才有意义，但是一般从实现的方面，规定： $\\text{gcd}(0, b) = a$ , $\\text{gcd}(a, 0) = a$ $\\text{gcd}(0, 0) = 0$辗转相减也是原始的欧几里得（Euclidean）..." }, { "title": "0685 - Redundant Connection II", "url": "/oth/LeetCode0685.html", "categories": "oth", "date": "2023-03-31 00:00:00 +0800", "snippet": "题干问题描述破题这题说难不难，没有复杂的数据结构和算法，但是情况比较繁琐细致，可以说非常贴近实际情况了。具体来说，这个题的破题的关键在于搞清楚一棵有向树，多了一条边后，会形成什么样的情况。这不是一次就能全想清楚的 ，在代码失败了几次后，我们总结出三种情况： 形成双头节点（a-&gt;b, c-&gt;b, b就是双头节点） 形成循环（a-&gt;b, b-&gt;c, c-&gt;a） ..." }, { "title": "加速 Rust 构建", "url": "/lang/SpeedupRustBuilding.html", "categories": "lang", "date": "2023-03-22 00:00:00 +0800", "snippet": "阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow总结了加速的注意事项： 拆分过大的 crate ，一个基本编译单元至少是一个 crate，拆分 crate 可以利用多核优势 检查不必要的依赖，某些依赖可能会大幅拖慢编译时间 避免不必要的多态，缩减编译时间 为 release 也开启增量编译 increm..." }, { "title": "基于前缀树的持久化向量（TrieVec）", "url": "/algs/TrieVec.html", "categories": "algs", "date": "2023-03-17 00:00:00 +0800", "snippet": "在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下另篇关于降低构建时间的笔记。前言本篇作为一个阶段性的总结篇，介绍一个基于前缀树（Trie）的持久化向量（Vector）的实现1 ，以下用 ..." }, { "title": "BT(3) - B+树完整版以及B*性质", "url": "/algs/BT-3-BPT_complete_with_star.html", "categories": "algs", "date": "2023-03-14 00:00:00 +0800", "snippet": "继承前两篇 B+树(Vec) 和 B+树(TreeMap) 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在这里数据结构树为了 pop_first / pop_last 增加了最小、最大节点。impl_tree!( /// B+ Trees /// BPT { cnt: usize, min_node: WeakNode&lt;K, V&..." }, { "title": "BT(2) - B+树（TreeMap）", "url": "/algs/BT-2-BPT2.html", "categories": "algs", "date": "2023-03-14 00:00:00 +0800", "snippet": "对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。没错，现在我们就是要用前文实现的 B+ 树作为我们新 B+ 树的节点基础。当然这是一个递归的概念，我们也可以继续下去把这个新的 B+ 树的实现作为节点基础实现 B+ 树，如此 $3$ 层、$..." }, { "title": "BT(1) - B+树（Vec）", "url": "/algs/BT-1-BPT.html", "categories": "algs", "date": "2023-03-13 00:00:00 +0800", "snippet": "在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。如果说之前好不容易把观念从二叉搜索树转换到了 B 树，那么从现在开始，从 B 树到 B+ 树又需要有一个很大的观念转变。不过请放心，本文讲得是依靠 Vec 实现的 B+ 树，后面还会介绍用 TreeMap 实现的 B+ 树，那时又需要一个很大的观念转变。整个 B 树系列计划了四篇文章，即使层层铺叠，每篇间的学习曲线都很陡峭..." }, { "title": "单词与短语", "url": "/oth/WordAndPhase.html", "categories": "oth", "date": "2023-02-27 00:00:00 +0800", "snippet": "Aa grinding halt陷入停顿 Memory-hogging programs can deplete the system’s memory, bringing the whole system to a grinding halt.Articulation` /ɑːrˌtɪk.jəˈleɪ.ʃən/`n.衔接、链接 If the top point does not con..." }, { "title": "疑难杂症备忘录", "url": "/oth/BackNotes.html", "categories": "oth", "date": "2023-02-20 00:00:00 +0800", "snippet": "Q1:Ubuntu 22.04 叠加几次需要重启的更新后重启发现WiFi模块找不到了A: 再次重启或关机重启都没有用，最后是重新关闭和启用了WiFi驱动（在软件更新里）解决的问题" }, { "title": "BT(0) - B树", "url": "/algs/BT-0-BT.html", "categories": "algs", "date": "2023-02-20 00:00:00 +0800", "snippet": "B 树是波音实验室的 Rudolf Bayer and Edward M. McCreight 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。本系列将介绍 B 树以及 B+ 树、B+ 树的 TreeMap 实现、 B+* 树等一些列算是 B 树的变种。概念基础B 树是完全平衡的多路搜索树，基本上已经是传统红黑树的上位替代。 节点数的减少，极大地节省了内..." }, { "title": "Disk上的存储结构", "url": "/oth/StorageMedium-1-Disk.html", "categories": "oth", "date": "2023-02-13 00:00:00 +0800", "snippet": "介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。盘片划分一个盘片的基本两级结构是： 轨道（Track）- 扇区（Sector）。轨道是盘片上的同心圆（考虑到轨道的宽度，实际上是很窄的同心圆环）而扇区则是一条轨道上按照一定角度划分的弧，是最基本的存储单元。注意这个概念显然有别于几何学上的扇区，这里的扇区实际是几何意义上的扇区在某一轨道上的交集。轨道编号习惯轨道的编号传统上从小到大按照从..." }, { "title": "存储介质（0）- 基础", "url": "/oth/StorageMedium-0-Basic.html", "categories": "oth", "date": "2023-02-13 00:00:00 +0800", "snippet": "分类按照记录数据的载体，可以分为磁性存储（magnetic）、光学存储（optical）和集成电路存储磁性存储 机械硬盘 软盘（floppy disk） 磁带鼓一个比一个老，磁带鼓更是老资格光学存储 光盘集成电路存储集成电路（Integrated Circuit， IC），不管有没有晶体管，都是有有半导体材料，也直接叫做半导体存储。在这样电路实现分为：RAM 和 ROMRAMRAM（..." }, { "title": "BST(5) - 树堆（Treep）", "url": "/algs/BST-5-Treep.html", "categories": "algs", "date": "2023-02-02 00:00:00 +0800", "snippet": "基本概念树堆的概念首次是由 Raimund Seidel and Cecilia R. Aragon 在 1989 年提出，它意思是节点用两个属性分别维护了二叉搜索树的性质和堆的性质。从二叉搜索树的角度看，可以类比前面的 Splay树，Splay 平衡性好要依赖于输入的数据具有随机性，而树堆干脆利用随机生成的权重来手动制造这种随机性。实质上都是通过随机化的输入来达到树结构的平衡。基础定义共同..." }, { "title": "BST(3) - 伸展树（Splay Tree）", "url": "/algs/BST-3-Splay-Tree.html", "categories": "algs", "date": "2023-01-30 00:00:00 +0800", "snippet": "基本概念伸缩树（Splay Tree）是 Daniel Sleator and Robert Tarjan 在 1985 年提出，它的想法就是一个，把最近访问的节点 roll 到根节点。它的性质与 CPU 缓存机制非常契合，又不需要存储额外字段，常用于缓存和垃圾回收器的实现。但是这样的性质也导致 查询的时候也会修改自身的结构，这在多线程环境和纯函数编程语言里会造成很大的麻烦； 这不是很“..." }, { "title": "BST(4.1) - 惰性替罪羊树（LSG）", "url": "/algs/BST-4.1-LSG-Tree.html", "categories": "algs", "date": "2023-01-29 00:00:00 +0800", "snippet": "基本概念替罪羊树 的基本概念前文已经介绍过，这里主要做两个变化，一个是增加 size 字段来省略动态计算 size 的时间，另一个是使用惰性删除。由于重构的存在，替罪羊树本来就很适合使用惰性删除的方法。基础定义共同结构def_tree!( /// Lazy Scapegoat Tree LSG { cnt: usize, /// nodes co..." }, { "title": "BST(4) - 替罪羊树（SG）", "url": "/algs/BST-4-SG-Tree.html", "categories": "algs", "date": "2023-01-29 00:00:00 +0800", "snippet": "基本概念替罪羊树（Scapegoat Tree）初始是在 1989 年由 Arne Andersson 发明，而在 1993 年 Igal Galperin and Ronald L. Rivest 正式提出这个概念。它是说不用每次修改树结构后都进行重平衡的操作，而是当检测到树的不平衡程度达到阈值时直接重构以某个节点为根的树。搜/插/删的平均时间复杂度与其他自平衡二叉搜索树一样，都是 $O(..." }, { "title": "BST(2) - RB(2) - AA树", "url": "/algs/BST-2-RB-Tree-2-AA.html", "categories": "algs", "date": "2023-01-20 00:00:00 +0800", "snippet": "基本概念AA 树（以下简称 AA）由 Arne Andersson 在 1993 年发明提出。AA 从理解到实现和 LLRB 是高度相似的（但是从作者关系上我们还是选择先介绍 LLRB），而一般的介绍资料，不管是 LLRB 还是 AA 的，都没有提这种密切的联系。在 LLRB 里面，通过颜色关系，让节点与 2-3/2-4 树的节点一一对应；而在 AA 里每个节点也对应2-3树的节点。我们说 ..." }, { "title": "BST(2) - RB(1) - 左偏红黑树", "url": "/algs/BST-2-RB-Tree-1-LLRB.html", "categories": "algs", "date": "2023-01-20 00:00:00 +0800", "snippet": "基本概念LLRB 是特化后的红黑树，基本来源是一个 2008年 Robert Sedgewick （原始红黑树的两位联合发明人之一）的教学 PPT ，和红黑树一样，基本也不太行（指得是实现复杂，不直观，而且不体面（指得是删除操作依靠节点内容的交换））关于 LLRB 名气很大，但是基本上也找不到很多除了原作者以外的介绍资料，大家抄得都是同一份 Slide 。实际上它在代码上如果不使用递归版本，..." }, { "title": "BST(2) - RB(0) - 原始红黑树", "url": "/algs/BST-2-RB-Tree-0-Origin.html", "categories": "algs", "date": "2023-01-19 00:00:00 +0800", "snippet": "基本概念红黑树是一种对平衡的要求比前面介绍的 AVL树 宽松一些的自平衡二叉搜索树，因此虽然查询性能稍差，但有更少的 插/删 所需要的旋转次数，也就是写的性能更加优秀。它是在在 1978 年由 Leonidas J. Guibas and Robert Sedgewick 联合提出，用红黑色标识区分主要是考虑到排版系统和手写方面的好处。（它模仿了 $4$ 阶 B树）它把节点分为红色和黑色（空..." }, { "title": "BST(1) - AVL树", "url": "/algs/BST-1-AVL-Tree.html", "categories": "algs", "date": "2023-01-17 00:00:00 +0800", "snippet": "前文介绍了二叉搜索树基础 ，这里是第一个自平衡的二叉搜索树 – AVL树，它是在 1962 年由前苏联的科学家 Georgy Adelson-Velsky 和 Evgenii Landis 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。基本概念AVL树对树平衡的要求是（每个节点）左右树高的差距不超过 $1$ 。定义 $\\texttt{BF}$（Balance Factor）= 右子..." }, { "title": "BST(0) - 二叉搜索树基础", "url": "/algs/BST-0-Basic.html", "categories": "algs", "date": "2023-01-14 00:00:00 +0800", "snippet": "作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。定义二叉搜索树是二叉树，但是额外需要每个节点满足：左孩子（如果有的话）的 key 比它的小，而右孩子的 key 比它的大 。实现前言考虑如何在实现上（Rust）把本文介绍的二叉搜索树的基础操作作为后面实现的具体种类的带自平衡的二叉搜索树的基础 ，..." }, { "title": "编译器前端基础", "url": "/algs/CompilerFrontEndBasic.html", "categories": "algs", "date": "2022-12-23 00:00:00 +0800", "snippet": "关于龙书本篇介绍的基本概念来自于经典的龙书（Compilers Principles, Techniques and Tools））。而整个龙书，不幸地是，很多技术概念完全是以 类C 语言为前提做的介绍，从名字上，从章节目录上感到应该有帮助，实际没用。另外对于 LR，LL 这些，似乎专注于做一个通用编译器的生成器，而不是编译器，而现在既然已有大量的通用生成器，但21世纪以来编程语言的发展趋势..." }, { "title": "字符编码（Character Encoding）", "url": "/algs/CharEncoding.html", "categories": "algs", "date": "2022-12-20 00:00:00 +0800", "snippet": "序言每次谈到技术标准的问题，就一定要探究一下相关历史，这样才能搞清楚一堆相关概念到底是什么意思，才能理解这个标准的意义到底在哪儿。通常这个历史发展有三个阶段： 蛮荒时期，各参与实体相对独立开发，各有各的标准； 过渡时期，为适应相关领域的发展，开始有一个统一的标准，但各实体的标准还继续起作用； 大一统时期，统一的标准已经统一了应用，蛮荒时期的标准被废弃，只存在于个别非常旧的应用里对于字符..." }, { "title": "最短路径（SP）问题", "url": "/algs/GraphSP.html", "categories": "algs", "date": "2022-12-01 00:00:00 +0800", "snippet": "像水面上打漂儿出的石头，只是“一击就弹出“地了解关于最短路径（Shortest Path，以下简称SP）问题。前言介绍的最短路径的算法以有向图（强连通）为基础，但也适用于无向图的情况，只是在涉及负环时情况略有不同1。遵循依赖关系，将依次介绍： Floyd 算法 （全源） Bellman-Ford 算法 （单源） Bellman-Ford 算法的著名改进： SPFA 算法 （单源） D..." }, { "title": "N叉堆实现（Rust）", "url": "/algs/DaryHeap.html", "categories": "algs", "date": "2022-11-23 00:00:00 +0800", "snippet": "一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为斐波那契堆的上位替代。下图 $q=2^1$数据结构/// Min Heap, I is unique, T is weight#[derive(Clone)]pub struct DaryHeap&lt;const E: usize, I, T&g..." }, { "title": "速通最小生成树（MST）", "url": "/algs/GraphMST.html", "categories": "algs", "date": "2022-11-18 00:00:00 +0800", "snippet": "前言介绍三种基本的最小生成树算法：它们都是贪心算法 基于最小边的 Kruskal 算法 基于最小距离的点（到生成树）的 Prim 算法 基于连通分量最小出边的 Boruvka 算法对于它们进行简单的比较实现基于图论基础里面提到的数据结构性质介绍一下最小生成树相关的性质1，可能让我们对算法的理解能拨其冗繁、摁其要务，看得更清楚一点。割的性质对于连通图 $G = (V, E)$ ，如果 $..." }, { "title": "指数提升（倍增，Binary Lifting）", "url": "/algs/BinaryLifting.html", "categories": "algs", "date": "2022-11-16 00:00:00 +0800", "snippet": "前言我一定要狠狠地“婊扬“一下“倍增“这个翻译，这个翻译从字面上看是要翻倍、增加，可是翻倍已经包含增加的内涵（一般概念上的对象都是自然数的），结果实际上一般人看到这个词就只能理解到翻倍的意涵，为什么要翻倍？这么做的好处在哪儿？ 这到底是什么东西？我每次看到这个词总是一头雾水，看了几次算法介绍也不能抓到关键点，而使用倍增这个翻译的介绍的大多数作者也没能抓住关键点，可能他们也被倍增这个鬼翻译迷惑..." }, { "title": "斐波那契堆的实作 (for Rust)", "url": "/algs/FibHeapImplRust.html", "categories": "algs", "date": "2022-11-13 00:00:00 +0800", "snippet": "算法理论部分，在上一篇论文 Fibonacci Heap 已经讲完了，下面是干活的部分1：语言特定数据共享、可变性与非null对象Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针 Rc (reference counter) 代替直接的指针，使用 RefCel..." }, { "title": "斐波那契堆（Fibonacci Heap）", "url": "/algs/FibHeap.html", "categories": "algs", "date": "2022-10-27 00:00:00 +0800", "snippet": "Fibonacci Heap12 3是一个基于链表结构的，理论时间复杂度很优的数据结构。常用于Dijkstra最短路径、Prim最小生成树等贪心算法，使用 push - decrease-key，都是 $O(1)$ 的时间复杂度。前言一点儿啰嗦，可以跳过。说实话本来看图例， 看着各种相比最优的时间复杂度颇为心动但仔细看下去，发现完全是典型的基于链表结构的算法，代意词是理论很好但实际性能和最好..." }, { "title": "图理论基础", "url": "/algs/GraphTheoryBasic.html", "categories": "algs", "date": "2022-10-09 00:00:00 +0800", "snippet": "概念假设图 G = {V, E}， V是顶点集，E是边集 边，无向边（edge） 有向边（arc）tail(起点) -&gt; head（终点） $|V|$: 点的个数，图的阶（order） 无根树，连通无向图 简单图 (simple graph)：若一个图中没有自环和重边，它被称为简单图。具有至少两个顶点的简单无向图中一定存..." }, { "title": "Linux上把大文件夹移动到其他存储设备上来释放空间", "url": "/os/mv-large-size-dir-to-another-dev.html", "categories": "os", "date": "2022-09-10 00:00:00 +0800", "snippet": "问题背景一个常见的问题是发现某个文件夹比如/var, /opt 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。约定不妨假设根系统/挂载在磁盘分区sda4，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为sdb。思路11一个体面的思路是在sdb上创建一个分区，假设为sdb1，创建LargeD..." }, { "title": "kernel crash dump", "url": "/os/kernel-crash-dump.html", "categories": "os", "date": "2022-09-01 00:00:00 +0800", "snippet": "Ubuntuinstall linux-crashdumpDump Outputalias crash=\"crash /usr/lib/debug/boot/vmlinux-$(uname -r)\"crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;bt: backtracelog: kernel log" }, { "title": "Compile Linux Kernel", "url": "/os/compile-linux-kernel.html", "categories": "os", "date": "2022-08-26 00:00:00 +0800", "snippet": "编译实践1：学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。Linux上游源代码（git地址在其页面下方）默认环境当前目录： kernel源目录Ubuntu注意源文件的下载，不要在系统目录比如/usr/src下进..." }, { "title": "TCP Congestion Control", "url": "/net/ietf_rfc_5681_obs2581.html", "categories": "net", "date": "2022-08-07 00:00:00 +0800", "snippet": "This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.041. Introduction介绍TCP四种交织在一起的拥塞控制算法： 慢启动（slow start） 拥塞避免（congestion avoidance） 快速重传（fast retransmit） 快速恢复（fast recove..." }, { "title": "Path MTU Discovery", "url": "/net/ietf_rfc_1191_obs1063.html", "categories": "net", "date": "2022-08-06 00:00:00 +0800", "snippet": "This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.071. Protocol Overview通过设置IP header 的 DF bit 来动态发现一个路径的PMTU1:以第一跳2的MTU为初始值(已知的)，如果收到ICMP code 3-434由于网络拓扑会随时间改变，PMTU的减少，仍然..." }, { "title": "C dialect options", "url": "/lang/c_dialect_options.html", "categories": "lang", "date": "2022-08-01 00:00:00 +0800", "snippet": "Ref: 1, 2 ISO C90 ISO C99 -ansi, -std=c89, iso9899:1990, (ISO C90) -std=c99, iso9899:1999 -std=iso9899:199409 (ISO C90 as modified in amendment 1)..." }, { "title": "C/C++ 陷阱", "url": "/lang/c_trap.html", "categories": "lang", "date": "2022-04-22 00:00:00 +0800", "snippet": " 变量初始化 在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据 结构体初始化注意要在堆上手动分配内存，否则是栈上的会被回收， 这与Rust使用习惯又不一样 " }, { "title": "Zero Cost Exception Mechanism", "url": "/lang/zero_cost_exception.html", "categories": "lang", "date": "2022-03-30 00:00:00 +0800", "snippet": "Related Header Definition依赖于 unwinding library 提供的至少如下的接口: _Unwind_RaiseException, _Unwind_Resume, _Unwind_DeleteException, _Unwind_GetGR, _Unwind_SetGR, _Unwind_GetIP, _Unwind_SetIP, _Unwi..." }, { "title": "C++ ABI 笔记 1", "url": "/oth/cxx-abi-node-0.html", "categories": "oth", "date": "2022-03-27 00:00:00 +0800", "snippet": "Ref: https://itanium-cxx-abi.github.io/cxx-abi/abi.htmlMember Pointer 数据成员指针类型的基本ABI属性是 ptrdiff_t, 表示数据成员到所属基类的字节偏移量. 空数据成员指针表示为-1 (但是通过显式派生到基类的转换,生成偏移量为-1的数据成员指针) 一个非空的数据成员指针的基到派生和派..." }, { "title": "吐嘈Python3.10", "url": "/lang/opinions_on_py310.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Python这一版更新引入了对于舒服的函数式编程至关重要的结构化的模式匹配, 我把它看作是Python面对逐渐尴尬境地的一种自救。实际上自从Rust持续发展以来, 从功能上好像是C++会受到冲击, 但由于Rust本身项目管理的科学性和工具链与文档的完善性, 和整个生态系统的蓬勃发展, 对于用户体验来讲, 我现在哪怕是脚本型的任务都会使用Rust而不是Python, Rust更甜,但是更有表现..." }, { "title": "LLVM IR入门笔记", "url": "/lang/llvm_notes_0.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Function任何函数体 必须有一个ret指令显式地提供返回值, 包括return void.Basic Blockblock只能是function的下层结构, 一个function value至少有一个block, 多个block按照固定顺序排列.也就是说block不能嵌套, 只能顺序排列.函数体的入口是first block, 但后续的基本块必须通过条件或非条件的分支指令来手动连接, ..." }, { "title": "Linker", "url": "/lang/Linker.html", "categories": "lang", "date": "2021-05-27 00:00:00 +0800", "snippet": "gcc target -m32: i386:x64-32 -mx32: elf32_x86_64ld target: elf_x86_64: ELF for x64-32 elf32_x86_64: ELF for x64-32, aka x32 — 32-bit x86-64 binaries elf_i386: ELF for i386 — 3..." }, { "title": "LL and LR", "url": "/lang/LL_LR.html", "categories": "lang", "date": "2021-05-08 00:00:00 +0800", "snippet": "First Sets and Follow SetsTo compute FIRST(X) for all grammar symbols X, apply the following rules until no more terminals or ε can be added to any FIRST set:1.If Xis terminal, then FIRST(X) is {X}..." }, { "title": "从Template Haskell（Haskell宏）来认识Haskell语法结构", "url": "/lang/template-haskell.html", "categories": "lang", "date": "2021-04-17 00:00:00 +0800", "snippet": "默认工作版本 ghc 8.10.4从模板Haskell上看，主要有如下几种构造器：Q QuotationxxE属于 Exp，是xxExpressionxxP属于Pattern，是xxPattterngenId :: Q ExpgenId = do x &lt;- newName \"x\" lamE [varP x] (varE x)等价于genId = [| \\x -&gt; x |] ..." }, { "title": "GHC extensions", "url": "/lang/GHCExtensions.html", "categories": "lang", "date": "2021-04-15 00:00:00 +0800", "snippet": "AllowAmbiguousTypessince 7.8The ambiguity check rejects functions that can never be called.ScopedTypeVariablessince 6.8.1Enable lexical scoping of type variables explicitly introduced with forall.T..." }, { "title": "最优原地后缀排序算法", "url": "/algs/sa_2016.html", "categories": "algs", "date": "2020-12-01 00:00:00 +0800", "snippet": "本章介绍线性时间复杂度的后缀排序的就地算法1（Optimal In-Place Suffix Sorting）。本章只建议在非常非常熟悉SA-IS23的前提下阅读。全局设定目标字符串 $\\texttt{Pat}$，后缀数组 $\\texttt{SA}$，串的序号从 0 开始，结尾字符是警戒哨，不妨设为 0 。在整形字母表上的后缀排序事实上这一部分可以看成是原地版本的 SA-IS 算法。因为是原..." }, { "title": "Haskell 学习", "url": "/lang/Haskell%E5%AD%A6%E4%B9%A0.html", "categories": "lang", "date": "2020-11-01 00:00:00 +0800", "snippet": "1. foldr, foldl 右结合与左结合echoes = foldr (\\ x xs -&gt; (replicate x x) ++ xs) [] -- replicate 2 3 =&gt; [3 3] 2个3take 10 (echoes [1..]) -- [1,2,2,3,3,3,4,4,4,4]echoes = foldl (\\ xs x -&gt; xs ++ (repl..." }, { "title": "Haskell开发准备", "url": "/lang/Haskell%E5%BC%80%E5%8F%91Q&A.html", "categories": "lang", "date": "2020-10-01 00:00:00 +0800", "snippet": "准备环境： 安装系统级Haskell（或者直接跳过1-3，直接到4） 安装Cabal-install 安装Stack 安装ghc/cabal多环境：ghcup curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh From https://..." }, { "title": "Boyer-Moore算法", "url": "/algs/BM.html", "categories": "algs", "date": "2020-08-01 00:00:00 +0800", "snippet": "author: minghu6本章节内容需要以《前缀函数与KMP算法》作为前置章节。之前的KMP算法将前缀匹配的信息用到了极致，而BM算法背后的基本思想是通过后缀匹配获得比前缀匹配更多的信息来实现更快的跳转。基础介绍想象一下，如果我们的的模式字符串 $pat$ ，被放在文本字符串$string$的左手起头部，使它们的第一个字符对齐。\\[\\begin{aligned}\\textit{pat}:..." }, { "title": "Common Lisp 语法", "url": "/lang/common-lisp-grammer.html", "categories": "lang", "date": "2020-07-22 00:00:00 +0800", "snippet": " 列表和点对的区别： 点对是列表构成的基本单元，列表通过点对嵌套构成: '(1 . (2 . nil)) 反过来，点对(1 . 2)看起来像长度为2的列表，但如果它的cdr不是列表，那么它就不是列表 " }, { "title": "Common Lisp 编写工程文件", "url": "/lang/common-lisp-write-project.html", "categories": "lang", "date": "2020-07-21 00:00:00 +0800", "snippet": "参考​\thttps://xach.livejournal.com/278047.html​\thttps://lisp-lang.org/learn/writing-libraries流程Step-0 从安装quicklisp开始https://www.quicklisp.org/beta/#installationStep-1 使用脚手架初始化项目(ql:quickload \"quickpr..." }, { "title": "RSYNC", "url": "/os/rsync.html", "categories": "os", "date": "2018-05-25 00:00:00 +0800", "snippet": "支持 ~ 在远程server上展开-z 压缩-a archive mode, syncs recursively and preserves symbolic links, special and device files, modification times, groups, owners, and permissions-v verbose–progress 显示进度 或者 -Prsy..." }, { "title": "RM 之 殇", "url": "/os/pain-of-rm.html", "categories": "os", "date": "2018-03-13 00:00:00 +0800", "snippet": "To this end I use trash-cli package and the following alias in my ~/.bashrcalias rm=trashThe files you remove will be moved to trash, and you can see them in nautilus trashcan.You can always access..." }, { "title": "cUrl", "url": "/lang/cUrl.html", "categories": "lang", "date": "2018-02-11 00:00:00 +0800", "snippet": "$cURL = curl_init();// set urlcurl_setopt($cURL, CURLOPT_URL, $url);// set method default is GET// curl_setopt($cURL, CURLOPT_CUSTOMREQUEST, \"POST\");// set header$deviceId = '1234567890'; // custo..." }, { "title": "Mongo Repository 相关", "url": "/oth/mongo-repository.html", "categories": "oth", "date": "2018-02-01 00:00:00 +0800", "snippet": "mongo repository springfindAll 批连查取只能自定义在接口无效key 字段缺失则无法过滤Model 的某个字段是某个(Model | Vo | id)的collection Model 完全的附属关系，没办法独立统计信息 Vo 完全不会更改信息,除了添加　(比如权限) id 最常见，可以更改信息的批量添加一个字段// 更新全部, 如果没有，就添加这个字段db..." }, { "title": "Hy Usage", "url": "/lang/hy-usage.html", "categories": "lang", "date": "2018-01-05 00:00:00 +0800", "snippet": "package hy module: build a normal python package write .hy file, and add import hy in toplevel or just __init__.py (to enable compile pyc using hy) write package data in setup on setup.py set..." }, { "title": "Sudo env", "url": "/os/sudo-env.html", "categories": "os", "date": "2017-12-15 00:00:00 +0800", "snippet": "继承环境变量sudo visudo Defaults env_keep=\"http_proxy https_proxy ftp_proxy no_proxy DISPLAY XAUTHORITY\"使用当前用户的PATHDefaults env_reset改成Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加alias sudo='sudo env..." } ]
