[ { "title": "字符编码（Character Encoding）", "url": "/algs/CharEncoding.html", "categories": "algs", "date": "2022-12-20 00:00:00 +0800", "snippet": "序言每次谈到技术标准的问题，就一定要探究一下相关历史，这样才能搞清楚一堆相关概念到底是什么意思，才能理解这个标准的意义到底在哪儿。通常这个历史发展有三个阶段： 蛮荒时期，各参与实体相对独立开发，各有各的标准； 过渡时期，为适应相关领域的发展，开始有一个统一的标准，但各实体的标准还继续起作用； 大一统时期，统一的标准已经统一了应用，蛮荒时期的标准被废弃，只存在于个别非常旧的应用里对于字符..." }, { "title": "短道水上漂（SP）", "url": "/algs/GraphSP.html", "categories": "algs", "date": "2022-12-01 00:00:00 +0800", "snippet": "像水面上打漂儿出的石头，只是“一击就弹出“地了解关于最短路径（Shortest Path，以下简称SP）问题。前言值得强调在前面得是，一般比如从构造实现上，会假定最基础的情况无向图，但最短路径是以有向图（强连通）为基础。所有下列介绍的算法的都假定一个有向图，而在无向图上，部分结论会有所不同。遵循依赖关系，将依次介绍： Floyd 算法 （全源） Bellman-Ford 算法 （单源） ..." }, { "title": "N叉堆实现（Rust）", "url": "/algs/DaryHeap.html", "categories": "algs", "date": "2022-11-23 00:00:00 +0800", "snippet": "一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为斐波那契堆的上位替代。下图 $q=2^1$数据结构/// Min Heap, I is unique, T is weight#[derive(Clone)]pub struct DaryHeap&lt;const E: usize, I, T&g..." }, { "title": "速通最小生成树（MST）", "url": "/algs/GraphMST.html", "categories": "algs", "date": "2022-11-18 00:00:00 +0800", "snippet": "前言介绍三种基本的最小生成树算法：它们都是贪心算法 基于最小边的 Kruskal 算法 基于最小距离的点（到生成树）的 Prim 算法 基于连通分量最小出边的 Boruvka 算法对于它们进行简单的比较实现基于图论基础里面提到的数据结构性质介绍一下最小生成树相关的性质1，可能让我们对算法的理解能拨其冗繁、摁其要务，看得更清楚一点。割的性质对于连通图 $G = (V, E)$ ，如果 $..." }, { "title": "指数提升（倍增，Binary Lifting）", "url": "/algs/BinaryLifting.html", "categories": "algs", "date": "2022-11-16 00:00:00 +0800", "snippet": "前言我一定要狠狠地“婊扬“一下“倍增“这个翻译，这个翻译从字面上看是要翻倍、增加，可是翻倍已经包含增加的内涵（一般概念上的对象都是自然数的），结果实际上一般人看到这个词就只能理解到翻倍的意涵，为什么要翻倍？这么做的好处在哪儿？ 这到底是什么东西？我每次看到这个词总是一头雾水，看了几次算法介绍也不能抓到关键点，而使用倍增这个翻译的介绍的大多数作者也没能抓住关键点，可能他们也被倍增这个鬼翻译迷惑..." }, { "title": "斐波那契堆的实作 (for Rust)", "url": "/algs/FibHeapImplRust.html", "categories": "algs", "date": "2022-11-13 00:00:00 +0800", "snippet": "算法理论部分，在上一篇论文 Fibonacci Heap 已经讲完了，下面是干活的部分1：语言特定数据共享、可变性与非null对象Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针 Rc (reference counter) 代替直接的指针，使用 RefCel..." }, { "title": "斐波那契堆（Fibonacci Heap）", "url": "/algs/FibHeap.html", "categories": "algs", "date": "2022-10-27 00:00:00 +0800", "snippet": "Fibonacci Heap12 3是一个基于链表结构的，理论时间复杂度很优的数据结构。常用于Dijkstra最短路径、Prim最小生成树等贪心算法，使用 push - decrease-key，都是 $O(1)$ 的时间复杂度。前言一点儿啰嗦，可以跳过。说实话本来看图例， 看着各种相比最优的时间复杂度颇为心动但仔细看下去，发现完全是典型的基于链表结构的算法，代意词是理论很好但实际性能和最好..." }, { "title": "图理论基础", "url": "/algs/GraphTheoryBasic.html", "categories": "algs", "date": "2022-10-09 00:00:00 +0800", "snippet": "概念假设图 G = {V, E}， V是顶点集，E是边集 边，无向边（edge） 有向边（arc）tail(起点) -&gt; head（终点） V : 点的个数，图的阶（order） 无根树，连通无向图 简单图 (simpl..." }, { "title": "Linux上把大文件夹移动到其他存储设备上来释放空间", "url": "/os/mv-large-size-dir-to-another-dev.html", "categories": "os", "date": "2022-09-10 00:00:00 +0800", "snippet": "问题背景一个常见的问题是发现某个文件夹比如/var, /opt 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。约定不妨假设根系统/挂载在磁盘分区sda4，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为sdb。思路11一个体面的思路是在sdb上创建一个分区，假设为sdb1，创建LargeD..." }, { "title": "kernel crash dump", "url": "/os/kernel-crash-dump.html", "categories": "os", "date": "2022-09-01 00:00:00 +0800", "snippet": "Ubuntuinstall linux-crashdumpDump Outputalias crash=\"crash /usr/lib/debug/boot/vmlinux-$(uname -r)\"crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;bt: backtracelog: kernel log" }, { "title": "Compile Linux Kernel", "url": "/os/compile-linux-kernel.html", "categories": "os", "date": "2022-08-26 00:00:00 +0800", "snippet": "编译实践1：学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。Linux上游源代码（git地址在其页面下方）默认环境当前目录： kernel源目录Ubuntu注意源文件的下载，不要在系统目录比如/usr/src下进..." }, { "title": "TCP Congestion Control", "url": "/net/ietf_rfc_5681_obs2581.html", "categories": "net", "date": "2022-08-07 00:00:00 +0800", "snippet": "This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.041. Introduction介绍TCP四种交织在一起的拥塞控制算法： 慢启动（slow start） 拥塞避免（congestion avoidance） 快速重传（fast retransmit） 快速恢复（fast recove..." }, { "title": "Path MTU Discovery", "url": "/net/ietf_rfc_1191_obs1063.html", "categories": "net", "date": "2022-08-06 00:00:00 +0800", "snippet": "This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.071. Protocol Overview通过设置IP header 的 DF bit 来动态发现一个路径的PMTU1:以第一跳2的MTU为初始值(已知的)，如果收到ICMP code 3-434由于网络拓扑会随时间改变，PMTU的减少，仍然..." }, { "title": "C dialect options", "url": "/lang/c_dialect_options.html", "categories": "lang", "date": "2022-08-01 00:00:00 +0800", "snippet": "Ref: 1, 2 ISO C90 ISO C99 -ansi, -std=c89, iso9899:1990, (ISO C90) -std=c99, iso9899:1999 -std=iso9899:199409 (ISO C90 as modified in amendment 1)..." }, { "title": "C/C++ 陷阱", "url": "/lang/c_trap.html", "categories": "lang", "date": "2022-04-22 00:00:00 +0800", "snippet": " 变量初始化 在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据 结构体初始化注意要在堆上手动分配内存，否则是栈上的会被回收， 这与Rust使用习惯又不一样 " }, { "title": "Zero Cost Exception Mechanism", "url": "/lang/zero_cost_exception.html", "categories": "lang", "date": "2022-03-30 00:00:00 +0800", "snippet": "Related Header Definition依赖于 unwinding library 提供的至少如下的接口: _Unwind_RaiseException, _Unwind_Resume, _Unwind_DeleteException, _Unwind_GetGR, _Unwind_SetGR, _Unwind_GetIP, _Unwind_SetIP, _Unwi..." }, { "title": "C++ ABI 笔记 1", "url": "/oth/cxx-abi-node-0.html", "categories": "oth", "date": "2022-03-27 00:00:00 +0800", "snippet": "Ref: https://itanium-cxx-abi.github.io/cxx-abi/abi.htmlMember Pointer 数据成员指针类型的基本ABI属性是 ptrdiff_t, 表示数据成员到所属基类的字节偏移量. 空数据成员指针表示为-1 (但是通过显式派生到基类的转换,生成偏移量为-1的数据成员指针) 一个非空的数据成员指针的基到派生和派..." }, { "title": "吐嘈Python3.10", "url": "/lang/opinions_on_py310.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Python这一版更新引入了对于舒服的函数式编程至关重要的结构化的模式匹配, 我把它看作是Python面对逐渐尴尬境地的一种自救。实际上自从Rust持续发展以来, 从功能上好像是C++会受到冲击, 但由于Rust本身项目管理的科学性和工具链与文档的完善性, 和整个生态系统的蓬勃发展, 对于用户体验来讲, 我现在哪怕是脚本型的任务都会使用Rust而不是Python, Rust更甜,但是更有表现..." }, { "title": "LLVM IR入门笔记", "url": "/lang/llvm_notes_0.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Function任何函数体 必须有一个ret指令显式地提供返回值, 包括return void.Basic Blockblock只能是function的下层结构, 一个function value至少有一个block, 多个block按照固定顺序排列.也就是说block不能嵌套, 只能顺序排列.函数体的入口是first block, 但后续的基本块必须通过条件或非条件的分支指令来手动连接, ..." }, { "title": "Linker", "url": "/lang/Linker.html", "categories": "lang", "date": "2021-05-27 00:00:00 +0800", "snippet": "gcc target -m32: i386:x64-32 -mx32: elf32_x86_64ld target: elf_x86_64: ELF for x64-32 elf32_x86_64: ELF for x64-32, aka x32 — 32-bit x86-64 binaries elf_i386: ELF for i386 — 3..." }, { "title": "LL and LR", "url": "/lang/LL_LR.html", "categories": "lang", "date": "2021-05-08 00:00:00 +0800", "snippet": "First Sets and Follow SetsTo compute FIRST(X) for all grammar symbols X, apply the following rules until no more terminals or ε can be added to any FIRST set:1.If Xis terminal, then FIRST(X) is {X}..." }, { "title": "从Template Haskell（Haskell宏）来认识Haskell语法结构", "url": "/lang/template-haskell.html", "categories": "lang", "date": "2021-04-17 00:00:00 +0800", "snippet": "默认工作版本 ghc 8.10.4从模板Haskell上看，主要有如下几种构造器：Q QuotationxxE属于 Exp，是xxExpressionxxP属于Pattern，是xxPattterngenId :: Q ExpgenId = do x &lt;- newName \"x\" lamE [varP x] (varE x)等价于genId = [| \\x -&gt; x |] ..." }, { "title": "GHC extensions", "url": "/lang/GHCExtensions.html", "categories": "lang", "date": "2021-04-15 00:00:00 +0800", "snippet": "AllowAmbiguousTypessince 7.8The ambiguity check rejects functions that can never be called.ScopedTypeVariablessince 6.8.1Enable lexical scoping of type variables explicitly introduced with forall.T..." }, { "title": "最优原地后缀排序算法", "url": "/algs/sa_2016.html", "categories": "algs", "date": "2020-12-01 00:00:00 +0800", "snippet": "本章介绍线性时间复杂度的后缀排序的就地算法1（Optimal In-Place Suffix Sorting）。本章只建议在非常非常熟悉SA-IS23的前提下阅读。全局设定目标字符串 $\\texttt{Pat}$，后缀数组 $\\texttt{SA}$，串的序号从 0 开始，结尾字符是警戒哨，不妨设为 0 。在整形字母表上的后缀排序事实上这一部分可以看成是原地版本的 SA-IS 算法。因为是原..." }, { "title": "Haskell 学习", "url": "/lang/Haskell%E5%AD%A6%E4%B9%A0.html", "categories": "lang", "date": "2020-11-01 00:00:00 +0800", "snippet": "1. foldr, foldl 右结合与左结合echoes = foldr (\\ x xs -&gt; (replicate x x) ++ xs) [] -- replicate 2 3 =&gt; [3 3] 2个3take 10 (echoes [1..]) -- [1,2,2,3,3,3,4,4,4,4]echoes = foldl (\\ xs x -&gt; xs ++ (repl..." }, { "title": "Haskell开发准备", "url": "/lang/Haskell%E5%BC%80%E5%8F%91Q&A.html", "categories": "lang", "date": "2020-10-01 00:00:00 +0800", "snippet": "准备环境： 安装系统级Haskell（或者直接跳过1-3，直接到4） 安装Cabal-install 安装Stack 安装ghc/cabal多环境：ghcup curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh From https://..." }, { "title": "Boyer-Moore算法", "url": "/algs/BM.html", "categories": "algs", "date": "2020-08-01 00:00:00 +0800", "snippet": "author: minghu6本章节内容需要以《前缀函数与KMP算法》作为前置章节。之前的KMP算法将前缀匹配的信息用到了极致，而BM算法背后的基本思想是通过后缀匹配获得比前缀匹配更多的信息来实现更快的跳转。基础介绍想象一下，如果我们的的模式字符串$pat$，被放在文本字符串$string$的左手起头部，使它们的第一个字符对齐。\\[\\begin{aligned}\\textit{pat}:\\q..." }, { "title": "Common Lisp 语法", "url": "/lang/common-lisp-grammer.html", "categories": "lang", "date": "2020-07-22 00:00:00 +0800", "snippet": " 列表和点对的区别： 点对是列表构成的基本单元，列表通过点对嵌套构成: '(1 . (2 . nil)) 反过来，点对(1 . 2)看起来像长度为2的列表，但如果它的cdr不是列表，那么它就不是列表 " }, { "title": "Common Lisp 编写工程文件", "url": "/lang/common-lisp-write-project.html", "categories": "lang", "date": "2020-07-21 00:00:00 +0800", "snippet": "参考​\thttps://xach.livejournal.com/278047.html​\thttps://lisp-lang.org/learn/writing-libraries流程Step-0 从安装quicklisp开始https://www.quicklisp.org/beta/#installationStep-1 使用脚手架初始化项目(ql:quickload \"quickpr..." }, { "title": "RSYNC", "url": "/os/rsync.html", "categories": "os", "date": "2018-05-25 00:00:00 +0800", "snippet": "支持 ~ 在远程server上展开-z 压缩-a archive mode, syncs recursively and preserves symbolic links, special and device files, modification times, groups, owners, and permissions-v verbose–progress 显示进度 或者 -Prsy..." }, { "title": "RM 之 殇", "url": "/os/pain-of-rm.html", "categories": "os", "date": "2018-03-13 00:00:00 +0800", "snippet": "To this end I use trash-cli package and the following alias in my ~/.bashrcalias rm=trashThe files you remove will be moved to trash, and you can see them in nautilus trashcan.You can always access..." }, { "title": "cUrl", "url": "/lang/cUrl.html", "categories": "lang", "date": "2018-02-11 00:00:00 +0800", "snippet": "$cURL = curl_init();// set urlcurl_setopt($cURL, CURLOPT_URL, $url);// set method default is GET// curl_setopt($cURL, CURLOPT_CUSTOMREQUEST, \"POST\");// set header$deviceId = '1234567890'; // custo..." }, { "title": "Mongo Repository 相关", "url": "/oth/mongo-repository.html", "categories": "oth", "date": "2018-02-01 00:00:00 +0800", "snippet": "mongo repository springfindAll 批连查取只能自定义在接口无效key 字段缺失则无法过滤Model 的某个字段是某个(Model | Vo | id)的collection Model 完全的附属关系，没办法独立统计信息 Vo 完全不会更改信息,除了添加　(比如权限) id 最常见，可以更改信息的批量添加一个字段// 更新全部, 如果没有，就添加这个字段db..." }, { "title": "Hy Usage", "url": "/lang/hy-usage.html", "categories": "lang", "date": "2018-01-05 00:00:00 +0800", "snippet": "package hy module: build a normal python package write .hy file, and add import hy in toplevel or just __init__.py (to enable compile pyc using hy) write package data in setup on setup.py set..." }, { "title": "Sudo env", "url": "/os/sudo-env.html", "categories": "os", "date": "2017-12-15 00:00:00 +0800", "snippet": "继承环境变量sudo visudo Defaults env_keep=\"http_proxy https_proxy ftp_proxy no_proxy DISPLAY XAUTHORITY\"使用当前用户的PATHDefaults env_reset改成Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加alias sudo='sudo env..." } ]
