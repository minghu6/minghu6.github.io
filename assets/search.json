[ { "title": "Rust 包内资源管理", "url": "/lang/RustResourceCode.html", "categories": "lang", "date": "2024-12-10 00:00:00 +0800", "snippet": "问题引入有时候在一个 Cargo package/workspace 需要放一些供内部使用的非代码文件，这些文件往往是从硬编码的代码里分离出来的，变成可配置的文件，比如测试数据。这时候就需要这些资源文件进行管理，传统的方法是把每一个从目录到文件的名字作为常量（&amp;'static str）写到一个专门定义常量的文件里，但这样至少有三个缺点： 没有目录层次，如果在名字上加目录前缀，就会让..." }, { "title": "探讨 Rust 实现自引用结构", "url": "/lang/BT-3-Extra-FlatBPT.html", "categories": "lang", "date": "2024-12-05 00:00:00 +0800", "snippet": "别名：BT(3-extra) - Flat B+树（Vec like）– 探索 Rust 编程模型下传统自引用数据结构的最佳实现– 实验一种基于数组的扁平化节点和键值分离的 B+ 树实现问题引入自引用数据结构（Self Referential Structures），指存在递归定义的结构体，最简单的比如链表里的节点，在 C 里使用指针（Pointer）实现这种定义struct Node { ..." }, { "title": "0264 - Ugly Number II", "url": "/oth/LeetCode0264.html", "categories": "oth", "date": "2024-10-28 00:00:00 +0800", "snippet": "题干问题描述An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.Given an integer n, return the nth ugly number.破题Medium 题目通常比 Hard 要棘手，因为干扰项多，很容易误入歧途，而 Hard 题目反而思路明确。轮筛陷阱这..." }, { "title": "Python Cleanup", "url": "/lang/PythonCleanup.html", "categories": "lang", "date": "2024-10-16 00:00:00 +0800", "snippet": "截止于 Python 3.13前言Python 资源自动释放的机制就是四种：with, __del__, atexit , weakref.finalizewith适用于局部资源管理，是主流的资源自动释放手段，还有方便编写的 contextlib.contextmanager 装饰器。但是对于经典的单例、全局资源类不适用。__del__即编写对象的钩子函数 __del__ ，但是 Pyth..." }, { "title": "微观基准测试", "url": "/lang/Bench.html", "categories": "lang", "date": "2024-10-10 00:00:00 +0800", "snippet": "前言这里讨论的是微观基准测试（micro-benchmarking）的实现，关心的主要问题是：在一次测试里到底要重复运行几次目标函数？我们希望在尽可能少的运行次数下，得到一个相对稳定、准确的测量统计。前车之辙不妨来看一下几个语言内置的微观测试框架做了什么。Python timeit这个模块就是一个连同命令行接口和文档注解都不超过 400 代码的单文件。从语法上看，就有将近 10 年的未被修改..." }, { "title": "数字类型 - 表示和编码", "url": "/algs/NumberTypes-0.html", "categories": "algs", "date": "2024-10-09 00:00:00 +0800", "snippet": "时间有限，草稿版本，以后深入研究再修。前言一般地讲，数字类型的存储可以分为两层抽象，表示形式和（对表示形式）的编码方式。整型（Integer）表示形式整型数字的表示形式没有什么特别的，就是它的自然二进制表示。1编码方式对于无符号整数和有符号的正整数来说，编码方式就是自然的二进制表示，只有对于有符号的负整数（包括负零）要考虑特别的编码方式。有几种对于负整数的编码方式：幅值编码（Sign–mag..." }, { "title": "质数筛子拓展", "url": "/algs/Prime2.html", "categories": "algs", "date": "2024-09-23 00:00:00 +0800", "snippet": "前言介绍一种特殊形式的筛子–增量筛子以及给出使用分段技术的筛子的并行化版本的实现代码。增量筛子增量筛子（incremental sieve），就是一种可以无限（内存空间限制内）获取质数的筛子，在不确定质数范围的情境下，配合函数式编程的风格，有它独特的作用。E. 筛增量筛（√）可以预先计算 $k$ 个质数，用前 $k$ 个质数筛完 $[0, p_k^2]$ 范围内的质数，如果还要继续筛选，就以..." }, { "title": "代数结构", "url": "/algs/AbstractAlgebraic.html", "categories": "algs", "date": "2024-09-16 00:00:00 +0800", "snippet": "我们介绍得是抽象代数（abstract algebraic, modern algebraic）的结构，相对的我们熟悉的初等代数（elementary algebraic）就是研究代数方程，而我们抽象代数，显然就是更抽象了，但还有在它之上抽象的存在，那就是范畴论（category theory），是从哲学系那边转学过来的。如果说初等代数是实参函数，抽象代数就是类接口，范畴论就是元类。群（Gr..." }, { "title": "Haskell 学习小记", "url": "/lang/Haskell%E5%AD%A6%E4%B9%A0.html", "categories": "lang", "date": "2024-09-08 00:00:00 +0800", "snippet": "origin written at 2020-11-01纯函数Haskell 是 纯函数 语言，语义实现的全过程都在于形式演算，而非传统的值计算。1形式化简阿尔法化简 （$\\alpha$-conversion）通过变量名重命名来做等价变换:2\\[\\lambda x \\rightarrow \\lambda y \\rightarrow x + y \\equiv \\lambda a \\righta..." }, { "title": "质数筛子", "url": "/algs/Prime1.html", "categories": "algs", "date": "2024-08-27 00:00:00 +0800", "snippet": "质数筛子的原理是质因数分解。前言有几个关于质数筛子的总结性观察：观察 1不使用分段技术的（可用的）质数筛子，不管它的时间复杂度和空间复杂度在理论上是超线性、线性还是亚线性，在实践上都可以视为线性。这是因为， 它们的区别往往只在于 $ N\\log\\log N$, $N$ 和 $\\large\\frac{N}{\\log\\log N}$ ，而 $\\log\\log N$ 对于一个 64 位机的指针..." }, { "title": "算法复杂度分析的标记符号", "url": "/algs/ComplexityNotations.html", "categories": "algs", "date": "2024-07-28 00:00:00 +0800", "snippet": "介绍下在分析算法复杂度时用到的标记符号，及其数学来源。这些标记符号开始源于德国数学家 Paul Bachmann 和 Edmund Landau 的发明，后经 Knuth 的整理，形成了现在熟悉的这些渐进符号（asymptotic notation）。$O$ 记号开始叫做 big-O1，后经过 Knuth 整理，也可以表示为 big Omicron 。形式化描述$f(x) = O(g(x))..." }, { "title": "质数基础", "url": "/algs/Prime0.html", "categories": "algs", "date": "2023-12-29 00:00:00 +0800", "snippet": "定义质数（prime），指大于 $1$ 的自然数里，不能拆解为比它严格更小两个的自然数乘积的数。1互质（co-prime），两个整数 $a$，$b$ 没有除了 $1$ 以外的作为正整数的共同除数（divisor），则说 $a$ 质于 $b$ ，或者 $a,b$ 互质2。3性质欧几里得引理欧几里得引理4，原始版本：如果质数 $p$ 能够除 $a\\cdot b$ 5，并且 $p$ 不能除 $a$..." }, { "title": "质数基础", "url": "/algs/Greedy.html", "categories": "algs", "date": "2023-12-29 00:00:00 +0800", "snippet": "定义质数（prime），指大于 $1$ 的自然数里，不能拆解为比它严格更小两个的自然数乘积的数。1互质（co-prime），两个整数 $a$，$b$ 没有除了 $1$ 以外的作为正整数的共同除数（divisor），则说 $a$ 质于 $b$ ，或者 $a,b$ 互质2。3性质欧几里得引理4原始版本：如果质数 $p$ 能够除 $a\\cdot b$ 5，并且 $p$ 不能除 $a$ ，则 $p$..." }, { "title": "LeetCode Packet 2", "url": "/oth/LeetCodePacket2.html", "categories": "oth", "date": "2023-12-25 00:00:00 +0800", "snippet": "" }, { "title": "0174 - Dungeon Game", "url": "/oth/LeetCode0174.html", "categories": "oth", "date": "2023-12-11 00:00:00 +0800", "snippet": "题干问题描述破题绝对标准地 Hard 难度的问题。给一个二维的地图，从左上角走到右下角，看起来非常像之前做过的譬如 0085 - Maximal Rectangle 这样的题目，只需要从上到下地逐行扫描，计算从起点到每一行的每个位置的子问题的解，直到最后一行的最后一个位置。但是对于本题这样做是不行的，因为一般到某个位置的路线有两条，一条是从上到下的，一条是从左到右的，而有两个指标用来选择最小..." }, { "title": "最大子数组", "url": "/algs/MaxSubArr.html", "categories": "algs", "date": "2023-11-17 00:00:00 +0800", "snippet": "收集一系列有关最大子数组的问题。最大子数组和最大子数组积" }, { "title": "0152 - Maximum Product Subarray", "url": "/algs/LeetCode0152.html", "categories": "algs", "date": "2023-11-17 00:00:00 +0800", "snippet": "题干问题描述破题经典 Medium 但是 Hard ，这道题单独看可以算作 Medium 类型的题目，但是作为 DP 标签就显得很 Hard，因为题目和一般的 DP 思路好像有关系，实质是没有关系，如果再类比 0053 - Maximum Subarray 的思路那就更困难了，难就难在干扰项。同样也是正、负、零三种整数，而累积和累和的区别在于累积的符号会翻转而且幅度越来越大，最大数可以由正数..." }, { "title": "1458 - Max Dot Product of Two Subsequences", "url": "/algs/LeetCode1458.html", "categories": "algs", "date": "2023-10-17 00:00:00 +0800", "snippet": "题干问题描述破题源代码一般地两串上的DP是从两个前缀子串开始的更小规模的问题扩展到全串，从而直接解决题目要求的问题，而本题特殊的地方是子序列并不是完整的前缀子串。不妨把前缀子串视为 border，而譬如子序列则是 content ，它和 border之间有 padding ，其他普通的问题可以通过 border 就可以直接计算出来，而对于子序列这样的问题，需要额外考虑是否需要“填充” pa..." }, { "title": "LeetCode Best Time to Buy and Sell Stock", "url": "/oth/LeetCodeBuySellStock.html", "categories": "oth", "date": "2023-10-01 00:00:00 +0800", "snippet": "0121. Best Time to Buy and Sell StockEasy单次交易def maxProfit(self, prices: List[int]) -&gt; int: n = len(prices) ans = 0 h = 0 for i in range(n-1, -1, -1): if h &lt; prices[i]: ..." }, { "title": "0115 - Distinct Subsequences", "url": "/oth/LeetCode0115.html", "categories": "oth", "date": "2023-09-30 00:00:00 +0800", "snippet": "题干问题描述破题源代码判断一个串的所有（非连续）子序列里，等于目标串的数量。这里要特别关注解3：子序列的窗口范式解①正解：这个是最直接的推导思路，考虑 $s$ 的前缀从 $s[..0]$ 逐个增加字符直到 $s[..n]$ ，观察对样本串 $t$ 它的前缀随之的变化。假设增加了一个字符 $x$ ，那么对于样本串 $t$ ，所有出现 $x$ 的位置的前缀都会因此受到影响。假设 $x$ 出现在 ..." }, { "title": "0087 - Scramble String", "url": "/oth/LeetCode0087.html", "categories": "oth", "date": "2023-09-19 00:00:00 +0800", "snippet": "题干问题描述破题源代码因为这道题是 3k点赞，1k点踩， 于是看了下评论，结果为我的解题带来了非常大的负面影响：有一个评论里讲什么这道题的题解非常困难，但是用4套嵌套循环实现非常简单，这一直影响我的思路。然而实际上这只是一道普通的 Top-down DP，或者说，记忆化搜索就可以通过的题目。另外让人不爽地是这个文本：“Randomly decide to swap the two subst..." }, { "title": "双串DP", "url": "/algs/TwoStrDP.html", "categories": "algs", "date": "2023-08-26 00:00:00 +0800", "snippet": "前言两个串，一个模板串，一个测试串，使之“匹配” 。如果更小规模，这里就是指两个串的前缀子串，的子问题的解决能适用贪心算法，直接被利用，计算出更大规模的问题。正则匹配0010 - Regular Expression Matching简化版0044 - Wildcard Matching编辑距离以莱文斯坦距离为例，对应有 LeetCode 原题： 0072 - Edit Distance 。..." }, { "title": "编辑距离", "url": "/algs/EditDistance.html", "categories": "algs", "date": "2023-08-26 00:00:00 +0800", "snippet": "基本概念编辑距离是从一个串变换到另一个串，需要的基础操作的数量，用来衡量两个串的相似度，用在 自然语言处理上，比如拼写检查； 生物学上，做 DNA 序列对比 其他这里的基础操作包括： 插入一个字符 删除一个字符 替换一个字符（substitution） 交换两个字符（transposition）编辑距离有：莱文斯坦距离Lavenshtein Distance，最常见的编辑距离，..." }, { "title": "0053 - Maximum Subarray", "url": "/algs/LeetCode0053.html", "categories": "algs", "date": "2023-08-18 00:00:00 +0800", "snippet": "前言这篇的重点在于讲述从启发式算法到对 Kadane算法 的独立再发现的过程。难度定位对于 LeetCode 来说，本题的定位在 Medium 难度，只能说这是一个令人不满意的折中的结果。首先这实在是一道太经典的题目，有很简单的解决方法，对于那些接触过它的人来说，只需要不到一分钟的时间就能写完，从这个角度上说，可以直接定位在 Easy 。但对于那些并没有正式接触过的人来说，就题论题，从输入的..." }, { "title": "1340 - Jump Games V", "url": "/oth/LeetCode1340.html", "categories": "oth", "date": "2023-08-10 00:00:00 +0800", "snippet": "题干问题描述破题源代码这个题的描述非常别扭，啰嗦还不得要领，配得示例图也抓不到展示的重点，让人很难进入这个题目，单就这个题目文本的编写我就要给出差评！简而言之，还是跳一个范围 $d$，双向都可以，但是只能从高跳到低，包括中途经过的位置也要比起点低。数据限制： 1 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt;= 105 1 &lt;= d..." }, { "title": "LeetCode Palindrome Partitioning", "url": "/oth/LeetCodePalindPart.html", "categories": "oth", "date": "2023-08-02 00:00:00 +0800", "snippet": "0131. Palindrome PartitioningMedium但是Hard解①DFS 搜索官方建议的通解，直接从前缀开始搜索，遇到一个回文串，就把它加入答案中，然后从跳过这个回文串递归，直到串结束。Tips： 在实现上，可以使用一个暂存的向量保存回文子串，在每一步的递归过程中， 把子串加入，等到递归分支结束的时候把这个向量的复制品加入到答案中，然后在每一步递归返回后，弹出这一步加入..." }, { "title": "LeetCode Jump Games", "url": "/oth/LeetCodeJumpGames.html", "categories": "oth", "date": "2023-08-02 00:00:00 +0800", "snippet": "源代码44 Jump Games II虽然名字上第二个，但题目编号反而要比1要早问题描述求跳到尾部的最小步数1。解①DP这个题目本身带有 DP 的标签，首先也就想到了简单的 DP 思路：记录跳到每个位置所需要的最小步数，从左到右扫描，每到一个位置，就用当前步数加一来更新该位置下一步所能到达的那一些位置。def solve(nums: List[int]) -&gt; int: dp =..." }, { "title": "LeetCode Packet 1", "url": "/oth/LeetCodePacket1.html", "categories": "oth", "date": "2023-07-29 00:00:00 +0800", "snippet": "44. Wildcard Matching各方面都更像 0010 - Regular Expression Matching II ，前者是正则匹配，后者则是一般 shell 上文件名的匹配，而且后者（也就是本题）的 DP 实现可以把时间和空间性能很好地结合在一起。把模式串的遍历放在外循环，唯一需要仔细考虑下的就是每一轮 DP 的初始化： 第一轮的 DP，$\\text{dp}[0] = \\..." }, { "title": "0042 - Trapping Rain Water", "url": "/oth/LeetCode0042.html", "categories": "oth", "date": "2023-07-27 00:00:00 +0800", "snippet": "题干问题描述破题源代码如果能知到每个单位区间左边和右边的最大高度，取其最小值，就是该单位的存雨量。12链接题目0032 - Longest Valid Parentheses解①双向扫描：可以认为下降和上升是需要匹配的两个阶段，如果事先记录下降前的高度，在一个下降-上升周期结束的时候，就可以回溯计算这个“坑道”的存雨量，不过这有一个前提，就是上升达到的最大高度不小于下降前的最大高度，确保我们..." }, { "title": "LeetCode Map", "url": "/oth/LeetCodeMap.html", "categories": "oth", "date": "2023-07-25 00:00:00 +0800", "snippet": "App Themes按照特定应用场景的分类LineSweep 0218 - The Skyline Problem 0391 - Perfect Rectangle 0850 - Rectangle Area II 1851 - Minimum Level to IncludeGraph 0685 - Redundant Connection IIPalindrome 0005 ..." }, { "title": "0032 - Longest Valid Parentheses", "url": "/oth/LeetCode0032.html", "categories": "oth", "date": "2023-07-25 00:00:00 +0800", "snippet": "题干问题描述破题源代码考虑合法的括号序列的性质： 开括号可以任意数量地出现，但是串结束的时候括号可能没有匹配完 闭括号不能超出开括号的数量 括号序列是对称的，从反方向来看，闭括号就是开括号，开括号就是闭括号给出一个 括号单元 的递归定义：unit ::= () | (unit+)一个合法的括号串： s=unit*链接题目 0022 - Generate Parentheses解①双向..." }, { "title": "0022 - Generate Parentheses", "url": "/oth/LeetCode0022.html", "categories": "oth", "date": "2023-07-24 00:00:00 +0800", "snippet": "题干问题描述破题源代码额，测试用例就是题目限制的 $8$ 个。解①直接构造：直接构造所有可能的字符串，从空串开始逐个增加字符，( 和 ) ，直到字符串长度达到 $2n$ 。 左括号可以随意增加，只要总数不超过 $n$ 右括号必须匹配一个左括号，不能随意增加，它的数量不能超过当前左括号的数量from typing import Listdef solve(n: int) -&gt; Li..." }, { "title": "0010 - Regular Expression Matching", "url": "/oth/LeetCode0010.html", "categories": "oth", "date": "2023-07-21 00:00:00 +0800", "snippet": "题干问题描述破题源代码这道题令人有些五味杂陈，说它是一道不好的题有它不好的理由，说它是一道好的题有好的理由，它好还是不好可能取决于你做题的流程。不好的说，这道题并不是那种抽象得非常干净的题目，它更像是现实中的问题，有开放式的解决方法，可能涉及多方面知识，主要时间需要用在考虑核心算法无关的处理细节。作为那种习惯性地先成功提交，然后才回去看解析和答案的人来说这种题是非常煎熬的而且花费时间的，除非..." }, { "title": "0336 - Palindrome Pairs", "url": "/algs/LeetCode0336.html", "categories": "algs", "date": "2023-07-12 00:00:00 +0800", "snippet": "通常为了分类页面的干净，不将LeetCode题解的文章放到算法分类里，但这一篇实在精彩，涉及了其他算法没有介绍过的，关于大量子串比较的通解性思路题干问题描述破题源代码有必要特别强调下这道题的数据特点： 1 &lt;= words.length &lt;= 5000 0 &lt;= words[i].length &lt;= 300 words[i] consists of lowerc..." }, { "title": "0005 - Longest Palindromic Substring", "url": "/oth/LeetCode0005.html", "categories": "oth", "date": "2023-07-05 00:00:00 +0800", "snippet": "题干问题描述破题选取最长的回文子串，如果有多个，任选一个即可。参考专门的回文章节，这里只列出 Python 实现。源代码解①朴素实现：\"\"\"O(n^2) 448ms, beats 92.33%\"\"\"def solve(s: str) -&gt; str: n = len(s) # Odd symmetric ans_odd_r = 0 ans_odd_i = 0 ..." }, { "title": "回文串基础", "url": "/algs/StringPalindrome.html", "categories": "algs", "date": "2023-07-03 00:00:00 +0800", "snippet": "前言讨论回文串的相关基础问题以及收集寻找本质不同回文串或最长回文串的各种算法。概念基础回文串（Palindrome），就是一个符号序列，它正着读和反着读都是相同的。也就是说回文串总是对称的，奇数长度的回文串在中间的字母上对称，而偶数长度的回文串在两个字母的空儿上对称。对称是回文最主要的性质，求解过程通常都要分奇数轴和偶数轴分别讨论。本质不同回文串它的一个子问题是，寻找最长回文串。朴素算法以考..." }, { "title": "串上DP", "url": "/algs/StringDP.html", "categories": "algs", "date": "2023-07-01 00:00:00 +0800", "snippet": "前言总结一系列在字符串上通过动态规划实现渐进最优的算法。为了形式化描述定义以下几个概念：朴素算法： 不使用 DP 思想，暴力比较的算法。匹配： 符合算法要求的一个子串，一般追踪地是最右边的一个匹配。模式串： 作为算法运行目标的串，有时候相对于其他子串，也叫它母串。同时： 用 $n$ 表示母串的长度； 用 $i_0$ 表示追踪的（最右）匹配所属的坐标，用 $s[l..r]$ 它所代表的子串..." }, { "title": "串哈希", "url": "/algs/StringHash.html", "categories": "algs", "date": "2023-06-26 00:00:00 +0800", "snippet": "概念基础字符串哈希是从 Rabin-Karp 算法 (1987) 衍生出来的，用于解决基于字符串子串比较问题的一种思路。RK 算法使用了一个简单的多项式滚动哈希算法1，对于任意子串 $\\text{substr}[l..r]$ ，它的哈希值可以由两端对应的前缀字符串 $\\text{substr}[0..l-1]$ 和 $\\text{substr}[0..r]$ 的哈希值计算得到，也..." }, { "title": "1851 - Minimum Level to Include", "url": "/oth/LeetCode1851.html", "categories": "oth", "date": "2023-06-11 00:00:00 +0800", "snippet": "题干问题描述源代码破题一般性思路看起来像是区间上的查询问题，而分段树总是可以解决这样的问题。用区间的长度表示一个区间的值，重叠部分取最小值，离散化区间坐标后建树，这些都是容易的，但问题是，对每次查询的值又要对它使用哪个或哪些离散化的坐标的查询结果进行表示？不可能的在线查询一开始我的考虑是如果对查询的值在区间坐标上做二分查找，如果成功的话就用那个找到的坐标在树上查询，如果失败的话就比较左右两个..." }, { "title": "0850 - Rectangle Area II", "url": "/oth/LeetCode0850.html", "categories": "oth", "date": "2023-06-11 00:00:00 +0800", "snippet": "题干问题描述破题要求矩形覆盖的面积，在做了天际线问题和完美矩形问题后，这个问题的思路就看得非常清楚了，只需要沿着某一轴扫描，计算在另一轴上覆盖的长度，计算的时机是遇到每个矩形的入边或者出边的（重复的不算），这样拆分成一个个小矩形，就得到了覆盖的面积和。于是问题的关键，不妨以 $x$ 轴为扫描方向，就在于如何动态地计算 $y$ 轴上的覆盖长度。由于本题的限制相当宽松，建筑的数量最多只到 $20..." }, { "title": "0000 - Number of digit one", "url": "/oth/LeetCode0233.html", "categories": "oth", "date": "2023-06-11 00:00:00 +0800", "snippet": "题干问题描述破题这道题的难度是 Hard ，但是题干明明看起来又非常简单，这实在让人倒吸一口凉气，这可能会有多种情况地、很复杂地展开。但是，但是，不要慌，先看一下数据规模，数据规模本身足以揭露答案。发现是 $10^9$ ，这意味着线性的、一遍扫描的办法是不通的，需要一个比如对数级的亚线性的算法。这对于一个数字来说，第一时间可以想到的就是按照10进制的位来分解问题。比如说，给定的数字 $\\te..." }, { "title": "0085 - Maximal Rectangle", "url": "/oth/LeetCode0085.html", "categories": "oth", "date": "2023-06-11 00:00:00 +0800", "snippet": "题干问题描述破题源代码缝合一个简单类型和一个中等难度类型，就是LeetCode经典地困难类型题目。简单型：求最大“1”矩形面积，问题拆解地话，可以按行或者列进行统计1，统计每一行的列位置上“1”的高度，可以借用“滚动数组”的方法，用前一行的高度计算得到当前行的数据，这样把空间复杂度从 $O(nm)$ 降低为 $O(m)$ ：当列位置值为“1”，就对前一行同一位置加一，否则置为零。中等型：这个..." }, { "title": "0072 - Edit Distance", "url": "/oth/LeetCode0072.html", "categories": "oth", "date": "2023-06-11 00:00:00 +0800", "snippet": "题干问题描述破题源代码典型地套题，这类题目几乎只有一种解法，而且不太容易从直觉算法推出，如果不得要领、误入歧途，就会觉得很难，但如果找到路径，就很容易，缺乏变化。就像对待前面的另一个套题： 0053 - Maximum Subarray 一样，LeetCode 也给它 Medium 难度，而我总是认为应当放到 Hard 难度，因为并不是题目本身简单，而只是著名、流行、有模板。解①DP：Top..." }, { "title": "0391 - Perfect Rectangle", "url": "/oth/LeetCode0391.html", "categories": "oth", "date": "2023-06-08 00:00:00 +0800", "snippet": "题干问题描述源代码破题求一个完美覆盖的矩形，首先想到的就是通过面积比较进行判断，也就是所有矩形的最右、最上、最左、最下4个坐标构成的矩形的面积是否等于各小矩形的面积之和。但是只有面积的比较还不足以证明是“完美覆盖”，因为面积相等还包括空隙和重叠并存的情况，必须要确保小矩形之间没有空隙或者没有覆盖。在面积相等的情况下，如果小矩形之间有空隙，则必然还存在重叠，反之有重叠必然也有空隙，因此只要能检..." }, { "title": "0218 - The Skyline Problem", "url": "/oth/LeetCode0218.html", "categories": "oth", "date": "2023-06-01 00:00:00 +0800", "snippet": "题干问题描述源代码破题这道题的关键是能观察到：关键点是顺着 $x$ 轴的方向，当剪影的高度发生变化时确定的。这样，如果能确定每个 $x$ 坐标对应的建筑物的最大高度，就能求出关键点。解①：分段树最直接的一个思路是把建筑列表里的每栋建筑的高度在它所属区间上标识出，这样就可以查询每个 $x$ 坐标的最大高度。分段树（Segment Tree）就适用于这种情况：考虑分段树的里的批量更新，既支持批量..." }, { "title": "拓扑排序", "url": "/algs/GraphTarjanDFS2.html", "categories": "algs", "date": "2023-05-25 00:00:00 +0800", "snippet": "是解决有前置课程限制的课表安排之类的问题，用有向边代表一个事件和它的前置事件，那么这样构成的有向图的拓扑排序（结果并不唯一）就是一个规划方案。拓扑排序的对图的要求是有向无环图（Directed Acyclic Graph，DAG），可以使用一个基于 DFS 的拓扑排序的方法，可以在线性时间里进行拓扑排序，并且能够检查环的存在。这个基于 DFS 的线性的拓扑排序的算法很可能也是来源于 Tarj..." }, { "title": "Tarjan DFS", "url": "/algs/GraphTarjanDFS.html", "categories": "algs", "date": "2023-05-20 00:00:00 +0800", "snippet": "本文资料来源于12Tarjan 其实是老朋友了，之前介绍过的斐波那契堆（1986），他就是它的两位作者之一， 现在是要介绍他早期（1972、1973）发表的通过图上 DFS 来线性时间解决3： 在无向图上划分双联通分量 查找强连通分量其中一些概念也是（可能）后续一些基于 DFS 的算法的基础。深度优先遍历对一个连通无向（简单）图，如下所示：（默认按照字母顺序）进行深度优先地图上遍历：\\[..." }, { "title": "树状数组", "url": "/algs/FenwickTree.html", "categories": "algs", "date": "2023-04-24 00:00:00 +0800", "snippet": "本文主要参考 OI-wiki 以及 cp-algorithms.com 相关页面1树状数组（Binary Indexed Tree, Fenwick Tree）2，以下简称 BIT，其命名是由于 Peter Fenwick 在 1994 年发表的文章里描述了这一结构，它的本质是通过高效地计算数组的前缀和来解决相关的问题。VS 分段树因此树状数组也能解决诸如给定区间的和之类的问题，只要这类问题..." }, { "title": "分片级联（Fractional Cascading）", "url": "/algs/FractionalCascading.html", "categories": "algs", "date": "2023-04-17 00:00:00 +0800", "snippet": "本文主要参考 wiki ，对其中一些内容进行了拓展，对个别错误进行了修正。分片级联是一种同时对多个有序列表进行二分查找的加速技术。假设有 $k$ 个有序列表，给定一个元素 $q$ ，查询在每个有序列表上的位置。思路原始做法依次在每个有序列表上执行二分查找，假设每个列表的平均长度为 $n$ ，总长度 $N=kn$ ， 则时间复杂度为 $O(k\\ \\text{log}\\ n)$ 。改进的做法可以..." }, { "title": "分段树（Segment Tree）", "url": "/algs/SegmentTree.html", "categories": "algs", "date": "2023-04-10 00:00:00 +0800", "snippet": "更常见的名字是线段树，但正如我不喜欢“倍增”而宁愿用“指数提升”一样，“线段”这种追求辞藻而导致语义失焦1的翻译，也不如“分段”这种平白直接的翻译。我一贯主张，翻译、特别是技术术语的翻译，应该以朴实易懂为主，但长期一来的翻译风格完全背道相驰，都是利用中文的博大精深，把一个简单的概念翻译得玄里玄幻，让人不仅摸不着头脑，而且望而生畏，难道他们的目的就在于此？本文基本算是对 cp-algorith..." }, { "title": "最大公约数（Great Common Divisor）", "url": "/algs/GCD.html", "categories": "algs", "date": "2023-04-06 00:00:00 +0800", "snippet": "假设对于非负整数，$a$ , $b$ ，求它们的最大公约数 $\\text{gcd}(a, b)$ ，以下简写作 $g$ 。数学上，最大公约数只有对两个非零整数才有意义，但是一般从实现的方面，规定： $\\text{gcd}(0, b) = a$ , $\\text{gcd}(a, 0) = a$ $\\text{gcd}(0, 0) = 0$辗转相减也是原始的欧几里得（Euclidean）..." }, { "title": "0685 - Redundant Connection II", "url": "/algs/LeetCode0685.html", "categories": "algs", "date": "2023-03-31 00:00:00 +0800", "snippet": "题干问题描述破题这题说难不难，没有复杂的数据结构和算法，但是情况比较繁琐细致，可以说非常贴近实际情况了。具体来说，这个题的破题的关键在于搞清楚一棵有向树，多了一条边后，会形成什么样的情况。这不是一次就能全想清楚的 ，在代码失败了几次后，我们总结出三种情况： 形成双头节点（a-&gt;b, c-&gt;b, b就是双头节点） 形成循环（a-&gt;b, b-&gt;c, c-&gt;a） ..." }, { "title": "加速 Rust 构建", "url": "/lang/SpeedupRustBuilding.html", "categories": "lang", "date": "2023-03-22 00:00:00 +0800", "snippet": "阅读了 https://fasterthanli.me/articles/why-is-my-rust-build-so-slow总结了加速的注意事项： 拆分过大的 crate ，一个基本编译单元至少是一个 crate，拆分 crate 可以利用多核优势 检查不必要的依赖，某些依赖可能会大幅拖慢编译时间 避免不必要的多态，缩减编译时间 为 release 也开启增量编译 increm..." }, { "title": "基于前缀树的持久化向量（TrieVec）", "url": "/algs/TrieVec.html", "categories": "algs", "date": "2023-03-17 00:00:00 +0800", "snippet": "在前面介绍了从 Fibonacci 堆、Dary 堆，到图上的诸多算法，从 BST 到 BT 的一系列数据结构和算法，并提供了它们的 Rust 实现，如果把这些代码都集成起来，可能就会发现这个编译的过程怎么这么熬人，似乎越来越让人难以忍受，这时可以参考一下另篇关于降低构建时间的笔记。前言本篇作为一个阶段性的总结篇，介绍一个基于前缀树（Trie）的持久化向量（Vector）的实现1 ，以下用 ..." }, { "title": "BT(3) - B+树完整版以及B*性质", "url": "/algs/BT-3-BPT_complete_with_star.html", "categories": "algs", "date": "2023-03-14 00:00:00 +0800", "snippet": "继承前两篇 B+树(Vec) 和 B+树(TreeMap) 的完整版 B+ 树 (Vec) 实现。系列所有代码可以在这里数据结构树为了 pop_first / pop_last 增加了最小、最大节点。impl_tree!( /// B+ Trees /// BPT { cnt: usize, min_node: WeakNode&lt;K, V&..." }, { "title": "BT(2) - B+树（TreeMap）", "url": "/algs/BT-2-BPT2.html", "categories": "algs", "date": "2023-03-14 00:00:00 +0800", "snippet": "对于 B 树来说，传统上有一种对节点分裂、合并时性能的改进方法，就是把存储结构由数组改为 TreeMap 。TreeMap 或者有序字典，比如我们前面介绍的所有的 BST，比如红黑树，以及，我们 B 树。没错，现在我们就是要用前文实现的 B+ 树作为我们新 B+ 树的节点基础。当然这是一个递归的概念，我们也可以继续下去把这个新的 B+ 树的实现作为节点基础实现 B+ 树，如此 $3$ 层、$..." }, { "title": "BT(1) - B+树（Vec）", "url": "/algs/BT-1-BPT.html", "categories": "algs", "date": "2023-03-13 00:00:00 +0800", "snippet": "在前一篇的文章里介绍了 B 树，这里介绍它的变种 B+ 树的基本实现。如果说之前好不容易把观念从二叉搜索树转换到了 B 树，那么从现在开始，从 B 树到 B+ 树又需要有一个很大的观念转变。不过请放心，本文讲得是依靠 Vec 实现的 B+ 树，后面还会介绍用 TreeMap 实现的 B+ 树，那时又需要一个很大的观念转变。整个 B 树系列计划了四篇文章，即使层层铺叠，每篇间的学习曲线都很陡峭..." }, { "title": "单词与短语", "url": "/oth/WordAndPhase.html", "categories": "oth", "date": "2023-02-27 00:00:00 +0800", "snippet": "Aa grinding halt陷入停顿 Memory-hogging programs can deplete the system’s memory, bringing the whole system to a grinding halt.Articulation` /ɑːrˌtɪk.jəˈleɪ.ʃən/`n.衔接、链接 If the top point does not con..." }, { "title": "BT(0) - B树", "url": "/algs/BT-0-BT.html", "categories": "algs", "date": "2023-02-20 00:00:00 +0800", "snippet": "B 树是波音实验室的 Rudolf Bayer and Edward M. McCreight 最初发明用来存储大量索引（超过主内存）的数据结构，在 1970 年的论文里正式提出。本系列将介绍 B 树以及 B+ 树、B+ 树的 TreeMap 实现、 B+* 树等一些列算是 B 树的变种。概念基础B 树是完全平衡的多路搜索树，基本上已经是传统红黑树的上位替代。 节点数的减少，极大地节省了内..." }, { "title": "Disk上的存储结构", "url": "/oth/StorageMedium-1-Disk.html", "categories": "oth", "date": "2023-02-13 00:00:00 +0800", "snippet": "介绍的是磁盘的存储结构，但技术原理上对于光盘也是通用的。盘片划分一个盘片的基本两级结构是： 轨道（Track）- 扇区（Sector）。轨道是盘片上的同心圆（考虑到轨道的宽度，实际上是很窄的同心圆环）而扇区则是一条轨道上按照一定角度划分的弧，是最基本的存储单元。注意这个概念显然有别于几何学上的扇区，这里的扇区实际是几何意义上的扇区在某一轨道上的交集。轨道编号习惯轨道的编号传统上从小到大按照从..." }, { "title": "存储介质（0）- 基础", "url": "/oth/StorageMedium-0-Basic.html", "categories": "oth", "date": "2023-02-13 00:00:00 +0800", "snippet": "分类按照记录数据的载体，可以分为磁性存储（magnetic）、光学存储（optical）和集成电路存储磁性存储 机械硬盘 软盘（floppy disk） 磁带鼓一个比一个老，磁带鼓更是老资格光学存储 光盘集成电路存储集成电路（Integrated Circuit， IC），不管有没有晶体管，都是有有半导体材料，也直接叫做半导体存储。在这样电路实现分为：RAM 和 ROMRAMRAM（..." }, { "title": "BST(5) - 树堆（Treep）", "url": "/algs/BST-5-Treep.html", "categories": "algs", "date": "2023-02-02 00:00:00 +0800", "snippet": "基本概念树堆的概念首次是由 Raimund Seidel and Cecilia R. Aragon 在 1989 年提出，它意思是节点用两个属性分别维护了二叉搜索树的性质和堆的性质。从二叉搜索树的角度看，可以类比前面的 Splay树，Splay 平衡性好要依赖于输入的数据具有随机性，而树堆干脆利用随机生成的权重来手动制造这种随机性。实质上都是通过随机化的输入来达到树结构的平衡。基础定义共同..." }, { "title": "BST(3) - 伸展树（Splay Tree）", "url": "/algs/BST-3-Splay-Tree.html", "categories": "algs", "date": "2023-01-30 00:00:00 +0800", "snippet": "基本概念伸缩树（Splay Tree）是 Daniel Sleator and Robert Tarjan 在 1985 年提出，它的想法就是一个，把最近访问的节点 roll 到根节点。它的性质与 CPU 缓存机制非常契合，又不需要存储额外字段，常用于缓存和垃圾回收器的实现。但是这样的性质也导致 查询的时候也会修改自身的结构，这在多线程环境和纯函数编程语言里会造成很大的麻烦； 这不是很“..." }, { "title": "BST(4.1) - 惰性替罪羊树（LSG）", "url": "/algs/BST-4.1-LSG-Tree.html", "categories": "algs", "date": "2023-01-29 00:00:00 +0800", "snippet": "基本概念替罪羊树 的基本概念前文已经介绍过，这里主要做两个变化，一个是增加 size 字段来省略动态计算 size 的时间，另一个是使用惰性删除。由于重构的存在，替罪羊树本来就很适合使用惰性删除的方法。基础定义共同结构def_tree!( /// Lazy Scapegoat Tree LSG { cnt: usize, /// nodes co..." }, { "title": "BST(4) - 替罪羊树（SG）", "url": "/algs/BST-4-SG-Tree.html", "categories": "algs", "date": "2023-01-29 00:00:00 +0800", "snippet": "基本概念替罪羊树（Scapegoat Tree）初始是在 1989 年由 Arne Andersson 发明，而在 1993 年 Igal Galperin and Ronald L. Rivest 正式提出这个概念。它是说不用每次修改树结构后都进行重平衡的操作，而是当检测到树的不平衡程度达到阈值时直接重构以某个节点为根的树。搜/插/删的平均时间复杂度与其他自平衡二叉搜索树一样，都是 $O(..." }, { "title": "BST(2) - RB(2) - AA树", "url": "/algs/BST-2-RB-Tree-2-AA.html", "categories": "algs", "date": "2023-01-20 00:00:00 +0800", "snippet": "基本概念AA 树（以下简称 AA）由 Arne Andersson 在 1993 年发明提出。AA 从理解到实现和 LLRB 是高度相似的（但是从作者关系上我们还是选择先介绍 LLRB），而一般的介绍资料，不管是 LLRB 还是 AA 的，都没有提这种密切的联系。在 LLRB 里面，通过颜色关系，让节点与 2-3/2-4 树的节点一一对应；而在 AA 里每个节点也对应2-3树的节点。我们说 ..." }, { "title": "BST(2) - RB(1) - 左偏红黑树", "url": "/algs/BST-2-RB-Tree-1-LLRB.html", "categories": "algs", "date": "2023-01-20 00:00:00 +0800", "snippet": "基本概念LLRB 是特化后的红黑树，基本来源是一个 2008年 Robert Sedgewick （原始红黑树的两位联合发明人之一）的教学 PPT ，和红黑树一样，基本也不太行（指得是实现复杂，不直观，而且不体面（指得是删除操作依靠节点内容的交换））关于 LLRB 名气很大，但是基本上也找不到很多除了原作者以外的介绍资料，大家抄得都是同一份 Slide 。实际上它在代码上如果不使用递归版本，..." }, { "title": "BST(2) - RB(0) - 原始红黑树", "url": "/algs/BST-2-RB-Tree-0-Origin.html", "categories": "algs", "date": "2023-01-19 00:00:00 +0800", "snippet": "基本概念红黑树是一种对平衡的要求比前面介绍的 AVL树 宽松一些的自平衡二叉搜索树，因此虽然查询性能稍差，但有更少的 插/删 所需要的旋转次数，也就是写的性能更加优秀。它是在在 1978 年由 Leonidas J. Guibas and Robert Sedgewick 联合提出，用红黑色标识区分主要是考虑到排版系统和手写方面的好处。（它模仿了 $4$ 阶 B树）它把节点分为红色和黑色（空..." }, { "title": "BST(1) - AVL树", "url": "/algs/BST-1-AVL-Tree.html", "categories": "algs", "date": "2023-01-17 00:00:00 +0800", "snippet": "前文介绍了二叉搜索树基础 ，这里是第一个自平衡的二叉搜索树 – AVL树，它是在 1962 年由前苏联的科学家 Georgy Adelson-Velsky 和 Evgenii Landis 提出的。它有最严格的平衡限制，因此有理论最佳的搜索效率。基本概念AVL树对树平衡的要求是（每个节点）左右树高的差距不超过 $1$ 。定义 $\\texttt{BF}$（Balance Factor）= 右子..." }, { "title": "BST(0) - 二叉搜索树基础", "url": "/algs/BST-0-Basic.html", "categories": "algs", "date": "2023-01-14 00:00:00 +0800", "snippet": "作为一系列自平衡（self-balancing）的二叉搜索树的博文的起始，这篇先介绍基础部分，之后的各篇将专注于 增/删 节点后，树重新平衡的部分。定义二叉搜索树是二叉树，但是额外需要每个节点满足：左孩子（如果有的话）的 key 比它的小，而右孩子的 key 比它的大 。实现前言考虑如何在实现上（Rust）把本文介绍的二叉搜索树的基础操作作为后面实现的具体种类的带自平衡的二叉搜索树的基础 ，..." }, { "title": "编译器前端基础", "url": "/algs/CompilerFrontEndBasic.html", "categories": "algs", "date": "2022-12-23 00:00:00 +0800", "snippet": "关于龙书本篇介绍的基本概念来自于经典的龙书（Compilers Principles, Techniques and Tools））。而整个龙书，不幸地是，很多技术概念完全是以 类C 语言为前提做的介绍，从名字上，从章节目录上感到应该有帮助，实际没用。另外对于 LR，LL 这些，似乎专注于做一个通用编译器的生成器，而不是编译器，而现在既然已有大量的通用生成器，但21世纪以来编程语言的发展趋势..." }, { "title": "字符编码（Character Encoding）", "url": "/algs/CharEncoding.html", "categories": "algs", "date": "2022-12-20 00:00:00 +0800", "snippet": "序言每次谈到技术标准的问题，就一定要探究一下相关历史，这样才能搞清楚一堆相关概念到底是什么意思，才能理解这个标准的意义到底在哪儿。通常这个历史发展有三个阶段： 蛮荒时期，各参与实体相对独立开发，各有各的标准； 过渡时期，为适应相关领域的发展，开始有一个统一的标准，但各实体的标准还继续起作用； 大一统时期，统一的标准已经统一了应用，蛮荒时期的标准被废弃，只存在于个别非常旧的应用里对于字符..." }, { "title": "最短路径（SP）问题", "url": "/algs/GraphSP.html", "categories": "algs", "date": "2022-12-01 00:00:00 +0800", "snippet": "前言介绍的最短路径的算法以有向图（强连通）为基础，但也适用于无向图的情况，只是在涉及负环时情况略有不同1。遵循依赖关系，将依次介绍： Floyd 算法 （全源） Bellman-Ford 算法 （单源） Bellman-Ford 算法的著名改进： SPFA 算法 （单源） Dijkstra 算法 （单源） Johnson 算法 （全源）Floyd 算法/flɔid/算法思想这个算法..." }, { "title": "N叉堆实现（Rust）", "url": "/algs/DaryHeap.html", "categories": "algs", "date": "2022-11-23 00:00:00 +0800", "snippet": "一个有建立在连续内存上的 $2$ 的 $n$ 次幂倍分叉完全树的最小堆（以下简称 d-ary 堆），理论和实践都最快的，用于图上经典贪心算法，作为斐波那契堆的上位替代。下图 $q=2^1$数据结构/// Min Heap, I is unique, T is weight#[derive(Clone)]pub struct DaryHeap&lt;const E: usize, I, T&g..." }, { "title": "速通最小生成树（MST）", "url": "/algs/GraphMST.html", "categories": "algs", "date": "2022-11-18 00:00:00 +0800", "snippet": "前言介绍三种基本的最小生成树算法：它们都是贪心算法 基于最小边的 Kruskal 算法 基于最小距离的点（到生成树）的 Prim 算法 基于连通分量最小出边的 Boruvka 算法对于它们进行简单的比较实现基于图论基础里面提到的数据结构性质介绍一下最小生成树相关的性质1，可能让我们对算法的理解能拨其冗繁、摁其要务，看得更清楚一点。割的性质对于连通图 $G = (V, E)$ ，如果 $..." }, { "title": "指数提升（倍增，Binary Lifting）", "url": "/algs/BinaryLifting.html", "categories": "algs", "date": "2022-11-16 00:00:00 +0800", "snippet": "前言我一定要狠狠地“表扬“一下“倍增“这个翻译，这个翻译从字面上看是要翻倍、增加，可是翻倍已经包含增加的内涵（一般概念上的对象都是自然数的），结果实际上一般人看到这个词就只能理解到翻倍的意涵，为什么要翻倍？这么做的好处在哪儿？ 这到底是什么东西？我每次看到这个词总是一头雾水，看了几次算法介绍也不能抓到关键点，而使用倍增这个翻译的介绍的大多数作者也没能抓住关键点，可能他们也被倍增这个鬼翻译迷惑..." }, { "title": "斐波那契堆的实作 (for Rust)", "url": "/algs/FibHeapImplRust.html", "categories": "algs", "date": "2022-11-13 00:00:00 +0800", "snippet": "算法理论部分，在上一篇论文 Fibonacci Heap 已经讲完了，下面是干活的部分1：语言特定数据共享、可变性与非null对象Rust 是安全的系统级编译语言，不同于传统的 C/C++ 的编程模型，继承发展了函数式编程语言对数据的一贯态度，明确了单一所有权的概念。对于传统的基于链表的数据结构，使用计数指针 Rc (reference counter) 代替直接的指针，使用 RefCel..." }, { "title": "Setup Ruby Environment", "url": "/oth/SetupRuby.html", "categories": "oth", "date": "2022-11-08 00:00:00 +0800", "snippet": "前言Ruby的应用就像Go、NodeJS一样，通常非常不体面，缺乏对各种情况的详细考虑，也无法灵活配置，运行错误信息不完整（甚至没有错误信息），这时候把环境尽可能地配置得和他们默认得一样就很重要。比如 gem install 不能有admin权限的限制，bundle update 显然要有一个本地的bundle环境等等。这时候有一个Ruby版本环境管理器就是必须的Ruby版本环境管理器RbE..." }, { "title": "斐波那契堆（Fibonacci Heap）", "url": "/algs/FibHeap.html", "categories": "algs", "date": "2022-10-27 00:00:00 +0800", "snippet": "Fibonacci Heap12 3是一个基于链表结构的，理论时间复杂度很优的数据结构。常用于 Dijkstra 最短路径、Prim 最小生成树等贪心算法，使用 push - decrease-key，都是 $O(1)$ 的时间复杂度。前言一点儿啰嗦，可以跳过。说实话本来看图例， 看着各种相比最优的时间复杂度颇为心动但仔细看下去，发现完全是典型的基于链表结构的算法，代意词是理论很好但实际性能..." }, { "title": "图理论基础", "url": "/algs/GraphTheoryBasic.html", "categories": "algs", "date": "2022-10-09 00:00:00 +0800", "snippet": "概念假设图 G = {V, E}， V是顶点集，E是边集 边，无向边（edge） 有向边（arc）tail(起点) -&gt; head（终点） $\\vert V\\vert$: 点的个数，图的阶（order） 无根树，连通无向图 简单图 (simple graph)：若一个图中没有自环和重边，它被称为简单图。具有至少两个顶点的..." }, { "title": "Linux上把大文件夹移动到其他存储设备上来释放空间", "url": "/os/mv-large-size-dir-to-another-dev.html", "categories": "os", "date": "2022-09-10 00:00:00 +0800", "snippet": "问题背景一个常见的问题是发现某个文件夹比如/var, /opt 过大，使得所在系统磁盘（比如一块儿容量很稀缺的高速SSD）的空间非常紧张，这时我们想把大文件夹移动到其他存储设备上来释放空间。约定不妨假设根系统/挂载在磁盘分区sda4，要移动的大目录LargeDir是根文件系统下的一个子目录，目标存储设备为sdb。思路11一个体面的思路是在sdb上创建一个分区，假设为sdb1，创建LargeD..." }, { "title": "kernel crash dump", "url": "/os/KernelCrashDump.html", "categories": "os", "date": "2022-09-01 00:00:00 +0800", "snippet": "Ubuntuinstall linux-crashdumpDump Outputalias crash=\"crash /usr/lib/debug/boot/vmlinux-$(uname -r)\"crash /var/crash/&lt;yyyymmmmhhmm&gt;/dump.&lt;yyyymmmmhhmm&gt;bt: backtracelog: kernel log" }, { "title": "Compile Linux Kernel", "url": "/os/compile-linux-kernel.html", "categories": "os", "date": "2022-08-26 00:00:00 +0800", "snippet": "编译实践1：学习Linux内核模块开发，需要增加一个FORCE_UNLOADING feature 以避免安装的模块崩溃时可以强行卸载而不必重启。而好像只有OpenSuSE可以通过修改配置文件来动态修改内核配置，而其他发行版只能重新编译内核。Linux上游源代码（git地址在其页面下方）默认环境当前目录： kernel源目录Ubuntu注意源文件的下载，不要在系统目录比如/usr/src下进..." }, { "title": "TCP Congestion Control", "url": "/net/ietf_rfc_5681_obs2581.html", "categories": "net", "date": "2022-08-07 00:00:00 +0800", "snippet": "This RFC is release on 2009.09 obsoletes RFC2581 which is release on 1999.041. Introduction介绍TCP四种交织在一起的拥塞控制算法： 慢启动（slow start） 拥塞避免（congestion avoidance） 快速重传（fast retransmit） 快速恢复（fast recove..." }, { "title": "Path MTU Discovery", "url": "/net/ietf_rfc_1191_obs1063.html", "categories": "net", "date": "2022-08-06 00:00:00 +0800", "snippet": "This RFC is release on 1990.11 obsoletes RFC1063 which is released on 1988.071. Protocol Overview通过设置IP header 的 DF bit 来动态发现一个路径的PMTU1:以第一跳2的MTU为初始值(已知的)，如果收到ICMP code 3-434由于网络拓扑会随时间改变，PMTU的减少，仍然..." }, { "title": "C dialect options", "url": "/lang/c_dialect_options.html", "categories": "lang", "date": "2022-08-01 00:00:00 +0800", "snippet": "Ref: 1, 2 ISO C90 ISO C99 -ansi, -std=c89, iso9899:1990, (ISO C90) -std=c99, iso9899:1999 -std=iso9899:199409 (ISO C90 as modified in amendment 1)..." }, { "title": "C/C++ 陷阱", "url": "/lang/CTrap.html", "categories": "lang", "date": "2022-04-22 00:00:00 +0800", "snippet": " 变量初始化 在Java里面基本变量都有一个初始化的值，但在C里并不是，而是脏数据 结构体初始化注意要在堆上手动分配内存，否则是栈上的会被回收， 这与Rust使用习惯又不一样 " }, { "title": "Zero Cost Exception Mechanism", "url": "/lang/zero_cost_exception.html", "categories": "lang", "date": "2022-03-30 00:00:00 +0800", "snippet": "Related Header Definition依赖于 unwinding library 提供的至少如下的接口: _Unwind_RaiseException, _Unwind_Resume, _Unwind_DeleteException, _Unwind_GetGR, _Unwind_SetGR, _Unwind_GetIP, _Unwind_SetIP, _Unwi..." }, { "title": "C++ ABI 笔记 1", "url": "/oth/cxx-abi-node-0.html", "categories": "oth", "date": "2022-03-27 00:00:00 +0800", "snippet": "Ref: https://itanium-cxx-abi.github.io/cxx-abi/abi.htmlMember Pointer 数据成员指针类型的基本ABI属性是 ptrdiff_t, 表示数据成员到所属基类的字节偏移量. 空数据成员指针表示为-1 (但是通过显式派生到基类的转换,生成偏移量为-1的数据成员指针) 一个非空的数据成员指针的基到派生和派..." }, { "title": "吐嘈Python3.10", "url": "/lang/opinions_on_py310.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Python这一版更新引入了对于舒服的函数式编程至关重要的结构化的模式匹配, 我把它看作是Python面对逐渐尴尬境地的一种自救。实际上自从Rust持续发展以来, 从功能上好像是C++会受到冲击, 但由于Rust本身项目管理的科学性和工具链与文档的完善性, 和整个生态系统的蓬勃发展, 对于用户体验来讲, 我现在哪怕是脚本型的任务都会使用Rust而不是Python, Rust更甜,但是更有表现..." }, { "title": "LLVM IR入门笔记", "url": "/lang/llvm_notes_0.html", "categories": "lang", "date": "2021-10-13 00:00:00 +0800", "snippet": "Function任何函数体 必须有一个ret指令显式地提供返回值, 包括return void.Basic Blockblock只能是function的下层结构, 一个function value至少有一个block, 多个block按照固定顺序排列.也就是说block不能嵌套, 只能顺序排列.函数体的入口是first block, 但后续的基本块必须通过条件或非条件的分支指令来手动连接, ..." }, { "title": "Linker", "url": "/lang/Linker.html", "categories": "lang", "date": "2021-05-27 00:00:00 +0800", "snippet": "gcc target -m32: i386:x64-32 -mx32: elf32_x86_64ld target: elf_x86_64: ELF for x64-32 elf32_x86_64: ELF for x64-32, aka x32 — 32-bit x86-64 binaries elf_i386: ELF for i386 — 3..." }, { "title": "LL and LR", "url": "/lang/LL_LR.html", "categories": "lang", "date": "2021-05-08 00:00:00 +0800", "snippet": "First Sets and Follow SetsTo compute FIRST(X) for all grammar symbols X, apply the following rules until no more terminals or ε can be added to any FIRST set:1.If Xis terminal, then FIRST(X) is {X}..." }, { "title": "从Template Haskell（Haskell宏）来认识Haskell语法结构", "url": "/lang/template-haskell.html", "categories": "lang", "date": "2021-04-17 00:00:00 +0800", "snippet": "默认工作版本 ghc 8.10.4从模板Haskell上看，主要有如下几种构造器：Q QuotationxxE属于 Exp，是xxExpressionxxP属于Pattern，是xxPattterngenId :: Q ExpgenId = do x &lt;- newName \"x\" lamE [varP x] (varE x)等价于genId = [| \\x -&gt; x |] ..." }, { "title": "GHC extensions", "url": "/lang/GHCExtensions.html", "categories": "lang", "date": "2021-04-15 00:00:00 +0800", "snippet": "AllowAmbiguousTypessince 7.8The ambiguity check rejects functions that can never be called.ScopedTypeVariablessince 6.8.1Enable lexical scoping of type variables explicitly introduced with forall.T..." }, { "title": "最优原地后缀排序算法", "url": "/algs/sa_2016.html", "categories": "algs", "date": "2020-12-01 00:00:00 +0800", "snippet": "本章介绍线性时间复杂度的后缀排序的就地算法1（Optimal In-Place Suffix Sorting）。本章只建议在非常非常熟悉SA-IS23的前提下阅读。全局设定目标字符串 $\\texttt{Pat}$，后缀数组 $\\texttt{SA}$，串的序号从 0 开始，结尾字符是警戒哨，不妨设为 0 。在整形字母表上的后缀排序事实上这一部分可以看成是原地版本的 SA-IS 算法。因为是原..." }, { "title": "Haskell开发准备", "url": "/lang/Haskell%E5%BC%80%E5%8F%91Q&A.html", "categories": "lang", "date": "2020-10-01 00:00:00 +0800", "snippet": "准备环境： 安装系统级Haskell（或者直接跳过1-3，直接到4） 安装Cabal-install 安装Stack 安装ghc/cabal多环境：ghcup curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh From https://..." }, { "title": "Boyer-Moore算法", "url": "/algs/BM.html", "categories": "algs", "date": "2020-08-01 00:00:00 +0800", "snippet": "author: minghu6(2nd) revised at 2024-10-29本章节内容需要以《前缀函数与KMP算法》作为前置章节。之前的KMP算法将前缀匹配的信息用到了极致，而 BM 算法背后的基本思想是通过 后缀匹配 获得比前缀匹配更多的信息来实现更快的跳转。基础介绍想象一下，如果我们的的模式字符串 $\\texttt{pat}$ ，被放在文本字符串 $\\texttt{string}..." }, { "title": "Common Lisp 语法", "url": "/lang/common-lisp-grammer.html", "categories": "lang", "date": "2020-07-22 00:00:00 +0800", "snippet": " 列表和点对的区别： 点对是列表构成的基本单元，列表通过点对嵌套构成: '(1 . (2 . nil)) 反过来，点对(1 . 2)看起来像长度为2的列表，但如果它的cdr不是列表，那么它就不是列表 " }, { "title": "Common Lisp 编写工程文件", "url": "/lang/common-lisp-write-project.html", "categories": "lang", "date": "2020-07-21 00:00:00 +0800", "snippet": "参考​\thttps://xach.livejournal.com/278047.html​\thttps://lisp-lang.org/learn/writing-libraries流程Step-0 从安装quicklisp开始https://www.quicklisp.org/beta/#installationStep-1 使用脚手架初始化项目(ql:quickload \"quickpr..." }, { "title": "RSYNC", "url": "/os/rsync.html", "categories": "os", "date": "2018-05-25 00:00:00 +0800", "snippet": "支持 ~ 在远程server上展开-z 压缩-a archive mode, syncs recursively and preserves symbolic links, special and device files, modification times, groups, owners, and permissions-v verbose–progress 显示进度 或者 -Prsy..." }, { "title": "cUrl", "url": "/lang/cUrl.html", "categories": "lang", "date": "2018-02-11 00:00:00 +0800", "snippet": "$cURL = curl_init();// set urlcurl_setopt($cURL, CURLOPT_URL, $url);// set method default is GET// curl_setopt($cURL, CURLOPT_CUSTOMREQUEST, \"POST\");// set header$deviceId = '1234567890'; // custo..." }, { "title": "Mongo Repository 相关", "url": "/oth/mongo-repository.html", "categories": "oth", "date": "2018-02-01 00:00:00 +0800", "snippet": "mongo repository springfindAll 批连查取只能自定义在接口无效key 字段缺失则无法过滤Model 的某个字段是某个(Model | Vo | id)的collection Model 完全的附属关系，没办法独立统计信息 Vo 完全不会更改信息,除了添加　(比如权限) id 最常见，可以更改信息的批量添加一个字段// 更新全部, 如果没有，就添加这个字段db..." }, { "title": "APT", "url": "/os/APT.html", "categories": "os", "date": "2018-01-04 00:00:00 +0800", "snippet": "查找包安装那些文件dpkg -L $package查找文件被哪个包安装的dpkg -S /path/to/file版本解读1. 1:2.11-8参考 stacloverflow 和 man deb-version: 前面的数字 1 是 epoch 省略是 0 ，用作版本排序。2. package-XubuntuY*_amd64参考 Ask Ubuntu" }, { "title": "Sudo env", "url": "/os/sudo-env.html", "categories": "os", "date": "2017-12-15 00:00:00 +0800", "snippet": "继承环境变量sudo visudo Defaults env_keep=\"http_proxy https_proxy ftp_proxy no_proxy DISPLAY XAUTHORITY\"使用当前用户的PATHDefaults env_reset改成Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加alias sudo='sudo env..." } ]
